<div id="Derive_Manager">
<div class="head">
<h1>Theory Derive_Manager</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Deriving class instances for datatypes
    Author:      Christian Sternagel and René Thiemann  &lt;christian.sternagel|rene.thiemann@uibk.ac.at&gt;
    Maintainer:  Christian Sternagel and René Thiemann 
    License:     LGPL
*)</span>
<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Derive Manager›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Derive_Manager
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">keywords</span></span> <span class="quoted">"print_derives"</span> <span class="main">::</span> diag <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted">"derive"</span> <span class="main">::</span> thy_decl
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The derive manager allows the user to register various derive-hooks, e.g., for orders,
  pretty-printers, hash-functions, etc. All registered hooks are accessible via the derive command.

  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">rail</span></span> ‹
    <span class="keyword1"><span class="keyword1">@</span></span><span class="inner_quoted"><span class="inner_quoted">'derive'</span></span> (<span class="inner_quoted"><span class="inner_quoted">'('</span></span> param <span class="inner_quoted"><span class="inner_quoted">')'</span></span>)<span class="keyword3"><span class="keyword3">?</span></span> sort (datatype<span class="keyword3"><span class="keyword3">+</span></span>)
  ›<span class="antiquote"><span class="antiquote">}</span></span></span></span>

  \begin{description}
  \item <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span><span class="hidden">❙</span><b>d</b><span class="hidden">❙</span><b>e</b><span class="hidden">❙</span><b>r</b><span class="hidden">❙</span><b>i</b><span class="hidden">❙</span><b>v</b><span class="hidden">❙</span><b>e</b> (param) sort datatype›</span></span></span></span> calls the hook for deriving <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sort›</span></span></span></span> (that
  may depend on the optional <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>param›</span></span></span></span>) on <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>datatype›</span></span></span></span> (if such a hook is registered).

  E.g., <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span><span class="hidden">❙</span><b>d</b><span class="hidden">❙</span><b>e</b><span class="hidden">❙</span><b>r</b><span class="hidden">❙</span><b>i</b><span class="hidden">❙</span><b>v</b><span class="hidden">❙</span><b>e</b> compare_order list›</span></span></span></span> will derive a comparator for datatype <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> list<span class="antiquote"><span class="antiquote">}</span></span></span></span>
  which is also used to define a linear order on <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> list<span class="antiquote"><span class="antiquote">}</span></span></span></span>s.
  \end{description}

  There is also the diagnostic command <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span><span class="hidden">❙</span><b>p</b><span class="hidden">❙</span><b>r</b><span class="hidden">❙</span><b>i</b><span class="hidden">❙</span><b>n</b><span class="hidden">❙</span><b>t</b><span class="hidden">❙</span><b>_</b><span class="hidden">❙</span><b>d</b><span class="hidden">❙</span><b>e</b><span class="hidden">❙</span><b>r</b><span class="hidden">❙</span><b>i</b><span class="hidden">❙</span><b>v</b><span class="hidden">❙</span><b>e</b><span class="hidden">❙</span><b>s</b>›</span></span></span></span> that shows the list of currently
  registered hooks.
›</span></span>

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹derive_manager.ML›</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/derive_manager.ML">
<div class="head">
<h1>File ‹derive_manager.ML›</h1>
</div>
<pre class="source"><span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">DERIVE_MANAGER</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="comment1">(* identifier, description, (fn dtyp_name =&gt; param =&gt; derive-method) *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> register_derive <span class="main">:</span> string <span class="main">-&gt;</span> string <span class="main">-&gt;</span> <span class="main">(</span>string <span class="main">-&gt;</span> string <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory<span class="main">)</span> <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="comment1">(* identifier, description, (fn dtyp_name =&gt; param =&gt; derive-method) *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> derive <span class="main">:</span> string <span class="main">-&gt;</span> string <span class="main">-&gt;</span> string <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> derive_cmd <span class="main">:</span> string <span class="main">-&gt;</span> string <span class="main">-&gt;</span> string <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="comment1">(* print all registered deriving-methods  *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> print_info <span class="main">:</span> theory <span class="main">-&gt;</span> unit
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Derive_Manager</span> <span class="main">:</span> <span class="entity">DERIVE_MANAGER</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Derive_Data</span> <span class="main">=</span> Theory_Data
  <span class="main">(</span>
    <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">T</span> <span class="main">=</span>
      <span class="main">(</span>string * <span class="main">(</span>string <span class="main">-&gt;</span> string <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory<span class="main">)</span><span class="main">)</span> Symtab.table  <span class="comment1">(* descr * derive-fun *)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">empty</span> <span class="main">=</span> Symtab.empty
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">extend</span> <span class="main">=</span> I
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">merge</span> <span class="main">=</span> Symtab.merge <span class="main">(</span>K true<span class="main">)</span>
  <span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">derive_options</span> <span class="main">=</span>
  Derive_Data.get #&gt; Symtab.dest #&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="main">(</span><span class="entity">descr</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">descr</span><span class="main">)</span><span class="main">)</span>

<span class="comment1">(* FIXME: possibly use Pretty function for presentation. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">print_info</span> <span class="entity">thy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> writeln <span class="inner_quoted">"The following sorts can be derived"</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">derive_options</span> <span class="entity">thy</span> |&gt; sort_by fst |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span><span class="entity">descr</span><span class="main">)</span> <span class="main">=&gt;</span> writeln <span class="main">(</span><span class="entity">id</span> ^ <span class="inner_quoted">": "</span> ^ <span class="entity">descr</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">register_derive</span> <span class="entity">id</span> <span class="entity">descr</span> <span class="entity">f</span> <span class="entity">thy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">if</span></span> Symtab.defined <span class="main">(</span>Derive_Data.get <span class="entity">thy</span><span class="main">)</span> <span class="entity">id</span> <span class="keyword2"><span class="keyword">then</span></span>
    error <span class="main">(</span><span class="inner_quoted">"Identifier "</span> ^ quote <span class="entity">id</span> ^ <span class="inner_quoted">" already in use for "</span> ^ quote <span class="inner_quoted">"deriving"</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">else</span></span>
    Derive_Data.map <span class="main">(</span>Symtab.update_new <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="main">(</span><span class="entity">descr</span><span class="main">,</span> <span class="entity">f</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">thy</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">gen_derive</span> <span class="entity">prep</span> <span class="entity">id</span> <span class="entity">dtname</span> <span class="entity">param</span> <span class="entity">thy</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> Symtab.lookup <span class="main">(</span>Derive_Data.get <span class="entity">thy</span><span class="main">)</span> <span class="entity">id</span> <span class="keyword2"><span class="keyword">of</span></span>
    NONE <span class="main">=&gt;</span> error <span class="main">(</span><span class="inner_quoted">"No handler to derive sort "</span> ^ quote <span class="entity">id</span> ^
      <span class="inner_quoted">" is registered. Try "</span> ^ quote <span class="inner_quoted">"print_derives"</span> ^ <span class="inner_quoted">" to see available sorts."</span><span class="main">)</span>
  <span class="main">|</span> SOME <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">f</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">f</span> <span class="main">(</span><span class="entity">prep</span> <span class="entity">thy</span> <span class="entity">dtname</span><span class="main">)</span> <span class="entity">param</span> <span class="entity">thy</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">derive</span> <span class="main">=</span> <span class="entity">gen_derive</span> <span class="main">(</span>K I<span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">derive_cmd</span> <span class="entity">id</span> <span class="entity">param</span> <span class="entity">dtname</span> <span class="main">=</span> <span class="entity">gen_derive</span>
  <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">thy</span> <span class="main">=&gt;</span> fst o dest_Type o Syntax.parse_typ <span class="main">(</span>Proof_Context.init_global <span class="entity">thy</span><span class="main">)</span><span class="main">)</span> <span class="entity">id</span> <span class="entity">dtname</span> <span class="entity">param</span>
  
<span class="comment1">(* TODO: also check for alternative of  *)</span>
<span class="comment1">(* NB: Proof_Context.read_type_name_proper ctxt false could be an alternative. *)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.command</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">command_keyword</span> <span class="keyword1">print_derives</span><span class="antiquote">}</span></span></span> <span class="inner_quoted">"lists all registered sorts which can be derived"</span>
    <span class="main">(</span>Scan.succeed <span class="main">(</span><span class="entity">Toplevel.theory</span> <span class="main">(</span>tap <span class="entity">print_info</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.command</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">command_keyword</span> <span class="keyword1">derive</span><span class="antiquote">}</span></span></span> <span class="inner_quoted">"derives some sort"</span>
    <span class="main">(</span>Parse.parname -- Parse.name -- Scan.repeat1 Parse.type_const &gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">param</span><span class="main">,</span> <span class="entity">s</span><span class="main">)</span><span class="main">,</span> <span class="entity">tycons</span><span class="main">)</span> <span class="main">=&gt;</span>
      <span class="entity">Toplevel.theory</span> <span class="main">(</span>fold <span class="main">(</span><span class="entity">derive_cmd</span> <span class="entity">s</span> <span class="entity">param</span><span class="main">)</span> <span class="entity">tycons</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

</pre>
</div><div id="Generator_Aux">
<div class="head">
<h1>Theory Generator_Aux</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Shared Utilities for all Generator›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In this theory we mainly provide some Isabelle/ML infrastructure
  that is used by several generators. It consists of a uniform interface
  to access all the theorems, terms, etc.\ from the BNF package, and 
  some auxiliary functions which provide recursors on datatypes, common tactics, etc.›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Generator_Aux
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="../../HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹bnf_access.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹generator_aux.ML›</span>

<span class="keyword1" id="Generator_Aux-in_set_simps"><span class="command">lemma</span></span> in_set_simps<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> set <span class="main">(</span><span class="free">y</span> <span class="main">#</span> <span class="free">z</span> <span class="main">#</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span> <span class="main">=</span> <span class="free">y</span> <span class="main">∨</span> <span class="free">x</span> <span class="main">∈</span> set <span class="main">(</span><span class="free">z</span> <span class="main">#</span> <span class="free">ys</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> set <span class="main">(</span><span class="main">[</span><span class="free">y</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span> <span class="main">=</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> set <span class="main">[]</span> <span class="main">=</span> False"</span></span> 
  <span class="quoted"><span class="quoted">"Ball <span class="main">(</span>set <span class="main">[]</span><span class="main">)</span> <span class="free">P</span> <span class="main">=</span> True"</span></span> 
  <span class="quoted"><span class="quoted">"Ball <span class="main">(</span>set <span class="main">[</span><span class="free">x</span><span class="main">]</span><span class="main">)</span> <span class="free">P</span> <span class="main">=</span> <span class="free">P</span> <span class="free">x</span>"</span></span> 
  <span class="quoted"><span class="quoted">"Ball <span class="main">(</span>set <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">y</span> <span class="main">#</span> <span class="free">zs</span><span class="main">)</span><span class="main">)</span> <span class="free">P</span> <span class="main">=</span> <span class="main">(</span><span class="free">P</span> <span class="free">x</span> <span class="main">∧</span> Ball <span class="main">(</span>set <span class="main">(</span><span class="free">y</span> <span class="main">#</span> <span class="free">zs</span><span class="main">)</span><span class="main">)</span> <span class="free">P</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
<span class="keyword1" id="Generator_Aux-conj_weak_cong"><span class="command">lemma</span></span> conj_weak_cong<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">=</span> <span class="free">b</span> <span class="main">⟹</span> <span class="free">c</span> <span class="main">=</span> <span class="free">d</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">a</span> <span class="main">∧</span> <span class="free">c</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">b</span> <span class="main">∧</span> <span class="free">d</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Generator_Aux-refl_True"><span class="command">lemma</span></span> refl_True<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">=</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> True"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/bnf_access.ML">
<div class="head">
<h1>File ‹bnf_access.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Deriving class instances for datatypes
    Author:      Christian Sternagel and René Thiemann  &lt;christian.sternagel|rene.thiemann@uibk.ac.at&gt;
    Maintainer:  Christian Sternagel and René Thiemann 
    License:     LGPL
*)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">BNF_ACCESS</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
<span class="comment1">(* thms *)</span>
<span class="keyword1"><span class="keyword">val</span></span> induct_thms <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string list <span class="main">-&gt;</span> thm list
<span class="keyword1"><span class="keyword">val</span></span> case_thms <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string list <span class="main">-&gt;</span> thm list
<span class="keyword1"><span class="keyword">val</span></span> distinct_thms <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string list <span class="main">-&gt;</span> thm list list
<span class="keyword1"><span class="keyword">val</span></span> inject_thms <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string list <span class="main">-&gt;</span> thm list list
<span class="keyword1"><span class="keyword">val</span></span> set_simps <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string list <span class="main">-&gt;</span> thm list list
<span class="keyword1"><span class="keyword">val</span></span> case_simps <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string list <span class="main">-&gt;</span> thm list list
<span class="keyword1"><span class="keyword">val</span></span> map_simps <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string list <span class="main">-&gt;</span> thm list list
<span class="keyword1"><span class="keyword">val</span></span> map_comps <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string list <span class="main">-&gt;</span> thm list

<span class="comment1">(* terms *)</span>
<span class="keyword1"><span class="keyword">val</span></span> map_terms <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string list <span class="main">-&gt;</span> term list
<span class="keyword1"><span class="keyword">val</span></span> set_terms <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string list <span class="main">-&gt;</span> term list list
<span class="keyword1"><span class="keyword">val</span></span> case_consts <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string list <span class="main">-&gt;</span> term list
<span class="keyword1"><span class="keyword">val</span></span> constr_terms <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string <span class="main">-&gt;</span> term list

<span class="comment1">(* types *)</span>
<span class="keyword1"><span class="keyword">val</span></span> constr_argument_types <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string list <span class="main">-&gt;</span> typ list list list
<span class="keyword1"><span class="keyword">val</span></span> bnf_types <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string list <span class="main">-&gt;</span> typ list

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Bnf_Access</span> <span class="main">:</span> <span class="entity">BNF_ACCESS</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">constr_terms</span> <span class="entity">lthy</span> <span class="main">=</span> <span class="entity">BNF_FP_Def_Sugar.fp_sugar_of</span> <span class="entity">lthy</span>
  #&gt; the #&gt; <span class="main">#</span>fp_ctr_sugar #&gt; <span class="main">#</span>ctr_sugar #&gt; <span class="main">#</span>ctrs

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">induct_thms</span> <span class="entity">lthy</span> <span class="main">=</span>
  map <span class="main">(</span>hd o <span class="main">#</span>co_inducts o the o <span class="main">#</span>fp_co_induct_sugar o the o <span class="entity">BNF_FP_Def_Sugar.fp_sugar_of</span> <span class="entity">lthy</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">case_thms</span> <span class="entity">lthy</span> <span class="main">=</span>
  map <span class="main">(</span><span class="main">#</span>exhaust o <span class="main">#</span>ctr_sugar o <span class="main">#</span>fp_ctr_sugar o the o <span class="entity">BNF_FP_Def_Sugar.fp_sugar_of</span> <span class="entity">lthy</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">set_simps</span> <span class="entity">lthy</span> <span class="main">=</span> 
  map <span class="main">(</span><span class="main">#</span>set_thms o <span class="main">#</span>fp_bnf_sugar o the o <span class="entity">BNF_FP_Def_Sugar.fp_sugar_of</span> <span class="entity">lthy</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">distinct_thms</span> <span class="entity">lthy</span> <span class="main">=</span>
  map <span class="main">(</span><span class="main">#</span>distincts o <span class="main">#</span>ctr_sugar o <span class="main">#</span>fp_ctr_sugar o the o <span class="entity">BNF_FP_Def_Sugar.fp_sugar_of</span> <span class="entity">lthy</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">inject_thms</span> <span class="entity">lthy</span> <span class="main">=</span>
  map <span class="main">(</span><span class="main">#</span>injects o <span class="main">#</span>ctr_sugar o <span class="main">#</span>fp_ctr_sugar o the o <span class="entity">BNF_FP_Def_Sugar.fp_sugar_of</span> <span class="entity">lthy</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">case_simps</span> <span class="entity">lthy</span> <span class="main">=</span> 
  map <span class="main">(</span><span class="main">#</span>case_thms o <span class="main">#</span>ctr_sugar o <span class="main">#</span>fp_ctr_sugar o the o <span class="entity">BNF_FP_Def_Sugar.fp_sugar_of</span> <span class="entity">lthy</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_simps</span> <span class="entity">lthy</span> <span class="main">=</span> 
  map <span class="main">(</span><span class="main">#</span>map_thms o <span class="main">#</span>fp_bnf_sugar o the o <span class="entity">BNF_FP_Def_Sugar.fp_sugar_of</span> <span class="entity">lthy</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_comps</span> <span class="entity">lthy</span> <span class="entity">tycos</span> <span class="main">=</span> hd <span class="entity">tycos</span>
  |&gt; <span class="main">(</span><span class="main">#</span>bnfs o <span class="main">#</span>fp_res o the o <span class="entity">BNF_FP_Def_Sugar.fp_sugar_of</span> <span class="entity">lthy</span><span class="main">)</span>
  |&gt; map <span class="main">(</span><span class="entity">BNF_Def.map_comp_of_bnf</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">constr_argument_types</span> <span class="entity">lthy</span> <span class="main">=</span> 
  map <span class="main">(</span><span class="main">#</span>ctrXs_Tss o <span class="main">#</span>fp_ctr_sugar o the o <span class="entity">BNF_FP_Def_Sugar.fp_sugar_of</span> <span class="entity">lthy</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">bnf_types</span> <span class="entity">lthy</span> <span class="main">=</span> 
  map <span class="main">(</span><span class="main">#</span>X o the o <span class="entity">BNF_FP_Def_Sugar.fp_sugar_of</span> <span class="entity">lthy</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_terms</span> <span class="entity">lthy</span> <span class="entity">tycos</span> <span class="main">=</span> hd <span class="entity">tycos</span>
  |&gt; <span class="main">(</span><span class="main">#</span>bnfs o <span class="main">#</span>fp_res o the o <span class="entity">BNF_FP_Def_Sugar.fp_sugar_of</span> <span class="entity">lthy</span><span class="main">)</span>
  |&gt; map <span class="main">(</span><span class="entity">BNF_Def.map_of_bnf</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">set_terms</span> <span class="entity">lthy</span> <span class="entity">tycos</span> <span class="main">=</span> hd <span class="entity">tycos</span>
  |&gt; <span class="main">(</span><span class="main">#</span>bnfs o <span class="main">#</span>fp_res o the o <span class="entity">BNF_FP_Def_Sugar.fp_sugar_of</span> <span class="entity">lthy</span><span class="main">)</span>
  |&gt; map <span class="main">(</span><span class="entity">BNF_Def.sets_of_bnf</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">case_consts</span> <span class="entity">lthy</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">BNF_FP_Def_Sugar.fp_sugar_of</span> <span class="entity">lthy</span>
  #&gt; the #&gt; <span class="main">#</span>fp_ctr_sugar #&gt; <span class="main">#</span>ctr_sugar #&gt; <span class="main">#</span>casex<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/generator_aux.ML">
<div class="head">
<h1>File ‹generator_aux.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Deriving class instances for datatypes
    Author:      Christian Sternagel and René Thiemann  &lt;christian.sternagel|rene.thiemann@uibk.ac.at&gt;
    Maintainer:  Christian Sternagel and René Thiemann
    License:     LGPL
*)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">GENERATOR_AUX</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> alist_to_string <span class="main">:</span> <span class="main">(</span>string * 'a<span class="main">)</span>list <span class="main">-&gt;</span> string

  <span class="comment1">(* put a string in sub-script *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> sub <span class="main">:</span> string <span class="main">-&gt;</span> string

  <span class="comment1">(* put a type-name in sub-script *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> subT <span class="main">:</span> string <span class="main">-&gt;</span> typ <span class="main">-&gt;</span> string

  <span class="comment1">(* [a,..,n] -&gt; _{a_.._n} *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> ints_to_subscript <span class="main">:</span> int list <span class="main">-&gt;</span> string

  <span class="comment1">(* drop last element of a non-empty list *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> drop_last <span class="main">:</span> 'a list <span class="main">-&gt;</span> 'a list

  <span class="comment1">(* rename old types to new types in term, typ-lists (fst and snd components) are assumed to be distinct *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> rename_types <span class="main">:</span> <span class="main">(</span>typ * typ<span class="main">)</span> list <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term

  <span class="comment1">(* λ x1 ... xn.t *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> lambdas <span class="main">:</span> term list <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term

  <span class="comment1">(* thm[OF _(NONE) foo (SOME foo) ...] *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> OF_option <span class="main">:</span> thm <span class="main">-&gt;</span> thm option list <span class="main">-&gt;</span> thm

  <span class="comment1">(* aim: treat a possible empty conjunction and handle each subcase
     by a specific tactic (indexed from 0 onwards) *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> conjI_tac <span class="main">:</span> thm list <span class="main">-&gt;</span>
    <span class="entity">Proof.context</span> <span class="main">-&gt;</span> 'a list <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">Proof.context</span> <span class="main">-&gt;</span> int <span class="main">-&gt;</span> tactic<span class="main">)</span> <span class="main">-&gt;</span> tactic

  <span class="comment1">(* check whether a given type is of a given sort *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> is_class_instance <span class="main">:</span> theory <span class="main">-&gt;</span> string <span class="main">-&gt;</span> sort <span class="main">-&gt;</span> bool

  <span class="keyword1"><span class="keyword">val</span></span> mk_case_tac <span class="main">:</span>
    <span class="entity">Proof.context</span> <span class="main">-&gt;</span>
    term option list list <span class="main">-&gt;</span>
    thm <span class="main">-&gt;</span>
    <span class="main">(</span>int <span class="main">-&gt;</span> <span class="entity">Proof.context</span> * thm list * <span class="main">(</span>string * cterm<span class="main">)</span> list <span class="main">-&gt;</span> tactic<span class="main">)</span> <span class="main">-&gt;</span>
    tactic

  <span class="comment1">(*type-inference after replacing all schematic type-variables by dummyT*)</span>
  <span class="keyword1"><span class="keyword">val</span></span> infer_type <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term

  <span class="comment1">(* like old prove_multi, but in non-blocking future-verion *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> prove_multi_future <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string list <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> term list <span class="main">-&gt;</span>
    <span class="main">(</span><span class="main">{</span>prems<span class="main">:</span> thm list<span class="main">,</span> context<span class="main">:</span> <span class="entity">Proof.context</span><span class="main">}</span> <span class="main">-&gt;</span> tactic<span class="main">)</span> <span class="main">-&gt;</span> thm list

  <span class="comment1">(* determines all mutual recursive types of a given BNF-least-fixpoint-type *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> mutual_recursive_types <span class="main">:</span> string <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string list * typ list

  <span class="comment1">(* a fold over types, differentiating mutual recursive types and other type-constructors *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> recursor <span class="main">:</span>
    <span class="main">(</span>string <span class="main">-&gt;</span> 'info<span class="main">)</span> * <span class="comment1">(* accessing the information of a datatype *)</span>
    <span class="main">(</span>'info <span class="main">-&gt;</span> bool list<span class="main">)</span> * <span class="comment1">(* which arguments are used of a datatype *)</span>
    string list <span class="main">-&gt;</span> <span class="comment1">(* information on used arguments and recursive types *)</span>
    bool <span class="main">-&gt;</span> <span class="comment1">(*recursion over all types (or only used types)*)</span>
    <span class="main">(</span>typ <span class="main">-&gt;</span> 'a<span class="main">)</span> <span class="main">-&gt;</span> <span class="comment1">(* how to treat TFrees *)</span>
    <span class="main">(</span>typ <span class="main">-&gt;</span> 'a<span class="main">)</span> <span class="main">-&gt;</span> <span class="comment1">(* how to treat TVars *)</span>
    <span class="main">(</span>typ <span class="main">-&gt;</span> 'a<span class="main">)</span> <span class="main">-&gt;</span> <span class="comment1">(* how to treat recursive case *)</span>
    <span class="main">(</span><span class="main">(</span>typ * 'a option<span class="main">)</span> list * 'info <span class="main">-&gt;</span> 'a<span class="main">)</span> <span class="main">-&gt;</span> <span class="comment1">(* how to treat non-rec.-case; NONE result for unused types, if all = false *)</span>
    typ <span class="main">-&gt;</span> 'a

  <span class="comment1">(* split global list of induction hypotheses according to list of argument types *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> split_IHs <span class="main">:</span> <span class="main">(</span>string <span class="main">-&gt;</span> 'info<span class="main">)</span> * <span class="main">(</span>'info <span class="main">-&gt;</span> bool list<span class="main">)</span> * string list <span class="main">-&gt;</span> typ list <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> thm list list

  <span class="comment1">(* a standard tactic to solve proof obligation with recursion on types:
     variables and rec.-cases are handled via IHs and preconditions,
     for non-rec.-type constructors  a partial soundness thm has to be generated from the info *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> std_recursor_tac <span class="main">:</span> <span class="main">(</span>string <span class="main">-&gt;</span> 'info<span class="main">)</span> * <span class="main">(</span>'info <span class="main">-&gt;</span> bool list<span class="main">)</span> * string list <span class="main">-&gt;</span>
    typ list <span class="main">-&gt;</span>
    <span class="main">(</span>'info <span class="main">-&gt;</span> thm<span class="main">)</span> <span class="main">-&gt;</span>
    thm list <span class="main">-&gt;</span> typ <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> tactic

  <span class="comment1">(* delivers a full type from a type name by instantiating the type-variables of that
   type with different variables of a given sort, also returns the chosen variables
   as second component *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> typ_and_vs_of_typname <span class="main">:</span> theory <span class="main">-&gt;</span> string <span class="main">-&gt;</span> sort <span class="main">-&gt;</span> typ * <span class="main">(</span>string * sort<span class="main">)</span> list

  <span class="comment1">(* similar to typ_and_vs_of_typname, but only for used types the sort contraint will be enforced *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> typ_and_vs_of_used_typname <span class="main">:</span> string <span class="main">-&gt;</span> bool list <span class="main">-&gt;</span> string list <span class="main">-&gt;</span> typ * <span class="main">(</span>string * string list<span class="main">)</span> list

  <span class="keyword1"><span class="keyword">val</span></span> freeify_tvars <span class="main">:</span> typ <span class="main">-&gt;</span> typ

  <span class="keyword1"><span class="keyword">val</span></span> add_used_tycos <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string <span class="main">-&gt;</span> string list <span class="main">-&gt;</span> string list

  <span class="keyword1"><span class="keyword">val</span></span> type_parameters <span class="main">:</span> typ <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="main">(</span>string * sort<span class="main">)</span> list * typ list

  <span class="keyword1"><span class="keyword">val</span></span> define_overloaded <span class="main">:</span> <span class="main">(</span>string * term<span class="main">)</span> <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span> thm * local_theory

  <span class="keyword1"><span class="keyword">val</span></span> define_overloaded_generic <span class="main">:</span> <span class="main">(</span><span class="entity">Attrib.binding</span> * term<span class="main">)</span> <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span> thm * local_theory

  <span class="keyword1"><span class="keyword">val</span></span> mk_id <span class="main">:</span> typ <span class="main">-&gt;</span> term

  <span class="keyword1"><span class="keyword">val</span></span> mk_def <span class="main">:</span> typ <span class="main">-&gt;</span> string <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term

  <span class="keyword1"><span class="keyword">val</span></span> mk_infer_const <span class="main">:</span> string <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term

  <span class="keyword1"><span class="keyword">val</span></span> ind_case_to_idxs <span class="main">:</span> 'a list list <span class="main">-&gt;</span> int <span class="main">-&gt;</span> int * int

  <span class="keyword1"><span class="keyword">val</span></span> create_partial <span class="main">:</span>
    'a <span class="main">-&gt;</span>
    <span class="main">(</span>typ <span class="main">-&gt;</span> bool<span class="main">)</span> <span class="main">-&gt;</span>
    <span class="main">(</span>local_theory <span class="main">-&gt;</span> string <span class="main">-&gt;</span> bool list<span class="main">)</span> <span class="main">-&gt;</span>
    <span class="main">(</span>local_theory <span class="main">-&gt;</span> string <span class="main">-&gt;</span> term<span class="main">)</span> <span class="main">-&gt;</span>
    <span class="main">(</span>local_theory <span class="main">-&gt;</span> string <span class="main">-&gt;</span> 'a <span class="main">-&gt;</span> term<span class="main">)</span> <span class="main">-&gt;</span>
    string list <span class="main">-&gt;</span>
    <span class="main">(</span>local_theory <span class="main">-&gt;</span> string <span class="main">-&gt;</span> 'a<span class="main">)</span> <span class="main">-&gt;</span>
    typ <span class="main">-&gt;</span>
    local_theory <span class="main">-&gt;</span> term

  <span class="keyword1"><span class="keyword">val</span></span> create_map <span class="main">:</span>
    <span class="main">(</span>typ <span class="main">-&gt;</span> term<span class="main">)</span> <span class="main">-&gt;</span> <span class="comment1">(*default operation*)</span>
    <span class="main">(</span>string * typ <span class="main">-&gt;</span> 'a <span class="main">-&gt;</span> term<span class="main">)</span> <span class="main">-&gt;</span> <span class="comment1">(*recursive occurrences of operation*)</span>
    'a <span class="main">-&gt;</span> <span class="comment1">(*initial state*)</span>
    <span class="main">(</span>typ <span class="main">-&gt;</span> bool<span class="main">)</span> <span class="main">-&gt;</span> <span class="comment1">(*early abort*)</span>
    <span class="main">(</span>local_theory <span class="main">-&gt;</span> string <span class="main">-&gt;</span> bool list<span class="main">)</span> <span class="main">-&gt;</span> <span class="comment1">(*used positions*)</span>
    <span class="main">(</span>local_theory <span class="main">-&gt;</span> string <span class="main">-&gt;</span> term<span class="main">)</span> <span class="main">-&gt;</span> <span class="comment1">(*map function*)</span>
    <span class="main">(</span>local_theory <span class="main">-&gt;</span> string <span class="main">-&gt;</span> 'a <span class="main">-&gt;</span> term<span class="main">)</span> <span class="main">-&gt;</span> <span class="comment1">(*partial operation*)</span>
    string list <span class="main">-&gt;</span> <span class="comment1">(*mutually recursive types*)</span>
    <span class="main">(</span>local_theory <span class="main">-&gt;</span> string <span class="main">-&gt;</span> 'a<span class="main">)</span> <span class="main">-&gt;</span> <span class="comment1">(*next state function*)</span>
    typ <span class="main">-&gt;</span> <span class="comment1">(*type for which map should be created*)</span>
    local_theory <span class="main">-&gt;</span> term

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Generator_Aux</span> <span class="main">:</span> <span class="entity">GENERATOR_AUX</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">alist_to_string</span> <span class="entity">al</span> <span class="main">=</span> map fst <span class="entity">al</span> |&gt; commas |&gt; enclose <span class="inner_quoted">"("</span> <span class="inner_quoted">")"</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">typ_and_vs_of_used_typname</span> <span class="entity">typ_name</span> <span class="entity">used_pos</span> <span class="entity">sort</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sorts</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">b</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">b</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">sort</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">type</span><span class="antiquote">}</span></span><span class="main">)</span> <span class="entity">used_pos</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty_vars</span> <span class="main">=</span> Name.invent_names <span class="main">(</span>Name.make_context <span class="main">[</span><span class="entity">typ_name</span><span class="main">]</span><span class="main">)</span> <span class="inner_quoted">"a"</span> <span class="entity">sorts</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty</span> <span class="main">=</span> Type <span class="main">(</span><span class="entity">typ_name</span><span class="main">,</span>map TFree <span class="entity">ty_vars</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="entity">ty</span><span class="main">,</span><span class="entity">ty_vars</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_class_instance</span> <span class="entity">thy</span> <span class="entity">tname</span> <span class="entity">class</span> <span class="main">=</span>
  Sorts.has_instance <span class="main">(</span>Sign.classes_of <span class="entity">thy</span><span class="main">)</span> <span class="entity">tname</span> <span class="entity">class</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">conjI_tac</span> <span class="entity">conj_thms</span> <span class="entity">ctxt</span> <span class="entity">xs</span> <span class="entity">tac</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">xs</span> <span class="keyword2"><span class="keyword">then</span></span> all_tac
  <span class="keyword2"><span class="keyword">else</span></span>
    <span class="main">(</span>K <span class="main">(</span><span class="entity">Method.try_intros_tac</span> <span class="entity">ctxt</span> <span class="entity">conj_thms</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
    THEN_ALL_NEW <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">k'</span> <span class="main">=&gt;</span>
      <span class="entity">Subgoal.SUBPROOF</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt'</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span> <span class="entity">tac</span> <span class="entity">ctxt'</span> <span class="main">(</span><span class="entity">k'</span> - <span class="inner_numeral">1</span><span class="main">)</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="entity">k'</span><span class="main">)</span><span class="main">)</span>
    <span class="inner_numeral">1</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_id</span> <span class="entity">T</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">x</span> <span class="main">=</span> Free <span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span> lambda <span class="entity">x</span> <span class="entity">x</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">local</span></span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">create_gen</span> <span class="entity">mk_comp</span> <span class="entity">dfun</span> <span class="entity">mk_p</span> <span class="entity">x</span> <span class="entity">early_abort</span> <span class="entity">up</span> <span class="entity">mfun</span> <span class="entity">pfun</span> <span class="entity">tycos</span> <span class="entity">read</span> <span class="entity">T</span> <span class="entity">lthy</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">create</span> <span class="entity">x</span> <span class="main">(</span><span class="entity">T</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">(</span>Type <span class="main">(</span><span class="entity">tyco</span><span class="main">,</span> <span class="entity">Ts</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
            <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">early_abort</span> <span class="entity">T</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">mk_id</span> dummyT
            <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> member <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">tycos</span> <span class="entity">tyco</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">mk_p</span> <span class="main">(</span><span class="entity">tyco</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="entity">x</span>
            <span class="keyword2"><span class="keyword">else</span></span>
              <span class="keyword2"><span class="keyword">let</span></span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">x'</span> <span class="main">=</span> <span class="entity">read</span> <span class="entity">lthy</span> <span class="entity">tyco</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ts</span> <span class="main">=</span> <span class="main">(</span><span class="entity">up</span> <span class="entity">lthy</span> <span class="entity">tyco</span> ~~ <span class="entity">Ts</span><span class="main">)</span> |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">used</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="main">=&gt;</span>
                  <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">used</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">create</span> <span class="entity">x'</span> <span class="entity">T</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">dfun</span> dummyT<span class="main">)</span>
              <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">mk_comp</span> <span class="main">(</span><span class="entity">pfun</span> <span class="entity">lthy</span> <span class="entity">tyco</span> <span class="entity">x</span><span class="main">,</span> list_comb <span class="main">(</span><span class="entity">mfun</span> <span class="entity">lthy</span> <span class="entity">tyco</span><span class="main">,</span> <span class="entity">ts</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>
        <span class="main">|</span> <span class="entity">create</span> <span class="main">_</span> <span class="main">_</span> <span class="main">=</span> <span class="entity">mk_id</span> dummyT
    <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">create</span> <span class="entity">x</span> <span class="entity">T</span> <span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword2"><span class="keyword">in</span></span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">create_partial</span> <span class="entity">x</span> <span class="main">=</span> <span class="entity">create_gen</span> <span class="entity">HOLogic.mk_comp</span> <span class="entity">mk_id</span> <span class="main">(</span><span class="main">(</span>K o K<span class="main">)</span> <span class="main">(</span><span class="entity">mk_id</span> dummyT<span class="main">)</span><span class="main">)</span> <span class="entity">x</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">create_map</span> <span class="entity">dfun</span> <span class="entity">mk_p</span> <span class="entity">x</span> <span class="main">=</span> <span class="entity">create_gen</span> snd <span class="entity">dfun</span> <span class="entity">mk_p</span> <span class="entity">x</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">drop_last</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> <span class="keyword3"><span class="keyword">raise</span></span> Empty
  <span class="main">|</span> <span class="entity">drop_last</span> <span class="main">(</span><span class="entity">x</span>::<span class="entity">xs</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">init</span> <span class="main">_</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="main">]</span>
          <span class="main">|</span> <span class="entity">init</span> <span class="entity">x</span> <span class="main">(</span><span class="entity">y</span>::<span class="entity">ys</span><span class="main">)</span> <span class="main">=</span> <span class="entity">x</span> :: <span class="entity">init</span> <span class="entity">y</span> <span class="entity">ys</span>
      <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">init</span> <span class="entity">x</span> <span class="entity">xs</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rename_types</span> <span class="main">[</span><span class="main">]</span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">t</span>
  <span class="main">|</span> <span class="entity">rename_types</span> <span class="main">(</span><span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> :: <span class="entity">ts</span><span class="main">)</span> <span class="entity">t</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">t1</span> <span class="main">=</span> <span class="entity">t2</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">rename_types</span> <span class="entity">ts</span> <span class="entity">t</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">swap</span> <span class="main">=</span> <span class="main">[</span><span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">t2</span><span class="main">,</span> <span class="entity">t1</span><span class="main">)</span><span class="main">]</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="entity">rename_types</span>
            <span class="main">(</span>map <span class="main">(</span>apfst <span class="main">(</span>typ_subst_atomic <span class="entity">swap</span><span class="main">)</span><span class="main">)</span> <span class="entity">ts</span><span class="main">)</span>
            <span class="main">(</span>subst_atomic_types <span class="entity">swap</span> <span class="entity">t</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">sub</span> <span class="entity">s</span> <span class="main">=</span> Symbol.explode <span class="entity">s</span> |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">c</span> <span class="main">=&gt;</span> <span class="inner_quoted">"⇩"</span> ^ <span class="entity">c</span><span class="main">)</span> |&gt; implode

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">subT</span> <span class="entity">name</span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">name</span> ^ <span class="entity">sub</span>
      <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">T</span> <span class="keyword2"><span class="keyword">of</span></span>
        TVar <span class="main">(</span><span class="entity">xi</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> Term.string_of_vname <span class="entity">xi</span>
      <span class="main">|</span> TFree <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">x</span>
      <span class="main">|</span> Type <span class="main">(</span><span class="entity">tyco</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">tyco</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ints_to_subscript</span> <span class="main">=</span> <span class="entity">sub</span> o foldr1 <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">x</span> ^ <span class="inner_quoted">"_"</span> ^ <span class="entity">y</span><span class="main">)</span> o map string_of_int

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ind_case_to_idxs</span> <span class="entity">cTys</span><span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">number</span> <span class="entity">n</span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span> <span class="entity">j</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="main">_</span> :: <span class="entity">xs</span><span class="main">)</span> :: <span class="entity">ys</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">n</span><span class="main">,</span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span> <span class="entity">j</span><span class="main">)</span><span class="main">)</span> :: <span class="entity">number</span> <span class="main">(</span><span class="entity">n</span>+<span class="inner_numeral">1</span><span class="main">)</span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span> <span class="entity">j</span>+<span class="inner_numeral">1</span><span class="main">)</span> <span class="main">(</span><span class="entity">xs</span> :: <span class="entity">ys</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">number</span> <span class="entity">n</span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span> :: <span class="entity">ys</span><span class="main">)</span> <span class="main">=</span> <span class="entity">number</span> <span class="entity">n</span> <span class="main">(</span><span class="entity">i</span>+<span class="inner_numeral">1</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span> <span class="entity">ys</span>
      <span class="main">|</span> <span class="entity">number</span> <span class="main">_</span> <span class="main">_</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">in</span></span> AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">(</span><span class="entity">number</span> <span class="inner_numeral">0</span> <span class="main">(</span><span class="inner_numeral">0</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span> <span class="entity">cTys</span><span class="main">)</span> #&gt; the <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(*recursively compute free type variables that are actually used by a given ((co)data)type, i.e.,
are not (indirect) phantom types.*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_used_tfrees</span> <span class="entity">ctxt</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span>

        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">err_schematic</span> <span class="entity">T</span> <span class="main">=</span>
              error <span class="main">(</span><span class="inner_quoted">"illegal schematic type variable "</span> ^ quote <span class="main">(</span>Syntax.string_of_typ <span class="entity">ctxt</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span>

        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add</span> <span class="main">_</span> <span class="main">(</span><span class="entity">T</span> <span class="keyword1"><span class="keyword">as</span></span> TVar <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">err_schematic</span> <span class="entity">T</span>
          <span class="main">|</span> <span class="entity">add</span> <span class="main">_</span> <span class="main">(</span>TFree <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> insert <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">x</span>
          <span class="main">|</span> <span class="entity">add</span> <span class="entity">skip</span> <span class="main">(</span>Type <span class="main">(</span><span class="entity">tyco</span><span class="main">,</span> <span class="entity">Ts</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
              <span class="keyword2"><span class="keyword">if</span></span> member <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">skip</span> <span class="entity">tyco</span> <span class="keyword2"><span class="keyword">then</span></span> I
              <span class="keyword2"><span class="keyword">else</span></span>
                <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">BNF_FP_Def_Sugar.fp_sugar_of</span> <span class="entity">ctxt</span> <span class="entity">tyco</span> <span class="keyword2"><span class="keyword">of</span></span>
                  NONE <span class="main">=&gt;</span> fold <span class="main">(</span><span class="entity">add</span> <span class="entity">skip</span><span class="main">)</span> <span class="entity">Ts</span>
                <span class="main">|</span> SOME <span class="main">_</span> <span class="main">=&gt;</span> <span class="comment1">(*(co)datatype*)</span>
                  <span class="entity">BNF_LFP_Compat.the_spec</span> <span class="entity">thy</span> <span class="entity">tyco</span>
                  |&gt;&gt; map TFree |&gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span> <span class="entity">x</span> ~~ <span class="entity">Ts</span><span class="main">)</span> ||&gt; map snd ||&gt; flat
                  |&gt; uncurry <span class="main">(</span>map o typ_subst_atomic<span class="main">)</span>
                  |&gt; fold <span class="main">(</span><span class="entity">add</span> <span class="main">(</span>insert <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">tyco</span> <span class="entity">skip</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">add</span> <span class="main">[</span><span class="main">]</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(*collect all Type(constructor) names occurring in a given type*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_tycos</span> <span class="main">(</span>Type <span class="main">(</span><span class="entity">tyco</span><span class="main">,</span> <span class="entity">Ts</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> insert <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">tyco</span> #&gt; fold <span class="entity">add_tycos</span> <span class="entity">Ts</span>
  <span class="main">|</span> <span class="entity">add_tycos</span> <span class="main">_</span> <span class="main">=</span> I

<span class="comment1">(*starting from a (co)datatype "tyco", collect all Type(constructor) names that are
involved in its construction*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_used_tycos</span> <span class="entity">ctxt</span> <span class="entity">tyco</span> <span class="main">=</span>
      <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">BNF_FP_Def_Sugar.fp_sugar_of</span> <span class="entity">ctxt</span> <span class="entity">tyco</span> <span class="keyword2"><span class="keyword">of</span></span>
        NONE <span class="main">=&gt;</span> I
      <span class="main">|</span> SOME <span class="entity">sugar</span> <span class="main">=&gt;</span> <span class="main">#</span>fp_ctr_sugar <span class="entity">sugar</span> |&gt; <span class="main">#</span>ctrXs_Tss |&gt; flat |&gt; fold <span class="entity">add_tycos</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">infer_type</span> <span class="entity">ctxt</span> <span class="main">=</span>
      map_types <span class="main">(</span>map_type_tvar <span class="main">(</span>K dummyT<span class="main">)</span><span class="main">)</span>
      #&gt; singleton <span class="main">(</span>Type_Infer_Context.infer_types <span class="entity">ctxt</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lambdas</span> <span class="main">=</span> fold_rev lambda

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_def</span> <span class="entity">T</span> <span class="entity">c</span> <span class="entity">rhs</span> <span class="main">=</span> Logic.mk_equals <span class="main">(</span>Const <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">OF_option</span> <span class="entity">thm</span> <span class="entity">thms</span> <span class="main">=</span> <span class="entity">thm</span> OF map <span class="main">(</span>the_default <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">lemma</span> <span class="quoted">"<span class="free">P</span> <span class="main">⟹</span> <span class="free">P</span>"</span> <span class="keyword1"><span class="keyword">by</span></span> <span class="operator">simp</span><span class="antiquote">}</span></span></span><span class="main">)</span> <span class="entity">thms</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">typ_and_vs_of_typname</span> <span class="entity">thy</span> <span class="entity">typ_name</span> <span class="entity">sort</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ar</span> <span class="main">=</span> Sign.arity_number <span class="entity">thy</span> <span class="entity">typ_name</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sorts</span> <span class="main">=</span> map <span class="main">(</span>K <span class="entity">sort</span><span class="main">)</span> <span class="main">(</span><span class="inner_numeral">1</span> upto <span class="entity">ar</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty_vars</span> <span class="main">=</span> Name.invent_names <span class="main">(</span>Name.make_context <span class="main">[</span><span class="entity">typ_name</span><span class="main">]</span><span class="main">)</span> <span class="inner_quoted">"a"</span> <span class="entity">sorts</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty</span> <span class="main">=</span> Type <span class="main">(</span><span class="entity">typ_name</span><span class="main">,</span>map TFree <span class="entity">ty_vars</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">ty</span><span class="main">,</span><span class="entity">ty_vars</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>


<span class="comment1">(* code copied from HOL/SPARK/TOOLS *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">define_overloaded_generic</span> <span class="main">(</span><span class="entity">binding</span><span class="main">,</span><span class="entity">eq</span><span class="main">)</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">eq</span> |&gt; Syntax.check_term <span class="entity">lthy</span> |&gt;
      Logic.dest_equals |&gt;&gt; dest_Free<span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">thm</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span> Local_Theory.define
      <span class="main">(</span><span class="main">(</span>Binding.name <span class="entity">c</span><span class="main">,</span> NoSyn<span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">binding</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span><span class="main">)</span> <span class="entity">lthy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt_thy</span> <span class="main">=</span> Proof_Context.init_global <span class="main">(</span>Proof_Context.theory_of <span class="entity">lthy'</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm'</span> <span class="main">=</span> singleton <span class="main">(</span>Proof_Context.export <span class="entity">lthy'</span> <span class="entity">ctxt_thy</span><span class="main">)</span> <span class="entity">thm</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">thm'</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">define_overloaded</span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span><span class="entity">eq</span><span class="main">)</span> <span class="main">=</span> <span class="entity">define_overloaded_generic</span> <span class="main">(</span><span class="main">(</span>Binding.name <span class="entity">name</span><span class="main">,</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">attributes</span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">,</span><span class="entity">eq</span><span class="main">)</span>


<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_case_tac</span> <span class="entity">ctxt</span> <span class="entity">insts</span> <span class="entity">thm</span> <span class="entity">sub_case_tac</span> <span class="main">=</span>
  <span class="main">(</span>DETERM o <span class="entity">Induct.cases_tac</span> <span class="entity">ctxt</span> false <span class="entity">insts</span> <span class="main">(</span>SOME <span class="entity">thm</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span>
  THEN_ALL_NEW <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">i</span> <span class="main">=&gt;</span>
    <span class="entity">Subgoal.SUBPROOF</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> prems <span class="main">=</span> <span class="entity">hyps</span><span class="main">,</span> params <span class="main">=</span> <span class="entity">params</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
      <span class="entity">sub_case_tac</span> <span class="main">(</span><span class="entity">i</span>-<span class="inner_numeral">1</span><span class="main">)</span> <span class="main">(</span><span class="entity">ctxt</span><span class="main">,</span> <span class="entity">hyps</span><span class="main">,</span> <span class="entity">params</span><span class="main">)</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="entity">i</span><span class="main">)</span><span class="main">)</span>
  <span class="inner_numeral">1</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">freeify_tvars</span> <span class="main">=</span> map_type_tvar <span class="main">(</span>TFree o apfst fst<span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mutual_recursive_types</span> <span class="entity">tyco</span> <span class="entity">lthy</span> <span class="main">=</span>
      <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">BNF_FP_Def_Sugar.fp_sugar_of</span> <span class="entity">lthy</span> <span class="entity">tyco</span> <span class="keyword2"><span class="keyword">of</span></span>
        SOME <span class="entity">sugar</span> <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">if</span></span> Sign.arity_number <span class="main">(</span>Proof_Context.theory_of <span class="entity">lthy</span><span class="main">)</span> <span class="entity">tyco</span> -
            <span class="entity">BNF_Def.live_of_bnf</span> <span class="main">(</span><span class="main">#</span>fp_bnf <span class="entity">sugar</span><span class="main">)</span> &gt; <span class="inner_numeral">0</span>
          <span class="keyword2"><span class="keyword">then</span></span> error <span class="inner_quoted">"only datatypes without dead type parameters are supported"</span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="main">#</span>fp <span class="entity">sugar</span> <span class="main">=</span> <span class="entity">BNF_Util.Least_FP</span> <span class="keyword2"><span class="keyword">then</span></span>
            <span class="entity">sugar</span> |&gt; <span class="main">#</span>fp_res |&gt; <span class="main">#</span>Ts |&gt; `<span class="main">(</span>map <span class="main">(</span>fst o dest_Type<span class="main">)</span><span class="main">)</span>
            ||&gt; map <span class="entity">freeify_tvars</span>
          <span class="keyword2"><span class="keyword">else</span></span> error <span class="inner_quoted">"only least fixpoints are supported"</span>
      <span class="main">|</span> NONE <span class="main">=&gt;</span> error <span class="main">(</span><span class="inner_quoted">"type "</span> ^ quote <span class="entity">tyco</span> ^ <span class="inner_quoted">" does not appear to be a new style datatype"</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">type_parameters</span> <span class="entity">T</span> <span class="entity">lthy</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tfrees</span> <span class="main">=</span> <span class="entity">T</span> |&gt; dest_Type |&gt; snd |&gt; map dest_TFree
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">used_tfrees</span> <span class="main">=</span> <span class="comment1">(*type parameters of type tyco that are used (maintain original order)*)</span>
          inter <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">(</span><span class="entity">add_used_tfrees</span> <span class="entity">lthy</span> <span class="entity">T</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="main">(</span>map fst <span class="entity">tfrees</span><span class="main">)</span>
          |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">a</span> <span class="main">=&gt;</span> TFree <span class="main">(</span><span class="entity">a</span><span class="main">,</span> AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">tfrees</span> <span class="entity">a</span> |&gt; the<span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">tfrees</span><span class="main">,</span> <span class="entity">used_tfrees</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">sum_list</span> <span class="entity">xs</span> <span class="main">=</span> fold <span class="main">(</span>curry <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> +<span class="main">)</span><span class="main">)</span> <span class="entity">xs</span> <span class="inner_numeral">0</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_infer_const</span> <span class="entity">name</span> <span class="entity">ctxt</span> <span class="entity">c</span> <span class="main">=</span> <span class="entity">infer_type</span> <span class="entity">ctxt</span> <span class="main">(</span>Const <span class="main">(</span><span class="entity">name</span><span class="main">,</span> dummyT<span class="main">)</span> $ <span class="entity">c</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove_multi_future</span> <span class="entity">ctxt</span> <span class="main">=</span> Goal.prove_common <span class="entity">ctxt</span> <span class="main">(</span>SOME <span class="inner_numeral">~1</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">recursor</span> <span class="entity">rec_info</span> <span class="entity">all</span> <span class="entity">free</span> <span class="entity">tvar</span> <span class="entity">r</span> <span class="entity">typ</span> <span class="main">(</span><span class="entity">T</span> <span class="keyword1"><span class="keyword">as</span></span> Type <span class="main">(</span><span class="entity">tyco</span><span class="main">,</span><span class="entity">Ts</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">if</span></span> member <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">(</span><span class="main">#</span><span class="inner_numeral">3</span> <span class="entity">rec_info</span><span class="main">)</span> <span class="entity">tyco</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">r</span> <span class="entity">T</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">get_info</span><span class="main">,</span><span class="entity">get_used</span><span class="main">,</span><span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">rec_info</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">info</span> <span class="main">=</span> <span class="entity">get_info</span> <span class="entity">tyco</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">up</span> <span class="main">=</span> <span class="entity">get_used</span> <span class="entity">info</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">recs</span> <span class="main">=</span> <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">all</span> <span class="keyword2"><span class="keyword">then</span></span> map <span class="main">(</span>pair true<span class="main">)</span> <span class="entity">Ts</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">up</span> ~~ <span class="entity">Ts</span><span class="main">)</span> |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">b</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="main">=&gt;</span>
            <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">b</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="entity">T</span><span class="main">,</span> SOME <span class="main">(</span><span class="entity">recursor</span> <span class="entity">rec_info</span> <span class="entity">all</span> <span class="entity">free</span> <span class="entity">tvar</span> <span class="entity">r</span> <span class="entity">typ</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="entity">T</span><span class="main">,</span> NONE<span class="main">)</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">typ</span> <span class="main">(</span><span class="entity">recs</span><span class="main">,</span> <span class="entity">info</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>
  <span class="main">|</span> <span class="entity">recursor</span> <span class="main">_</span> <span class="main">_</span> <span class="entity">free</span> <span class="main">_</span> <span class="main">_</span> <span class="main">_</span> <span class="main">(</span><span class="entity">T</span> <span class="keyword1"><span class="keyword">as</span></span> TFree <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">free</span> <span class="entity">T</span>
  <span class="main">|</span> <span class="entity">recursor</span> <span class="main">_</span> <span class="main">_</span> <span class="main">_</span> <span class="entity">tvar</span> <span class="main">_</span> <span class="main">_</span> <span class="main">(</span><span class="entity">T</span> <span class="keyword1"><span class="keyword">as</span></span> TVar <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">tvar</span> <span class="entity">T</span>

<span class="comment1">(* use the recursor to compute the number of IHs, in order to split them *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">num_IHs</span> <span class="entity">rec_info</span> <span class="main">=</span> <span class="entity">recursor</span> <span class="entity">rec_info</span> true <span class="main">(</span>K <span class="inner_numeral">0</span><span class="main">)</span> <span class="main">(</span>K <span class="inner_numeral">0</span><span class="main">)</span> <span class="main">(</span>K <span class="inner_numeral">1</span><span class="main">)</span>
      <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">xs</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">sum_list</span> <span class="main">(</span>map <span class="main">(</span>the o snd<span class="main">)</span> <span class="entity">xs</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">split_IHs</span> <span class="entity">rec_info</span> <span class="main">(</span><span class="entity">ty</span> :: <span class="entity">tys</span> <span class="main">:</span> typ list<span class="main">)</span> <span class="main">(</span><span class="entity">IHs</span> <span class="main">:</span> thm list<span class="main">)</span> <span class="main">:</span> thm list list <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">n</span> <span class="main">=</span> <span class="entity">num_IHs</span> <span class="entity">rec_info</span> <span class="entity">ty</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">n</span> &gt; length <span class="entity">IHs</span> <span class="keyword2"><span class="keyword">then</span></span> error <span class="inner_quoted">"split IH error: too few"</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        take <span class="entity">n</span> <span class="entity">IHs</span> :: <span class="entity">split_IHs</span> <span class="entity">rec_info</span> <span class="entity">tys</span> <span class="main">(</span>drop <span class="entity">n</span> <span class="entity">IHs</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
  <span class="main">|</span> <span class="entity">split_IHs</span> <span class="main">_</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="main">]</span>
  <span class="main">|</span> <span class="entity">split_IHs</span> <span class="main">_</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span><span class="main">_</span> :: <span class="main">_</span><span class="main">)</span> <span class="main">=</span> error <span class="inner_quoted">"split IH error: too many"</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">std_recursor_tac</span> <span class="entity">rec_info</span> <span class="entity">used_tfrees</span> <span class="entity">info_to_pthm</span> <span class="entity">assms</span> <span class="main">=</span> <span class="entity">recursor</span> <span class="entity">rec_info</span> false
      <span class="comment1">(* TFrees via pre_condition and blast *)</span>
      <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">T</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">IH</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">IH</span> <span class="keyword2"><span class="keyword">then</span></span>
            <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="main">[</span>nth <span class="entity">assms</span> <span class="main">(</span>find_index <span class="main">(</span>equal <span class="entity">T</span><span class="main">)</span> <span class="entity">used_tfrees</span><span class="main">)</span><span class="main">]</span> THEN_ALL_NEW <span class="entity">blast_tac</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="inner_numeral">1</span>
          <span class="keyword2"><span class="keyword">else</span></span> error <span class="inner_quoted">"error 1 in distributing IHs in recursor_tac"</span><span class="main">)</span>
      <span class="comment1">(* TVars may not occur *)</span>
      <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ty</span> <span class="main">=&gt;</span> error <span class="main">(</span><span class="inner_quoted">"error in recursor_tac for "</span> ^ <span class="antiquoted"><span class="entity"><span class="entity"><span class="antiquote">@{</span><span class="operator">make_string</span><span class="antiquote">}</span></span></span></span> <span class="entity">ty</span><span class="main">)</span><span class="main">)</span>
      <span class="comment1">(* recursive case via IH and blast *)</span>
      <span class="main">(</span>K <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">IHs</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">if</span></span> length <span class="entity">IHs</span> <span class="main">=</span> <span class="inner_numeral">1</span> <span class="keyword2"><span class="keyword">then</span></span>
          <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="main">[</span>hd <span class="entity">IHs</span><span class="main">]</span> THEN_ALL_NEW <span class="entity">blast_tac</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="inner_numeral">1</span>
        <span class="keyword2"><span class="keyword">else</span></span> error <span class="inner_quoted">"error 2 in distributing IHs in recursor_tac"</span><span class="main">)</span><span class="main">)</span>
      <span class="comment1">(* non-rec.-case distributed IHs and invokes partial soundness thm *)</span>
      <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">tys_tactics</span><span class="main">,</span> <span class="entity">info</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">IH</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">IHs</span> <span class="main">=</span> <span class="entity">split_IHs</span> <span class="entity">rec_info</span> <span class="main">(</span>map fst <span class="entity">tys_tactics</span><span class="main">)</span> <span class="entity">IH</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tactics</span> <span class="main">=</span> <span class="entity">tys_tactics</span> ~~ <span class="entity">IHs</span> |&gt; map_filter <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">tac_opt</span><span class="main">)</span><span class="main">,</span> <span class="entity">IH</span><span class="main">)</span> <span class="main">=&gt;</span>
            Option.map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">f</span> <span class="main">=&gt;</span> <span class="entity">f</span> <span class="entity">IH</span><span class="main">)</span> <span class="entity">tac_opt</span><span class="main">)</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pthm</span> <span class="main">=</span> <span class="entity">info_to_pthm</span> <span class="entity">info</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          HEADGOAL <span class="main">(</span>
            resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">pthm</span><span class="main">]</span>
            THEN_ALL_NEW <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">k</span> <span class="main">=&gt;</span> <span class="entity">Subgoal.SUBPROOF</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span><span class="entity">prems</span><span class="main">,</span> context <span class="main">=</span> <span class="entity">ctxt'</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
              <span class="entity">Method.insert_tac</span> <span class="entity">ctxt'</span> <span class="entity">prems</span> <span class="inner_numeral">1</span>
              THEN <span class="main">(</span>nth <span class="entity">tactics</span> <span class="main">(</span><span class="entity">k</span> - <span class="inner_numeral">1</span><span class="main">)</span> <span class="entity">ctxt'</span><span class="main">)</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="entity">k</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Comparator">
<div class="head">
<h1>Theory Comparator</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Deriving class instances for datatypes
    Author:      Christian Sternagel and René Thiemann  &lt;christian.sternagel|rene.thiemann@uibk.ac.at&gt;
    Maintainer:  Christian Sternagel and René Thiemann 
    License:     LGPL
*)</span>
<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Comparisons›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Comparators and Linear Orders›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Comparator
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Instead of having to define a strict and a weak linear order, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="main"><span class="main">(&lt;)</span></span><span class="main"><span class="main">,</span></span> <span class="main"><span class="main">(≤)</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
 one can alternative use a comparator to define the linear order, which may deliver 
 three possible outcomes when comparing two values.›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> order <span class="main">=</span> Eq <span class="main">|</span> Lt <span class="main">|</span> Gt

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'a</span> comparator <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> order"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In the following, we provide the obvious definitions how to switch between 
  linear orders and comparators.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">lt_of_comp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> comparator <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lt_of_comp</span> <span class="free"><span class="bound"><span class="entity">acomp</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">acomp</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="keyword1">of</span> Lt <span class="main">⇒</span> True <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> False<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">le_of_comp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> comparator <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">le_of_comp</span> <span class="free"><span class="bound"><span class="entity">acomp</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">acomp</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="keyword1">of</span> Gt <span class="main">⇒</span> False <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> True<span class="main">)</span>"</span></span>
  
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">comp_of_ords</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> comparator"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">comp_of_ords</span> <span class="free"><span class="bound"><span class="entity">le</span></span></span> <span class="free"><span class="bound"><span class="entity">lt</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">lt</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="keyword1">then</span> Lt <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">le</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="keyword1">then</span> Eq <span class="keyword1">else</span> Gt<span class="main">)</span>"</span></span>

<span class="keyword1" id="Comparator-comp_of_ords_of_le_lt"><span class="command">lemma</span></span> comp_of_ords_of_le_lt<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"comp_of_ords <span class="main">(</span>le_of_comp <span class="free">c</span><span class="main">)</span> <span class="main">(</span>lt_of_comp <span class="free">c</span><span class="main">)</span> <span class="main">=</span> <span class="free">c</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> ext<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> comp_of_ords_def le_of_comp_def lt_of_comp_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> order.split<span class="main">)</span>

<span class="keyword1" id="Comparator-lt_of_comp_of_ords"><span class="command">lemma</span></span> lt_of_comp_of_ords<span class="main">:</span> <span class="quoted"><span class="quoted">"lt_of_comp <span class="main">(</span>comp_of_ords <span class="free">le</span> <span class="free">lt</span><span class="main">)</span> <span class="main">=</span> <span class="free">lt</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> ext<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> comp_of_ords_def le_of_comp_def lt_of_comp_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> order.split<span class="main">)</span>

<span class="keyword1" id="Comparator-le_of_comp_of_ords_gen"><span class="command">lemma</span></span> le_of_comp_of_ords_gen<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">lt</span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">⟹</span> <span class="free">le</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span> <span class="main">⟹</span> le_of_comp <span class="main">(</span>comp_of_ords <span class="free">le</span> <span class="free">lt</span><span class="main">)</span> <span class="main">=</span> <span class="free">le</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> ext<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> comp_of_ords_def le_of_comp_def lt_of_comp_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> order.split<span class="main">)</span>

<span class="keyword1" id="Comparator-le_of_comp_of_ords_linorder"><span class="command">lemma</span></span> le_of_comp_of_ords_linorder<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"class.linorder <span class="free">le</span> <span class="free">lt</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"le_of_comp <span class="main">(</span>comp_of_ords <span class="free">le</span> <span class="free">lt</span><span class="main">)</span> <span class="main">=</span> <span class="free">le</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> linorder <span class="quoted"><span class="free">le</span></span> <span class="quoted"><span class="free">lt</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> le_of_comp_of_ords_gen<span class="main">)</span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">invert_order</span><span class="main">::</span> <span class="quoted"><span class="quoted">"order <span class="main">⇒</span> order"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">invert_order</span> Lt <span class="main">=</span> Gt"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">invert_order</span> Gt <span class="main">=</span> Lt"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">invert_order</span> Eq <span class="main">=</span> Eq"</span></span>

<span class="keyword1"><span class="command">locale</span></span> comparator <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">comp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> comparator"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> sym<span class="main">:</span> <span class="quoted"><span class="quoted">"invert_order <span class="main">(</span><span class="free">comp</span> <span class="free">x</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="free">comp</span> <span class="free">y</span> <span class="free">x</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> weak_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">comp</span> <span class="free">x</span> <span class="free">y</span> <span class="main">=</span> Eq <span class="main">⟹</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> trans<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">comp</span> <span class="free">x</span> <span class="free">y</span> <span class="main">=</span> Lt <span class="main">⟹</span> <span class="free">comp</span> <span class="free">y</span> <span class="free">z</span> <span class="main">=</span> Lt <span class="main">⟹</span> <span class="free">comp</span> <span class="free">x</span> <span class="free">z</span> <span class="main">=</span> Lt"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span> 

<span class="keyword1" id="Comparator-eq"><span class="command">lemma</span></span> eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">comp</span> <span class="free">x</span> <span class="free">y</span> <span class="main">=</span> Eq<span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span> <span class="main">=</span> <span class="free">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">with</span></span> sym <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">y</span></span> <span class="quoted"><span class="free">y</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">comp</span> <span class="free">x</span> <span class="free">y</span> <span class="main">=</span> Eq"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">comp</span> <span class="free">x</span> <span class="free">y</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">rule</span> weak_eq<span class="main">)</span>

<span class="keyword1" id="Comparator-comp_same"><span class="command">lemma</span></span> comp_same <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">comp</span> <span class="free">x</span> <span class="free">x</span> <span class="main">=</span> Eq"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq<span class="main">)</span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">lt</span> <span class="main">≡</span> lt_of_comp <span class="free">comp</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">le</span> <span class="main">≡</span> le_of_comp <span class="free">comp</span>"</span></span>

<span class="keyword1" id="Comparator-linorder"><span class="command">lemma</span></span> linorder<span class="main">:</span> <span class="quoted"><span class="quoted">"class.linorder le lt"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> lt_of_comp_def le_of_comp_def
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="skolem">z</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"lt <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">=</span> <span class="main">(</span>le <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">∧</span> <span class="main">¬</span> le <span class="skolem">y</span> <span class="skolem">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> sym <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">x</span></span> <span class="quoted"><span class="skolem">y</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">comp</span> <span class="skolem">x</span> <span class="skolem">y</span>"</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"le <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">∨</span> le <span class="skolem">y</span> <span class="skolem">x</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> sym <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">x</span></span> <span class="quoted"><span class="skolem">y</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">comp</span> <span class="skolem">x</span> <span class="skolem">y</span>"</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"le <span class="skolem">x</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> eq <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">x</span></span> <span class="quoted"><span class="skolem">x</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"le <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">⟹</span> le <span class="skolem">y</span> <span class="skolem">x</span> <span class="main">⟹</span> <span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> sym <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">x</span></span> <span class="quoted"><span class="skolem">y</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">comp</span> <span class="skolem">x</span> <span class="skolem">y</span>"</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"le <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">⟹</span> le <span class="skolem">y</span> <span class="skolem">z</span> <span class="main">⟹</span> le <span class="skolem">x</span> <span class="skolem">z</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">comp</span> <span class="skolem">x</span> <span class="skolem">y</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">comp</span> <span class="skolem">y</span> <span class="skolem">z</span>"</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> order.exhaust <span class="main"><span class="main">[</span></span><span class="operator">case_product</span> order.exhaust<span class="main"><span class="main">]</span></span><span class="main">)</span>
       <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> trans <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> eq<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> linorder <span class="quoted">le</span> <span class="quoted">lt</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> linorder<span class="main">)</span>

<span class="keyword1" id="Comparator-Gt_lt_conv"><span class="command">lemma</span></span> Gt_lt_conv<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">comp</span> <span class="free">x</span> <span class="free">y</span> <span class="main">=</span> Gt <span class="main">⟷</span> lt <span class="free">y</span> <span class="free">x</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> lt_of_comp_def sym<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">y</span></span><span class="main">,</span> <span class="operator">symmetric</span><span class="main">]</span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">comp</span> <span class="free">x</span> <span class="free">y</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1" id="Comparator-Lt_lt_conv"><span class="command">lemma</span></span> Lt_lt_conv<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">comp</span> <span class="free">x</span> <span class="free">y</span> <span class="main">=</span> Lt <span class="main">⟷</span> lt <span class="free">x</span> <span class="free">y</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> lt_of_comp_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">comp</span> <span class="free">x</span> <span class="free">y</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1" id="Comparator-eq_Eq_conv"><span class="command">lemma</span></span> eq_Eq_conv<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">comp</span> <span class="free">x</span> <span class="free">y</span> <span class="main">=</span> Eq <span class="main">⟷</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> eq<span class="main">)</span>
<span class="keyword1" id="Comparator-nGt_le_conv"><span class="command">lemma</span></span> nGt_le_conv<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">comp</span> <span class="free">x</span> <span class="free">y</span> <span class="main">≠</span> Gt <span class="main">⟷</span> le <span class="free">x</span> <span class="free">y</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> le_of_comp_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">comp</span> <span class="free">x</span> <span class="free">y</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1" id="Comparator-nLt_le_conv"><span class="command">lemma</span></span> nLt_le_conv<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">comp</span> <span class="free">x</span> <span class="free">y</span> <span class="main">≠</span> Lt <span class="main">⟷</span> le <span class="free">y</span> <span class="free">x</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> le_of_comp_def sym<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">y</span></span><span class="main">,</span> <span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">comp</span> <span class="free">x</span> <span class="free">y</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1" id="Comparator-nEq_neq_conv"><span class="command">lemma</span></span> nEq_neq_conv<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">comp</span> <span class="free">x</span> <span class="free">y</span> <span class="main">≠</span> Eq <span class="main">⟷</span> <span class="free">x</span> <span class="main">≠</span> <span class="free">y</span>"</span></span> 
  <span class="keyword1"><span class="command">using</span></span> eq_Eq_conv<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">y</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemmas</span></span> le_lt_convs <span class="main">=</span>  nLt_le_conv nGt_le_conv Gt_lt_conv Lt_lt_conv eq_Eq_conv nEq_neq_conv

<span class="keyword1" id="Comparator-two_comparisons_into_case_order"><span class="command">lemma</span></span> two_comparisons_into_case_order<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">if</span> le <span class="free">x</span> <span class="free">y</span> <span class="keyword1">then</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span> <span class="keyword1">then</span> <span class="free">P</span> <span class="keyword1">else</span> <span class="free">Q</span><span class="main">)</span> <span class="keyword1">else</span> <span class="free">R</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>case_order <span class="free">P</span> <span class="free">Q</span> <span class="free">R</span> <span class="main">(</span><span class="free">comp</span> <span class="free">x</span> <span class="free">y</span><span class="main">)</span><span class="main">)</span>"</span></span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">if</span> le <span class="free">x</span> <span class="free">y</span> <span class="keyword1">then</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">y</span> <span class="main">=</span> <span class="free">x</span> <span class="keyword1">then</span> <span class="free">P</span> <span class="keyword1">else</span> <span class="free">Q</span><span class="main">)</span> <span class="keyword1">else</span> <span class="free">R</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>case_order <span class="free">P</span> <span class="free">Q</span> <span class="free">R</span> <span class="main">(</span><span class="free">comp</span> <span class="free">x</span> <span class="free">y</span><span class="main">)</span><span class="main">)</span>"</span></span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">if</span> le <span class="free">x</span> <span class="free">y</span> <span class="keyword1">then</span> <span class="main">(</span><span class="keyword1">if</span> le <span class="free">y</span> <span class="free">x</span> <span class="keyword1">then</span> <span class="free">P</span> <span class="keyword1">else</span> <span class="free">Q</span><span class="main">)</span> <span class="keyword1">else</span> <span class="free">R</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>case_order <span class="free">P</span> <span class="free">Q</span> <span class="free">R</span> <span class="main">(</span><span class="free">comp</span> <span class="free">x</span> <span class="free">y</span><span class="main">)</span><span class="main">)</span>"</span></span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">if</span> le <span class="free">x</span> <span class="free">y</span> <span class="keyword1">then</span> <span class="main">(</span><span class="keyword1">if</span> lt <span class="free">x</span> <span class="free">y</span> <span class="keyword1">then</span> <span class="free">Q</span> <span class="keyword1">else</span> <span class="free">P</span><span class="main">)</span> <span class="keyword1">else</span> <span class="free">R</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>case_order <span class="free">P</span> <span class="free">Q</span> <span class="free">R</span> <span class="main">(</span><span class="free">comp</span> <span class="free">x</span> <span class="free">y</span><span class="main">)</span><span class="main">)</span>"</span></span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">if</span> lt <span class="free">x</span> <span class="free">y</span> <span class="keyword1">then</span> <span class="free">Q</span> <span class="keyword1">else</span> <span class="main">(</span><span class="keyword1">if</span> le <span class="free">x</span> <span class="free">y</span> <span class="keyword1">then</span> <span class="free">P</span> <span class="keyword1">else</span> <span class="free">R</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>case_order <span class="free">P</span> <span class="free">Q</span> <span class="free">R</span> <span class="main">(</span><span class="free">comp</span> <span class="free">x</span> <span class="free">y</span><span class="main">)</span><span class="main">)</span>"</span></span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">if</span> lt <span class="free">x</span> <span class="free">y</span> <span class="keyword1">then</span> <span class="free">Q</span> <span class="keyword1">else</span> <span class="main">(</span><span class="keyword1">if</span> lt <span class="free">y</span> <span class="free">x</span> <span class="keyword1">then</span> <span class="free">R</span> <span class="keyword1">else</span> <span class="free">P</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>case_order <span class="free">P</span> <span class="free">Q</span> <span class="free">R</span> <span class="main">(</span><span class="free">comp</span> <span class="free">x</span> <span class="free">y</span><span class="main">)</span><span class="main">)</span>"</span></span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">if</span> lt <span class="free">x</span> <span class="free">y</span> <span class="keyword1">then</span> <span class="free">Q</span> <span class="keyword1">else</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span> <span class="keyword1">then</span> <span class="free">P</span> <span class="keyword1">else</span> <span class="free">R</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>case_order <span class="free">P</span> <span class="free">Q</span> <span class="free">R</span> <span class="main">(</span><span class="free">comp</span> <span class="free">x</span> <span class="free">y</span><span class="main">)</span><span class="main">)</span>"</span></span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">if</span> lt <span class="free">x</span> <span class="free">y</span> <span class="keyword1">then</span> <span class="free">Q</span> <span class="keyword1">else</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">y</span> <span class="main">=</span> <span class="free">x</span> <span class="keyword1">then</span> <span class="free">P</span> <span class="keyword1">else</span> <span class="free">R</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>case_order <span class="free">P</span> <span class="free">Q</span> <span class="free">R</span> <span class="main">(</span><span class="free">comp</span> <span class="free">x</span> <span class="free">y</span><span class="main">)</span><span class="main">)</span>"</span></span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">if</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span> <span class="keyword1">then</span> <span class="free">P</span> <span class="keyword1">else</span> <span class="main">(</span><span class="keyword1">if</span> lt <span class="free">y</span> <span class="free">x</span> <span class="keyword1">then</span> <span class="free">R</span> <span class="keyword1">else</span> <span class="free">Q</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>case_order <span class="free">P</span> <span class="free">Q</span> <span class="free">R</span> <span class="main">(</span><span class="free">comp</span> <span class="free">x</span> <span class="free">y</span><span class="main">)</span><span class="main">)</span>"</span></span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">if</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span> <span class="keyword1">then</span> <span class="free">P</span> <span class="keyword1">else</span> <span class="main">(</span><span class="keyword1">if</span> lt <span class="free">x</span> <span class="free">y</span> <span class="keyword1">then</span> <span class="free">Q</span> <span class="keyword1">else</span> <span class="free">R</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>case_order <span class="free">P</span> <span class="free">Q</span> <span class="free">R</span> <span class="main">(</span><span class="free">comp</span> <span class="free">x</span> <span class="free">y</span><span class="main">)</span><span class="main">)</span>"</span></span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">if</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span> <span class="keyword1">then</span> <span class="free">P</span> <span class="keyword1">else</span> <span class="main">(</span><span class="keyword1">if</span> le <span class="free">y</span> <span class="free">x</span> <span class="keyword1">then</span> <span class="free">R</span> <span class="keyword1">else</span> <span class="free">Q</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>case_order <span class="free">P</span> <span class="free">Q</span> <span class="free">R</span> <span class="main">(</span><span class="free">comp</span> <span class="free">x</span> <span class="free">y</span><span class="main">)</span><span class="main">)</span>"</span></span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">if</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span> <span class="keyword1">then</span> <span class="free">P</span> <span class="keyword1">else</span> <span class="main">(</span><span class="keyword1">if</span> le <span class="free">x</span> <span class="free">y</span> <span class="keyword1">then</span> <span class="free">Q</span> <span class="keyword1">else</span> <span class="free">R</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>case_order <span class="free">P</span> <span class="free">Q</span> <span class="free">R</span> <span class="main">(</span><span class="free">comp</span> <span class="free">x</span> <span class="free">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> le_lt_convs <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> order.splits<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Comparator-comp_of_ords"><span class="command">lemma</span></span> comp_of_ords<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"class.linorder <span class="free">le</span> <span class="free">lt</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"comparator <span class="main">(</span>comp_of_ords <span class="free">le</span> <span class="free">lt</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> linorder <span class="quoted"><span class="free">le</span></span> <span class="quoted"><span class="free">lt</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> comp_of_ords_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> linorder<span class="main">)</span> <span class="entity">comparator_of</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> comparator"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">comparator_of</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="keyword1">then</span> Lt <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="keyword1">then</span> Eq <span class="keyword1">else</span> Gt<span class="main">)</span>"</span></span>

<span class="keyword1" id="Comparator-comparator_of"><span class="command">lemma</span></span> comparator_of<span class="main">:</span> <span class="quoted"><span class="quoted">"comparator comparator_of"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> comparator_of_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Compare">
<div class="head">
<h1>Theory Compare</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Deriving class instances for datatypes
    Author:      Christian Sternagel and René Thiemann  &lt;christian.sternagel|rene.thiemann@uibk.ac.at&gt;
    Maintainer:  Christian Sternagel and René Thiemann 
    License:     LGPL
*)</span>
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Compare›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Compare
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Comparator.html">Comparator</a>
<span class="keyword2"><span class="keyword">keywords</span></span> <span class="quoted">"compare_code"</span> <span class="main">::</span> thy_decl
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This introduces a type class for having a proper comparator, similar to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> linorder<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  Since most of the Isabelle/HOL algorithms work on the latter, we also provide a method which 
  turns linear-order based algorithms into comparator-based algorithms, where two consecutive 
  invocations of linear orders and equality are merged into one comparator invocation.
  We further define a class which both define a linear order and a comparator, and where the
  induces orders coincide.›</span></span>

<span class="keyword1"><span class="command">class</span></span> compare <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free"><span class="free"><span class="free">compare</span></span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> comparator"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> comparator_compare<span class="main">:</span> <span class="quoted"><span class="quoted">"comparator <span class="free">compare</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Compare-compare_Eq_is_eq"><span class="command">lemma</span></span> compare_Eq_is_eq <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"compare <span class="free">x</span> <span class="free">y</span> <span class="main">=</span> Eq <span class="main">⟷</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> comparator.eq <span class="main"><span class="main">[</span></span><span class="operator">OF</span> comparator_compare<span class="main"><span class="main">]</span></span><span class="main">)</span>
  
<span class="keyword1" id="Compare-compare_refl"><span class="command">lemma</span></span> compare_refl <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"compare <span class="free">x</span> <span class="free">x</span> <span class="main">=</span> Eq"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> linorder<span class="main">)</span> le_lt_comparator_of<span class="main">:</span>
  <span class="quoted"><span class="quoted">"le_of_comp comparator_of <span class="main">=</span> <span class="main">(≤)</span>"</span></span> <span class="quoted"><span class="quoted">"lt_of_comp comparator_of <span class="main">=</span> <span class="main">(&lt;)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> ext<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> comparator_of_def le_of_comp_def lt_of_comp_def<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">class</span></span> compare_order <span class="main">=</span> ord <span class="main">+</span> compare <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> ord_defs<span class="main">:</span> <span class="quoted"><span class="quoted">"le_of_comp compare <span class="main">=</span> <span class="main">(≤)</span> "</span></span> <span class="quoted"><span class="quoted">"lt_of_comp compare <span class="main">=</span> <span class="main">(&lt;)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹ <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> compare_order<span class="antiquote"><span class="antiquote">}</span></span></span></span> is <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> compare<span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> linorder<span class="antiquote"><span class="antiquote">}</span></span></span></span>, where comparator and orders 
  define the same ordering.›</span></span>

<span class="keyword1"><span class="command">subclass</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> compare_order<span class="main">)</span> linorder
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> ord_defs<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> comparator.linorder<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> comparator_compare<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> compare_order
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Compare-compare_is_comparator_of"><span class="command">lemma</span></span> compare_is_comparator_of<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"compare <span class="main">=</span> comparator_of"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> ext<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"compare <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">=</span> comparator_of <span class="skolem">x</span> <span class="skolem">y</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span>  <span class="main">(</span><span class="operator">unfold</span> comparator_of_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">unfold</span> ord_defs<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> lt_of_comp_def<span class="main"><span class="keyword3">,</span></span> 
      <span class="operator">cases</span> <span class="quoted"><span class="quoted">"compare <span class="skolem">x</span> <span class="skolem">y</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> two_comparisons_into_compare <span class="main">=</span> 
  comparator.two_comparisons_into_case_order<span class="main">[</span><span class="operator">OF</span> comparator_compare<span class="main">,</span> <span class="operator">unfolded</span> ord_defs<span class="main">]</span>
  
<span class="keyword1"><span class="command">thm</span></span> two_comparisons_into_compare
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹compare_code.ML›</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Compare_Code.change_compare_code const ty-vars›</span></span></span></span> changes the code equations of some constant such that
  two consecutive comparisons via <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(&lt;=)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(&lt;)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>", or <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(=)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> are turned into one
  invocation of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> compare<span class="antiquote"><span class="antiquote">}</span></span></span></span>. 
  The difference to a standard <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>code_unfold›</span></span></span></span> is that here we change the code-equations
  where an additional sort-constraint on <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> compare_order<span class="antiquote"><span class="antiquote">}</span></span></span></span> can be added. Otherwise, there would
  be no <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> compare<span class="antiquote"><span class="antiquote">}</span></span></span></span>-function.›</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/compare_code.ML">
<div class="head">
<h1>File ‹compare_code.ML›</h1>
</div>
<pre class="source"><span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">COMPARE_CODE</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  
  <span class="comment1">(* changes the code equations of some constant such that
     two consecutive comparisons via &lt;=, &lt;, or = are turned into one
     invocation of the comparator. 
     The difference to a standard code_unfold is that here we change the code-equations
     where an additional sort-constraint on compare_order can be added. Otherwise, there would
     be no compare-function. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> change_compare_code <span class="main">:</span> 
    term                      <span class="comment1">(* the constant *)</span> 
    <span class="main">-&gt;</span> string list     <span class="comment1">(* the list of type parameters which should be constraint to @{sort compare_order} *)</span> 
    <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span> local_theory

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Compare_Code</span> <span class="main">:</span> <span class="entity">COMPARE_CODE</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">drop_leading_qmark</span> <span class="entity">s</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">if</span></span> String.isPrefix <span class="inner_quoted">"?"</span> <span class="entity">s</span> <span class="keyword2"><span class="keyword">then</span></span> String.substring <span class="main">(</span><span class="entity">s</span><span class="main">,</span><span class="inner_numeral">1</span><span class="main">,</span>String.size <span class="entity">s</span> - <span class="inner_numeral">1</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">s</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">change_compare_code</span> <span class="entity">const</span> <span class="entity">inst_names</span> <span class="entity">lthy</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inst_names</span> <span class="main">=</span> map <span class="entity">drop_leading_qmark</span> <span class="entity">inst_names</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">const_string</span> <span class="main">=</span> quote <span class="main">(</span>Pretty.string_of <span class="main">(</span>Syntax.pretty_term <span class="entity">lthy</span> <span class="entity">const</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cname</span> <span class="main">=</span> <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">const</span> <span class="keyword2"><span class="keyword">of</span></span> Const <span class="main">(</span><span class="entity">cname</span><span class="main">,</span><span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">cname</span> <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> 
      error <span class="main">(</span><span class="inner_quoted">"expected constant as input, but got "</span> ^ <span class="entity">const_string</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cert</span> <span class="main">=</span> <span class="entity">Code.get_cert</span> <span class="entity">lthy</span> <span class="main">[</span><span class="main">]</span> <span class="entity">cname</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">code_eqs</span> <span class="main">=</span> <span class="entity">cert</span> |&gt; <span class="entity">Code.equations_of_cert</span> <span class="main">(</span>Proof_Context.theory_of <span class="entity">lthy</span><span class="main">)</span>
    |&gt; snd |&gt; these |&gt; map <span class="main">(</span>fst o snd<span class="main">)</span> |&gt; map_filter I
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">code_eqs</span> <span class="keyword2"><span class="keyword">then</span></span> error <span class="inner_quoted">"could not find code equations"</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="main">)</span>

    <span class="comment1">(* adding sort-constraint compare_order within code equations*)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">const'</span> <span class="main">=</span> hd <span class="entity">code_eqs</span> |&gt; Thm.concl_of |&gt; Logic.dest_equals |&gt; fst |&gt; strip_comb |&gt; fst
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">types</span> <span class="main">=</span> Term.add_tvars <span class="entity">const'</span> <span class="main">[</span><span class="main">]</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctyp_of</span> <span class="main">=</span> TVar #&gt; Thm.ctyp_of <span class="entity">lthy</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">filt</span> <span class="entity">s</span> <span class="main">=</span> not <span class="main">(</span>member <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">ord</span><span class="antiquote">}</span></span> @ <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">linorder</span><span class="antiquote">}</span></span> @ <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">order</span><span class="antiquote">}</span></span><span class="main">)</span> <span class="entity">s</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">map_types</span> <span class="main">=</span> maps <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ty</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">if</span></span> List.exists <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">tn</span> <span class="main">=&gt;</span> <span class="entity">tn</span> <span class="main">=</span> <span class="main">(</span>fst o fst<span class="main">)</span> <span class="entity">ty</span><span class="main">)</span> <span class="entity">inst_names</span> <span class="keyword2"><span class="keyword">then</span></span> 
      <span class="main">[</span><span class="main">(</span><span class="entity">ty</span><span class="main">,</span> <span class="entity">ctyp_of</span> <span class="main">(</span>apsnd <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ss</span> <span class="main">=&gt;</span> filter <span class="entity">filt</span> <span class="entity">ss</span> @ <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">compare_order</span><span class="antiquote">}</span></span><span class="main">)</span> <span class="entity">ty</span><span class="main">)</span><span class="main">)</span><span class="main">]</span> <span class="keyword2"><span class="keyword">else</span></span> 
      <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="entity">types</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">code_eqs</span> <span class="main">=</span> map <span class="main">(</span>Thm.instantiate <span class="main">(</span><span class="entity">map_types</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="entity">code_eqs</span> 

    <span class="comment1">(* replace comparisons and register code eqns *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">new_code_eqs</span> <span class="main">=</span> map <span class="main">(</span>Local_Defs.unfold <span class="entity">lthy</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> two_comparisons_into_compare<span class="antiquote">}</span></span></span><span class="main">)</span> <span class="entity">code_eqs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> map Thm.prop_of <span class="entity">new_code_eqs</span> <span class="main">=</span> map Thm.prop_of <span class="entity">code_eqs</span> <span class="keyword2"><span class="keyword">then</span></span>
      warning <span class="main">(</span><span class="inner_quoted">"Code equations for "</span> ^ <span class="entity">const_string</span> ^ <span class="inner_quoted">" did not change\n"</span> ^
      <span class="inner_quoted">"Perhaps you have to provide some type variables which should be restricted to compare_order\n"</span> ^
      <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="entity"><span class="antiquote">@{</span><span class="operator">make_string</span><span class="antiquote">}</span></span></span></span> <span class="main">(</span>map TVar <span class="entity">types</span> ~~ map snd <span class="entity">types</span><span class="main">,</span> <span class="entity">const'</span><span class="main">,</span> <span class="entity">code_eqs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> 
      <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lthy</span> <span class="main">=</span> Local_Theory.note <span class="main">(</span>
      <span class="main">(</span>Binding.name <span class="main">(</span>Long_Name.base_name <span class="entity">cname</span> ^ <span class="inner_quoted">"_compare_code"</span><span class="main">)</span><span class="main">,</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">attributes</span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">,</span> <span class="entity">new_code_eqs</span><span class="main">)</span> <span class="entity">lthy</span> 
      |&gt; snd    
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">lthy</span>
  <span class="keyword2"><span class="keyword">end</span></span>
  
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">change_compare_code_cmd</span> <span class="entity">const</span> <span class="entity">tnames_option</span> <span class="entity">lthy</span> <span class="main">=</span> 
  <span class="entity">change_compare_code</span> <span class="main">(</span>Syntax.read_term <span class="entity">lthy</span> <span class="entity">const</span><span class="main">)</span> <span class="entity">tnames_option</span> <span class="entity">lthy</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.local_theory</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">command_keyword</span> <span class="keyword1">compare_code</span><span class="antiquote">}</span></span></span> 
    <span class="inner_quoted">"turn comparisons via &lt;= and &lt; into compare within code-equations"</span>
    <span class="main">(</span>Scan.optional <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> "<span class="keyword2">(</span>"<span class="antiquote">}</span></span></span> |-- <span class="main">(</span>Parse.list Parse.string<span class="main">)</span> --| <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> "<span class="keyword2">)</span>"<span class="antiquote">}</span></span></span><span class="main">)</span> <span class="main">[</span><span class="main">]</span> --
      Parse.term &gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">inst</span><span class="main">,</span> <span class="entity">c</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">change_compare_code_cmd</span> <span class="entity">c</span> <span class="entity">inst</span><span class="main">)</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="RBT_Compare_Order_Impl">
<div class="head">
<h1>Theory RBT_Compare_Order_Impl</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Example: Modifying the Code-Equations of Red-Black-Trees›</span></span>

<span class="keyword1"><span class="command">theory</span></span> RBT_Compare_Order_Impl
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Compare.html">Compare</a>
  <span class="quoted">"<a href="../../HOL/HOL-Library/RBT_Impl.html">HOL-Library.RBT_Impl</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In the following, we modify all code-equations of the red-black-tree 
  implementation that perform comparisons. As a positive result, they now all require
  one invocation of comparator, where before two comparisons have been performed.
  The disadvantage of this simple solution is the additional class constraint on
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> compare_order<span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>

<span class="keyword1"><span class="command">compare_code</span></span> <span class="main">(</span><span class="quoted">"'a"</span><span class="main">)</span> <span class="quoted">rbt_ins</span>
<span class="keyword1"><span class="command">compare_code</span></span> <span class="main">(</span><span class="quoted">"'a"</span><span class="main">)</span> <span class="quoted">rbt_lookup</span>
<span class="keyword1"><span class="command">compare_code</span></span> <span class="main">(</span><span class="quoted">"'a"</span><span class="main">)</span> <span class="quoted">rbt_del</span>
<span class="keyword1"><span class="command">compare_code</span></span> <span class="main">(</span><span class="quoted">"'a"</span><span class="main">)</span> <span class="quoted">rbt_map_entry</span>
<span class="keyword1"><span class="command">compare_code</span></span> <span class="main">(</span><span class="quoted">"'a"</span><span class="main">)</span> <span class="quoted">sunion_with</span>
<span class="keyword1"><span class="command">compare_code</span></span> <span class="main">(</span><span class="quoted">"'a"</span><span class="main">)</span> <span class="quoted">sinter_with</span>
<span class="keyword1"><span class="command">compare_code</span></span> <span class="main">(</span><span class="quoted">"'a"</span><span class="main">)</span> <span class="quoted">rbt_split</span>

<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">rbt_ins</span></span> <span class="quoted"><span class="quoted">rbt_lookup</span></span> <span class="quoted"><span class="quoted">rbt_del</span></span> <span class="quoted"><span class="quoted">rbt_map_entry</span></span> <span class="quoted"><span class="quoted">rbt_union_with_key</span></span> <span class="quoted"><span class="quoted">rbt_inter_with_key</span></span> <span class="quoted"><span class="quoted">rbt_minus</span></span> <span class="keyword2"><span class="keyword">in</span></span> Haskell

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="RBT_Comparator_Impl">
<div class="head">
<h1>Theory RBT_Comparator_Impl</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹A Comparator-Interface to Red-Black-Trees›</span></span>

<span class="keyword1"><span class="command">theory</span></span> RBT_Comparator_Impl
<span class="keyword2"><span class="keyword">imports</span></span> 
  <span class="quoted">"<a href="../../HOL/HOL-Library/RBT_Impl.html">HOL-Library.RBT_Impl</a>"</span>
  <a href="Comparator.html">Comparator</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹For all of the main algorithms of red-black trees, we
  provide alternatives which are completely based on comparators,
  and which are provable equivalent. At the time of writing,
  this interface is used in the Container AFP-entry.
  
  It does not rely on the modifications of code-equations as in 
  the previous subsection.›</span></span>

<span class="keyword1"><span class="command">context</span></span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">c</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> comparator"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">rbt_comp_lookup</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> rbt <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇀</span> <span class="tfree">'b</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">rbt_comp_lookup</span> RBT_Impl.Empty <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">=</span> None"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">rbt_comp_lookup</span> <span class="main">(</span>Branch <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">=</span> 
   <span class="main">(</span><span class="keyword1">case</span> <span class="free">c</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">of</span> Lt <span class="main">⇒</span> <span class="free">rbt_comp_lookup</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> 
     <span class="main">|</span> Gt <span class="main">⇒</span> <span class="free">rbt_comp_lookup</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> 
     <span class="main">|</span> Eq <span class="main">⇒</span> Some <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span>
  <span class="entity">rbt_comp_ins</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> rbt <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> rbt"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">rbt_comp_ins</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> RBT_Impl.Empty <span class="main">=</span> Branch RBT_Impl.R RBT_Impl.Empty <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span>  RBT_Impl.Empty"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">rbt_comp_ins</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">(</span>Branch RBT_Impl.B <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">c</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">of</span> 
      Lt <span class="main">⇒</span> balance <span class="main">(</span><span class="free">rbt_comp_ins</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span>
    <span class="main">|</span> Gt <span class="main">⇒</span> balance <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">(</span><span class="free">rbt_comp_ins</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span>
    <span class="main">|</span> Eq <span class="main">⇒</span> Branch RBT_Impl.B <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">rbt_comp_ins</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">(</span>Branch RBT_Impl.R <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">c</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">of</span> 
      Lt <span class="main">⇒</span> Branch RBT_Impl.R <span class="main">(</span><span class="free">rbt_comp_ins</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span>
    <span class="main">|</span> Gt <span class="main">⇒</span> Branch RBT_Impl.R <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">(</span><span class="free">rbt_comp_ins</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span>
    <span class="main">|</span> Eq <span class="main">⇒</span> Branch RBT_Impl.R <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">rbt_comp_insert_with_key</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> rbt <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> rbt"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">rbt_comp_insert_with_key</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">=</span> paint RBT_Impl.B <span class="main">(</span>rbt_comp_ins <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">rbt_comp_insert</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> rbt <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> rbt"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">rbt_comp_insert</span> <span class="main">=</span> rbt_comp_insert_with_key <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="bound">nv</span><span class="main">.</span> <span class="bound">nv</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span>
  <span class="entity">rbt_comp_del_from_left</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> rbt <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> rbt <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> rbt"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="entity">rbt_comp_del_from_right</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> rbt <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> rbt <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> rbt"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="entity">rbt_comp_del</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> rbt <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> rbt"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">rbt_comp_del</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> RBT_Impl.Empty <span class="main">=</span> RBT_Impl.Empty"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">rbt_comp_del</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span>Branch <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span> <span class="main">=</span> 
   <span class="main">(</span><span class="keyword1">case</span> <span class="free">c</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="keyword1">of</span> 
        Lt <span class="main">⇒</span> <span class="free">rbt_comp_del_from_left</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> 
      <span class="main">|</span> Gt <span class="main">⇒</span> <span class="free">rbt_comp_del_from_right</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span>
      <span class="main">|</span> Eq <span class="main">⇒</span> combine <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">rbt_comp_del_from_left</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span>Branch RBT_Impl.B <span class="free"><span class="bound"><span class="entity">lt</span></span></span> <span class="free"><span class="bound"><span class="entity">z</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">rt</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">=</span> balance_left <span class="main">(</span><span class="free">rbt_comp_del</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span>Branch RBT_Impl.B <span class="free"><span class="bound"><span class="entity">lt</span></span></span> <span class="free"><span class="bound"><span class="entity">z</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">rt</span></span></span><span class="main">)</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">rbt_comp_del_from_left</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">=</span> Branch RBT_Impl.R <span class="main">(</span><span class="free">rbt_comp_del</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">rbt_comp_del_from_right</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">(</span>Branch RBT_Impl.B <span class="free"><span class="bound"><span class="entity">lt</span></span></span> <span class="free"><span class="bound"><span class="entity">z</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">rt</span></span></span><span class="main">)</span> <span class="main">=</span> balance_right <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">(</span><span class="free">rbt_comp_del</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span>Branch RBT_Impl.B <span class="free"><span class="bound"><span class="entity">lt</span></span></span> <span class="free"><span class="bound"><span class="entity">z</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">rt</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">|</span> 
  <span class="quoted"><span class="quoted">"<span class="free">rbt_comp_del_from_right</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">=</span> Branch RBT_Impl.R <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">(</span><span class="free">rbt_comp_del</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">rbt_comp_delete</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">=</span> paint RBT_Impl.B <span class="main">(</span>rbt_comp_del <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">rbt_comp_bulkload</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> foldr <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">k</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">.</span> rbt_comp_insert <span class="bound">k</span> <span class="bound">v</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> RBT_Impl.Empty"</span></span>

<span class="keyword1"><span class="command">primrec</span></span>
  <span class="entity">rbt_comp_map_entry</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> rbt <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> rbt"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">rbt_comp_map_entry</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> RBT_Impl.Empty <span class="main">=</span> RBT_Impl.Empty"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">rbt_comp_map_entry</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>Branch <span class="free"><span class="bound"><span class="entity">cc</span></span></span> <span class="free"><span class="bound"><span class="entity">lt</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">rt</span></span></span><span class="main">)</span> <span class="main">=</span>
    <span class="main">(</span><span class="keyword1">case</span> <span class="free">c</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">of</span> 
        Lt <span class="main">⇒</span> Branch <span class="free"><span class="bound"><span class="entity">cc</span></span></span> <span class="main">(</span><span class="free">rbt_comp_map_entry</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">lt</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">rt</span></span></span>
      <span class="main">|</span> Gt <span class="main">⇒</span> Branch <span class="free"><span class="bound"><span class="entity">cc</span></span></span> <span class="free"><span class="bound"><span class="entity">lt</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">(</span><span class="free">rbt_comp_map_entry</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">rt</span></span></span><span class="main">)</span>
      <span class="main">|</span> Eq <span class="main">⇒</span> Branch <span class="free"><span class="bound"><span class="entity">cc</span></span></span> <span class="free"><span class="bound"><span class="entity">lt</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">rt</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">function</span></span> <span class="entity">comp_sunion_with</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> list <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> list <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> list"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">comp_sunion_with</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">k'</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">v'</span></span></span><span class="main">)</span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">bs</span></span></span><span class="main">)</span> <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">case</span> <span class="free">c</span> <span class="free"><span class="bound"><span class="entity">k'</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="keyword1">of</span> 
        Lt <span class="main">⇒</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">k'</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">v'</span></span></span><span class="main">)</span> <span class="main">#</span> <span class="free">comp_sunion_with</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">bs</span></span></span>
      <span class="main">|</span> Gt <span class="main">⇒</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">#</span> <span class="free">comp_sunion_with</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">as</span></span></span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">k'</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">v'</span></span></span><span class="main">)</span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">bs</span></span></span><span class="main">)</span>
      <span class="main">|</span> Eq <span class="main">⇒</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">v'</span></span></span><span class="main">)</span> <span class="main">#</span> <span class="free">comp_sunion_with</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">as</span></span></span> <span class="free"><span class="bound"><span class="entity">bs</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">comp_sunion_with</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">[]</span> <span class="free"><span class="bound"><span class="entity">bs</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">bs</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">comp_sunion_with</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">as</span></span></span> <span class="main">[]</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">as</span></span></span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">pat_completeness</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">termination</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">lexicographic_order</span>

<span class="keyword1"><span class="command">function</span></span> <span class="entity">comp_sinter_with</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> list <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> list <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> list"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">comp_sinter_with</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">k'</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">v'</span></span></span><span class="main">)</span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">bs</span></span></span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> <span class="free">c</span> <span class="free"><span class="bound"><span class="entity">k'</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="keyword1">of</span> 
      Lt <span class="main">⇒</span> <span class="free">comp_sinter_with</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">bs</span></span></span>
    <span class="main">|</span> Gt <span class="main">⇒</span> <span class="free">comp_sinter_with</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">as</span></span></span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">k'</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">v'</span></span></span><span class="main">)</span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">bs</span></span></span><span class="main">)</span>
    <span class="main">|</span> Eq <span class="main">⇒</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">v'</span></span></span><span class="main">)</span> <span class="main">#</span> <span class="free">comp_sinter_with</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">as</span></span></span> <span class="free"><span class="bound"><span class="entity">bs</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">comp_sinter_with</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">[]</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">comp_sinter_with</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">[]</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">pat_completeness</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">termination</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">lexicographic_order</span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">rbt_split_comp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> rbt <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> rbt <span class="main">×</span> <span class="tfree">'b</span> option <span class="main">×</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> rbt"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">rbt_split_comp</span> RBT_Impl.Empty <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">=</span> <span class="main">(</span>RBT_Impl.Empty<span class="main">,</span> None<span class="main">,</span> RBT_Impl.Empty<span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">rbt_split_comp</span> <span class="main">(</span>RBT_Impl.Branch <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">c</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="keyword1">of</span>
    Lt <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">rbt_split_comp</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">l1</span><span class="main">,</span> <span class="bound">β</span><span class="main">,</span> <span class="bound">l2</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="bound">l1</span><span class="main">,</span> <span class="bound">β</span><span class="main">,</span> rbt_join <span class="bound">l2</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span><span class="main">)</span>
  <span class="main">|</span> Gt <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">rbt_split_comp</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">r1</span><span class="main">,</span> <span class="bound">β</span><span class="main">,</span> <span class="bound">r2</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span>rbt_join <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="bound">r1</span><span class="main">,</span> <span class="bound">β</span><span class="main">,</span> <span class="bound">r2</span><span class="main">)</span><span class="main">)</span>
  <span class="main">|</span> Eq <span class="main">⇒</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">,</span> Some <span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="RBT_Comparator_Impl-rbt_split_comp_size"><span class="command">lemma</span></span> rbt_split_comp_size<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">l2</span><span class="main">,</span> <span class="free">b</span><span class="main">,</span> <span class="free">r2</span><span class="main">)</span> <span class="main">=</span> rbt_split_comp <span class="free">t2</span> <span class="free">a</span> <span class="main">⟹</span> size <span class="free">l2</span> <span class="main">+</span> size <span class="free">r2</span> <span class="main">≤</span> size <span class="free">t2</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">t2</span></span> <span class="quoted"><span class="free">a</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">l2</span></span> <span class="quoted"><span class="free">b</span></span> <span class="quoted"><span class="free">r2</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rbt_split_comp.induct<span class="main">)</span>
     <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> order.splits if_splits prod.splits<span class="main">)</span>

<span class="keyword1"><span class="command">function</span></span> <span class="entity">rbt_comp_union_rec</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> rbt <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> rbt <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> rbt"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">rbt_comp_union_rec</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">t1</span></span></span> <span class="free"><span class="bound"><span class="entity">t2</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="main">(</span><span class="bound">f</span><span class="main">,</span> <span class="bound">t2</span><span class="main">,</span> <span class="bound">t1</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword1">if</span> flip_rbt <span class="free"><span class="bound"><span class="entity">t2</span></span></span> <span class="free"><span class="bound"><span class="entity">t1</span></span></span> <span class="keyword1">then</span> <span class="main">(</span><span class="main">λ</span><span class="bound">k</span> <span class="bound">v</span> <span class="bound">v'</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">k</span> <span class="bound">v'</span> <span class="bound">v</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">t1</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">t2</span></span></span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">t2</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">t1</span></span></span><span class="main">)</span> <span class="keyword1">in</span>
    <span class="keyword1">if</span> small_rbt <span class="bound">t2</span> <span class="keyword1">then</span> RBT_Impl.fold <span class="main">(</span>rbt_comp_insert_with_key <span class="bound">f</span><span class="main">)</span> <span class="bound">t2</span> <span class="bound">t1</span>
    <span class="keyword1">else</span> <span class="main">(</span><span class="keyword1">case</span> <span class="bound">t1</span> <span class="keyword1">of</span> RBT_Impl.Empty <span class="main">⇒</span> <span class="bound">t2</span>
      <span class="main">|</span> RBT_Impl.Branch <span class="main"><span class="bound">_</span></span> <span class="bound">l1</span> <span class="bound">a</span> <span class="bound">b</span> <span class="bound">r1</span> <span class="main">⇒</span>
        <span class="keyword1">case</span> rbt_split_comp <span class="bound">t2</span> <span class="bound">a</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">l2</span><span class="main">,</span> <span class="bound">β</span><span class="main">,</span> <span class="bound">r2</span><span class="main">)</span> <span class="main">⇒</span>
          rbt_join <span class="main">(</span><span class="free">rbt_comp_union_rec</span> <span class="bound">f</span> <span class="bound">l1</span> <span class="bound">l2</span><span class="main">)</span> <span class="bound">a</span> <span class="main">(</span><span class="keyword1">case</span> <span class="bound">β</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="bound">b</span> <span class="main">|</span> Some <span class="bound">b'</span> <span class="main">⇒</span> <span class="bound">f</span> <span class="bound">a</span> <span class="bound">b</span> <span class="bound">b'</span><span class="main">)</span> <span class="main">(</span><span class="free">rbt_comp_union_rec</span> <span class="bound">f</span> <span class="bound">r1</span> <span class="bound">r2</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">pat_completeness</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">termination</span></span>
  <span class="keyword1"><span class="command">using</span></span> rbt_split_comp_size
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">relation</span> <span class="quoted"><span class="quoted">"measure <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">t1</span><span class="main">,</span><span class="bound">t2</span><span class="main">)</span><span class="main">.</span> size <span class="bound">t1</span> <span class="main">+</span> size <span class="bound">t2</span><span class="main">)</span>"</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">declare</span></span> rbt_comp_union_rec.simps<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span>

<span class="keyword1"><span class="command">function</span></span> <span class="entity">rbt_comp_union_swap_rec</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> bool <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> rbt <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> rbt <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> rbt"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">rbt_comp_union_swap_rec</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">γ</span></span></span> <span class="free"><span class="bound"><span class="entity">t1</span></span></span> <span class="free"><span class="bound"><span class="entity">t2</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="main">(</span><span class="bound">γ</span><span class="main">,</span> <span class="bound">t2</span><span class="main">,</span> <span class="bound">t1</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword1">if</span> flip_rbt <span class="free"><span class="bound"><span class="entity">t2</span></span></span> <span class="free"><span class="bound"><span class="entity">t1</span></span></span> <span class="keyword1">then</span> <span class="main">(</span><span class="main">¬</span><span class="free"><span class="bound"><span class="entity">γ</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">t1</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">t2</span></span></span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">γ</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">t2</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">t1</span></span></span><span class="main">)</span><span class="main">;</span>
    <span class="bound">f'</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">γ</span> <span class="keyword1">then</span> <span class="main">(</span><span class="main">λ</span><span class="bound">k</span> <span class="bound">v</span> <span class="bound">v'</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">k</span> <span class="bound">v'</span> <span class="bound">v</span><span class="main">)</span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span> <span class="keyword1">in</span>
    <span class="keyword1">if</span> small_rbt <span class="bound">t2</span> <span class="keyword1">then</span> RBT_Impl.fold <span class="main">(</span>rbt_comp_insert_with_key <span class="bound">f'</span><span class="main">)</span> <span class="bound">t2</span> <span class="bound">t1</span>
    <span class="keyword1">else</span> <span class="keyword1">case</span> <span class="bound">t1</span> <span class="keyword1">of</span> rbt.Empty <span class="main">⇒</span> <span class="bound">t2</span>
      <span class="main">|</span> Branch <span class="bound">x</span> <span class="bound">l1</span> <span class="bound">a</span> <span class="bound">b</span> <span class="bound">r1</span> <span class="main">⇒</span>
        <span class="keyword1">case</span> rbt_split_comp <span class="bound">t2</span> <span class="bound">a</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">l2</span><span class="main">,</span> <span class="bound">β</span><span class="main">,</span> <span class="bound">r2</span><span class="main">)</span> <span class="main">⇒</span>
          rbt_join <span class="main">(</span><span class="free">rbt_comp_union_swap_rec</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">γ</span> <span class="bound">l1</span> <span class="bound">l2</span><span class="main">)</span> <span class="bound">a</span> <span class="main">(</span><span class="keyword1">case</span> <span class="bound">β</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="bound">b</span> <span class="main">|</span> Some <span class="bound">x</span> <span class="main">⇒</span> <span class="bound">f'</span> <span class="bound">a</span> <span class="bound">b</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">rbt_comp_union_swap_rec</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">γ</span> <span class="bound">r1</span> <span class="bound">r2</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">pat_completeness</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">termination</span></span>
  <span class="keyword1"><span class="command">using</span></span> rbt_split_comp_size
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">relation</span> <span class="quoted"><span class="quoted">"measure <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">γ</span><span class="main">,</span><span class="bound">t1</span><span class="main">,</span> <span class="bound">t2</span><span class="main">)</span><span class="main">.</span> size <span class="bound">t1</span> <span class="main">+</span> size <span class="bound">t2</span><span class="main">)</span>"</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">declare</span></span> rbt_comp_union_swap_rec.simps<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span>

<span class="keyword1" id="RBT_Comparator_Impl-rbt_comp_union_swap_rec"><span class="command">lemma</span></span> rbt_comp_union_swap_rec<span class="main">:</span> <span class="quoted"><span class="quoted">"rbt_comp_union_swap_rec <span class="free">f</span> <span class="free">γ</span> <span class="free">t1</span> <span class="free">t2</span> <span class="main">=</span>
  rbt_comp_union_rec <span class="main">(</span><span class="keyword1">if</span> <span class="free">γ</span> <span class="keyword1">then</span> <span class="main">(</span><span class="main">λ</span><span class="bound">k</span> <span class="bound">v</span> <span class="bound">v'</span><span class="main">.</span> <span class="free">f</span> <span class="bound">k</span> <span class="bound">v'</span> <span class="bound">v</span><span class="main">)</span> <span class="keyword1">else</span> <span class="free">f</span><span class="main">)</span> <span class="free">t1</span> <span class="free">t2</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">f</span></span> <span class="quoted"><span class="free">γ</span></span> <span class="quoted"><span class="free">t1</span></span> <span class="quoted"><span class="free">t2</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rbt_comp_union_swap_rec.induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">f</span> <span class="skolem">γ</span> <span class="skolem">t1</span> <span class="skolem">t2</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> 1<span class="main">[</span><span class="operator">OF</span> refl _ refl refl _ refl _ refl<span class="main">]</span>
    <span class="keyword1"><span class="command">unfolding</span></span> rbt_comp_union_swap_rec.simps<span class="main">[</span><span class="operator">of</span> <span class="main">_</span> <span class="main">_</span> <span class="quoted"><span class="skolem">t1</span></span><span class="main">]</span> rbt_comp_union_rec.simps<span class="main">[</span><span class="operator">of</span> <span class="main">_</span> <span class="quoted"><span class="skolem">t1</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> rbt.splits prod.splits option.splits<span class="main">)</span> <span class="comment1">(* slow *)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="RBT_Comparator_Impl-rbt_comp_union_swap_rec_code"><span class="command">lemma</span></span> rbt_comp_union_swap_rec_code<span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"rbt_comp_union_swap_rec <span class="free">f</span> <span class="free">γ</span> <span class="free">t1</span> <span class="free">t2</span> <span class="main">=</span> <span class="main">(</span>
    <span class="keyword1">let</span> <span class="bound">bh1</span> <span class="main">=</span> bheight <span class="free">t1</span><span class="main">;</span> <span class="bound">bh2</span> <span class="main">=</span> bheight <span class="free">t2</span><span class="main">;</span> <span class="main">(</span><span class="bound">γ</span><span class="main">,</span> <span class="bound">t2</span><span class="main">,</span> <span class="bound">bh2</span><span class="main">,</span> <span class="bound">t1</span><span class="main">,</span> <span class="bound">bh1</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword1">if</span> <span class="bound">bh1</span> <span class="main">&lt;</span> <span class="bound">bh2</span> <span class="keyword1">then</span> <span class="main">(</span><span class="main">¬</span><span class="free">γ</span><span class="main">,</span> <span class="free">t1</span><span class="main">,</span> <span class="bound">bh1</span><span class="main">,</span> <span class="free">t2</span><span class="main">,</span> <span class="bound">bh2</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">(</span><span class="free">γ</span><span class="main">,</span> <span class="free">t2</span><span class="main">,</span> <span class="bound">bh2</span><span class="main">,</span> <span class="free">t1</span><span class="main">,</span> <span class="bound">bh1</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">f'</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">γ</span> <span class="keyword1">then</span> <span class="main">(</span><span class="main">λ</span><span class="bound">k</span> <span class="bound">v</span> <span class="bound">v'</span><span class="main">.</span> <span class="free">f</span> <span class="bound">k</span> <span class="bound">v'</span> <span class="bound">v</span><span class="main">)</span> <span class="keyword1">else</span> <span class="free">f</span><span class="main">)</span> <span class="keyword1">in</span>
    <span class="keyword1">if</span> <span class="bound">bh2</span> <span class="main">&lt;</span> <span class="numeral">4</span> <span class="keyword1">then</span> RBT_Impl.fold <span class="main">(</span>rbt_comp_insert_with_key <span class="bound">f'</span><span class="main">)</span> <span class="bound">t2</span> <span class="bound">t1</span>
    <span class="keyword1">else</span> <span class="keyword1">case</span> <span class="bound">t1</span> <span class="keyword1">of</span> rbt.Empty <span class="main">⇒</span> <span class="bound">t2</span>
      <span class="main">|</span> Branch <span class="bound">x</span> <span class="bound">l1</span> <span class="bound">a</span> <span class="bound">b</span> <span class="bound">r1</span> <span class="main">⇒</span>
        <span class="keyword1">case</span> rbt_split_comp <span class="bound">t2</span> <span class="bound">a</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">l2</span><span class="main">,</span> <span class="bound">β</span><span class="main">,</span> <span class="bound">r2</span><span class="main">)</span> <span class="main">⇒</span>
          rbt_join <span class="main">(</span>rbt_comp_union_swap_rec <span class="free">f</span> <span class="bound">γ</span> <span class="bound">l1</span> <span class="bound">l2</span><span class="main">)</span> <span class="bound">a</span> <span class="main">(</span><span class="keyword1">case</span> <span class="bound">β</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="bound">b</span> <span class="main">|</span> Some <span class="bound">x</span> <span class="main">⇒</span> <span class="bound">f'</span> <span class="bound">a</span> <span class="bound">b</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span>rbt_comp_union_swap_rec <span class="free">f</span> <span class="bound">γ</span> <span class="bound">r1</span> <span class="bound">r2</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rbt_comp_union_swap_rec.simps flip_rbt_def small_rbt_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">rbt_comp_union_with_key</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">t1</span></span></span> <span class="free"><span class="bound"><span class="entity">t2</span></span></span> <span class="main">=</span> paint RBT_Impl.B <span class="main">(</span>rbt_comp_union_swap_rec <span class="free"><span class="bound"><span class="entity">f</span></span></span> False <span class="free"><span class="bound"><span class="entity">t1</span></span></span> <span class="free"><span class="bound"><span class="entity">t2</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">map_filter_comp_inter</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">t1</span></span></span> <span class="free"><span class="bound"><span class="entity">t2</span></span></span> <span class="main">=</span> List.map_filter <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">k</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">.</span>
  <span class="keyword1">case</span> rbt_comp_lookup <span class="free"><span class="bound"><span class="entity">t1</span></span></span> <span class="bound">k</span> <span class="keyword1">of</span> None <span class="main">⇒</span> None
  <span class="main">|</span> Some <span class="bound">v'</span> <span class="main">⇒</span> Some <span class="main">(</span><span class="bound">k</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">k</span> <span class="bound">v'</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>RBT_Impl.entries <span class="free"><span class="bound"><span class="entity">t2</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">function</span></span> <span class="entity">rbt_comp_inter_rec</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> rbt <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> rbt <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> rbt"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">rbt_comp_inter_rec</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">t1</span></span></span> <span class="free"><span class="bound"><span class="entity">t2</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="main">(</span><span class="bound">f</span><span class="main">,</span> <span class="bound">t2</span><span class="main">,</span> <span class="bound">t1</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword1">if</span> flip_rbt <span class="free"><span class="bound"><span class="entity">t2</span></span></span> <span class="free"><span class="bound"><span class="entity">t1</span></span></span> <span class="keyword1">then</span> <span class="main">(</span><span class="main">λ</span><span class="bound">k</span> <span class="bound">v</span> <span class="bound">v'</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">k</span> <span class="bound">v'</span> <span class="bound">v</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">t1</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">t2</span></span></span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">t2</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">t1</span></span></span><span class="main">)</span> <span class="keyword1">in</span>
    <span class="keyword1">if</span> small_rbt <span class="bound">t2</span> <span class="keyword1">then</span> rbtreeify <span class="main">(</span>map_filter_comp_inter <span class="bound">f</span> <span class="bound">t1</span> <span class="bound">t2</span><span class="main">)</span>
    <span class="keyword1">else</span> <span class="keyword1">case</span> <span class="bound">t1</span> <span class="keyword1">of</span> RBT_Impl.Empty <span class="main">⇒</span> RBT_Impl.Empty
    <span class="main">|</span> RBT_Impl.Branch <span class="main"><span class="bound">_</span></span> <span class="bound">l1</span> <span class="bound">a</span> <span class="bound">b</span> <span class="bound">r1</span> <span class="main">⇒</span>
      <span class="keyword1">case</span> rbt_split_comp <span class="bound">t2</span> <span class="bound">a</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">l2</span><span class="main">,</span> <span class="bound">β</span><span class="main">,</span> <span class="bound">r2</span><span class="main">)</span> <span class="main">⇒</span> <span class="keyword1">let</span> <span class="bound">l'</span> <span class="main">=</span> <span class="free">rbt_comp_inter_rec</span> <span class="bound">f</span> <span class="bound">l1</span> <span class="bound">l2</span><span class="main">;</span> <span class="bound">r'</span> <span class="main">=</span> <span class="free">rbt_comp_inter_rec</span> <span class="bound">f</span> <span class="bound">r1</span> <span class="bound">r2</span> <span class="keyword1">in</span>
      <span class="main">(</span><span class="keyword1">case</span> <span class="bound">β</span> <span class="keyword1">of</span> None <span class="main">⇒</span> rbt_join2 <span class="bound">l'</span> <span class="bound">r'</span> <span class="main">|</span> Some <span class="bound">b'</span> <span class="main">⇒</span> rbt_join <span class="bound">l'</span> <span class="bound">a</span> <span class="main">(</span><span class="bound">f</span> <span class="bound">a</span> <span class="bound">b</span> <span class="bound">b'</span><span class="main">)</span> <span class="bound">r'</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">pat_completeness</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">termination</span></span>
  <span class="keyword1"><span class="command">using</span></span> rbt_split_comp_size
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">relation</span> <span class="quoted"><span class="quoted">"measure <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">t1</span><span class="main">,</span><span class="bound">t2</span><span class="main">)</span><span class="main">.</span> size <span class="bound">t1</span> <span class="main">+</span> size <span class="bound">t2</span><span class="main">)</span>"</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">declare</span></span> rbt_comp_inter_rec.simps<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span>

<span class="keyword1"><span class="command">function</span></span> <span class="entity">rbt_comp_inter_swap_rec</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> bool <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> rbt <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> rbt <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> rbt"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">rbt_comp_inter_swap_rec</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">γ</span></span></span> <span class="free"><span class="bound"><span class="entity">t1</span></span></span> <span class="free"><span class="bound"><span class="entity">t2</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="main">(</span><span class="bound">γ</span><span class="main">,</span> <span class="bound">t2</span><span class="main">,</span> <span class="bound">t1</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword1">if</span> flip_rbt <span class="free"><span class="bound"><span class="entity">t2</span></span></span> <span class="free"><span class="bound"><span class="entity">t1</span></span></span> <span class="keyword1">then</span> <span class="main">(</span><span class="main">¬</span><span class="free"><span class="bound"><span class="entity">γ</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">t1</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">t2</span></span></span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">γ</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">t2</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">t1</span></span></span><span class="main">)</span><span class="main">;</span>
    <span class="bound">f'</span> <span class="main">=</span> <span class="keyword1">if</span> <span class="bound">γ</span> <span class="keyword1">then</span> <span class="main">(</span><span class="main">λ</span><span class="bound">k</span> <span class="bound">v</span> <span class="bound">v'</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">k</span> <span class="bound">v'</span> <span class="bound">v</span><span class="main">)</span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="keyword1">in</span>
    <span class="keyword1">if</span> small_rbt <span class="bound">t2</span> <span class="keyword1">then</span> rbtreeify <span class="main">(</span>map_filter_comp_inter <span class="bound">f'</span> <span class="bound">t1</span> <span class="bound">t2</span><span class="main">)</span>
    <span class="keyword1">else</span> <span class="keyword1">case</span> <span class="bound">t1</span> <span class="keyword1">of</span> rbt.Empty <span class="main">⇒</span> rbt.Empty
    <span class="main">|</span> Branch <span class="bound">x</span> <span class="bound">l1</span> <span class="bound">a</span> <span class="bound">b</span> <span class="bound">r1</span> <span class="main">⇒</span>
      <span class="main">(</span><span class="keyword1">case</span> rbt_split_comp <span class="bound">t2</span> <span class="bound">a</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">l2</span><span class="main">,</span> <span class="bound">β</span><span class="main">,</span> <span class="bound">r2</span><span class="main">)</span> <span class="main">⇒</span> <span class="keyword1">let</span> <span class="bound">l'</span> <span class="main">=</span> <span class="free">rbt_comp_inter_swap_rec</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">γ</span> <span class="bound">l1</span> <span class="bound">l2</span><span class="main">;</span> <span class="bound">r'</span> <span class="main">=</span> <span class="free">rbt_comp_inter_swap_rec</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">γ</span> <span class="bound">r1</span> <span class="bound">r2</span> <span class="keyword1">in</span>
      <span class="main">(</span><span class="keyword1">case</span> <span class="bound">β</span> <span class="keyword1">of</span> None <span class="main">⇒</span> rbt_join2 <span class="bound">l'</span> <span class="bound">r'</span> <span class="main">|</span> Some <span class="bound">b'</span> <span class="main">⇒</span> rbt_join <span class="bound">l'</span> <span class="bound">a</span> <span class="main">(</span><span class="bound">f'</span> <span class="bound">a</span> <span class="bound">b</span> <span class="bound">b'</span><span class="main">)</span> <span class="bound">r'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">pat_completeness</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">termination</span></span>
  <span class="keyword1"><span class="command">using</span></span> rbt_split_comp_size
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">relation</span> <span class="quoted"><span class="quoted">"measure <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">γ</span><span class="main">,</span><span class="bound">t1</span><span class="main">,</span><span class="bound">t2</span><span class="main">)</span><span class="main">.</span> size <span class="bound">t1</span> <span class="main">+</span> size <span class="bound">t2</span><span class="main">)</span>"</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">declare</span></span> rbt_comp_inter_swap_rec.simps<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span>

<span class="keyword1" id="RBT_Comparator_Impl-rbt_comp_inter_swap_rec"><span class="command">lemma</span></span> rbt_comp_inter_swap_rec<span class="main">:</span> <span class="quoted"><span class="quoted">"rbt_comp_inter_swap_rec <span class="free">f</span> <span class="free">γ</span> <span class="free">t1</span> <span class="free">t2</span> <span class="main">=</span>
  rbt_comp_inter_rec <span class="main">(</span><span class="keyword1">if</span> <span class="free">γ</span> <span class="keyword1">then</span> <span class="main">(</span><span class="main">λ</span><span class="bound">k</span> <span class="bound">v</span> <span class="bound">v'</span><span class="main">.</span> <span class="free">f</span> <span class="bound">k</span> <span class="bound">v'</span> <span class="bound">v</span><span class="main">)</span> <span class="keyword1">else</span> <span class="free">f</span><span class="main">)</span> <span class="free">t1</span> <span class="free">t2</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">f</span></span> <span class="quoted"><span class="free">γ</span></span> <span class="quoted"><span class="free">t1</span></span> <span class="quoted"><span class="free">t2</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rbt_comp_inter_swap_rec.induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">f</span> <span class="skolem">γ</span> <span class="skolem">t1</span> <span class="skolem">t2</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> 1<span class="main">[</span><span class="operator">OF</span> refl _ refl refl _ refl _ refl<span class="main">]</span>
    <span class="keyword1"><span class="command">unfolding</span></span> rbt_comp_inter_swap_rec.simps<span class="main">[</span><span class="operator">of</span> <span class="main">_</span> <span class="main">_</span> <span class="quoted"><span class="skolem">t1</span></span><span class="main">]</span> rbt_comp_inter_rec.simps<span class="main">[</span><span class="operator">of</span> <span class="main">_</span> <span class="quoted"><span class="skolem">t1</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> rbt.splits prod.splits option.splits<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="RBT_Comparator_Impl-comp_inter_with_key_code"><span class="command">lemma</span></span> comp_inter_with_key_code<span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"rbt_comp_inter_swap_rec <span class="free">f</span> <span class="free">γ</span> <span class="free">t1</span> <span class="free">t2</span> <span class="main">=</span> <span class="main">(</span>
  <span class="keyword1">let</span> <span class="bound">bh1</span> <span class="main">=</span> bheight <span class="free">t1</span><span class="main">;</span> <span class="bound">bh2</span> <span class="main">=</span> bheight <span class="free">t2</span><span class="main">;</span> <span class="main">(</span><span class="bound">γ</span><span class="main">,</span> <span class="bound">t2</span><span class="main">,</span> <span class="bound">bh2</span><span class="main">,</span> <span class="bound">t1</span><span class="main">,</span> <span class="bound">bh1</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword1">if</span> <span class="bound">bh1</span> <span class="main">&lt;</span> <span class="bound">bh2</span> <span class="keyword1">then</span> <span class="main">(</span><span class="main">¬</span><span class="free">γ</span><span class="main">,</span> <span class="free">t1</span><span class="main">,</span> <span class="bound">bh1</span><span class="main">,</span> <span class="free">t2</span><span class="main">,</span> <span class="bound">bh2</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">(</span><span class="free">γ</span><span class="main">,</span> <span class="free">t2</span><span class="main">,</span> <span class="bound">bh2</span><span class="main">,</span> <span class="free">t1</span><span class="main">,</span> <span class="bound">bh1</span><span class="main">)</span><span class="main">;</span>
  <span class="bound">f'</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">γ</span> <span class="keyword1">then</span> <span class="main">(</span><span class="main">λ</span><span class="bound">k</span> <span class="bound">v</span> <span class="bound">v'</span><span class="main">.</span> <span class="free">f</span> <span class="bound">k</span> <span class="bound">v'</span> <span class="bound">v</span><span class="main">)</span> <span class="keyword1">else</span> <span class="free">f</span><span class="main">)</span> <span class="keyword1">in</span>
  <span class="keyword1">if</span> <span class="bound">bh2</span> <span class="main">&lt;</span> <span class="numeral">4</span> <span class="keyword1">then</span> rbtreeify <span class="main">(</span>map_filter_comp_inter <span class="bound">f'</span> <span class="bound">t1</span> <span class="bound">t2</span><span class="main">)</span>
  <span class="keyword1">else</span> <span class="keyword1">case</span> <span class="bound">t1</span> <span class="keyword1">of</span> rbt.Empty <span class="main">⇒</span> rbt.Empty
    <span class="main">|</span> Branch <span class="bound">x</span> <span class="bound">l1</span> <span class="bound">a</span> <span class="bound">b</span> <span class="bound">r1</span> <span class="main">⇒</span>
      <span class="main">(</span><span class="keyword1">case</span> rbt_split_comp <span class="bound">t2</span> <span class="bound">a</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">l2</span><span class="main">,</span> <span class="bound">β</span><span class="main">,</span> <span class="bound">r2</span><span class="main">)</span> <span class="main">⇒</span> <span class="keyword1">let</span> <span class="bound">l'</span> <span class="main">=</span> rbt_comp_inter_swap_rec <span class="free">f</span> <span class="bound">γ</span> <span class="bound">l1</span> <span class="bound">l2</span><span class="main">;</span> <span class="bound">r'</span> <span class="main">=</span> rbt_comp_inter_swap_rec <span class="free">f</span> <span class="bound">γ</span> <span class="bound">r1</span> <span class="bound">r2</span> <span class="keyword1">in</span>
      <span class="main">(</span><span class="keyword1">case</span> <span class="bound">β</span> <span class="keyword1">of</span> None <span class="main">⇒</span> rbt_join2 <span class="bound">l'</span> <span class="bound">r'</span> <span class="main">|</span> Some <span class="bound">b'</span> <span class="main">⇒</span> rbt_join <span class="bound">l'</span> <span class="bound">a</span> <span class="main">(</span><span class="bound">f'</span> <span class="bound">a</span> <span class="bound">b</span> <span class="bound">b'</span><span class="main">)</span> <span class="bound">r'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rbt_comp_inter_swap_rec.simps flip_rbt_def small_rbt_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">rbt_comp_inter_with_key</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">t1</span></span></span> <span class="free"><span class="bound"><span class="entity">t2</span></span></span> <span class="main">=</span> paint RBT_Impl.B <span class="main">(</span>rbt_comp_inter_swap_rec <span class="free"><span class="bound"><span class="entity">f</span></span></span> False <span class="free"><span class="bound"><span class="entity">t1</span></span></span> <span class="free"><span class="bound"><span class="entity">t2</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">filter_comp_minus</span> <span class="free"><span class="bound"><span class="entity">t1</span></span></span> <span class="free"><span class="bound"><span class="entity">t2</span></span></span> <span class="main">=</span>
  filter <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">k</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> rbt_comp_lookup <span class="free"><span class="bound"><span class="entity">t2</span></span></span> <span class="bound">k</span> <span class="main">=</span> None<span class="main">)</span> <span class="main">(</span>RBT_Impl.entries <span class="free"><span class="bound"><span class="entity">t1</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">comp_minus</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> rbt <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> rbt <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> rbt"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">comp_minus</span> <span class="free"><span class="bound"><span class="entity">t1</span></span></span> <span class="free"><span class="bound"><span class="entity">t2</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> small_rbt <span class="free"><span class="bound"><span class="entity">t2</span></span></span> <span class="keyword1">then</span> RBT_Impl.fold <span class="main">(</span><span class="main">λ</span><span class="bound">k</span> <span class="main"><span class="bound">_</span></span> <span class="bound">t</span><span class="main">.</span> rbt_comp_delete <span class="bound">k</span> <span class="bound">t</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">t2</span></span></span> <span class="free"><span class="bound"><span class="entity">t1</span></span></span>
    <span class="keyword1">else</span> <span class="keyword1">if</span> small_rbt <span class="free"><span class="bound"><span class="entity">t1</span></span></span> <span class="keyword1">then</span> rbtreeify <span class="main">(</span>filter_comp_minus <span class="free"><span class="bound"><span class="entity">t1</span></span></span> <span class="free"><span class="bound"><span class="entity">t2</span></span></span><span class="main">)</span>
    <span class="keyword1">else</span> <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">t2</span></span></span> <span class="keyword1">of</span> RBT_Impl.Empty <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">t1</span></span></span>
      <span class="main">|</span> RBT_Impl.Branch <span class="main"><span class="bound">_</span></span> <span class="bound">l2</span> <span class="bound">a</span> <span class="bound">b</span> <span class="bound">r2</span> <span class="main">⇒</span>
        <span class="keyword1">case</span> rbt_split_comp <span class="free"><span class="bound"><span class="entity">t1</span></span></span> <span class="bound">a</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">l1</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">r1</span><span class="main">)</span> <span class="main">⇒</span> rbt_join2 <span class="main">(</span><span class="free">comp_minus</span> <span class="bound">l1</span> <span class="bound">l2</span><span class="main">)</span> <span class="main">(</span><span class="free">comp_minus</span> <span class="bound">r1</span> <span class="bound">r2</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">declare</span></span> comp_minus.simps<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">rbt_comp_minus</span> <span class="free"><span class="bound"><span class="entity">t1</span></span></span> <span class="free"><span class="bound"><span class="entity">t2</span></span></span> <span class="main">=</span> paint RBT_Impl.B <span class="main">(</span>comp_minus <span class="free"><span class="bound"><span class="entity">t1</span></span></span> <span class="free"><span class="bound"><span class="entity">t2</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> c<span class="main">:</span> <span class="quoted"><span class="quoted">"comparator <span class="free">c</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="RBT_Comparator_Impl-rbt_comp_lookup"><span class="command">lemma</span></span> rbt_comp_lookup<span class="main">:</span> <span class="quoted"><span class="quoted">"rbt_comp_lookup <span class="main">=</span> ord.rbt_lookup <span class="main">(</span>lt_of_comp <span class="free">c</span><span class="main">)</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> ext<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">k</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">t</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span>rbt"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"rbt_comp_lookup <span class="skolem">t</span> <span class="skolem">k</span> <span class="main">=</span> ord.rbt_lookup <span class="main">(</span>lt_of_comp <span class="free">c</span><span class="main">)</span> <span class="skolem">t</span> <span class="skolem">k</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">t</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">unfold</span> rbt_comp_lookup.simps ord.rbt_lookup.simps
      comparator.two_comparisons_into_case_order<span class="main"><span class="main">[</span></span><span class="operator">OF</span> c<span class="main"><span class="main">]</span></span><span class="main">)</span> 
      <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> order.splits<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>  

<span class="keyword1" id="RBT_Comparator_Impl-rbt_comp_ins"><span class="command">lemma</span></span> rbt_comp_ins<span class="main">:</span> <span class="quoted"><span class="quoted">"rbt_comp_ins <span class="main">=</span> ord.rbt_ins <span class="main">(</span>lt_of_comp <span class="free">c</span><span class="main">)</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> ext<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span> <span class="skolem">k</span> <span class="skolem">v</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">t</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span>rbt"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"rbt_comp_ins <span class="skolem">f</span> <span class="skolem">k</span> <span class="skolem">v</span> <span class="skolem">t</span> <span class="main">=</span> ord.rbt_ins <span class="main">(</span>lt_of_comp <span class="free">c</span><span class="main">)</span> <span class="skolem">f</span> <span class="skolem">k</span> <span class="skolem">v</span> <span class="skolem">t</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">f</span></span> <span class="quoted"><span class="skolem">k</span></span> <span class="quoted"><span class="skolem">v</span></span> <span class="quoted"><span class="skolem">t</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rbt_comp_ins.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">unfold</span> rbt_comp_ins.simps ord.rbt_ins.simps
      comparator.two_comparisons_into_case_order<span class="main"><span class="main">[</span></span><span class="operator">OF</span> c<span class="main"><span class="main">]</span></span><span class="main">)</span> 
      <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> order.splits<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>  

<span class="keyword1" id="RBT_Comparator_Impl-rbt_comp_insert_with_key"><span class="command">lemma</span></span> rbt_comp_insert_with_key<span class="main">:</span> <span class="quoted"><span class="quoted">"rbt_comp_insert_with_key <span class="main">=</span> ord.rbt_insert_with_key <span class="main">(</span>lt_of_comp <span class="free">c</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> rbt_comp_insert_with_key_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> ord.rbt_insert_with_key_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
  <span class="keyword1"><span class="command">unfolding</span></span> rbt_comp_ins <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1" id="RBT_Comparator_Impl-rbt_comp_insert"><span class="command">lemma</span></span> rbt_comp_insert<span class="main">:</span> <span class="quoted"><span class="quoted">"rbt_comp_insert <span class="main">=</span> ord.rbt_insert <span class="main">(</span>lt_of_comp <span class="free">c</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> rbt_comp_insert_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> ord.rbt_insert_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
  <span class="keyword1"><span class="command">unfolding</span></span> rbt_comp_insert_with_key <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1" id="RBT_Comparator_Impl-rbt_comp_del"><span class="command">lemma</span></span> rbt_comp_del<span class="main">:</span> <span class="quoted"><span class="quoted">"rbt_comp_del <span class="main">=</span> ord.rbt_del <span class="main">(</span>lt_of_comp <span class="free">c</span><span class="main">)</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span> <span class="keyword1"><span class="command">{</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">k</span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">s</span> <span class="skolem">t</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span>rbt"</span></span>
  <span class="keyword1"><span class="command">have</span></span> 
    <span class="quoted"><span class="quoted">"rbt_comp_del_from_left <span class="skolem">k</span> <span class="skolem">t</span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="skolem">s</span> <span class="main">=</span> ord.rbt_del_from_left <span class="main">(</span>lt_of_comp <span class="free">c</span><span class="main">)</span> <span class="skolem">k</span> <span class="skolem">t</span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="skolem">s</span>"</span></span>
    <span class="quoted"><span class="quoted">"rbt_comp_del_from_right <span class="skolem">k</span> <span class="skolem">t</span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="skolem">s</span> <span class="main">=</span> ord.rbt_del_from_right <span class="main">(</span>lt_of_comp <span class="free">c</span><span class="main">)</span> <span class="skolem">k</span> <span class="skolem">t</span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="skolem">s</span>"</span></span>
    <span class="quoted"><span class="quoted">"rbt_comp_del <span class="skolem">k</span> <span class="skolem">t</span> <span class="main">=</span> ord.rbt_del <span class="main">(</span>lt_of_comp <span class="free">c</span><span class="main">)</span> <span class="skolem">k</span> <span class="skolem">t</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">k</span></span> <span class="quoted"><span class="skolem">t</span></span> <span class="quoted"><span class="skolem">a</span></span> <span class="quoted"><span class="skolem">b</span></span> <span class="quoted"><span class="skolem">s</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> <span class="quoted"><span class="skolem">k</span></span> <span class="quoted"><span class="skolem">t</span></span> <span class="quoted"><span class="skolem">a</span></span> <span class="quoted"><span class="skolem">b</span></span> <span class="quoted"><span class="skolem">s</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> <span class="quoted"><span class="skolem">k</span></span> <span class="quoted"><span class="skolem">t</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rbt_comp_del_from_left_rbt_comp_del_from_right_rbt_comp_del.induct<span class="main"><span class="keyword3">,</span></span>
    <span class="operator">unfold</span> 
      rbt_comp_del.simps ord.rbt_del.simps
      rbt_comp_del_from_left.simps ord.rbt_del_from_left.simps
      rbt_comp_del_from_right.simps ord.rbt_del_from_right.simps
      comparator.two_comparisons_into_case_order<span class="main"><span class="main">[</span></span><span class="operator">OF</span> c<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span>
    <span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> order.split<span class="main">)</span> 
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> ext<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>  

<span class="keyword1" id="RBT_Comparator_Impl-rbt_comp_delete"><span class="command">lemma</span></span> rbt_comp_delete<span class="main">:</span> <span class="quoted"><span class="quoted">"rbt_comp_delete <span class="main">=</span> ord.rbt_delete <span class="main">(</span>lt_of_comp <span class="free">c</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> rbt_comp_delete_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> ord.rbt_delete_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
  <span class="keyword1"><span class="command">unfolding</span></span> rbt_comp_del <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1" id="RBT_Comparator_Impl-rbt_comp_bulkload"><span class="command">lemma</span></span> rbt_comp_bulkload<span class="main">:</span> <span class="quoted"><span class="quoted">"rbt_comp_bulkload <span class="main">=</span> ord.rbt_bulkload <span class="main">(</span>lt_of_comp <span class="free">c</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> rbt_comp_bulkload_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> ord.rbt_bulkload_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
  <span class="keyword1"><span class="command">unfolding</span></span> rbt_comp_insert <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1" id="RBT_Comparator_Impl-rbt_comp_map_entry"><span class="command">lemma</span></span> rbt_comp_map_entry<span class="main">:</span> <span class="quoted"><span class="quoted">"rbt_comp_map_entry <span class="main">=</span> ord.rbt_map_entry <span class="main">(</span>lt_of_comp <span class="free">c</span><span class="main">)</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> ext<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span> <span class="skolem">k</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">t</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span>rbt"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"rbt_comp_map_entry <span class="skolem">f</span> <span class="skolem">k</span> <span class="skolem">t</span> <span class="main">=</span> ord.rbt_map_entry <span class="main">(</span>lt_of_comp <span class="free">c</span><span class="main">)</span> <span class="skolem">f</span> <span class="skolem">k</span> <span class="skolem">t</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">t</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">unfold</span> rbt_comp_map_entry.simps ord.rbt_map_entry.simps
      comparator.two_comparisons_into_case_order<span class="main"><span class="main">[</span></span><span class="operator">OF</span> c<span class="main"><span class="main">]</span></span><span class="main">)</span> 
      <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> order.splits<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>  

<span class="keyword1" id="RBT_Comparator_Impl-comp_sunion_with"><span class="command">lemma</span></span> comp_sunion_with<span class="main">:</span> <span class="quoted"><span class="quoted">"comp_sunion_with <span class="main">=</span> ord.sunion_with <span class="main">(</span>lt_of_comp <span class="free">c</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> ext<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">as</span> <span class="skolem">bs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span>list"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"comp_sunion_with <span class="skolem">f</span> <span class="skolem">as</span> <span class="skolem">bs</span> <span class="main">=</span> ord.sunion_with <span class="main">(</span>lt_of_comp <span class="free">c</span><span class="main">)</span> <span class="skolem">f</span> <span class="skolem">as</span> <span class="skolem">bs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">f</span></span> <span class="quoted"><span class="skolem">as</span></span> <span class="quoted"><span class="skolem">bs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> comp_sunion_with.induct<span class="main"><span class="keyword3">,</span></span>
      <span class="operator">unfold</span> comp_sunion_with.simps ord.sunion_with.simps
      comparator.two_comparisons_into_case_order<span class="main"><span class="main">[</span></span><span class="operator">OF</span> c<span class="main"><span class="main">]</span></span><span class="main">)</span> 
      <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> order.splits<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="RBT_Comparator_Impl-anti_sym"><span class="command">lemma</span></span> anti_sym<span class="main">:</span> <span class="quoted"><span class="quoted">"lt_of_comp <span class="free">c</span> <span class="free">a</span> <span class="free">x</span> <span class="main">⟹</span> lt_of_comp <span class="free">c</span> <span class="free">x</span> <span class="free">a</span> <span class="main">⟹</span> False"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> c comparator.Gt_lt_conv comparator.Lt_lt_conv order.distinct<span class="main"><span class="main">(</span></span>5<span class="main"><span class="main">)</span></span><span class="main">)</span>

<span class="keyword1" id="RBT_Comparator_Impl-rbt_split_comp"><span class="command">lemma</span></span> rbt_split_comp<span class="main">:</span> <span class="quoted"><span class="quoted">"rbt_split_comp <span class="free">t</span> <span class="free">x</span> <span class="main">=</span> ord.rbt_split <span class="main">(</span>lt_of_comp <span class="free">c</span><span class="main">)</span> <span class="free">t</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">x</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rbt_split_comp.induct<span class="main">)</span>
     <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ord.rbt_split.simps comparator.le_lt_convs<span class="main"><span class="main">[</span></span><span class="operator">OF</span> c<span class="main"><span class="main">]</span></span>
      <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> order.splits prod.splits <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> anti_sym<span class="main">)</span>

<span class="keyword1" id="RBT_Comparator_Impl-comp_union_with_key"><span class="command">lemma</span></span> comp_union_with_key<span class="main">:</span> <span class="quoted"><span class="quoted">"rbt_comp_union_rec <span class="free">f</span> <span class="free">t1</span> <span class="free">t2</span> <span class="main">=</span> ord.rbt_union_rec <span class="main">(</span>lt_of_comp <span class="free">c</span><span class="main">)</span> <span class="free">f</span> <span class="free">t1</span> <span class="free">t2</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">f</span></span> <span class="quoted"><span class="free">t1</span></span> <span class="quoted"><span class="free">t2</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rbt_comp_union_rec.induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">f</span> <span class="skolem">t1</span> <span class="skolem">t2</span><span class="main">)</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">f'</span></span> <span class="skolem"><span class="skolem">t1'</span></span> <span class="skolem"><span class="skolem">t2'</span></span> <span class="keyword2"><span class="keyword">where</span></span> flip<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">f'</span><span class="main">,</span> <span class="skolem">t2'</span><span class="main">,</span> <span class="skolem">t1'</span><span class="main">)</span> <span class="main">=</span>
    <span class="main">(</span><span class="keyword1">if</span> flip_rbt <span class="skolem">t2</span> <span class="skolem">t1</span> <span class="keyword1">then</span> <span class="main">(</span><span class="main">λ</span><span class="bound">k</span> <span class="bound">v</span> <span class="bound">v'</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">k</span> <span class="bound">v'</span> <span class="bound">v</span><span class="main">,</span> <span class="skolem">t1</span><span class="main">,</span> <span class="skolem">t2</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">(</span><span class="skolem">f</span><span class="main">,</span> <span class="skolem">t2</span><span class="main">,</span> <span class="skolem">t1</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">t1'</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Branch _ <span class="skolem">l1</span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="skolem">r1</span><span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> t1_not_Empty<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">t1'</span> <span class="main">≠</span> RBT_Impl.Empty"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Branch<span class="main">)</span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">l2</span></span> <span class="skolem"><span class="skolem">β</span></span> <span class="skolem"><span class="skolem">r2</span></span> <span class="keyword2"><span class="keyword">where</span></span> split<span class="main">:</span> <span class="quoted"><span class="quoted">"rbt_split_comp <span class="skolem">t2'</span> <span class="skolem">a</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">l2</span><span class="main">,</span> <span class="skolem">β</span><span class="main">,</span> <span class="skolem">r2</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"rbt_split_comp <span class="skolem">t2'</span> <span class="skolem">a</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> 1<span class="main">[</span><span class="operator">OF</span> flip refl _ _ Branch<span class="main">]</span>
      <span class="keyword1"><span class="command">unfolding</span></span> rbt_comp_union_rec.simps<span class="main">[</span><span class="operator">of</span> <span class="main">_</span> <span class="quoted"><span class="skolem">t1</span></span><span class="main">]</span> ord.rbt_union_rec.simps<span class="main">[</span><span class="operator">of</span> <span class="main">_</span> <span class="main">_</span> <span class="quoted"><span class="skolem">t1</span></span><span class="main">]</span> flip<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Branch split rbt_split_comp<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> rbt_comp_insert_with_key
          <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rbt_comp_union_rec.simps<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="skolem">t1</span></span><span class="main"><span class="main">]</span></span> ord.rbt_union_rec.simps<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="skolem">t1</span></span><span class="main"><span class="main">]</span></span> flip<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span>
       rbt_comp_insert_with_key rbt_split_comp<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="RBT_Comparator_Impl-comp_sinter_with"><span class="command">lemma</span></span> comp_sinter_with<span class="main">:</span> <span class="quoted"><span class="quoted">"comp_sinter_with <span class="main">=</span> ord.sinter_with <span class="main">(</span>lt_of_comp <span class="free">c</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> ext<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">as</span> <span class="skolem">bs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span>list"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"comp_sinter_with <span class="skolem">f</span> <span class="skolem">as</span> <span class="skolem">bs</span> <span class="main">=</span> ord.sinter_with <span class="main">(</span>lt_of_comp <span class="free">c</span><span class="main">)</span> <span class="skolem">f</span> <span class="skolem">as</span> <span class="skolem">bs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">f</span></span> <span class="quoted"><span class="skolem">as</span></span> <span class="quoted"><span class="skolem">bs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> comp_sinter_with.induct<span class="main"><span class="keyword3">,</span></span>
      <span class="operator">unfold</span> comp_sinter_with.simps ord.sinter_with.simps
      comparator.two_comparisons_into_case_order<span class="main"><span class="main">[</span></span><span class="operator">OF</span> c<span class="main"><span class="main">]</span></span><span class="main">)</span> 
      <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> order.splits<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="RBT_Comparator_Impl-rbt_comp_union_with_key"><span class="command">lemma</span></span> rbt_comp_union_with_key<span class="main">:</span> <span class="quoted"><span class="quoted">"rbt_comp_union_with_key <span class="main">=</span> ord.rbt_union_with_key <span class="main">(</span>lt_of_comp <span class="free">c</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
     <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rbt_comp_union_with_key_def rbt_comp_union_swap_rec ord.rbt_union_with_key_def
      ord.rbt_union_swap_rec comp_union_with_key<span class="main">)</span>

<span class="keyword1" id="RBT_Comparator_Impl-comp_inter_with_key"><span class="command">lemma</span></span> comp_inter_with_key<span class="main">:</span> <span class="quoted"><span class="quoted">"rbt_comp_inter_rec <span class="free">f</span> <span class="free">t1</span> <span class="free">t2</span> <span class="main">=</span> ord.rbt_inter_rec <span class="main">(</span>lt_of_comp <span class="free">c</span><span class="main">)</span> <span class="free">f</span> <span class="free">t1</span> <span class="free">t2</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">f</span></span> <span class="quoted"><span class="free">t1</span></span> <span class="quoted"><span class="free">t2</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rbt_comp_inter_rec.induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">f</span> <span class="skolem">t1</span> <span class="skolem">t2</span><span class="main">)</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">f'</span></span> <span class="skolem"><span class="skolem">t1'</span></span> <span class="skolem"><span class="skolem">t2'</span></span> <span class="keyword2"><span class="keyword">where</span></span> flip<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">f'</span><span class="main">,</span> <span class="skolem">t2'</span><span class="main">,</span> <span class="skolem">t1'</span><span class="main">)</span> <span class="main">=</span>
    <span class="main">(</span><span class="keyword1">if</span> flip_rbt <span class="skolem">t2</span> <span class="skolem">t1</span> <span class="keyword1">then</span> <span class="main">(</span><span class="main">λ</span><span class="bound">k</span> <span class="bound">v</span> <span class="bound">v'</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">k</span> <span class="bound">v'</span> <span class="bound">v</span><span class="main">,</span> <span class="skolem">t1</span><span class="main">,</span> <span class="skolem">t2</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">(</span><span class="skolem">f</span><span class="main">,</span> <span class="skolem">t2</span><span class="main">,</span> <span class="skolem">t1</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">t1'</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Branch _ <span class="skolem">l1</span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="skolem">r1</span><span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> t1_not_Empty<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">t1'</span> <span class="main">≠</span> RBT_Impl.Empty"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Branch<span class="main">)</span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">l2</span></span> <span class="skolem"><span class="skolem">β</span></span> <span class="skolem"><span class="skolem">r2</span></span> <span class="keyword2"><span class="keyword">where</span></span> split<span class="main">:</span> <span class="quoted"><span class="quoted">"rbt_split_comp <span class="skolem">t2'</span> <span class="skolem">a</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">l2</span><span class="main">,</span> <span class="skolem">β</span><span class="main">,</span> <span class="skolem">r2</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"rbt_split_comp <span class="skolem">t2'</span> <span class="skolem">a</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> 1<span class="main">[</span><span class="operator">OF</span> flip refl _ _ Branch<span class="main">]</span>
      <span class="keyword1"><span class="command">unfolding</span></span> rbt_comp_inter_rec.simps<span class="main">[</span><span class="operator">of</span> <span class="main">_</span> <span class="quoted"><span class="skolem">t1</span></span><span class="main">]</span> ord.rbt_inter_rec.simps<span class="main">[</span><span class="operator">of</span> <span class="main">_</span> <span class="main">_</span> <span class="quoted"><span class="skolem">t1</span></span><span class="main">]</span> flip<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Branch split rbt_split_comp<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> rbt_comp_lookup
          ord.map_filter_inter_def map_filter_comp_inter_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rbt_comp_inter_rec.simps<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="skolem">t1</span></span><span class="main"><span class="main">]</span></span> ord.rbt_inter_rec.simps<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="skolem">t1</span></span><span class="main"><span class="main">]</span></span> flip<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span>
       ord.map_filter_inter_def map_filter_comp_inter_def rbt_comp_lookup rbt_split_comp<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="RBT_Comparator_Impl-rbt_comp_inter_with_key"><span class="command">lemma</span></span> rbt_comp_inter_with_key<span class="main">:</span> <span class="quoted"><span class="quoted">"rbt_comp_inter_with_key <span class="main">=</span> ord.rbt_inter_with_key <span class="main">(</span>lt_of_comp <span class="free">c</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
     <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rbt_comp_inter_with_key_def rbt_comp_inter_swap_rec
      ord.rbt_inter_with_key_def ord.rbt_inter_swap_rec comp_inter_with_key<span class="main">)</span>

<span class="keyword1" id="RBT_Comparator_Impl-comp_minus"><span class="command">lemma</span></span> comp_minus<span class="main">:</span> <span class="quoted"><span class="quoted">"comp_minus <span class="free">t1</span> <span class="free">t2</span> <span class="main">=</span> ord.rbt_minus_rec <span class="main">(</span>lt_of_comp <span class="free">c</span><span class="main">)</span> <span class="free">t1</span> <span class="free">t2</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">t1</span></span> <span class="quoted"><span class="free">t2</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> comp_minus.induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">t1</span> <span class="skolem">t2</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">t2</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Branch _ <span class="skolem">l2</span> <span class="skolem">a</span> <span class="skolem">u</span> <span class="skolem">r2</span><span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> t2_not_Empty<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">t2</span> <span class="main">≠</span> RBT_Impl.Empty"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Branch<span class="main">)</span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">l1</span></span> <span class="skolem"><span class="skolem">β</span></span> <span class="skolem"><span class="skolem">r1</span></span> <span class="keyword2"><span class="keyword">where</span></span> split<span class="main">:</span> <span class="quoted"><span class="quoted">"rbt_split_comp <span class="skolem">t1</span> <span class="skolem">a</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">l1</span><span class="main">,</span> <span class="skolem">β</span><span class="main">,</span> <span class="skolem">r1</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"rbt_split_comp <span class="skolem">t1</span> <span class="skolem">a</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> 1<span class="main">[</span><span class="operator">OF</span> _ _ Branch<span class="main">]</span>
      <span class="keyword1"><span class="command">unfolding</span></span> comp_minus.simps<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">t1</span></span> <span class="quoted"><span class="skolem">t2</span></span><span class="main">]</span> ord.rbt_minus_rec.simps<span class="main">[</span><span class="operator">of</span> <span class="main">_</span> <span class="quoted"><span class="skolem">t1</span></span> <span class="quoted"><span class="skolem">t2</span></span><span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Branch split rbt_split_comp<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> rbt_comp_delete rbt_comp_lookup
          filter_comp_minus_def ord.filter_minus_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> comp_minus.simps<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="skolem">t1</span></span><span class="main"><span class="main">]</span></span> ord.rbt_minus_rec.simps<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="skolem">t1</span></span><span class="main"><span class="main">]</span></span>
       filter_comp_minus_def ord.filter_minus_def
       rbt_comp_delete rbt_comp_lookup rbt_split_comp<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="RBT_Comparator_Impl-rbt_comp_minus"><span class="command">lemma</span></span> rbt_comp_minus<span class="main">:</span> <span class="quoted"><span class="quoted">"rbt_comp_minus <span class="main">=</span> ord.rbt_minus <span class="main">(</span>lt_of_comp <span class="free">c</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span><span class="main"><span class="keyword3">+</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rbt_comp_minus_def ord.rbt_minus_def comp_minus<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> rbt_comp_simps <span class="main">=</span> 
  rbt_comp_insert
  rbt_comp_lookup
  rbt_comp_delete
  rbt_comp_bulkload
  rbt_comp_map_entry
  rbt_comp_union_with_key
  rbt_comp_inter_with_key
  rbt_comp_minus
<span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Comparator_Generator">
<div class="head">
<h1>Theory Comparator_Generator</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Deriving class instances for datatypes
    Author:      Christian Sternagel and René Thiemann  &lt;christian.sternagel|rene.thiemann@uibk.ac.at&gt;
    Maintainer:  Christian Sternagel and René Thiemann 
    License:     LGPL
*)</span>
<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Generating Comparators›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Comparator_Generator
<span class="keyword2"><span class="keyword">imports</span></span>
  <span class="quoted">"<a href="Generator_Aux.html">../Generator_Aux</a>"</span>
  <span class="quoted">"<a href="Derive_Manager.html">../Derive_Manager</a>"</span>
  <a href="Comparator.html">Comparator</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">typedecl</span></span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">,</span><span class="tfree">'c</span><span class="main">,</span><span class="tfree">'z</span><span class="main">)</span>type

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In the following, we define a generator which for a given datatype <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">,</span></span><span class="tfree"><span class="tfree">'b</span></span><span class="main"><span class="main">,</span></span><span class="tfree"><span class="tfree">'c</span></span><span class="main"><span class="main">,</span></span><span class="tfree"><span class="tfree">'z</span></span><span class="main"><span class="main">)</span></span>type"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
  constructs a comparator of type 
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> comparator <span class="main"><span class="main">⇒</span></span> <span class="tfree"><span class="tfree">'b</span></span> comparator <span class="main"><span class="main">⇒</span></span> <span class="tfree"><span class="tfree">'c</span></span> comparator <span class="main"><span class="main">⇒</span></span> <span class="tfree"><span class="tfree">'z</span></span> comparator <span class="main"><span class="main">⇒</span></span> <span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">,</span></span><span class="tfree"><span class="tfree">'b</span></span><span class="main"><span class="main">,</span></span><span class="tfree"><span class="tfree">'c</span></span><span class="main"><span class="main">,</span></span><span class="tfree"><span class="tfree">'z</span></span><span class="main"><span class="main">)</span></span>type"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  To this end, we first compare the index of the constructors, then for equal constructors, we
  compare the arguments recursively and combine the results lexicographically.›</span></span>

<span class="keyword1"><span class="command">hide_type</span></span> <span class="quoted">"type"</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Lexicographic combination of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">order</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">comp_lex</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"order list <span class="main">⇒</span> order"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">comp_lex</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">cs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="keyword1">of</span> Eq <span class="main">⇒</span> <span class="free">comp_lex</span> <span class="free"><span class="bound"><span class="entity">cs</span></span></span> <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">comp_lex</span> <span class="main">[]</span> <span class="main">=</span> Eq"</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Improved code for non-lazy languages›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The following equations will eliminate all occurrences of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">comp_lex</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
  in the generated code of the comparators.›</span></span>

<span class="keyword1" id="Comparator_Generator-comp_lex_unfolds"><span class="command">lemma</span></span> comp_lex_unfolds<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"comp_lex <span class="main">[]</span> <span class="main">=</span> Eq"</span></span>
  <span class="quoted"><span class="quoted">"comp_lex <span class="main">[</span><span class="free">c</span><span class="main">]</span> <span class="main">=</span> <span class="free">c</span>"</span></span>
  <span class="quoted"><span class="quoted">"comp_lex <span class="main">(</span><span class="free">c</span> <span class="main">#</span> <span class="free">d</span> <span class="main">#</span> <span class="free">cs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">c</span> <span class="keyword1">of</span> Eq <span class="main">⇒</span> comp_lex <span class="main">(</span><span class="free">d</span> <span class="main">#</span> <span class="free">cs</span><span class="main">)</span> <span class="main">|</span> <span class="bound">z</span> <span class="main">⇒</span> <span class="bound">z</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">c</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Pointwise properties for equality, symmetry, and transitivity›</span></span> 


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The pointwise properties are important during inductive proofs of soundness of comparators.
  They are defined in a way that are combinable with <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> comp_lex<span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>

<span class="keyword1" id="Comparator_Generator-comp_lex_eq"><span class="command">lemma</span></span> comp_lex_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"comp_lex <span class="free">os</span> <span class="main">=</span> Eq <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">ord</span> <span class="main">∈</span> set <span class="free">os</span><span class="main">.</span> <span class="bound">ord</span> <span class="main">=</span> Eq<span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">os</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> order.splits<span class="main">)</span>
  
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">trans_order</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"order <span class="main">⇒</span> order <span class="main">⇒</span> order <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">trans_order</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">z</span></span></span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≠</span> Gt <span class="main">⟶</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">≠</span> Gt <span class="main">⟶</span> <span class="free"><span class="bound"><span class="entity">z</span></span></span> <span class="main">≠</span> Gt <span class="main">∧</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> Lt <span class="main">∨</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> Lt<span class="main">)</span> <span class="main">⟶</span> <span class="free"><span class="bound"><span class="entity">z</span></span></span> <span class="main">=</span> Lt<span class="main">)</span>"</span></span>

<span class="keyword1" id="Comparator_Generator-trans_orderI"><span class="command">lemma</span></span> trans_orderI<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">≠</span> Gt <span class="main">⟹</span> <span class="free">y</span> <span class="main">≠</span> Gt <span class="main">⟹</span> <span class="free">z</span> <span class="main">≠</span> Gt <span class="main">∧</span> <span class="main">(</span><span class="main">(</span><span class="free">x</span> <span class="main">=</span> Lt <span class="main">∨</span> <span class="free">y</span> <span class="main">=</span> Lt<span class="main">)</span> <span class="main">⟶</span> <span class="free">z</span> <span class="main">=</span> Lt<span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> trans_order <span class="free">x</span> <span class="free">y</span> <span class="free">z</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> trans_order_def<span class="main">)</span>

<span class="keyword1" id="Comparator_Generator-trans_orderD"><span class="command">lemma</span></span> trans_orderD<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"trans_order <span class="free">x</span> <span class="free">y</span> <span class="free">z</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≠</span> Gt"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">≠</span> Gt"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">z</span> <span class="main">≠</span> Gt"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> Lt <span class="main">∨</span> <span class="free">y</span> <span class="main">=</span> Lt <span class="main">⟹</span> <span class="free">z</span> <span class="main">=</span> Lt"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> trans_order_def<span class="main">)</span>

<span class="keyword1" id="Comparator_Generator-All_less_Suc"><span class="command">lemma</span></span> All_less_Suc<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">i</span></span> <span class="main">&lt;</span> Suc <span class="free">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">i</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">P</span> <span class="main">0</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">i</span></span> <span class="main">&lt;</span> <span class="free">x</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span>Suc <span class="bound">i</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> less_Suc_eq_0_disj <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>

<span class="keyword1" id="Comparator_Generator-comp_lex_trans"><span class="command">lemma</span></span> comp_lex_trans<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"length <span class="free">xs</span> <span class="main">=</span> length <span class="free">ys</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"length <span class="free">ys</span> <span class="main">=</span> length <span class="free">zs</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound"><span class="bound">i</span></span> <span class="main">&lt;</span> length <span class="free">zs</span><span class="main">.</span> trans_order <span class="main">(</span><span class="free">xs</span> <span class="main">!</span> <span class="bound">i</span><span class="main">)</span> <span class="main">(</span><span class="free">ys</span> <span class="main">!</span> <span class="bound">i</span><span class="main">)</span> <span class="main">(</span><span class="free">zs</span> <span class="main">!</span> <span class="bound">i</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"trans_order <span class="main">(</span>comp_lex <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>comp_lex <span class="free">ys</span><span class="main">)</span> <span class="main">(</span>comp_lex <span class="free">zs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quoted"><span class="free">zs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> list_induct3<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">x</span> <span class="skolem">xs</span> <span class="skolem">y</span> <span class="skolem">ys</span> <span class="skolem">z</span> <span class="skolem">zs</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> trans_orderI<span class="main">)</span>
       <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span> <span class="quoted"><span class="skolem">y</span></span> <span class="quoted"><span class="skolem">z</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> order.exhaust <span class="main"><span class="main">[</span></span><span class="operator">case_product</span> order.exhaust order.exhaust<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span>
        <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> All_less_Suc <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> trans_orderD<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> trans_order_def<span class="main">)</span>

<span class="keyword1" id="Comparator_Generator-comp_lex_sym"><span class="command">lemma</span></span> comp_lex_sym<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"length <span class="free">xs</span> <span class="main">=</span> length <span class="free">ys</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound"><span class="bound">i</span></span> <span class="main">&lt;</span> length <span class="free">ys</span><span class="main">.</span> invert_order <span class="main">(</span><span class="free">xs</span> <span class="main">!</span> <span class="bound">i</span><span class="main">)</span> <span class="main">=</span> <span class="free">ys</span> <span class="main">!</span> <span class="bound">i</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"invert_order <span class="main">(</span>comp_lex <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> comp_lex <span class="free">ys</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> list_induct2<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main">)</span> <span class="operator">fastforce</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">declare</span></span> comp_lex.simps <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword">del</span></span><span class="main">]</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">peq_comp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> comparator <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">peq_comp</span> <span class="free"><span class="bound"><span class="entity">acomp</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">y</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">acomp</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="bound">y</span> <span class="main">=</span> Eq <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="bound">y</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Comparator_Generator-peq_compD"><span class="command">lemma</span></span> peq_compD<span class="main">:</span> <span class="quoted"><span class="quoted">"peq_comp <span class="free">acomp</span> <span class="free">x</span> <span class="main">⟹</span> <span class="free">acomp</span> <span class="free">x</span> <span class="free">y</span> <span class="main">=</span> Eq <span class="main">⟷</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> peq_comp_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Comparator_Generator-peq_compI"><span class="command">lemma</span></span> peq_compI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span> <span class="bound">y</span><span class="main">.</span> <span class="free">acomp</span> <span class="free">x</span> <span class="bound">y</span> <span class="main">=</span> Eq <span class="main">⟷</span> <span class="free">x</span> <span class="main">=</span> <span class="bound">y</span><span class="main">)</span> <span class="main">⟹</span> peq_comp <span class="free">acomp</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> peq_comp_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">psym_comp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> comparator <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">psym_comp</span> <span class="free"><span class="bound"><span class="entity">acomp</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">y</span><span class="main">.</span> invert_order <span class="main">(</span><span class="free"><span class="bound"><span class="entity">acomp</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="bound">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">acomp</span></span></span> <span class="bound">y</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Comparator_Generator-psym_compD"><span class="command">lemma</span></span> psym_compD<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"psym_comp <span class="free">acomp</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"invert_order <span class="main">(</span><span class="free">acomp</span> <span class="free">x</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">acomp</span> <span class="free">y</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> psym_comp_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Comparator_Generator-psym_compI"><span class="command">lemma</span></span> psym_compI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">y</span><span class="main">.</span> invert_order <span class="main">(</span><span class="free">acomp</span> <span class="free">x</span> <span class="bound">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">acomp</span> <span class="bound">y</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"psym_comp <span class="free">acomp</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> psym_comp_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ptrans_comp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> comparator <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ptrans_comp</span> <span class="free"><span class="bound"><span class="entity">acomp</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">y</span> <span class="bound">z</span><span class="main">.</span> trans_order <span class="main">(</span><span class="free"><span class="bound"><span class="entity">acomp</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="bound">y</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">acomp</span></span></span> <span class="bound">y</span> <span class="bound">z</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">acomp</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="bound">z</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Comparator_Generator-ptrans_compD"><span class="command">lemma</span></span> ptrans_compD<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ptrans_comp <span class="free">acomp</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"trans_order <span class="main">(</span><span class="free">acomp</span> <span class="free">x</span> <span class="free">y</span><span class="main">)</span> <span class="main">(</span><span class="free">acomp</span> <span class="free">y</span> <span class="free">z</span><span class="main">)</span> <span class="main">(</span><span class="free">acomp</span> <span class="free">x</span> <span class="free">z</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> ptrans_comp_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Comparator_Generator-ptrans_compI"><span class="command">lemma</span></span> ptrans_compI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">y</span> <span class="bound">z</span><span class="main">.</span> trans_order <span class="main">(</span><span class="free">acomp</span> <span class="free">x</span> <span class="bound">y</span><span class="main">)</span> <span class="main">(</span><span class="free">acomp</span> <span class="bound">y</span> <span class="bound">z</span><span class="main">)</span> <span class="main">(</span><span class="free">acomp</span> <span class="free">x</span> <span class="bound">z</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ptrans_comp <span class="free">acomp</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> ptrans_comp_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Separate properties of comparators›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">eq_comp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> comparator <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">eq_comp</span> <span class="free"><span class="bound"><span class="entity">acomp</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">x</span><span class="main">.</span> peq_comp <span class="free"><span class="bound"><span class="entity">acomp</span></span></span> <span class="bound">x</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Comparator_Generator-eq_compD2"><span class="command">lemma</span></span> eq_compD2<span class="main">:</span> <span class="quoted"><span class="quoted">"eq_comp <span class="free">acomp</span> <span class="main">⟹</span> peq_comp <span class="free">acomp</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> eq_comp_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="Comparator_Generator-eq_compI2"><span class="command">lemma</span></span> eq_compI2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span> <span class="bound">x</span><span class="main">.</span> peq_comp <span class="free">acomp</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⟹</span> eq_comp <span class="free">acomp</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> eq_comp_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">trans_comp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> comparator <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">trans_comp</span> <span class="free"><span class="bound"><span class="entity">acomp</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">x</span><span class="main">.</span> ptrans_comp <span class="free"><span class="bound"><span class="entity">acomp</span></span></span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  
<span class="keyword1" id="Comparator_Generator-trans_compD2"><span class="command">lemma</span></span> trans_compD2<span class="main">:</span> <span class="quoted"><span class="quoted">"trans_comp <span class="free">acomp</span> <span class="main">⟹</span> ptrans_comp <span class="free">acomp</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> trans_comp_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="Comparator_Generator-trans_compI2"><span class="command">lemma</span></span> trans_compI2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span> <span class="bound">x</span><span class="main">.</span> ptrans_comp <span class="free">acomp</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⟹</span> trans_comp <span class="free">acomp</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> trans_comp_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

  
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">sym_comp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> comparator <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">sym_comp</span> <span class="free"><span class="bound"><span class="entity">acomp</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">x</span><span class="main">.</span> psym_comp <span class="free"><span class="bound"><span class="entity">acomp</span></span></span> <span class="bound">x</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Comparator_Generator-sym_compD2"><span class="command">lemma</span></span> sym_compD2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"sym_comp <span class="free">acomp</span> <span class="main">⟹</span> psym_comp <span class="free">acomp</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> sym_comp_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="Comparator_Generator-sym_compI2"><span class="command">lemma</span></span> sym_compI2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span> <span class="bound">x</span><span class="main">.</span> psym_comp <span class="free">acomp</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⟹</span> sym_comp <span class="free">acomp</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> sym_comp_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="Comparator_Generator-eq_compD"><span class="command">lemma</span></span> eq_compD<span class="main">:</span> <span class="quoted"><span class="quoted">"eq_comp <span class="free">acomp</span> <span class="main">⟹</span> <span class="free">acomp</span> <span class="free">x</span> <span class="free">y</span> <span class="main">=</span> Eq <span class="main">⟷</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> peq_compD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> eq_compD2<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Comparator_Generator-eq_compI"><span class="command">lemma</span></span> eq_compI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">acomp</span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">=</span> Eq <span class="main">⟷</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">y</span><span class="main">)</span> <span class="main">⟹</span> eq_comp <span class="free">acomp</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> eq_compI2 peq_compI<span class="main">)</span>

<span class="keyword1" id="Comparator_Generator-trans_compD"><span class="command">lemma</span></span> trans_compD<span class="main">:</span> <span class="quoted"><span class="quoted">"trans_comp <span class="free">acomp</span> <span class="main">⟹</span> trans_order <span class="main">(</span><span class="free">acomp</span> <span class="free">x</span> <span class="free">y</span><span class="main">)</span> <span class="main">(</span><span class="free">acomp</span> <span class="free">y</span> <span class="free">z</span><span class="main">)</span> <span class="main">(</span><span class="free">acomp</span> <span class="free">x</span> <span class="free">z</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> ptrans_compD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> trans_compD2<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Comparator_Generator-trans_compI"><span class="command">lemma</span></span> trans_compI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span> <span class="bound">x</span> <span class="bound">y</span> <span class="bound">z</span><span class="main">.</span> trans_order <span class="main">(</span><span class="free">acomp</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span> <span class="main">(</span><span class="free">acomp</span> <span class="bound">y</span> <span class="bound">z</span><span class="main">)</span> <span class="main">(</span><span class="free">acomp</span> <span class="bound">x</span> <span class="bound">z</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> trans_comp <span class="free">acomp</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> trans_compI2 ptrans_compI<span class="main">)</span>

<span class="keyword1" id="Comparator_Generator-sym_compD"><span class="command">lemma</span></span> sym_compD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"sym_comp <span class="free">acomp</span> <span class="main">⟹</span> invert_order <span class="main">(</span><span class="free">acomp</span> <span class="free">x</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">acomp</span> <span class="free">y</span> <span class="free">x</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> psym_compD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> sym_compD2<span class="main"><span class="main">]</span></span><span class="main">)</span>
  
<span class="keyword1" id="Comparator_Generator-sym_compI"><span class="command">lemma</span></span> sym_compI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> invert_order <span class="main">(</span><span class="free">acomp</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">acomp</span> <span class="bound">y</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> sym_comp <span class="free">acomp</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> sym_compI2 psym_compI<span class="main">)</span>

<span class="keyword1" id="Comparator_Generator-eq_sym_trans_imp_comparator"><span class="command">lemma</span></span> eq_sym_trans_imp_comparator<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"eq_comp <span class="free">acomp</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"sym_comp <span class="free">acomp</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"trans_comp <span class="free">acomp</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"comparator <span class="free">acomp</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="skolem">z</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"invert_order <span class="main">(</span><span class="free">acomp</span> <span class="skolem">x</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">=</span> <span class="free">acomp</span> <span class="skolem">y</span> <span class="skolem">x</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> sym_compD <span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹sym_comp <span class="free">acomp</span>›</span></span><span class="main">]</span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">acomp</span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">=</span> Eq"</span></span>
    <span class="keyword1"><span class="command">with</span></span> eq_compD <span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹eq_comp <span class="free">acomp</span>›</span></span><span class="main">]</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">acomp</span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">=</span> Lt"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">acomp</span> <span class="skolem">y</span> <span class="skolem">z</span> <span class="main">=</span> Lt"</span></span>
    <span class="keyword1"><span class="command">with</span></span> trans_orderD <span class="main">[</span><span class="operator">OF</span> trans_compD <span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator"><span class="operator">OF</span></span> <span class="quoted"><span class="quoted"><span class="quoted">‹trans_comp <span class="free"><span class="free">acomp</span></span>›</span></span></span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">x</span></span></span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">y</span></span></span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">z</span></span></span></span><span class="main">]</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">acomp</span> <span class="skolem">x</span> <span class="skolem">z</span> <span class="main">=</span> Lt"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">}</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Comparator_Generator-comparator_imp_eq_sym_trans"><span class="command">lemma</span></span> comparator_imp_eq_sym_trans<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"comparator <span class="free">acomp</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"eq_comp <span class="free">acomp</span>"</span></span> <span class="quoted"><span class="quoted">"sym_comp <span class="free">acomp</span>"</span></span> <span class="quoted"><span class="quoted">"trans_comp <span class="free">acomp</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> comparator <span class="quoted"><span class="free">acomp</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"eq_comp <span class="free">acomp</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> eq <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> eq_compI<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"sym_comp <span class="free">acomp</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> sym <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> sym_compI<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"trans_comp <span class="free">acomp</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> trans_compI trans_orderI<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="skolem">z</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">acomp</span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">≠</span> Gt"</span></span> <span class="quoted"><span class="quoted">"<span class="free">acomp</span> <span class="skolem">y</span> <span class="skolem">z</span> <span class="main">≠</span> Gt"</span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">acomp</span> <span class="skolem">x</span> <span class="skolem">z</span> <span class="main">≠</span> Gt <span class="main">∧</span> <span class="main">(</span><span class="free">acomp</span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">=</span> Lt <span class="main">∨</span> <span class="free">acomp</span> <span class="skolem">y</span> <span class="skolem">z</span> <span class="main">=</span> Lt <span class="main">⟶</span> <span class="free">acomp</span> <span class="skolem">x</span> <span class="skolem">z</span> <span class="main">=</span> Lt<span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> trans <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">x</span></span> <span class="quoted"><span class="skolem">y</span></span> <span class="quoted"><span class="skolem">z</span></span><span class="main">]</span> <span class="keyword2"><span class="keyword">and</span></span> eq <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">x</span></span> <span class="quoted"><span class="skolem">y</span></span><span class="main">]</span> <span class="keyword2"><span class="keyword">and</span></span> eq <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">y</span></span> <span class="quoted"><span class="skolem">z</span></span><span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">acomp</span> <span class="skolem">x</span> <span class="skolem">y</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">acomp</span> <span class="skolem">y</span> <span class="skolem">z</span>"</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> order.exhaust <span class="main"><span class="main">[</span></span><span class="operator">case_product</span> order.exhaust<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">acomp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> comparator"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> c<span class="main">:</span> <span class="quoted"><span class="quoted">"comparator <span class="free">acomp</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1" id="Comparator_Generator-comp_to_psym_comp"><span class="command">lemma</span></span> comp_to_psym_comp<span class="main">:</span> <span class="quoted"><span class="quoted">"psym_comp <span class="free">acomp</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> comparator_imp_eq_sym_trans<span class="main">[</span><span class="operator">OF</span> c<span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> sym_compD2<span class="main">)</span>

<span class="keyword1" id="Comparator_Generator-comp_to_peq_comp"><span class="command">lemma</span></span> comp_to_peq_comp<span class="main">:</span> <span class="quoted"><span class="quoted">"peq_comp <span class="free">acomp</span> <span class="free">x</span>"</span></span> 
  <span class="keyword1"><span class="command">using</span></span> comparator_imp_eq_sym_trans <span class="main">[</span><span class="operator">OF</span> c<span class="main">]</span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> eq_compD2<span class="main">)</span>
  
<span class="keyword1" id="Comparator_Generator-comp_to_ptrans_comp"><span class="command">lemma</span></span> comp_to_ptrans_comp<span class="main">:</span> <span class="quoted"><span class="quoted">"ptrans_comp <span class="free">acomp</span> <span class="free">x</span>"</span></span> 
  <span class="keyword1"><span class="command">using</span></span> comparator_imp_eq_sym_trans <span class="main">[</span><span class="operator">OF</span> c<span class="main">]</span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> trans_compD2<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Auxiliary Lemmas for Comparator Generator›</span></span>

<span class="keyword1" id="Comparator_Generator-forall_finite"><span class="command">lemma</span></span> forall_finite<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span> <span class="bound"><span class="bound">i</span></span> <span class="main">&lt;</span> <span class="main">(</span><span class="main">0</span> <span class="main">::</span> nat<span class="main">)</span><span class="main">.</span> <span class="free">P</span> <span class="bound">i</span><span class="main">)</span> <span class="main">=</span> True"</span></span>
   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span> <span class="bound"><span class="bound">i</span></span> <span class="main">&lt;</span> Suc <span class="main">0</span><span class="main">.</span> <span class="free">P</span> <span class="bound">i</span><span class="main">)</span> <span class="main">=</span> <span class="free">P</span> <span class="main">0</span>"</span></span>
   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span> <span class="bound"><span class="bound">i</span></span> <span class="main">&lt;</span> Suc <span class="main">(</span>Suc <span class="free">x</span><span class="main">)</span><span class="main">.</span> <span class="free">P</span> <span class="bound">i</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">P</span> <span class="main">0</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span> <span class="bound"><span class="bound">i</span></span> <span class="main">&lt;</span> Suc <span class="free">x</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span>Suc <span class="bound">i</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">case_tac</span> <span class="quoted"><span class="improper">i</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  
<span class="keyword1" id="Comparator_Generator-trans_order_different"><span class="command">lemma</span></span> trans_order_different<span class="main">:</span>
  <span class="quoted"><span class="quoted">"trans_order <span class="free">a</span> <span class="free">b</span> Lt"</span></span>
  <span class="quoted"><span class="quoted">"trans_order Gt <span class="free">b</span> <span class="free">c</span>"</span></span>
  <span class="quoted"><span class="quoted">"trans_order <span class="free">a</span> Gt <span class="free">c</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> trans_orderI<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Comparator_Generator-length_nth_simps"><span class="command">lemma</span></span> length_nth_simps<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"length <span class="main">[]</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="quoted"><span class="quoted">"length <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> Suc <span class="main">(</span>length <span class="free">xs</span><span class="main">)</span>"</span></span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">!</span> <span class="main">0</span> <span class="main">=</span> <span class="free">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">!</span> <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="main">=</span> <span class="free">xs</span> <span class="main">!</span> <span class="free">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹The Comparator Generator›</span></span>

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹comparator_generator.ML›</span>
                 
<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/comparator_generator.ML">
<div class="head">
<h1>File ‹comparator_generator.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Deriving class instances for datatypes
    Author:      Christian Sternagel and René Thiemann  &lt;christian.sternagel|rene.thiemann@uibk.ac.at&gt;
    Maintainer:  Christian Sternagel and René Thiemann
    License:     LGPL
*)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">COMPARATOR_GENERATOR</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>

  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">info</span> <span class="main">=</span>
   <span class="main">{</span>map <span class="main">:</span> term<span class="main">,</span>                    <span class="comment1">(* take % x. x, if there is no map *)</span>
    pcomp <span class="main">:</span> term<span class="main">,</span>                  <span class="comment1">(* partial comparator *)</span>
    comp <span class="main">:</span> term<span class="main">,</span>                   <span class="comment1">(* full comparator *)</span>
    comp_def <span class="main">:</span> thm option<span class="main">,</span>         <span class="comment1">(* definition of comparator, important for nesting *)</span>
    map_comp <span class="main">:</span> thm option<span class="main">,</span>         <span class="comment1">(* compositionality of map, important for nesting *)</span>
    partial_comp_thms <span class="main">:</span> thm list<span class="main">,</span>  <span class="comment1">(* first eq, then sym, finally trans *)</span>
    comp_thm <span class="main">:</span> thm<span class="main">,</span>               <span class="comment1">(* comparator acomp ⟹ … ⟹ comparator (full_comp acomp …) *)</span>
    used_positions <span class="main">:</span> bool list<span class="main">}</span>

  <span class="comment1">(* registers @{term comparator_of :: "some_type :: linorder comparator"}
     where some_type must just be a type without type-arguments *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> register_comparator_of <span class="main">:</span> string <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span> local_theory

  <span class="keyword1"><span class="keyword">val</span></span> register_foreign_comparator <span class="main">:</span>
    typ <span class="main">-&gt;</span> <span class="comment1">(* type-constant without type-variables *)</span>
    term <span class="main">-&gt;</span> <span class="comment1">(* comparator for type *)</span>
    thm <span class="main">-&gt;</span> <span class="comment1">(* comparator thm for provided comparator *)</span>
    local_theory <span class="main">-&gt;</span> local_theory

  <span class="keyword1"><span class="keyword">val</span></span> register_foreign_partial_and_full_comparator <span class="main">:</span>
    string <span class="main">-&gt;</span> <span class="comment1">(* long type name *)</span>
    term <span class="main">-&gt;</span> <span class="comment1">(* map function, should be λx. x, if there is no map *)</span>
    term <span class="main">-&gt;</span> <span class="comment1">(* partial comparator of type ('a =&gt; order, 'b)ty =&gt; ('a,'b)ty =&gt; order,
      where 'a is used, 'b is unused *)</span>
    term <span class="main">-&gt;</span> <span class="comment1">(* (full) comparator of type ('a ⇒ 'a ⇒ order) ⇒ ('a,'b)ty ⇒ ('a,'b)ty ⇒ order,
      where 'a is used, 'b is unused *)</span>
    thm option <span class="main">-&gt;</span> <span class="comment1">(* comp_def, should be full_comp = pcomp o map acomp ..., important for nesting *)</span>
    thm option <span class="main">-&gt;</span> <span class="comment1">(* map compositionality, important for nesting *)</span>
    thm <span class="main">-&gt;</span> <span class="comment1">(* partial eq thm for full comparator *)</span>
    thm <span class="main">-&gt;</span> <span class="comment1">(* partial sym thm for full comparator *)</span>
    thm <span class="main">-&gt;</span> <span class="comment1">(* partial trans thm for full comparator *)</span>
    thm <span class="main">-&gt;</span> <span class="comment1">(* full thm: comparator a-comp =&gt; comparator (full_comp a-comp) *)</span>
    bool list <span class="main">-&gt;</span> <span class="comment1">(*used positions*)</span>
    local_theory <span class="main">-&gt;</span> local_theory

  <span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">comparator_type</span> <span class="main">=</span> <span class="entity">Linorder</span> <span class="main">|</span> <span class="entity">BNF</span>

  <span class="keyword1"><span class="keyword">val</span></span> generate_comparators_from_bnf_fp <span class="main">:</span>
    string <span class="main">-&gt;</span>                 <span class="comment1">(* name of type *)</span>
    local_theory <span class="main">-&gt;</span>
    <span class="main">(</span><span class="main">(</span>term * thm list<span class="main">)</span> list * <span class="comment1">(* partial comparators + simp-rules *)</span>
    <span class="main">(</span>term * thm<span class="main">)</span> list<span class="main">)</span> *      <span class="comment1">(* non-partial comparator + def_rule *)</span>
    local_theory

  <span class="keyword1"><span class="keyword">val</span></span> generate_comparator <span class="main">:</span>
    <span class="entity">comparator_type</span> <span class="main">-&gt;</span>
    string <span class="main">-&gt;</span> <span class="comment1">(* name of type *)</span>
    local_theory <span class="main">-&gt;</span> local_theory

  <span class="keyword1"><span class="keyword">val</span></span> get_info <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string <span class="main">-&gt;</span> <span class="entity">info</span> option

  <span class="comment1">(* ensures that the info will be available on later requests *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> ensure_info <span class="main">:</span> <span class="entity">comparator_type</span> <span class="main">-&gt;</span> string <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span> local_theory

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Comparator_Generator</span> <span class="main">:</span> <span class="entity">COMPARATOR_GENERATOR</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword3"><span class="keyword">open</span></span> Generator_Aux

<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">comparator_type</span> <span class="main">=</span> <span class="entity">BNF</span> <span class="main">|</span> <span class="entity">Linorder</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">debug</span> <span class="main">=</span> false
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">debug_out</span> <span class="entity">s</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">debug</span> <span class="keyword2"><span class="keyword">then</span></span> writeln <span class="entity">s</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">orderT</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">order</span><span class="antiquote">}</span></span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">compT</span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">T</span> --&gt; <span class="entity">T</span> --&gt; <span class="entity">orderT</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">orderify</span> <span class="main">=</span> map_atyps <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">T</span> <span class="main">=&gt;</span> <span class="entity">T</span> --&gt; <span class="entity">orderT</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pcompT</span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">orderify</span> <span class="entity">T</span> --&gt; <span class="entity">T</span> --&gt; <span class="entity">orderT</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">info</span> <span class="main">=</span>
 <span class="main">{</span>map <span class="main">:</span> term<span class="main">,</span>
  pcomp <span class="main">:</span> term<span class="main">,</span>
  comp <span class="main">:</span> term<span class="main">,</span>
  comp_def <span class="main">:</span> thm option<span class="main">,</span>
  map_comp <span class="main">:</span> thm option<span class="main">,</span>
  partial_comp_thms <span class="main">:</span> thm list<span class="main">,</span>
  comp_thm <span class="main">:</span> thm<span class="main">,</span>
  used_positions <span class="main">:</span> bool list<span class="main">}</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Data</span> <span class="main">=</span> Generic_Data <span class="main">(</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">info</span> Symtab.table<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">empty</span> <span class="main">=</span> Symtab.empty<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">extend</span> <span class="main">=</span> I<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">merge</span> <span class="main">=</span> Symtab.merge <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">info1</span> <span class="main">:</span> <span class="entity">info</span><span class="main">,</span> <span class="entity">info2</span> <span class="main">:</span> <span class="entity">info</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">#</span>comp <span class="entity">info1</span> <span class="main">=</span> <span class="main">#</span>comp <span class="entity">info2</span><span class="main">)</span><span class="main">;</span>
<span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_info</span> <span class="entity">T</span> <span class="entity">info</span> <span class="main">=</span> Data.map <span class="main">(</span>Symtab.update_new <span class="main">(</span><span class="entity">T</span><span class="main">,</span> <span class="entity">info</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">get_info</span> <span class="main">=</span> Context.Proof #&gt; Data.get #&gt; Symtab.lookup

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">the_info</span> <span class="entity">ctxt</span> <span class="entity">tyco</span> <span class="main">=</span>
     <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">get_info</span> <span class="entity">ctxt</span> <span class="entity">tyco</span> <span class="keyword2"><span class="keyword">of</span></span>
        SOME <span class="entity">info</span> <span class="main">=&gt;</span> <span class="entity">info</span>
      <span class="main">|</span> NONE <span class="main">=&gt;</span> error <span class="main">(</span><span class="inner_quoted">"no comparator information available for type "</span> ^ quote <span class="entity">tyco</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">declare_info</span> <span class="entity">tyco</span> <span class="entity">m</span> <span class="entity">p</span> <span class="entity">c</span> <span class="entity">c_def</span> <span class="entity">m_comp</span> <span class="entity">p_thms</span> <span class="entity">c_thm</span> <span class="entity">used_pos</span> <span class="main">=</span>
  Local_Theory.declaration <span class="main">{</span>syntax <span class="main">=</span> false<span class="main">,</span> pervasive <span class="main">=</span> false<span class="main">}</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">phi</span> <span class="main">=&gt;</span>
    <span class="entity">add_info</span> <span class="entity">tyco</span>
     <span class="main">{</span>map <span class="main">=</span> Morphism.term <span class="entity">phi</span> <span class="entity">m</span><span class="main">,</span>
      pcomp <span class="main">=</span> Morphism.term <span class="entity">phi</span> <span class="entity">p</span><span class="main">,</span>
      comp <span class="main">=</span> Morphism.term <span class="entity">phi</span> <span class="entity">c</span><span class="main">,</span>
      comp_def <span class="main">=</span> Option.map <span class="main">(</span>Morphism.thm <span class="entity">phi</span><span class="main">)</span> <span class="entity">c_def</span><span class="main">,</span>
      map_comp <span class="main">=</span> Option.map <span class="main">(</span>Morphism.thm <span class="entity">phi</span><span class="main">)</span> <span class="entity">m_comp</span><span class="main">,</span>
      partial_comp_thms <span class="main">=</span> Morphism.fact <span class="entity">phi</span> <span class="entity">p_thms</span><span class="main">,</span>
      comp_thm <span class="main">=</span> Morphism.thm <span class="entity">phi</span> <span class="entity">c_thm</span><span class="main">,</span>
      used_positions <span class="main">=</span> <span class="entity">used_pos</span><span class="main">}</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">EQ</span> <span class="main">=</span> <span class="inner_numeral">0</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">SYM</span> <span class="main">=</span> <span class="inner_numeral">1</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">TRANS</span> <span class="main">=</span> <span class="inner_numeral">2</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">register_foreign_partial_and_full_comparator</span> <span class="entity">tyco</span> <span class="entity">m</span> <span class="entity">p</span> <span class="entity">c</span> <span class="entity">c_def</span> <span class="entity">m_comp</span> <span class="entity">eq_thm</span> <span class="entity">sym_thm</span>
  <span class="entity">trans_thm</span> <span class="entity">c_thm</span> <span class="main">=</span>
  <span class="entity">declare_info</span> <span class="entity">tyco</span> <span class="entity">m</span> <span class="entity">p</span> <span class="entity">c</span> <span class="entity">c_def</span> <span class="entity">m_comp</span> <span class="main">[</span><span class="entity">eq_thm</span><span class="main">,</span> <span class="entity">sym_thm</span><span class="main">,</span> <span class="entity">trans_thm</span><span class="main">]</span> <span class="entity">c_thm</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_infer_const</span> <span class="entity">name</span> <span class="entity">ctxt</span> <span class="entity">c</span> <span class="main">=</span> <span class="entity">infer_type</span> <span class="entity">ctxt</span> <span class="main">(</span>Const <span class="main">(</span><span class="entity">name</span><span class="main">,</span> dummyT<span class="main">)</span> $ <span class="entity">c</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mk_eq_comp</span> <span class="main">=</span> <span class="entity">mk_infer_const</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> eq_comp<span class="antiquote">}</span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mk_peq_comp</span> <span class="main">=</span> <span class="entity">mk_infer_const</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> peq_comp<span class="antiquote">}</span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mk_sym_comp</span> <span class="main">=</span> <span class="entity">mk_infer_const</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> sym_comp<span class="antiquote">}</span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mk_psym_comp</span> <span class="main">=</span> <span class="entity">mk_infer_const</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> psym_comp<span class="antiquote">}</span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mk_trans_comp</span> <span class="main">=</span> <span class="entity">mk_infer_const</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> trans_comp<span class="antiquote">}</span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mk_ptrans_comp</span> <span class="main">=</span> <span class="entity">mk_infer_const</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> ptrans_comp<span class="antiquote">}</span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mk_comp</span> <span class="main">=</span> <span class="entity">mk_infer_const</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> comparator<span class="antiquote">}</span></span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">default_comp</span> <span class="entity">T</span> <span class="main">=</span> absdummy <span class="entity">T</span> <span class="main">(</span>absdummy <span class="entity">T</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">Eq</span><span class="antiquote">}</span></span><span class="main">)</span> <span class="comment1">(*%_ _. Eq*)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">register_foreign_comparator</span> <span class="entity">T</span> <span class="entity">comp</span> <span class="entity">comp_thm</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tyco</span> <span class="main">=</span> <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">T</span> <span class="keyword2"><span class="keyword">of</span></span> Type <span class="main">(</span><span class="entity">tyco</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">tyco</span> <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> error <span class="inner_quoted">"expected type constant"</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> comp_to_peq_comp<span class="antiquote">}</span></span></span> OF <span class="main">[</span><span class="entity">comp_thm</span><span class="main">]</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sym</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> comp_to_psym_comp<span class="antiquote">}</span></span></span> OF <span class="main">[</span><span class="entity">comp_thm</span><span class="main">]</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">trans</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> comp_to_ptrans_comp<span class="antiquote">}</span></span></span> OF <span class="main">[</span><span class="entity">comp_thm</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">register_foreign_partial_and_full_comparator</span>
      <span class="entity">tyco</span> <span class="main">(</span><span class="entity">HOLogic.id_const</span> <span class="entity">T</span><span class="main">)</span> <span class="entity">comp</span> <span class="entity">comp</span> NONE NONE <span class="entity">eq</span> <span class="entity">sym</span> <span class="entity">trans</span> <span class="entity">comp_thm</span> <span class="main">[</span><span class="main">]</span> <span class="entity">lthy</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">register_comparator_of</span> <span class="entity">tyco</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">T</span> <span class="main">=</span> Type <span class="main">(</span><span class="entity">tyco</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">comp</span> <span class="main">=</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> comparator_of<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">compT</span> <span class="entity">T</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">comp_thm</span> <span class="main">=</span> Thm.instantiate' <span class="main">[</span>SOME <span class="main">(</span>Thm.ctyp_of <span class="entity">lthy</span> <span class="entity">T</span><span class="main">)</span><span class="main">]</span>
      <span class="main">[</span><span class="main">]</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> comparator_of<span class="antiquote">}</span></span></span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">register_foreign_comparator</span> <span class="entity">T</span> <span class="entity">comp</span> <span class="entity">comp_thm</span> <span class="entity">lthy</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">generate_comparators_from_bnf_fp</span> <span class="entity">tyco</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">tycos</span><span class="main">,</span> <span class="entity">Ts</span><span class="main">)</span> <span class="main">=</span> <span class="entity">mutual_recursive_types</span> <span class="entity">tyco</span> <span class="entity">lthy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">tyco</span> <span class="main">=&gt;</span> <span class="inner_quoted">"generating comparator for type "</span> ^ quote <span class="entity">tyco</span><span class="main">)</span> <span class="entity">tycos</span>
      |&gt; cat_lines |&gt; writeln
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">tfrees</span><span class="main">,</span> <span class="entity">used_tfrees</span><span class="main">)</span> <span class="main">=</span> <span class="entity">type_parameters</span> <span class="main">(</span>hd <span class="entity">Ts</span><span class="main">)</span> <span class="entity">lthy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">used_positions</span> <span class="main">=</span> map <span class="main">(</span>member <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">used_tfrees</span> o TFree<span class="main">)</span> <span class="entity">tfrees</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cs</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">subT</span> <span class="inner_quoted">"comp"</span><span class="main">)</span> <span class="entity">used_tfrees</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">comp_Ts</span> <span class="main">=</span> map <span class="entity">compT</span> <span class="entity">used_tfrees</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg_comps</span> <span class="main">=</span> map Free <span class="main">(</span><span class="entity">cs</span> ~~ <span class="entity">comp_Ts</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dep_tycos</span> <span class="main">=</span> fold <span class="main">(</span><span class="entity">add_used_tycos</span> <span class="entity">lthy</span><span class="main">)</span> <span class="entity">tycos</span> <span class="main">[</span><span class="main">]</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">XTys</span> <span class="main">=</span> <span class="entity">Bnf_Access.bnf_types</span> <span class="entity">lthy</span> <span class="entity">tycos</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inst_types</span> <span class="main">=</span> typ_subst_atomic <span class="main">(</span><span class="entity">XTys</span> ~~ <span class="entity">Ts</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cTys</span> <span class="main">=</span> map <span class="main">(</span>map <span class="main">(</span>map <span class="entity">inst_types</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="entity">Bnf_Access.constr_argument_types</span> <span class="entity">lthy</span> <span class="entity">tycos</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">map_simps</span> <span class="main">=</span> <span class="entity">Bnf_Access.map_simps</span> <span class="entity">lthy</span> <span class="entity">tycos</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">case_simps</span> <span class="main">=</span> <span class="entity">Bnf_Access.case_simps</span> <span class="entity">lthy</span> <span class="entity">tycos</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">maps</span> <span class="main">=</span> <span class="entity">Bnf_Access.map_terms</span> <span class="entity">lthy</span> <span class="entity">tycos</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">map_comp_thms</span> <span class="main">=</span> <span class="entity">Bnf_Access.map_comps</span> <span class="entity">lthy</span> <span class="entity">tycos</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t_ixs</span> <span class="main">=</span> <span class="inner_numeral">0</span> upto <span class="main">(</span>length <span class="entity">Ts</span> - <span class="inner_numeral">1</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">compNs</span> <span class="main">=</span>
      <span class="comment1">(*TODO: clashes in presence of same type names in different theories*)</span>
      map <span class="main">(</span>Long_Name.base_name<span class="main">)</span> <span class="entity">tycos</span>
      |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">s</span> <span class="main">=&gt;</span> <span class="inner_quoted">"comparator_"</span> ^ <span class="entity">s</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">gen_vars</span> <span class="entity">prefix</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span> <span class="entity">pty</span><span class="main">)</span> <span class="main">=&gt;</span> Free <span class="main">(</span><span class="entity">prefix</span> ^ <span class="entity">ints_to_subscript</span> <span class="main">[</span><span class="entity">i</span><span class="main">]</span><span class="main">,</span> <span class="entity">pty</span><span class="main">)</span><span class="main">)</span>
      <span class="main">(</span><span class="entity">t_ixs</span> ~~ <span class="entity">Ts</span><span class="main">)</span>

    <span class="comment1">(* primrec definitions of partial comparators *)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_pcomp</span> <span class="main">(</span><span class="entity">tyco</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="inner_quoted">"partial_comparator_"</span> ^ Long_Name.base_name <span class="entity">tyco</span><span class="main">,</span> <span class="entity">pcompT</span> <span class="entity">T</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">constr_terms</span> <span class="entity">lthy</span> <span class="main">=</span>
      <span class="entity">Bnf_Access.constr_terms</span> <span class="entity">lthy</span>
      #&gt; map <span class="main">(</span>apsnd <span class="main">(</span>map <span class="entity">freeify_tvars</span> o fst o strip_type<span class="main">)</span> o dest_Const<span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">generate_pcomp_eqs</span> <span class="entity">lthy</span> <span class="main">(</span><span class="entity">tyco</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">constrs</span> <span class="main">=</span> <span class="entity">constr_terms</span> <span class="entity">lthy</span> <span class="entity">tyco</span>

        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">comp_arg</span> <span class="entity">T</span> <span class="entity">x</span> <span class="entity">y</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">m</span> <span class="main">=</span> <span class="entity">Generator_Aux.create_map</span> <span class="entity">default_comp</span> <span class="main">(</span>K o Free o <span class="entity">mk_pcomp</span><span class="main">)</span> <span class="main">(</span><span class="main">)</span> <span class="main">(</span>K false<span class="main">)</span>
              <span class="main">(</span><span class="main">#</span>used_positions oo <span class="entity">the_info</span><span class="main">)</span> <span class="main">(</span><span class="main">#</span>map oo <span class="entity">the_info</span><span class="main">)</span> <span class="main">(</span>K o <span class="main">#</span>pcomp oo <span class="entity">the_info</span><span class="main">)</span>
              <span class="entity">tycos</span> <span class="main">(</span><span class="main">(</span>K o K<span class="main">)</span> <span class="main">(</span><span class="main">)</span><span class="main">)</span> <span class="entity">T</span> <span class="entity">lthy</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">p</span> <span class="main">=</span> <span class="entity">Generator_Aux.create_partial</span> <span class="main">(</span><span class="main">)</span> <span class="main">(</span>K false<span class="main">)</span>
              <span class="main">(</span><span class="main">#</span>used_positions oo <span class="entity">the_info</span><span class="main">)</span> <span class="main">(</span><span class="main">#</span>map oo <span class="entity">the_info</span><span class="main">)</span> <span class="main">(</span>K o <span class="main">#</span>pcomp oo <span class="entity">the_info</span><span class="main">)</span>
              <span class="entity">tycos</span> <span class="main">(</span><span class="main">(</span>K o K<span class="main">)</span> <span class="main">(</span><span class="main">)</span><span class="main">)</span> <span class="entity">T</span> <span class="entity">lthy</span>
          <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">p</span> $ <span class="main">(</span><span class="entity">m</span> $ <span class="entity">x</span><span class="main">)</span> $ <span class="entity">y</span> |&gt; <span class="entity">infer_type</span> <span class="entity">lthy</span> <span class="keyword2"><span class="keyword">end</span></span>

        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">generate_eq</span> <span class="entity">lthy</span> <span class="main">(</span><span class="entity">c_T</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">(</span><span class="entity">cN</span><span class="main">,</span> <span class="entity">Ts</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg_Ts'</span> <span class="main">=</span> map <span class="entity">orderify</span> <span class="entity">Ts</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">c</span> <span class="main">=</span> Const <span class="main">(</span><span class="entity">cN</span><span class="main">,</span> <span class="entity">arg_Ts'</span> ---&gt; <span class="entity">orderify</span> <span class="entity">T</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">y</span><span class="main">,</span> <span class="main">(</span><span class="entity">xs</span><span class="main">,</span> <span class="entity">ys</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Name.variant <span class="inner_quoted">"y"</span> <span class="main">(</span>Variable.names_of <span class="entity">lthy</span><span class="main">)</span> |&gt;&gt; Free o rpair <span class="entity">T</span>
              ||&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> Name.invent_names <span class="entity">ctxt</span> <span class="inner_quoted">"x"</span> <span class="main">(</span><span class="entity">arg_Ts'</span> @ <span class="entity">Ts</span><span class="main">)</span> |&gt; map Free<span class="main">)</span>
              ||&gt; chop <span class="main">(</span>length <span class="entity">Ts</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">k</span> <span class="main">=</span> find_index <span class="main">(</span>curry <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">c_T</span><span class="main">)</span> <span class="entity">constrs</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cases</span> <span class="main">=</span> <span class="entity">constrs</span> |&gt; map_index <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">Ts'</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span>
              <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">i</span> &lt; <span class="entity">k</span> <span class="keyword2"><span class="keyword">then</span></span> fold_rev absdummy <span class="entity">Ts'</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">Gt</span><span class="antiquote">}</span></span>
              <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">k</span> &lt; <span class="entity">i</span> <span class="keyword2"><span class="keyword">then</span></span> fold_rev absdummy <span class="entity">Ts'</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">Lt</span><span class="antiquote">}</span></span>
              <span class="keyword2"><span class="keyword">else</span></span>
                <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">comp_lex</span><span class="antiquote">}</span></span> $ <span class="entity">HOLogic.mk_list</span> <span class="entity">orderT</span> <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">map</span> 3<span class="antiquote">}</span></span></span> <span class="entity">comp_arg</span> <span class="entity">Ts</span> <span class="entity">xs</span> <span class="entity">ys</span><span class="main">)</span>
                |&gt; <span class="entity">lambdas</span> <span class="entity">ys</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs</span> <span class="main">=</span> Free <span class="main">(</span><span class="entity">mk_pcomp</span> <span class="main">(</span><span class="entity">tyco</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span> $ list_comb <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">xs</span><span class="main">)</span> $ <span class="entity">y</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span> list_comb <span class="main">(</span>singleton <span class="main">(</span><span class="entity">Bnf_Access.case_consts</span> <span class="entity">lthy</span><span class="main">)</span> <span class="entity">tyco</span><span class="main">,</span> <span class="entity">cases</span><span class="main">)</span> $ <span class="entity">y</span>
          <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span><span class="main">)</span> |&gt; <span class="entity">infer_type</span> <span class="entity">lthy</span> <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword2"><span class="keyword">in</span></span> map <span class="main">(</span><span class="entity">generate_eq</span> <span class="entity">lthy</span><span class="main">)</span> <span class="entity">constrs</span> <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eqs</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">generate_pcomp_eqs</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">(</span><span class="entity">tycos</span> ~~ <span class="entity">Ts</span><span class="main">)</span> |&gt; flat
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">bindings</span> <span class="main">=</span> <span class="entity">tycos</span> ~~ <span class="entity">Ts</span> |&gt; map <span class="entity">mk_pcomp</span>
      |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span>Binding.name <span class="entity">name</span><span class="main">,</span> SOME <span class="entity">T</span><span class="main">,</span> NoSyn<span class="main">)</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">pcomps</span><span class="main">,</span> <span class="entity">pcomp_simps</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">lthy</span>
      |&gt; Local_Theory.begin_nested
      |&gt; snd
      |&gt; <span class="main">(</span><span class="entity">BNF_LFP_Rec_Sugar.primrec</span> false <span class="main">[</span><span class="main">]</span> <span class="entity">bindings</span>
          <span class="main">(</span>map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">(</span>Binding.empty_atts<span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="entity">eqs</span><span class="main">)</span><span class="main">)</span>
      |&gt; Local_Theory.end_nested_result <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">phi</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">pcomps</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">pcomp_simps</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span>map <span class="main">(</span>Morphism.term <span class="entity">phi</span><span class="main">)</span> <span class="entity">pcomps</span><span class="main">,</span> map <span class="main">(</span>Morphism.fact <span class="entity">phi</span><span class="main">)</span> <span class="entity">pcomp_simps</span><span class="main">)</span><span class="main">)</span>

    <span class="comment1">(* definitions of comparators via partial comparators and maps *)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">generate_comp_def</span> <span class="entity">tyco</span> <span class="entity">lthy</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cs</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">subT</span> <span class="inner_quoted">"comp"</span><span class="main">)</span> <span class="entity">used_tfrees</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg_Ts</span> <span class="main">=</span> map <span class="entity">compT</span> <span class="entity">used_tfrees</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span> map Free <span class="main">(</span><span class="entity">cs</span> ~~ <span class="entity">arg_Ts</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">pcomp</span><span class="main">,</span> <span class="entity">m</span><span class="main">)</span> <span class="main">=</span> AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">(</span><span class="entity">tycos</span> ~~ <span class="main">(</span><span class="entity">pcomps</span> ~~ <span class="entity">maps</span><span class="main">)</span><span class="main">)</span> <span class="entity">tyco</span> |&gt; the
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ts</span> <span class="main">=</span> <span class="entity">tfrees</span> |&gt; map TFree |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">T</span> <span class="main">=&gt;</span>
          AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">(</span><span class="entity">used_tfrees</span> ~~ <span class="entity">args</span><span class="main">)</span> <span class="entity">T</span> |&gt; the_default <span class="main">(</span><span class="entity">default_comp</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span> <span class="entity">HOLogic.mk_comp</span> <span class="main">(</span><span class="entity">pcomp</span><span class="main">,</span> list_comb <span class="main">(</span><span class="entity">m</span><span class="main">,</span> <span class="entity">ts</span><span class="main">)</span><span class="main">)</span> |&gt; <span class="entity">infer_type</span> <span class="entity">lthy</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">abs_def</span> <span class="main">=</span> <span class="entity">lambdas</span> <span class="entity">args</span> <span class="entity">rhs</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">name</span> <span class="main">=</span> <span class="inner_quoted">"comparator_"</span> ^ Long_Name.base_name <span class="entity">tyco</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">comp</span><span class="main">,</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">prethm</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span>
          Local_Theory.define <span class="main">(</span><span class="main">(</span>Binding.name <span class="entity">name</span><span class="main">,</span> NoSyn<span class="main">)</span><span class="main">,</span> <span class="main">(</span>Binding.empty_atts<span class="main">,</span> <span class="entity">abs_def</span><span class="main">)</span><span class="main">)</span> <span class="entity">lthy</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq</span> <span class="main">=</span> Logic.mk_equals <span class="main">(</span>list_comb <span class="main">(</span><span class="entity">comp</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm</span> <span class="main">=</span> Goal.prove <span class="entity">lthy</span> <span class="main">(</span>map <span class="main">(</span>fst o dest_Free<span class="main">)</span> <span class="entity">args</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span> <span class="entity">eq</span> <span class="main">(</span>K <span class="main">(</span><span class="entity">unfold_tac</span> <span class="entity">lthy</span> <span class="main">[</span><span class="entity">prethm</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        Local_Theory.note <span class="main">(</span><span class="main">(</span>Binding.name <span class="main">(</span><span class="entity">name</span> ^ <span class="inner_quoted">"_def"</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="entity">thm</span><span class="main">]</span><span class="main">)</span> <span class="entity">lthy</span>
        |&gt;&gt; the_single o snd
        |&gt;&gt; `<span class="main">(</span>K <span class="entity">comp</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">comps</span><span class="main">,</span> <span class="entity">comp_defs</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">lthy</span>
      |&gt; Local_Theory.begin_nested
      |&gt; snd
      |&gt; fold_map <span class="entity">generate_comp_def</span> <span class="entity">tycos</span>
      |&gt;&gt; split_list
      |&gt; Local_Theory.end_nested_result 
          <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">phi</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">comps</span><span class="main">,</span> <span class="entity">comp_defs</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span>map <span class="main">(</span>Morphism.term <span class="entity">phi</span><span class="main">)</span> <span class="entity">comps</span><span class="main">,</span> map <span class="main">(</span>Morphism.thm <span class="entity">phi</span><span class="main">)</span> <span class="entity">comp_defs</span><span class="main">)</span><span class="main">)</span>

    <span class="comment1">(* alternative simp-rules for comparators *)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">full_comps</span> <span class="main">=</span> map <span class="main">(</span>list_comb o rpair <span class="entity">arg_comps</span><span class="main">)</span> <span class="entity">comps</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">generate_comp_simps</span> <span class="main">(</span><span class="entity">tyco</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="entity">lthy</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">constrs</span> <span class="main">=</span> <span class="entity">constr_terms</span> <span class="entity">lthy</span> <span class="entity">tyco</span>

        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">comp_arg</span> <span class="entity">T</span> <span class="entity">x</span> <span class="entity">y</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">create_comp</span> <span class="main">(</span><span class="entity">T</span> <span class="keyword1"><span class="keyword">as</span></span> TFree <span class="main">_</span><span class="main">)</span> <span class="main">=</span>
                  AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">(</span><span class="entity">used_tfrees</span> ~~ <span class="entity">arg_comps</span><span class="main">)</span> <span class="entity">T</span>
                  |&gt; the_default <span class="main">(</span><span class="entity">HOLogic.id_const</span> dummyT<span class="main">)</span>
              <span class="main">|</span> <span class="entity">create_comp</span> <span class="main">(</span>Type <span class="main">(</span><span class="entity">tyco</span><span class="main">,</span> <span class="entity">Ts</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
                  <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">(</span><span class="entity">tycos</span> ~~ <span class="entity">comps</span><span class="main">)</span> <span class="entity">tyco</span> <span class="keyword2"><span class="keyword">of</span></span>
                    SOME <span class="entity">c</span> <span class="main">=&gt;</span> list_comb <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">arg_comps</span><span class="main">)</span>
                  <span class="main">|</span> NONE <span class="main">=&gt;</span>
                      <span class="keyword2"><span class="keyword">let</span></span>
                        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span>comp <span class="main">=</span> <span class="entity">c</span><span class="main">,</span> used_positions <span class="main">=</span> <span class="entity">up</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">the_info</span> <span class="entity">lthy</span> <span class="entity">tyco</span>
                        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ts</span> <span class="main">=</span> <span class="main">(</span><span class="entity">up</span> ~~ <span class="entity">Ts</span><span class="main">)</span> |&gt; map_filter <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">b</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="main">=&gt;</span>
                          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">b</span> <span class="keyword2"><span class="keyword">then</span></span> SOME <span class="main">(</span><span class="entity">create_comp</span> <span class="entity">T</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> NONE<span class="main">)</span>
                      <span class="keyword2"><span class="keyword">in</span></span> list_comb <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">ts</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>
              <span class="main">|</span> <span class="entity">create_comp</span> <span class="entity">T</span> <span class="main">=</span>
                  error <span class="main">(</span><span class="inner_quoted">"unexpected schematic variable "</span> ^ quote <span class="main">(</span>Syntax.string_of_typ <span class="entity">lthy</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">comp</span> <span class="main">=</span> <span class="entity">create_comp</span> <span class="entity">T</span>
          <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">comp</span> $ <span class="entity">x</span> $ <span class="entity">y</span> |&gt; <span class="entity">infer_type</span> <span class="entity">lthy</span> <span class="keyword2"><span class="keyword">end</span></span>

        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">generate_eq_thm</span> <span class="entity">lthy</span> <span class="main">(</span><span class="entity">c_T</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">Ts</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">xs</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="main">=</span> Variable.names_of <span class="entity">lthy</span>
              |&gt; fold_map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">T</span> <span class="main">=&gt;</span> Name.variant <span class="inner_quoted">"x"</span> #&gt;&gt; Free o rpair <span class="entity">T</span><span class="main">)</span> <span class="entity">Ts</span>
            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_const</span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">Ts</span><span class="main">)</span> <span class="main">=</span> Const <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">Ts</span> ---&gt; <span class="entity">T</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">comp_const</span> <span class="main">=</span> AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">(</span><span class="entity">tycos</span> ~~ <span class="entity">comps</span><span class="main">)</span> <span class="entity">tyco</span> |&gt; the
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs</span> <span class="main">=</span> list_comb <span class="main">(</span><span class="entity">comp_const</span><span class="main">,</span> <span class="entity">arg_comps</span><span class="main">)</span> $ list_comb <span class="main">(</span><span class="entity">mk_const</span> <span class="entity">c_T</span><span class="main">,</span> <span class="entity">xs</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">k</span> <span class="main">=</span> find_index <span class="main">(</span>curry <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">c_T</span><span class="main">)</span> <span class="entity">constrs</span>

            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_eq</span> <span class="entity">c</span> <span class="entity">ys</span> <span class="entity">rhs</span> <span class="main">=</span>
              <span class="keyword2"><span class="keyword">let</span></span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">y</span> <span class="main">=</span> list_comb <span class="main">(</span><span class="entity">mk_const</span> <span class="entity">c</span><span class="main">,</span> <span class="entity">ys</span><span class="main">)</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq</span> <span class="main">=</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">lhs</span> $ <span class="entity">y</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span><span class="main">)</span>
              <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">ys</span><span class="main">,</span> <span class="entity">eq</span> |&gt; <span class="entity">infer_type</span> <span class="entity">lthy</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>

            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">ys</span><span class="main">,</span> <span class="entity">eqs</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> fold_map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span> <span class="entity">c</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">Ts'</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span>
              <span class="keyword2"><span class="keyword">let</span></span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">ys</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="main">=</span> fold_map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">T</span> <span class="main">=&gt;</span> Name.variant <span class="inner_quoted">"y"</span> #&gt;&gt; Free o rpair <span class="entity">T</span><span class="main">)</span> <span class="entity">Ts'</span> <span class="entity">ctxt</span>
              <span class="keyword2"><span class="keyword">in</span></span>
                <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">i</span> &lt; <span class="entity">k</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">mk_eq</span> <span class="entity">c</span> <span class="entity">ys</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">Gt</span><span class="antiquote">}</span></span>
                <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">k</span> &lt; <span class="entity">i</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">mk_eq</span> <span class="entity">c</span> <span class="entity">ys</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">Lt</span><span class="antiquote">}</span></span>
                <span class="keyword2"><span class="keyword">else</span></span>
                  <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">comp_lex</span><span class="antiquote">}</span></span> $ <span class="entity">HOLogic.mk_list</span> <span class="entity">orderT</span> <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">map</span> 3<span class="antiquote">}</span></span></span> <span class="entity">comp_arg</span> <span class="entity">Ts</span> <span class="entity">xs</span> <span class="entity">ys</span><span class="main">)</span>
                  |&gt; <span class="entity">mk_eq</span> <span class="entity">c</span> <span class="entity">ys</span><span class="main">,</span>
                <span class="entity">ctxt</span><span class="main">)</span>
              <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span> <span class="main">(</span>tag_list <span class="inner_numeral">0</span> <span class="entity">constrs</span><span class="main">)</span> <span class="entity">ctxt</span>
              |&gt; apfst <span class="main">(</span>apfst flat o split_list<span class="main">)</span>

            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dep_comp_defs</span> <span class="main">=</span> map_filter <span class="main">(</span><span class="main">#</span>comp_def o <span class="entity">the_info</span> <span class="entity">lthy</span><span class="main">)</span> <span class="entity">dep_tycos</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dep_map_comps</span> <span class="main">=</span> map_filter <span class="main">(</span><span class="main">#</span>map_comp o <span class="entity">the_info</span> <span class="entity">lthy</span><span class="main">)</span> <span class="entity">dep_tycos</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thms</span> <span class="main">=</span> <span class="entity">prove_multi_future</span> <span class="entity">lthy</span> <span class="main">(</span>map <span class="main">(</span>fst o dest_Free<span class="main">)</span> <span class="main">(</span><span class="entity">xs</span> @ <span class="entity">ys</span><span class="main">)</span> @ <span class="entity">cs</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span> <span class="entity">eqs</span>
              <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
                Goal.conjunction_tac <span class="inner_numeral">1</span>
                THEN <span class="entity">unfold_tac</span> <span class="entity">ctxt</span>
                  <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> id_apply o_def<span class="antiquote">}</span></span></span> @
                    flat <span class="entity">case_simps</span> @
                    flat <span class="entity">pcomp_simps</span> @
                    <span class="entity">dep_map_comps</span> @ <span class="entity">comp_defs</span> @ <span class="entity">dep_comp_defs</span> @ flat <span class="entity">map_simps</span><span class="main">)</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">thms</span> <span class="keyword2"><span class="keyword">end</span></span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thms</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">generate_eq_thm</span> <span class="entity">lthy</span><span class="main">)</span> <span class="entity">constrs</span> |&gt; flat
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simp_thms</span> <span class="main">=</span> map <span class="main">(</span>Local_Defs.unfold <span class="entity">lthy</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> comp_lex_unfolds<span class="antiquote">}</span></span></span><span class="main">)</span> <span class="entity">thms</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">name</span> <span class="main">=</span> <span class="inner_quoted">"comparator_"</span> ^ Long_Name.base_name <span class="entity">tyco</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="entity">lthy</span>
        |&gt; Local_Theory.note <span class="main">(</span><span class="main">(</span>Binding.name <span class="main">(</span><span class="entity">name</span> ^ <span class="inner_quoted">"_simps"</span><span class="main">)</span><span class="main">,</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">attributes</span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">code</span><span class="main">]</span><span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">,</span> <span class="entity">simp_thms</span><span class="main">)</span>
        |&gt; snd
        |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">lthy</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">thms</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">comp_simps</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">lthy</span>
      |&gt; Local_Theory.begin_nested
      |&gt; snd
      |&gt; fold_map <span class="entity">generate_comp_simps</span> <span class="main">(</span><span class="entity">tycos</span> ~~ <span class="entity">Ts</span><span class="main">)</span>
      |&gt; Local_Theory.end_nested_result <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">phi</span> <span class="main">=&gt;</span> map <span class="main">(</span>Morphism.fact <span class="entity">phi</span><span class="main">)</span><span class="main">)</span>

    <span class="comment1">(* partial theorems *)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">set_funs</span> <span class="main">=</span> <span class="entity">Bnf_Access.set_terms</span> <span class="entity">lthy</span> <span class="entity">tycos</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">x_vars</span> <span class="main">=</span> <span class="entity">gen_vars</span> <span class="inner_quoted">"x"</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">free_names</span> <span class="main">=</span> map <span class="main">(</span>fst o dest_Free<span class="main">)</span> <span class="main">(</span><span class="entity">x_vars</span> @ <span class="entity">arg_comps</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">xi_vars</span> <span class="main">=</span> map_index <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span>
      map_index <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">j</span><span class="main">,</span> <span class="entity">pty</span><span class="main">)</span> <span class="main">=&gt;</span> Free <span class="main">(</span><span class="inner_quoted">"x"</span> ^ <span class="entity">ints_to_subscript</span> <span class="main">[</span><span class="entity">i</span><span class="main">,</span> <span class="entity">j</span><span class="main">]</span><span class="main">,</span> <span class="entity">pty</span><span class="main">)</span><span class="main">)</span> <span class="entity">used_tfrees</span><span class="main">)</span> <span class="entity">Ts</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_eq_sym_trans_thm'</span> <span class="entity">mk_eq_sym_trans'</span> <span class="main">=</span> map_index <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span> <span class="main">(</span><span class="main">(</span><span class="entity">set_funs</span><span class="main">,</span> <span class="entity">x</span><span class="main">)</span><span class="main">,</span> <span class="entity">xis</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">create_cond</span> <span class="main">(</span><span class="main">(</span><span class="entity">set_t</span><span class="main">,</span> <span class="entity">xi</span><span class="main">)</span><span class="main">,</span> <span class="entity">c</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span> <span class="entity">mk_eq_sym_trans'</span> <span class="entity">lthy</span> <span class="entity">c</span> $ <span class="entity">xi</span> |&gt; <span class="entity">HOLogic.mk_Trueprop</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs</span> <span class="main">=</span> <span class="entity">HOLogic.mk_mem</span> <span class="main">(</span><span class="entity">xi</span><span class="main">,</span> <span class="entity">set_t</span> $ <span class="entity">x</span><span class="main">)</span> |&gt; <span class="entity">HOLogic.mk_Trueprop</span>
          <span class="keyword2"><span class="keyword">in</span></span> Logic.all <span class="entity">xi</span> <span class="main">(</span>Logic.mk_implies <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">used_sets</span> <span class="main">=</span> map <span class="main">(</span>the o AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">(</span>map TFree <span class="entity">tfrees</span> ~~ <span class="entity">set_funs</span><span class="main">)</span><span class="main">)</span> <span class="entity">used_tfrees</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">conds</span> <span class="main">=</span> map <span class="entity">create_cond</span> <span class="main">(</span><span class="entity">used_sets</span> ~~ <span class="entity">xis</span> ~~ <span class="entity">arg_comps</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">concl</span> <span class="main">=</span> <span class="entity">mk_eq_sym_trans'</span> <span class="entity">lthy</span> <span class="main">(</span>nth <span class="entity">full_comps</span> <span class="entity">i</span><span class="main">)</span> $ <span class="entity">x</span> |&gt; <span class="entity">HOLogic.mk_Trueprop</span>
      <span class="keyword2"><span class="keyword">in</span></span> Logic.list_implies <span class="main">(</span><span class="entity">conds</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span> |&gt; <span class="entity">infer_type</span> <span class="entity">lthy</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span> <span class="main">(</span><span class="entity">set_funs</span> ~~ <span class="entity">x_vars</span> ~~ <span class="entity">xi_vars</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">induct_thms</span> <span class="main">=</span> <span class="entity">Bnf_Access.induct_thms</span> <span class="entity">lthy</span> <span class="entity">tycos</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">set_simps</span> <span class="main">=</span> <span class="entity">Bnf_Access.set_simps</span> <span class="entity">lthy</span> <span class="entity">tycos</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">case_thms</span> <span class="main">=</span> <span class="entity">Bnf_Access.case_thms</span> <span class="entity">lthy</span> <span class="entity">tycos</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">distinct_thms</span> <span class="main">=</span> <span class="entity">Bnf_Access.distinct_thms</span> <span class="entity">lthy</span> <span class="entity">tycos</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inject_thms</span> <span class="main">=</span> <span class="entity">Bnf_Access.inject_thms</span> <span class="entity">lthy</span> <span class="entity">tycos</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rec_info</span> <span class="main">=</span> <span class="main">(</span><span class="entity">the_info</span> <span class="entity">lthy</span><span class="main">,</span> <span class="main">#</span>used_positions<span class="main">,</span> <span class="entity">tycos</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">split_IHs</span> <span class="main">=</span> <span class="entity">split_IHs</span> <span class="entity">rec_info</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">unknown_value</span> <span class="main">=</span> false <span class="comment1">(* effect of choosing false / true not yet visible *)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">induct_tac</span> <span class="entity">ctxt</span> <span class="entity">f</span> <span class="main">=</span>
      <span class="main">(</span><span class="main">(</span>DETERM o <span class="entity">Induction.induction_tac</span> <span class="entity">ctxt</span> false
        <span class="main">(</span>map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span> <span class="main">[</span>SOME <span class="main">(</span>NONE<span class="main">,</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">unknown_value</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="entity">x_vars</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span>SOME <span class="entity">induct_thms</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
      THEN_ALL_NEW <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">i</span> <span class="main">=&gt;</span>
        <span class="entity">Subgoal.SUBPROOF</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> prems <span class="main">=</span> <span class="entity">prems</span><span class="main">,</span> params <span class="main">=</span> <span class="entity">iparams</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
          <span class="entity">f</span> <span class="main">(</span><span class="entity">i</span> - <span class="inner_numeral">1</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="entity">prems</span> <span class="entity">iparams</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="entity">i</span><span class="main">)</span><span class="main">)</span> <span class="inner_numeral">1</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">recursor_tac</span> <span class="entity">kind</span> <span class="main">=</span> <span class="entity">std_recursor_tac</span> <span class="entity">rec_info</span> <span class="entity">used_tfrees</span>
      <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">info</span> <span class="main">=&gt;</span> nth <span class="main">(</span><span class="main">#</span>partial_comp_thms <span class="entity">info</span><span class="main">)</span> <span class="entity">kind</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">instantiate_IHs</span> <span class="entity">IHs</span> <span class="entity">pre_conds</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">IH</span> <span class="main">=&gt;</span>
      <span class="entity">OF_option</span> <span class="entity">IH</span> <span class="main">(</span>replicate <span class="main">(</span>Thm.nprems_of <span class="entity">IH</span> - length <span class="entity">pre_conds</span><span class="main">)</span> NONE @ map SOME <span class="entity">pre_conds</span><span class="main">)</span><span class="main">)</span> <span class="entity">IHs</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_v_i</span> <span class="entity">vs</span> <span class="entity">k</span> <span class="main">=</span> nth <span class="entity">vs</span> <span class="entity">k</span> |&gt; snd |&gt; SOME

    <span class="comment1">(* partial eq-theorem *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">debug_out</span> <span class="inner_quoted">"Partial equality"</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq_thms'</span> <span class="main">=</span> <span class="entity">mk_eq_sym_trans_thm'</span> <span class="entity">mk_peq_comp</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">eq_solve_tac</span> <span class="entity">i</span> <span class="entity">ctxt</span> <span class="entity">IH_prems</span> <span class="entity">xs</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span> <span class="entity">j</span><span class="main">)</span> <span class="main">=</span> <span class="entity">ind_case_to_idxs</span> <span class="entity">cTys</span> <span class="entity">i</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">k</span> <span class="main">=</span> length <span class="entity">IH_prems</span> - length <span class="entity">arg_comps</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pre_conds</span> <span class="main">=</span> drop <span class="entity">k</span> <span class="entity">IH_prems</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">IH</span> <span class="main">=</span> take <span class="entity">k</span> <span class="entity">IH_prems</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">comp_simps</span> <span class="main">=</span> nth <span class="entity">comp_simps</span> <span class="entity">i</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">case_thm</span> <span class="main">=</span> nth <span class="entity">case_thms</span> <span class="entity">i</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">distinct_thms</span> <span class="main">=</span> nth <span class="entity">distinct_thms</span> <span class="entity">i</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inject_thms</span> <span class="main">=</span> nth <span class="entity">inject_thms</span> <span class="entity">i</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">set_thms</span> <span class="main">=</span> nth <span class="entity">set_simps</span> <span class="entity">i</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="comment1">(* after induction *)</span>
        resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> peq_compI<span class="antiquote">}</span></span></span> <span class="inner_numeral">1</span>
        THEN <span class="entity">Subgoal.FOCUS</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">focus</span> <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">y</span> <span class="main">=</span> <span class="main">#</span>params <span class="entity">focus</span> |&gt; hd
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">yt</span> <span class="main">=</span> <span class="entity">y</span> |&gt; snd |&gt; Thm.term_of
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="main">#</span>context <span class="entity">focus</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pre_cond</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">pre_cond</span> <span class="main">=&gt;</span> Local_Defs.unfold <span class="entity">ctxt</span> <span class="entity">set_thms</span> <span class="entity">pre_cond</span><span class="main">)</span> <span class="entity">pre_conds</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">IH</span> <span class="main">=</span> <span class="entity">instantiate_IHs</span> <span class="entity">IH</span> <span class="entity">pre_cond</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">xs_tys</span> <span class="main">=</span> map <span class="main">(</span>fastype_of o Thm.term_of o snd<span class="main">)</span> <span class="entity">xs</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">IHs</span> <span class="main">=</span> <span class="entity">split_IHs</span> <span class="entity">xs_tys</span> <span class="entity">IH</span>

            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">sub_case_tac</span> <span class="entity">j'</span> <span class="main">(</span><span class="entity">ctxt</span><span class="main">,</span> <span class="entity">y_simp</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span>
              <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">j</span> <span class="main">=</span> <span class="entity">j'</span> <span class="keyword2"><span class="keyword">then</span></span>
                <span class="entity">unfold_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">y_simp</span> @ <span class="entity">comp_simps</span><span class="main">)</span>
                THEN <span class="entity">unfold_tac</span> <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> comp_lex_eq<span class="antiquote">}</span></span></span>
                THEN <span class="entity">unfold_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> in_set_simps<span class="antiquote">}</span></span></span> @ <span class="entity">inject_thms</span> @ <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> refl_True<span class="antiquote">}</span></span></span><span class="main">)</span>
                THEN <span class="entity">conjI_tac</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> conj_weak_cong<span class="antiquote">}</span></span></span> <span class="entity">ctxt</span> <span class="entity">xs</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt'</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">k</span> <span class="main">=&gt;</span>
                  resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> peq_compD<span class="antiquote">}</span></span></span> <span class="inner_numeral">1</span>
                  THEN <span class="entity">recursor_tac</span> <span class="entity">EQ</span> <span class="entity">pre_cond</span> <span class="main">(</span>nth <span class="entity">xs_tys</span> <span class="entity">k</span><span class="main">)</span> <span class="main">(</span>nth <span class="entity">IHs</span> <span class="entity">k</span><span class="main">)</span> <span class="entity">ctxt'</span><span class="main">)</span>
              <span class="keyword2"><span class="keyword">else</span></span>
                <span class="comment1">(* different constructors *)</span>
                <span class="entity">unfold_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">y_simp</span> @ <span class="entity">distinct_thms</span> @ <span class="entity">comp_simps</span> @ <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> order.simps<span class="antiquote">}</span></span></span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="entity">mk_case_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">[</span>SOME <span class="entity">yt</span><span class="main">]</span><span class="main">]</span> <span class="entity">case_thm</span> <span class="entity">sub_case_tac</span>
          <span class="keyword2"><span class="keyword">end</span></span>
        <span class="main">)</span> <span class="entity">ctxt</span> <span class="inner_numeral">1</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq_thms'</span> <span class="main">=</span> <span class="entity">prove_multi_future</span> <span class="entity">lthy</span> <span class="entity">free_names</span> <span class="main">[</span><span class="main">]</span> <span class="entity">eq_thms'</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
      <span class="entity">induct_tac</span> <span class="entity">ctxt</span> <span class="entity">eq_solve_tac</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">debug_out</span> <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="entity"><span class="antiquote">@{</span><span class="operator">make_string</span><span class="antiquote">}</span></span></span></span> <span class="entity">eq_thms'</span><span class="main">)</span>

    <span class="comment1">(* partial symmetry-theorem *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">debug_out</span> <span class="inner_quoted">"Partial symmetry"</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sym_thms'</span> <span class="main">=</span> <span class="entity">mk_eq_sym_trans_thm'</span> <span class="entity">mk_psym_comp</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">sym_solve_tac</span> <span class="entity">i</span> <span class="entity">ctxt</span> <span class="entity">IH_prems</span> <span class="entity">xs</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span> <span class="entity">j</span><span class="main">)</span> <span class="main">=</span> <span class="entity">ind_case_to_idxs</span> <span class="entity">cTys</span> <span class="entity">i</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">k</span> <span class="main">=</span> length <span class="entity">IH_prems</span> - length <span class="entity">arg_comps</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pre_conds</span> <span class="main">=</span> drop <span class="entity">k</span> <span class="entity">IH_prems</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">IH</span> <span class="main">=</span> take <span class="entity">k</span> <span class="entity">IH_prems</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">comp_simps</span> <span class="main">=</span> nth <span class="entity">comp_simps</span> <span class="entity">i</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">case_thm</span> <span class="main">=</span> nth <span class="entity">case_thms</span> <span class="entity">i</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">set_thms</span> <span class="main">=</span> nth <span class="entity">set_simps</span> <span class="entity">i</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="comment1">(* after induction *)</span>
        resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> psym_compI<span class="antiquote">}</span></span></span> <span class="inner_numeral">1</span>
        THEN <span class="entity">Subgoal.FOCUS</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">focus</span> <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">y</span> <span class="main">=</span> <span class="main">#</span>params <span class="entity">focus</span> |&gt; hd
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">yt</span> <span class="main">=</span> <span class="entity">y</span> |&gt; snd |&gt; Thm.term_of
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="main">#</span>context <span class="entity">focus</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pre_cond</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">pre_cond</span> <span class="main">=&gt;</span> Local_Defs.unfold <span class="entity">ctxt</span> <span class="entity">set_thms</span> <span class="entity">pre_cond</span><span class="main">)</span> <span class="entity">pre_conds</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">IH</span> <span class="main">=</span> <span class="entity">instantiate_IHs</span> <span class="entity">IH</span> <span class="entity">pre_cond</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">xs_tys</span> <span class="main">=</span> map <span class="main">(</span>fastype_of o Thm.term_of o snd<span class="main">)</span> <span class="entity">xs</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">IHs</span> <span class="main">=</span> <span class="entity">split_IHs</span> <span class="entity">xs_tys</span> <span class="entity">IH</span>

            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">sub_case_tac</span> <span class="entity">j'</span> <span class="main">(</span><span class="entity">ctxt</span><span class="main">,</span> <span class="entity">y_simp</span><span class="main">,</span> <span class="entity">ys</span><span class="main">)</span> <span class="main">=</span>
              <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">j</span> <span class="main">=</span> <span class="entity">j'</span> <span class="keyword2"><span class="keyword">then</span></span>
                <span class="entity">unfold_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">y_simp</span> @ <span class="entity">comp_simps</span><span class="main">)</span>
                THEN resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> comp_lex_sym<span class="antiquote">}</span></span></span> <span class="inner_numeral">1</span>
                THEN <span class="entity">unfold_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> length_nth_simps forall_finite<span class="antiquote">}</span></span></span><span class="main">)</span>
                THEN <span class="entity">conjI_tac</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> conjI<span class="antiquote">}</span></span></span> <span class="entity">ctxt</span> <span class="entity">xs</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt'</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">k</span> <span class="main">=&gt;</span>
                  resolve_tac <span class="entity">ctxt'</span> <span class="main">[</span>infer_instantiate' <span class="entity">ctxt'</span>
                    <span class="main">[</span>NONE<span class="main">,</span> <span class="entity">get_v_i</span> <span class="entity">xs</span> <span class="entity">k</span><span class="main">,</span> <span class="entity">get_v_i</span> <span class="entity">ys</span> <span class="entity">k</span><span class="main">]</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> psym_compD<span class="antiquote">}</span></span></span><span class="main">]</span> <span class="inner_numeral">1</span>
                  THEN <span class="entity">recursor_tac</span> <span class="entity">SYM</span> <span class="entity">pre_cond</span> <span class="main">(</span>nth <span class="entity">xs_tys</span> <span class="entity">k</span><span class="main">)</span> <span class="main">(</span>nth <span class="entity">IHs</span> <span class="entity">k</span><span class="main">)</span> <span class="entity">ctxt'</span><span class="main">)</span>
              <span class="keyword2"><span class="keyword">else</span></span>
                <span class="comment1">(* different constructors *)</span>
                <span class="entity">unfold_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">y_simp</span> @ <span class="entity">comp_simps</span> @ <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> invert_order.simps<span class="antiquote">}</span></span></span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="entity">mk_case_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">[</span>SOME <span class="entity">yt</span><span class="main">]</span><span class="main">]</span> <span class="entity">case_thm</span> <span class="entity">sub_case_tac</span>
          <span class="keyword2"><span class="keyword">end</span></span>
        <span class="main">)</span> <span class="entity">ctxt</span> <span class="inner_numeral">1</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sym_thms'</span> <span class="main">=</span> <span class="entity">prove_multi_future</span> <span class="entity">lthy</span> <span class="entity">free_names</span> <span class="main">[</span><span class="main">]</span> <span class="entity">sym_thms'</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
      <span class="entity">induct_tac</span> <span class="entity">ctxt</span> <span class="entity">sym_solve_tac</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">debug_out</span> <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="entity"><span class="antiquote">@{</span><span class="operator">make_string</span><span class="antiquote">}</span></span></span></span> <span class="entity">sym_thms'</span><span class="main">)</span>

    <span class="comment1">(* partial transitivity-theorem *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">debug_out</span> <span class="inner_quoted">"Partial transitivity"</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">trans_thms'</span> <span class="main">=</span> <span class="entity">mk_eq_sym_trans_thm'</span> <span class="entity">mk_ptrans_comp</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">trans_solve_tac</span> <span class="entity">i</span> <span class="entity">ctxt</span> <span class="entity">IH_prems</span> <span class="entity">xs</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span> <span class="entity">j</span><span class="main">)</span> <span class="main">=</span> <span class="entity">ind_case_to_idxs</span> <span class="entity">cTys</span> <span class="entity">i</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">k</span> <span class="main">=</span> length <span class="entity">IH_prems</span> - length <span class="entity">arg_comps</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pre_conds</span> <span class="main">=</span> drop <span class="entity">k</span> <span class="entity">IH_prems</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">IH</span> <span class="main">=</span> take <span class="entity">k</span> <span class="entity">IH_prems</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">comp_simps</span> <span class="main">=</span> nth <span class="entity">comp_simps</span> <span class="entity">i</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">case_thm</span> <span class="main">=</span> nth <span class="entity">case_thms</span> <span class="entity">i</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">set_thms</span> <span class="main">=</span> nth <span class="entity">set_simps</span> <span class="entity">i</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="comment1">(* after induction *)</span>
        resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> ptrans_compI<span class="antiquote">}</span></span></span> <span class="inner_numeral">1</span>
        THEN <span class="entity">Subgoal.FOCUS</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">focus</span> <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">y</span> <span class="main">=</span> nth <span class="main">(</span><span class="main">#</span>params <span class="entity">focus</span><span class="main">)</span> <span class="inner_numeral">0</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">z</span> <span class="main">=</span> nth <span class="main">(</span><span class="main">#</span>params <span class="entity">focus</span><span class="main">)</span> <span class="inner_numeral">1</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">yt</span> <span class="main">=</span> <span class="entity">y</span> |&gt; snd |&gt; Thm.term_of
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">zt</span> <span class="main">=</span> <span class="entity">z</span> |&gt; snd |&gt; Thm.term_of
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="main">#</span>context <span class="entity">focus</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pre_cond</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">pre_cond</span> <span class="main">=&gt;</span> Local_Defs.unfold <span class="entity">ctxt</span> <span class="entity">set_thms</span> <span class="entity">pre_cond</span><span class="main">)</span> <span class="entity">pre_conds</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">IH</span> <span class="main">=</span> <span class="entity">instantiate_IHs</span> <span class="entity">IH</span> <span class="entity">pre_cond</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">xs_tys</span> <span class="main">=</span> map <span class="main">(</span>fastype_of o Thm.term_of o snd<span class="main">)</span> <span class="entity">xs</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">IHs</span> <span class="main">=</span> <span class="entity">split_IHs</span> <span class="entity">xs_tys</span> <span class="entity">IH</span>

            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">sub_case_tac</span> <span class="entity">j'</span> <span class="main">(</span><span class="entity">ctxt</span><span class="main">,</span> <span class="entity">y_simp</span><span class="main">,</span> <span class="entity">ys</span><span class="main">)</span> <span class="main">=</span>
              <span class="keyword2"><span class="keyword">let</span></span>
                <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">sub_case_tac'</span> <span class="entity">j''</span> <span class="main">(</span><span class="entity">ctxt</span><span class="main">,</span> <span class="entity">z_simp</span><span class="main">,</span> <span class="entity">zs</span><span class="main">)</span> <span class="main">=</span>
                      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">j</span> <span class="main">=</span> <span class="entity">j'</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">j</span> <span class="main">=</span> <span class="entity">j''</span> <span class="keyword2"><span class="keyword">then</span></span>
                        <span class="entity">unfold_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">y_simp</span> @ <span class="entity">z_simp</span> @ <span class="entity">comp_simps</span><span class="main">)</span>
                        THEN resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> comp_lex_trans<span class="antiquote">}</span></span></span> <span class="inner_numeral">1</span>
                        THEN <span class="entity">unfold_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> length_nth_simps forall_finite<span class="antiquote">}</span></span></span><span class="main">)</span>
                        THEN <span class="entity">conjI_tac</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> conjI<span class="antiquote">}</span></span></span> <span class="entity">ctxt</span> <span class="entity">xs</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt'</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">k</span> <span class="main">=&gt;</span>
                          resolve_tac <span class="entity">ctxt'</span> <span class="main">[</span>infer_instantiate' <span class="entity">ctxt'</span>
                            <span class="main">[</span>NONE<span class="main">,</span> <span class="entity">get_v_i</span> <span class="entity">xs</span> <span class="entity">k</span><span class="main">,</span> <span class="entity">get_v_i</span> <span class="entity">ys</span> <span class="entity">k</span><span class="main">,</span> <span class="entity">get_v_i</span> <span class="entity">zs</span> <span class="entity">k</span><span class="main">]</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> ptrans_compD<span class="antiquote">}</span></span></span><span class="main">]</span> <span class="inner_numeral">1</span>
                          THEN <span class="entity">recursor_tac</span> <span class="entity">TRANS</span> <span class="entity">pre_cond</span> <span class="main">(</span>nth <span class="entity">xs_tys</span> <span class="entity">k</span><span class="main">)</span> <span class="main">(</span>nth <span class="entity">IHs</span> <span class="entity">k</span><span class="main">)</span> <span class="entity">ctxt'</span><span class="main">)</span>
                      <span class="keyword2"><span class="keyword">else</span></span>
                        <span class="comment1">(* different constructors *)</span>
                        <span class="entity">unfold_tac</span> <span class="entity">ctxt</span>
                          <span class="main">(</span><span class="entity">y_simp</span> @ <span class="entity">z_simp</span> @ <span class="entity">comp_simps</span> @ <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> trans_order_different<span class="antiquote">}</span></span></span><span class="main">)</span>
              <span class="keyword2"><span class="keyword">in</span></span>
                <span class="entity">mk_case_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">[</span>SOME <span class="entity">zt</span><span class="main">]</span><span class="main">]</span> <span class="entity">case_thm</span> <span class="entity">sub_case_tac'</span>
              <span class="keyword2"><span class="keyword">end</span></span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="entity">mk_case_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">[</span>SOME <span class="entity">yt</span><span class="main">]</span><span class="main">]</span> <span class="entity">case_thm</span> <span class="entity">sub_case_tac</span>
          <span class="keyword2"><span class="keyword">end</span></span>
        <span class="main">)</span> <span class="entity">ctxt</span> <span class="inner_numeral">1</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">trans_thms'</span> <span class="main">=</span> <span class="entity">prove_multi_future</span> <span class="entity">lthy</span> <span class="entity">free_names</span> <span class="main">[</span><span class="main">]</span> <span class="entity">trans_thms'</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
      <span class="entity">induct_tac</span> <span class="entity">ctxt</span> <span class="entity">trans_solve_tac</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">debug_out</span> <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="entity"><span class="antiquote">@{</span><span class="operator">make_string</span><span class="antiquote">}</span></span></span></span> <span class="entity">trans_thms'</span><span class="main">)</span>

    <span class="comment1">(* total theorems *)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_eq_sym_trans_thm</span> <span class="entity">mk_eq_sym_trans</span> <span class="entity">compI2</span> <span class="entity">compE2</span> <span class="entity">thms'</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">conds</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">c</span> <span class="main">=&gt;</span> <span class="entity">mk_eq_sym_trans</span> <span class="entity">lthy</span> <span class="entity">c</span> |&gt; <span class="entity">HOLogic.mk_Trueprop</span><span class="main">)</span> <span class="entity">arg_comps</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thms</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">i</span> <span class="main">=&gt;</span>
           <span class="entity">mk_eq_sym_trans</span> <span class="entity">lthy</span> <span class="main">(</span>nth <span class="entity">full_comps</span> <span class="entity">i</span><span class="main">)</span>
           |&gt; <span class="entity">HOLogic.mk_Trueprop</span>
           |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">concl</span> <span class="main">=&gt;</span> Logic.list_implies <span class="main">(</span><span class="entity">conds</span><span class="main">,</span><span class="entity">concl</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
           <span class="entity">t_ixs</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thms</span> <span class="main">=</span> <span class="entity">prove_multi_future</span> <span class="entity">lthy</span> <span class="entity">free_names</span> <span class="main">[</span><span class="main">]</span> <span class="entity">thms</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
          ALLGOALS Goal.conjunction_tac
          THEN <span class="entity">Method.intros_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> conjI<span class="antiquote">}</span></span></span> :: <span class="entity">compI2</span> :: <span class="entity">thms'</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span>
          THEN ALLGOALS <span class="main">(</span>eresolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">compE2</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">thms</span> <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq_thms</span> <span class="main">=</span> <span class="entity">mk_eq_sym_trans_thm</span> <span class="entity">mk_eq_comp</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> eq_compI2<span class="antiquote">}</span></span></span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> eq_compD2<span class="antiquote">}</span></span></span> <span class="entity">eq_thms'</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sym_thms</span> <span class="main">=</span> <span class="entity">mk_eq_sym_trans_thm</span> <span class="entity">mk_sym_comp</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> sym_compI2<span class="antiquote">}</span></span></span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> sym_compD2<span class="antiquote">}</span></span></span> <span class="entity">sym_thms'</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">trans_thms</span> <span class="main">=</span> <span class="entity">mk_eq_sym_trans_thm</span> <span class="entity">mk_trans_comp</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> trans_compI2<span class="antiquote">}</span></span></span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> trans_compD2<span class="antiquote">}</span></span></span>
      <span class="entity">trans_thms'</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">debug_out</span> <span class="inner_quoted">"full comparator thms"</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_comp_thm</span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span> <span class="main">(</span><span class="main">(</span><span class="entity">e</span><span class="main">,</span> <span class="entity">s</span><span class="main">)</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">conds</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">c</span> <span class="main">=&gt;</span> <span class="entity">mk_comp</span> <span class="entity">lthy</span> <span class="entity">c</span> |&gt; <span class="entity">HOLogic.mk_Trueprop</span><span class="main">)</span> <span class="entity">arg_comps</span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">from_comp</span> <span class="entity">thm</span> <span class="entity">i</span> <span class="main">=</span> <span class="entity">thm</span> OF replicate <span class="main">(</span>Thm.prems_of <span class="entity">thm</span> |&gt; length<span class="main">)</span>
          <span class="main">(</span>nth <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> comparator_imp_eq_sym_trans<span class="antiquote">}</span></span></span> <span class="entity">i</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">nearly_thm</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> eq_sym_trans_imp_comparator<span class="antiquote">}</span></span></span> OF
          <span class="main">[</span><span class="entity">from_comp</span> <span class="entity">e</span> <span class="entity">EQ</span><span class="main">,</span> <span class="entity">from_comp</span> <span class="entity">s</span> <span class="entity">SYM</span><span class="main">,</span> <span class="entity">from_comp</span> <span class="entity">t</span> <span class="entity">TRANS</span><span class="main">]</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm</span> <span class="main">=</span>
           <span class="entity">mk_comp</span> <span class="entity">lthy</span> <span class="main">(</span>nth <span class="entity">full_comps</span> <span class="entity">i</span><span class="main">)</span>
           |&gt; <span class="entity">HOLogic.mk_Trueprop</span>
           |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">concl</span> <span class="main">=&gt;</span> Logic.list_implies <span class="main">(</span><span class="entity">conds</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        Goal.prove_future <span class="entity">lthy</span> <span class="entity">free_names</span> <span class="main">[</span><span class="main">]</span> <span class="entity">thm</span>
          <span class="main">(</span>K <span class="main">(</span>resolve_tac <span class="entity">lthy</span> <span class="main">[</span><span class="entity">nearly_thm</span><span class="main">]</span> <span class="inner_numeral">1</span> THEN ALLGOALS <span class="main">(</span>assume_tac <span class="entity">lthy</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">comp_thms</span> <span class="main">=</span> map_index <span class="entity">mk_comp_thm</span> <span class="main">(</span><span class="entity">eq_thms</span> ~~ <span class="entity">sym_thms</span> ~~ <span class="entity">trans_thms</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span> fold_map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">thm</span><span class="main">,</span> <span class="entity">cname</span><span class="main">)</span> <span class="main">=&gt;</span>
      Local_Theory.note <span class="main">(</span><span class="main">(</span>Binding.name <span class="entity">cname</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="entity">thm</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="entity">comp_thms</span> ~~ <span class="entity">compNs</span><span class="main">)</span> <span class="entity">lthy</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">debug_out</span> <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="entity"><span class="antiquote">@{</span><span class="operator">make_string</span><span class="antiquote">}</span></span></span></span> <span class="entity">comp_thms</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pcomp_thms</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">e</span><span class="main">,</span> <span class="entity">s</span><span class="main">)</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="entity">e</span><span class="main">,</span> <span class="entity">s</span><span class="main">,</span> <span class="entity">t</span><span class="main">]</span><span class="main">)</span> <span class="main">(</span><span class="entity">eq_thms'</span> ~~ <span class="entity">sym_thms'</span> ~~ <span class="entity">trans_thms'</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span> fold_map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">thms</span><span class="main">,</span> <span class="entity">cname</span><span class="main">)</span> <span class="main">=&gt;</span>
      Local_Theory.note <span class="main">(</span><span class="main">(</span>Binding.name <span class="main">(</span><span class="entity">cname</span> ^ <span class="inner_quoted">"_pointwise"</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">thms</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="entity">pcomp_thms</span> ~~ <span class="entity">compNs</span><span class="main">)</span> <span class="entity">lthy</span>

  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="main">(</span><span class="entity">pcomps</span> ~~ <span class="entity">pcomp_simps</span><span class="main">,</span> <span class="entity">comps</span> ~~ <span class="entity">comp_defs</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span>
    ||&gt; fold <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">tyco</span><span class="main">,</span> <span class="entity">map</span><span class="main">)</span><span class="main">,</span> <span class="entity">pcomp</span><span class="main">)</span><span class="main">,</span> <span class="entity">comp</span><span class="main">)</span><span class="main">,</span> <span class="entity">comp_def</span><span class="main">)</span><span class="main">,</span> <span class="entity">map_comp</span><span class="main">)</span><span class="main">,</span> <span class="entity">pcomp_thms</span><span class="main">)</span><span class="main">,</span> <span class="entity">comp_thm</span><span class="main">)</span> <span class="main">=&gt;</span>
          <span class="entity">declare_info</span> <span class="entity">tyco</span> <span class="entity">map</span> <span class="entity">pcomp</span> <span class="entity">comp</span> <span class="main">(</span>SOME <span class="entity">comp_def</span><span class="main">)</span> <span class="main">(</span>SOME <span class="entity">map_comp</span><span class="main">)</span>
            <span class="entity">pcomp_thms</span> <span class="entity">comp_thm</span> <span class="entity">used_positions</span><span class="main">)</span>
         <span class="main">(</span><span class="entity">tycos</span> ~~ <span class="entity">maps</span> ~~ <span class="entity">pcomps</span> ~~ <span class="entity">comps</span> ~~ <span class="entity">comp_defs</span> ~~ <span class="entity">map_comp_thms</span> ~~ <span class="entity">pcomp_thms</span> ~~ <span class="entity">comp_thms</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">generate_comparator</span> <span class="entity">gen_type</span> <span class="entity">tyco</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> is_some <span class="main">(</span><span class="entity">get_info</span> <span class="entity">lthy</span> <span class="entity">tyco</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">andalso</span></span> error <span class="main">(</span><span class="inner_quoted">"type "</span> ^ quote <span class="entity">tyco</span> ^ <span class="inner_quoted">" does already have a comparator"</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">gen_type</span> <span class="keyword2"><span class="keyword">of</span></span>
      <span class="entity">BNF</span> <span class="main">=&gt;</span> <span class="entity">generate_comparators_from_bnf_fp</span> <span class="entity">tyco</span> <span class="entity">lthy</span> |&gt; snd
    <span class="main">|</span> <span class="entity">Linorder</span> <span class="main">=&gt;</span> <span class="entity">register_comparator_of</span> <span class="entity">tyco</span> <span class="entity">lthy</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ensure_info</span> <span class="entity">gen_type</span> <span class="entity">tyco</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">get_info</span> <span class="entity">lthy</span> <span class="entity">tyco</span> <span class="keyword2"><span class="keyword">of</span></span>
    SOME <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">lthy</span>
  <span class="main">|</span> NONE <span class="main">=&gt;</span> <span class="entity">generate_comparator</span> <span class="entity">gen_type</span> <span class="entity">tyco</span> <span class="entity">lthy</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">generate_comparator_cmd</span> <span class="entity">tyco</span> <span class="entity">param</span> <span class="main">=</span> <span class="entity">Named_Target.theory_map</span> <span class="main">(</span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">param</span> <span class="main">=</span> <span class="inner_quoted">"linorder"</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">generate_comparator</span> <span class="entity">Linorder</span> <span class="entity">tyco</span>
  <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">param</span> <span class="main">=</span> <span class="inner_quoted">""</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">generate_comparator</span> <span class="entity">BNF</span> <span class="entity">tyco</span>
  <span class="keyword2"><span class="keyword">else</span></span> error <span class="main">(</span><span class="inner_quoted">"unknown parameter, expecting no parameter for BNF-datatypes, "</span> ^
         <span class="inner_quoted">"or \"linorder\" for types which are already in linorder"</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  Theory.setup
    <span class="main">(</span><span class="entity">Derive_Manager.register_derive</span>
      <span class="inner_quoted">"comparator"</span>
      <span class="inner_quoted">"generate comparators for given types, options: (linorder) or ()"</span>
      <span class="entity">generate_comparator_cmd</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Compare_Generator">
<div class="head">
<h1>Theory Compare_Generator</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Deriving class instances for datatypes
    Author:      Christian Sternagel and René Thiemann  &lt;christian.sternagel|rene.thiemann@uibk.ac.at&gt;
    Maintainer:  Christian Sternagel and René Thiemann 
    License:     LGPL
*)</span>
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Compare Generator›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Compare_Generator
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="Comparator_Generator.html">Comparator_Generator</a>
  <a href="Compare.html">Compare</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We provide a generator which takes the comparators of the comparator generator
  to synthesize suitable <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> compare<span class="antiquote"><span class="antiquote">}</span></span></span></span>-functions from the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> compare<span class="antiquote"><span class="antiquote">}</span></span></span></span>-class.

One can further also use these comparison functions to derive an instance of the
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> compare_order<span class="antiquote"><span class="antiquote">}</span></span></span></span>-class, and therefore also for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> linorder<span class="antiquote"><span class="antiquote">}</span></span></span></span>. In total, we provide the three
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>derive›</span></span></span></span>-methods where the example type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> prod<span class="antiquote"><span class="antiquote">}</span></span></span></span> can be replaced by any other datatype.

\begin{itemize}
\item <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>derive compare prod›</span></span></span></span> creates an instance <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> prod<span class="antiquote"><span class="antiquote">}</span></span></span></span> :: (<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> compare<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> compare<span class="antiquote"><span class="antiquote">}</span></span></span></span>) <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> compare<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
\item <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>derive compare_order prod›</span></span></span></span> creates an instance <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> prod<span class="antiquote"><span class="antiquote">}</span></span></span></span> :: (<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> compare<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> compare<span class="antiquote"><span class="antiquote">}</span></span></span></span>) <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> compare_order<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
\item <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>derive linorder prod›</span></span></span></span> creates an instance <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> prod<span class="antiquote"><span class="antiquote">}</span></span></span></span> :: (<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> linorder<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> linorder<span class="antiquote"><span class="antiquote">}</span></span></span></span>) <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> linorder<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
\end{itemize}

Usually, the use of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>derive linorder›</span></span></span></span> is not recommended if there are comparators available:
Internally, the linear orders will directly be converted into comparators, so a direct use of the
comparators will result in more efficient generated code. This command is mainly provided as a convenience method
where comparators are not yet present. For example, at the time of writing, the Container Framework
has partly been adapted to internally use comparators, whereas in other AFP-entries, we did not
integrate comparators.
›</span></span>

<span class="keyword1" id="Compare_Generator-linorder_axiomsD"><span class="command">lemma</span></span> linorder_axiomsD<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"class.linorder <span class="free">le</span> <span class="free">lt</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">lt</span> <span class="free">x</span> <span class="free">y</span> <span class="main">=</span> <span class="main">(</span><span class="free">le</span> <span class="free">x</span> <span class="free">y</span> <span class="main">∧</span> <span class="main">¬</span> <span class="free">le</span> <span class="free">y</span> <span class="free">x</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?a</span></span></span><span class="main">)</span>
  <span class="quoted"><span class="quoted">"<span class="free">le</span> <span class="free">x</span> <span class="free">x</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?b</span></span></span><span class="main">)</span>
  <span class="quoted"><span class="quoted">"<span class="free">le</span> <span class="free">x</span> <span class="free">y</span> <span class="main">⟹</span> <span class="free">le</span> <span class="free">y</span> <span class="free">z</span> <span class="main">⟹</span> <span class="free">le</span> <span class="free">x</span> <span class="free">z</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?c1</span> <span class="main">⟹</span> <span class="var">?c2</span> <span class="main">⟹</span> <span class="var">?c3</span>"</span></span><span class="main">)</span> 
  <span class="quoted"><span class="quoted">"<span class="free">le</span> <span class="free">x</span> <span class="free">y</span> <span class="main">⟹</span> <span class="free">le</span> <span class="free">y</span> <span class="free">x</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?d1</span> <span class="main">⟹</span> <span class="var">?d2</span> <span class="main">⟹</span> <span class="var">?d3</span>"</span></span><span class="main">)</span>
  <span class="quoted"><span class="quoted">"<span class="free">le</span> <span class="free">x</span> <span class="free">y</span> <span class="main">∨</span> <span class="free">le</span> <span class="free">y</span> <span class="free">x</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?e</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> linorder <span class="quoted"><span class="free">le</span></span> <span class="quoted"><span class="free">lt</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?a</span></span></span> <span class="var"><span class="quoted"><span class="var">?b</span></span></span> <span class="quoted"><span class="quoted">"<span class="var">?c1</span> <span class="main">⟹</span> <span class="var">?c2</span> <span class="main">⟹</span> <span class="var">?c3</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="var">?d1</span> <span class="main">⟹</span> <span class="var">?d2</span> <span class="main">⟹</span> <span class="var">?d3</span>"</span></span> <span class="var"><span class="quoted"><span class="var">?e</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>
 
<span class="keyword1"><span class="command">named_theorems</span></span> compare_simps <span class="quoted">"simp theorems to derive \"compare = comparator_of\""</span>

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹compare_generator.ML›</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/compare_generator.ML">
<div class="head">
<h1>File ‹compare_generator.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Deriving class instances for datatypes
    Author:      Christian Sternagel and René Thiemann  &lt;christian.sternagel|rene.thiemann@uibk.ac.at&gt;
    Maintainer:  Christian Sternagel and René Thiemann 
    License:     LGPL
*)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">COMPARE_GENERATOR</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
<span class="comment1">(* derives a compare-instance for a given class. depending on the comparator_type, this will
   just be comparator_of (via linorder), or it will be a comparator constructed for BNF datatypes *)</span>
<span class="keyword1"><span class="keyword">val</span></span> compare_instance <span class="main">:</span> <span class="entity">Comparator_Generator.comparator_type</span> <span class="main">-&gt;</span> string <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory

<span class="comment1">(* derives an instance for class compare_order via linorder, 
   where the main comparator will be comparator_of *)</span>
<span class="keyword1"><span class="keyword">val</span></span> compare_order_instance_via_comparator_of <span class="main">:</span> string <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory

<span class="comment1">(* derives an instance for class compare_order via compare, where 
   the orders are defined via le_of_comp and lt_of_comp *)</span>
<span class="keyword1"><span class="keyword">val</span></span> compare_order_instance_via_compare <span class="main">:</span> string <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Compare_Generator</span> <span class="main">:</span> <span class="entity">COMPARE_GENERATOR</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword3"><span class="keyword">open</span></span> Generator_Aux

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cmpS</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">compare</span><span class="antiquote">}</span></span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cmpoS</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">compare_order</span><span class="antiquote">}</span></span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cmpN</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> compare<span class="antiquote">}</span></span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lessN</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> less<span class="antiquote">}</span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">less_eqN</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> less_eq<span class="antiquote">}</span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">linordS</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">linorder</span><span class="antiquote">}</span></span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">cmpT</span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">T</span> --&gt; <span class="entity">T</span> --&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">order</span><span class="antiquote">}</span></span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ordT</span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">T</span> --&gt; <span class="entity">T</span> --&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">bool</span><span class="antiquote">}</span></span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">cmp_const</span> <span class="entity">T</span> <span class="main">=</span> Const <span class="main">(</span><span class="entity">cmpN</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">cmp_of_const</span> <span class="entity">T</span> <span class="main">=</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> comparator_of<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">;</span>


<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_comp</span> <span class="entity">ctxt</span> <span class="entity">tname</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">Comparator_Generator.get_info</span> <span class="entity">ctxt</span> <span class="entity">tname</span> <span class="keyword2"><span class="keyword">of</span></span>
    SOME <span class="main">{</span>comp <span class="main">=</span> <span class="entity">c</span><span class="main">,</span> comp_thm <span class="main">=</span> <span class="entity">c_thm</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Ts</span> <span class="main">=</span> fastype_of <span class="entity">c</span> |&gt; strip_type |&gt; fst |&gt; `<span class="main">(</span><span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span> <span class="entity">x</span> - <span class="inner_numeral">2</span><span class="main">)</span> o length<span class="main">)</span> |&gt; uncurry take
      <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">c_thm</span><span class="main">,</span> <span class="entity">Ts</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>
  <span class="main">|</span> NONE <span class="main">=&gt;</span> error <span class="main">(</span><span class="inner_quoted">"no order info for type "</span> ^ quote <span class="entity">tname</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">all_tys</span> <span class="entity">comp</span> <span class="entity">free_types</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Ts</span> <span class="main">=</span> fastype_of <span class="entity">comp</span> |&gt; strip_type |&gt; fst |&gt; <span class="entity">drop_last</span> |&gt; List.last |&gt; dest_Type |&gt; snd
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">rename_types</span> <span class="main">(</span><span class="entity">Ts</span> ~~ <span class="entity">free_types</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_cmp_rhs</span> <span class="entity">c</span> <span class="entity">Ts</span> <span class="main">=</span>
  list_comb <span class="main">(</span><span class="entity">c</span><span class="main">,</span> map <span class="entity">cmp_const</span> <span class="entity">Ts</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_cmp_rhs_comparator_of</span> <span class="entity">c</span> <span class="entity">Ts</span> <span class="main">=</span>
  list_comb <span class="main">(</span><span class="entity">c</span><span class="main">,</span> map <span class="entity">cmp_of_const</span> <span class="entity">Ts</span><span class="main">)</span>


<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_cmp_def</span> <span class="entity">T</span> <span class="entity">rhs</span> <span class="main">=</span>
  Logic.mk_equals <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> compare<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">cmpT</span> <span class="entity">T</span><span class="main">)</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_ord_def</span> <span class="entity">T</span> <span class="entity">strict</span> <span class="entity">rhs</span> <span class="main">=</span>
  Logic.mk_equals <span class="main">(</span>
    Const <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">strict</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">lessN</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">less_eqN</span><span class="main">,</span> <span class="entity">ordT</span> <span class="entity">T</span><span class="main">)</span><span class="main">,</span>
    Const <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">strict</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> lt_of_comp<span class="antiquote">}</span></span> <span class="keyword2"><span class="keyword">else</span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> le_of_comp<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">cmpT</span> <span class="entity">T</span> --&gt; <span class="entity">ordT</span> <span class="entity">T</span><span class="main">)</span> $ <span class="entity">rhs</span><span class="main">)</span>
  
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_binop_def</span> <span class="entity">binop</span> <span class="entity">T</span> <span class="entity">rhs</span> <span class="main">=</span>
  Logic.mk_equals <span class="main">(</span>Const <span class="main">(</span><span class="entity">binop</span><span class="main">,</span> <span class="entity">T</span> --&gt; <span class="entity">T</span> --&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">bool</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">comparator_tac</span> <span class="entity">ctxt</span> <span class="entity">tname</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">c_thm</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dest_comp</span> <span class="entity">ctxt</span> <span class="entity">tname</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">c_thm</span><span class="main">]</span> THEN_ALL_NEW resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> comparator_compare<span class="antiquote">}</span></span></span><span class="main">)</span> <span class="inner_numeral">1</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">comparator_tac_comparator_of</span> <span class="entity">ctxt</span> <span class="entity">tname</span> <span class="entity">i</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">c_thm</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dest_comp</span> <span class="entity">ctxt</span> <span class="entity">tname</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">c_thm</span><span class="main">]</span> THEN_ALL_NEW resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> comparator_of<span class="antiquote">}</span></span></span><span class="main">)</span> <span class="entity">i</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">compare_instance</span> <span class="entity">gen_type</span> <span class="entity">tname</span> <span class="entity">thy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">is_class_instance</span> <span class="entity">thy</span> <span class="entity">tname</span> <span class="entity">cmpS</span>
      <span class="keyword1"><span class="keyword">andalso</span></span> error <span class="main">(</span><span class="inner_quoted">"type "</span> ^ quote <span class="entity">tname</span> ^ <span class="inner_quoted">" is already an instance of class \"compare\""</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> writeln <span class="main">(</span><span class="inner_quoted">"deriving \"compare\" instance for type "</span> ^ quote <span class="entity">tname</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> <span class="entity">Named_Target.theory_map</span> <span class="main">(</span><span class="entity">Comparator_Generator.ensure_info</span> <span class="entity">gen_type</span> <span class="entity">tname</span><span class="main">)</span> <span class="entity">thy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span>used_positions <span class="main">=</span> <span class="entity">us</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> the <span class="main">(</span><span class="entity">Comparator_Generator.get_info</span> 
        <span class="main">(</span><span class="entity">Named_Target.theory_init</span> <span class="entity">thy</span><span class="main">)</span> <span class="entity">tname</span><span class="main">)</span> 

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">xs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">typ_and_vs_of_used_typname</span> <span class="entity">tname</span> <span class="entity">us</span> <span class="entity">cmpS</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">cmp_thm</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">Class.instantiation</span> <span class="main">(</span><span class="main">[</span><span class="entity">tname</span><span class="main">]</span><span class="main">,</span> <span class="entity">xs</span><span class="main">,</span> <span class="entity">cmpS</span><span class="main">)</span> <span class="entity">thy</span>
      |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">Ts</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dest_comp</span> <span class="entity">ctxt</span> <span class="entity">tname</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">typ_mapping</span> <span class="main">=</span> <span class="entity">all_tys</span> <span class="entity">c</span> <span class="main">(</span>map TFree <span class="entity">xs</span><span class="main">)</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cmp_def</span> <span class="main">=</span> <span class="entity">mk_cmp_def</span> dummyT <span class="main">(</span><span class="entity">mk_cmp_rhs</span> <span class="entity">c</span> <span class="entity">Ts</span><span class="main">)</span> |&gt; <span class="entity">typ_mapping</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="entity">Generator_Aux.define_overloaded_generic</span>
           <span class="main">(</span><span class="main">(</span>Binding.name <span class="main">(</span><span class="inner_quoted">"compare_"</span> ^ Long_Name.base_name <span class="entity">tname</span> ^ <span class="inner_quoted">"_def"</span><span class="main">)</span><span class="main">,</span>
            <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">attributes</span> <span class="main">[</span><span class="operator">code</span><span class="main">,</span> <span class="operator">compare_simps</span><span class="main">]</span><span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">,</span>
            <span class="entity">cmp_def</span><span class="main">)</span> <span class="entity">ctxt</span>
        <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">Class.prove_instantiation_exit</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span>
      <span class="entity">Class.intro_classes_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span>
      THEN <span class="entity">unfold_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">cmp_thm</span><span class="main">]</span>
      THEN <span class="entity">comparator_tac</span> <span class="entity">ctxt</span> <span class="entity">tname</span><span class="main">)</span> <span class="entity">lthy</span>
  <span class="keyword2"><span class="keyword">end</span></span>
  
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">linorder_instance</span> <span class="entity">gen_type</span> <span class="entity">tname</span> <span class="entity">thy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">is_class_instance</span> <span class="entity">thy</span> <span class="entity">tname</span> <span class="entity">linordS</span>
      <span class="keyword1"><span class="keyword">andalso</span></span> error <span class="main">(</span><span class="inner_quoted">"type "</span> ^ quote <span class="entity">tname</span> ^ <span class="inner_quoted">" is already an instance of class \"linorder\""</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> writeln <span class="main">(</span><span class="inner_quoted">"deriving \"linorder\" instance for type "</span> ^ quote <span class="entity">tname</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> <span class="entity">Named_Target.theory_map</span> <span class="main">(</span><span class="entity">Comparator_Generator.ensure_info</span> <span class="entity">gen_type</span> <span class="entity">tname</span><span class="main">)</span> <span class="entity">thy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span>used_positions <span class="main">=</span> <span class="entity">us</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> the <span class="main">(</span><span class="entity">Comparator_Generator.get_info</span> 
        <span class="main">(</span><span class="entity">Named_Target.theory_init</span> <span class="entity">thy</span><span class="main">)</span> <span class="entity">tname</span><span class="main">)</span> 

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">xs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">typ_and_vs_of_used_typname</span> <span class="entity">tname</span> <span class="entity">us</span> <span class="entity">linordS</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">less_thm</span><span class="main">,</span> <span class="main">(</span><span class="entity">less_eq_thm</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">Class.instantiation</span> <span class="main">(</span><span class="main">[</span><span class="entity">tname</span><span class="main">]</span><span class="main">,</span> <span class="entity">xs</span><span class="main">,</span> <span class="entity">linordS</span><span class="main">)</span> <span class="entity">thy</span>
      |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">Ts</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dest_comp</span> <span class="entity">ctxt</span> <span class="entity">tname</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">typ_mapping</span> <span class="main">=</span> <span class="entity">all_tys</span> <span class="entity">c</span> <span class="main">(</span>map TFree <span class="entity">xs</span><span class="main">)</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cmp</span> <span class="main">=</span> <span class="entity">mk_cmp_rhs_comparator_of</span> <span class="entity">c</span> <span class="entity">Ts</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">less_def</span> <span class="main">=</span> <span class="entity">mk_ord_def</span> dummyT true <span class="entity">cmp</span> |&gt; <span class="entity">typ_mapping</span> |&gt; <span class="entity">infer_type</span> <span class="entity">ctxt</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">less_eq_def</span> <span class="main">=</span> <span class="entity">mk_ord_def</span> dummyT false <span class="entity">cmp</span> |&gt; <span class="entity">typ_mapping</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">base_name</span> <span class="main">=</span> Long_Name.base_name <span class="entity">tname</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="main">(</span><span class="entity">ctxt</span> 
          |&gt; <span class="entity">Generator_Aux.define_overloaded_generic</span>
            <span class="main">(</span><span class="main">(</span>Binding.name <span class="main">(</span><span class="inner_quoted">"less_"</span> ^ <span class="entity">base_name</span> ^ <span class="inner_quoted">"_def"</span><span class="main">)</span><span class="main">,</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">attributes</span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">,</span> <span class="entity">less_def</span><span class="main">)</span>            
          ||&gt; <span class="entity">Generator_Aux.define_overloaded_generic</span>
            <span class="main">(</span><span class="main">(</span>Binding.name <span class="main">(</span><span class="inner_quoted">"less_eq_"</span> ^ <span class="entity">base_name</span> ^ <span class="inner_quoted">"_def"</span><span class="main">)</span><span class="main">,</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">attributes</span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">,</span> <span class="entity">less_eq_def</span><span class="main">)</span><span class="main">)</span>

        <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">linear_tac</span> <span class="entity">ctxt</span> <span class="entity">i</span> <span class="main">=</span> 
      resolve_tac <span class="entity">ctxt</span> <span class="main">[</span>nth <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> linorder_axiomsD<span class="antiquote">}</span></span></span> <span class="main">(</span><span class="entity">i</span> - <span class="inner_numeral">1</span><span class="main">)</span><span class="main">]</span> <span class="entity">i</span>
      THEN resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> comparator.linorder<span class="antiquote">}</span></span></span> <span class="entity">i</span>
      THEN <span class="entity">comparator_tac_comparator_of</span> <span class="entity">ctxt</span> <span class="entity">tname</span> <span class="entity">i</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">Class.prove_instantiation_exit</span> <span class="main">(</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> 
      <span class="entity">Class.intro_classes_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span>
      THEN <span class="entity">unfold_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">less_thm</span><span class="main">,</span> <span class="entity">less_eq_thm</span><span class="main">]</span>
      THEN <span class="entity">linear_tac</span> <span class="entity">ctxt</span> <span class="inner_numeral">5</span>
      THEN <span class="entity">linear_tac</span> <span class="entity">ctxt</span> <span class="inner_numeral">4</span>
      THEN <span class="entity">linear_tac</span> <span class="entity">ctxt</span> <span class="inner_numeral">3</span>
      THEN <span class="entity">linear_tac</span> <span class="entity">ctxt</span> <span class="inner_numeral">2</span>
      THEN <span class="entity">linear_tac</span> <span class="entity">ctxt</span> <span class="inner_numeral">1</span>
      THEN <span class="entity">auto_tac</span> <span class="entity">ctxt</span> 
    <span class="main">)</span> <span class="entity">lthy</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">compare_instance_param</span> <span class="entity">tname</span> <span class="entity">param</span> <span class="main">=</span>  
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">gen_type</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">param</span> <span class="main">=</span> <span class="inner_quoted">""</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">Comparator_Generator.BNF</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">param</span> <span class="main">=</span> <span class="inner_quoted">"linorder"</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">Comparator_Generator.Linorder</span>
      <span class="keyword2"><span class="keyword">else</span></span> error <span class="inner_quoted">"unknown parameter for compare instance"</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">compare_instance</span> <span class="entity">gen_type</span> <span class="entity">tname</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">linorder_instance_param</span> <span class="entity">tname</span> <span class="entity">param</span> <span class="main">=</span>  
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">gen_type</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">param</span> <span class="main">=</span> <span class="inner_quoted">""</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">Comparator_Generator.BNF</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">param</span> <span class="main">=</span> <span class="inner_quoted">"linorder"</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">Comparator_Generator.Linorder</span>
      <span class="keyword2"><span class="keyword">else</span></span> error <span class="inner_quoted">"unknown parameter for compare instance"</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">linorder_instance</span> <span class="entity">gen_type</span> <span class="entity">tname</span> <span class="keyword2"><span class="keyword">end</span></span>


<span class="comment1">(*if "tname" not yet instance of "compare", instantiate*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">maybe_instantiate_compare</span> <span class="entity">gen_type</span> <span class="entity">tname</span> <span class="entity">thy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_class_instance</span> <span class="entity">thy</span> <span class="entity">tname</span> <span class="entity">cmpS</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">thy</span>
  <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">compare_instance</span> <span class="entity">gen_type</span> <span class="entity">tname</span> <span class="entity">thy</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">compare_order_instance_via_compare</span> <span class="entity">tname</span> <span class="entity">thy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">gen_type</span> <span class="main">=</span> <span class="entity">Comparator_Generator.BNF</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> <span class="entity">maybe_instantiate_compare</span> <span class="entity">gen_type</span> <span class="entity">tname</span> <span class="entity">thy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span>used_positions <span class="main">=</span> <span class="entity">us</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> the <span class="main">(</span><span class="entity">Comparator_Generator.get_info</span> 
      <span class="main">(</span><span class="entity">Named_Target.theory_init</span> <span class="entity">thy</span><span class="main">)</span> <span class="entity">tname</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">T</span><span class="main">,</span> <span class="entity">xs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">typ_and_vs_of_used_typname</span> <span class="entity">tname</span> <span class="entity">us</span> <span class="entity">cmpS</span>
    
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cmp</span> <span class="main">=</span> <span class="entity">cmp_const</span> <span class="main">(</span><span class="entity">cmpT</span> <span class="entity">T</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">le_thm</span><span class="main">,</span> <span class="entity">less_thm</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">Class.instantiation</span> <span class="main">(</span><span class="main">[</span><span class="entity">tname</span><span class="main">]</span><span class="main">,</span> <span class="entity">xs</span><span class="main">,</span> <span class="entity">cmpoS</span><span class="main">)</span> <span class="entity">thy</span>
      |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">lthy</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span> 
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">less_def</span> <span class="main">=</span> <span class="entity">mk_binop_def</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> less<span class="antiquote">}</span></span> <span class="entity">T</span> 
            <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> lt_of_comp<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">cmpT</span> <span class="entity">T</span> --&gt; <span class="entity">T</span> --&gt; <span class="entity">T</span> --&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">bool</span><span class="antiquote">}</span></span><span class="main">)</span> $ <span class="entity">cmp</span><span class="main">)</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">le_def</span> <span class="main">=</span> <span class="entity">mk_binop_def</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> less_eq<span class="antiquote">}</span></span> <span class="entity">T</span> 
            <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> le_of_comp<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">cmpT</span> <span class="entity">T</span> --&gt; <span class="entity">T</span> --&gt; <span class="entity">T</span> --&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">bool</span><span class="antiquote">}</span></span><span class="main">)</span> $ <span class="entity">cmp</span><span class="main">)</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">less_thm</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span>  <span class="entity">Generator_Aux.define_overloaded</span> 
            <span class="main">(</span><span class="inner_quoted">"less_"</span> ^ Long_Name.base_name <span class="entity">tname</span> ^ <span class="inner_quoted">"_def"</span><span class="main">,</span> <span class="entity">less_def</span><span class="main">)</span> <span class="entity">lthy</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">le_thm</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Generator_Aux.define_overloaded</span> 
            <span class="main">(</span><span class="inner_quoted">"less_eq_"</span> ^ Long_Name.base_name <span class="entity">tname</span> ^ <span class="inner_quoted">"_def"</span><span class="main">,</span> <span class="entity">le_def</span><span class="main">)</span> <span class="entity">lthy</span>         
        <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">le_thm</span><span class="main">,</span> <span class="entity">less_thm</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">Class.prove_instantiation_exit</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span>
      <span class="entity">Class.intro_classes_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span>
      THEN <span class="entity">unfold_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">le_thm</span><span class="main">]</span>
      THEN <span class="entity">unfold_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">less_thm</span><span class="main">]</span><span class="main">)</span> <span class="entity">lthy</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">compare_order_instance_via_comparator_of</span> <span class="entity">tname</span> <span class="entity">thy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">gen_type</span> <span class="main">=</span> <span class="entity">Comparator_Generator.Linorder</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> <span class="entity">maybe_instantiate_compare</span> <span class="entity">gen_type</span> <span class="entity">tname</span> <span class="entity">thy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">xs</span> <span class="main">=</span> <span class="entity">Generator_Aux.typ_and_vs_of_typname</span> <span class="entity">thy</span> <span class="entity">tname</span> <span class="entity">cmpS</span> |&gt; snd
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lthy</span> <span class="main">=</span> <span class="entity">Class.instantiation</span> <span class="main">(</span><span class="main">[</span><span class="entity">tname</span><span class="main">]</span><span class="main">,</span> <span class="entity">xs</span><span class="main">,</span> <span class="entity">cmpoS</span><span class="main">)</span> <span class="entity">thy</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">Class.prove_instantiation_exit</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span>
      <span class="entity">Class.intro_classes_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span>
      THEN <span class="entity">unfold_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">Named_Theorems.get</span> <span class="entity">ctxt</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">named_theorems</span> compare_simps<span class="antiquote">}</span></span><span class="main">)</span>
      THEN resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> le_lt_comparator_of<span class="main">(</span>1<span class="main">)</span><span class="antiquote">}</span></span></span> <span class="inner_numeral">1</span>
      THEN resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> le_lt_comparator_of<span class="main">(</span>2<span class="main">)</span><span class="antiquote">}</span></span></span> <span class="inner_numeral">1</span><span class="main">)</span> <span class="entity">lthy</span>
  <span class="keyword2"><span class="keyword">end</span></span>
  
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">compare_order_instance</span> <span class="entity">tname</span> <span class="entity">param</span> <span class="entity">thy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">is_class_instance</span> <span class="entity">thy</span> <span class="entity">tname</span> <span class="entity">cmpoS</span>
      <span class="keyword1"><span class="keyword">andalso</span></span> error <span class="main">(</span><span class="inner_quoted">"type "</span> ^ quote <span class="entity">tname</span> ^ <span class="inner_quoted">" is already an instance of class \"compare_order\""</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> writeln <span class="main">(</span><span class="inner_quoted">"deriving \"compare_order\" instance for type "</span> ^ quote <span class="entity">tname</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">param</span> <span class="main">=</span> <span class="inner_quoted">""</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">compare_order_instance_via_compare</span> <span class="entity">tname</span> <span class="entity">thy</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">param</span> <span class="main">=</span> <span class="inner_quoted">"linorder"</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">compare_order_instance_via_comparator_of</span> <span class="entity">tname</span> <span class="entity">thy</span>
    <span class="keyword2"><span class="keyword">else</span></span> error <span class="inner_quoted">"unknown parameter, supported are (no parameter) and \"linorder\""</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  Theory.setup
    <span class="main">(</span><span class="entity">Derive_Manager.register_derive</span> 
      <span class="inner_quoted">"compare"</span> 
      <span class="inner_quoted">"register types in class compare, options: (linorder) or ()"</span> 
      <span class="entity">compare_instance_param</span>
    #&gt; <span class="entity">Derive_Manager.register_derive</span> 
      <span class="inner_quoted">"compare_order"</span> 
      <span class="inner_quoted">"register types in class compare_order, options: (linorder) or ()"</span> 
      <span class="entity">compare_order_instance</span>
    #&gt; <span class="entity">Derive_Manager.register_derive</span> 
      <span class="inner_quoted">"linorder"</span> 
      <span class="inner_quoted">"register types in class linorder, options: (linorder) or ()"</span> 
      <span class="entity">linorder_instance_param</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Compare_Instances">
<div class="head">
<h1>Theory Compare_Instances</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Deriving class instances for datatypes
    Author:      Christian Sternagel and René Thiemann  &lt;christian.sternagel|rene.thiemann@uibk.ac.at&gt;
    Maintainer:  Christian Sternagel and René Thiemann 
    License:     LGPL
*)</span>
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Defining Comparators and Compare-Instances for Common Types›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Compare_Instances
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Compare_Generator.html">Compare_Generator</a>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Char_ord.html">HOL-Library.Char_ord</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹For all of the following types, we define comparators and register them in the class 
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> compare<span class="antiquote"><span class="antiquote">}</span></span></span></span>:
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> int<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> integer<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> nat<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> char<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> bool<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> unit<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> sum<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> option<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> list<span class="antiquote"><span class="antiquote">}</span></span></span></span>,
  and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> prod<span class="antiquote"><span class="antiquote">}</span></span></span></span>. We do not register those classes in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> compare_order<span class="antiquote"><span class="antiquote">}</span></span></span></span> where
  so far no linear order is defined, in particular if there are conflicting orders, like pair-wise or
  lexicographic comparison on pairs.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹For <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> int<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> nat<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> integer<span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> char<span class="antiquote"><span class="antiquote">}</span></span></span></span> we just use their linear orders as comparators.›</span></span>
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>linorder<span class="main">)</span> compare_order <span class="quoted">int</span> <span class="quoted">integer</span> <span class="quoted">nat</span> <span class="quoted">char</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹For <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> sum<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> list<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> prod<span class="antiquote"><span class="antiquote">}</span></span></span></span>, and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> option<span class="antiquote"><span class="antiquote">}</span></span></span></span> we generate comparators 
  which are however are not used to instantiate <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> linorder<span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>
<span class="keyword1"><span class="command">derive</span></span> compare <span class="quoted">sum</span> <span class="quoted">list</span> <span class="quoted">prod</span> <span class="quoted">option</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We do not use the linear order to define the comparator for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">bool</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">unit</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, 
  but implement more efficient ones.›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">comparator_unit</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"unit comparator"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">comparator_unit</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> Eq"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">comparator_bool</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"bool comparator"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">comparator_bool</span> False False <span class="main">=</span> Eq"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">comparator_bool</span> False True <span class="main">=</span> Lt"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">comparator_bool</span> True True <span class="main">=</span> Eq"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">comparator_bool</span> True False <span class="main">=</span> Gt"</span></span>

<span class="keyword1" id="Compare_Instances-comparator_unit"><span class="command">lemma</span></span> comparator_unit<span class="main">:</span> <span class="quoted"><span class="quoted">"comparator comparator_unit"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="Compare_Instances-comparator_bool"><span class="command">lemma</span></span> comparator_bool<span class="main">:</span> <span class="quoted"><span class="quoted">"comparator comparator_bool"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="skolem">z</span> <span class="main">::</span> <span class="quoted">bool</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"invert_order <span class="main">(</span>comparator_bool <span class="skolem">x</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">=</span> comparator_bool <span class="skolem">y</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main"><span class="keyword3">,</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">y</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"comparator_bool <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">=</span> Eq <span class="main">⟹</span> <span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main"><span class="keyword3">,</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">y</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"comparator_bool <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">=</span> Lt <span class="main">⟹</span> comparator_bool <span class="skolem">y</span> <span class="skolem">z</span> <span class="main">=</span> Lt <span class="main">⟹</span> comparator_bool <span class="skolem">x</span> <span class="skolem">z</span> <span class="main">=</span> Lt"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main"><span class="keyword3">,</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">y</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">y</span></span><span class="main"><span class="keyword3">,</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">z</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">local_setup</span></span> <span class="quoted">‹
  <span class="entity">Comparator_Generator.register_foreign_comparator</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">unit</span><span class="antiquote">}</span></span>
    <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">comparator_unit</span><span class="antiquote">}</span></span>
    <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> comparator_unit<span class="antiquote">}</span></span></span>
›</span>

<span class="keyword1"><span class="command">local_setup</span></span> <span class="quoted">‹
  <span class="entity">Comparator_Generator.register_foreign_comparator</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">bool</span><span class="antiquote">}</span></span>
    <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">comparator_bool</span><span class="antiquote">}</span></span>
    <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> comparator_bool<span class="antiquote">}</span></span></span>
›</span>

<span class="keyword1"><span class="command">derive</span></span> compare <span class="quoted">bool</span> <span class="quoted">unit</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹It is not directly possible to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>derive (linorder) bool unit›</span></span></span></span>, since 
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"compare <span class="main"><span class="main">::</span></span> bool comparator"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
  was not defined as <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"comparator_of <span class="main"><span class="main">::</span></span> bool comparator"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, but as
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> comparator_bool<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  However, we can manually prove this equivalence
  and then use this knowledge to prove the instance of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> compare_order<span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>

<span class="keyword1" id="Compare_Instances-comparator_bool_comparator_of"><span class="command">lemma</span></span> comparator_bool_comparator_of <span class="main">[</span><span class="operator">compare_simps</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"comparator_bool <span class="main">=</span> comparator_of"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> ext<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">b</span> 
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"comparator_bool <span class="skolem">a</span> <span class="skolem">b</span> <span class="main">=</span> comparator_of <span class="skolem">a</span> <span class="skolem">b</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> comparator_of_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">a</span></span><span class="main"><span class="keyword3">,</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">b</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Compare_Instances-comparator_unit_comparator_of"><span class="command">lemma</span></span> comparator_unit_comparator_of <span class="main">[</span><span class="operator">compare_simps</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"comparator_unit <span class="main">=</span> comparator_of"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> ext<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">b</span> 
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"comparator_unit <span class="skolem">a</span> <span class="skolem">b</span> <span class="main">=</span> comparator_of <span class="skolem">a</span> <span class="skolem">b</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> comparator_of_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>linorder<span class="main">)</span> compare_order <span class="quoted">bool</span> <span class="quoted">unit</span>
<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Compare_Order_Instances">
<div class="head">
<h1>Theory Compare_Order_Instances</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Deriving class instances for datatypes
    Author:      Christian Sternagel and René Thiemann  &lt;christian.sternagel|rene.thiemann@uibk.ac.at&gt;
    Maintainer:  Christian Sternagel and René Thiemann 
    License:     LGPL
*)</span>
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Defining Compare-Order-Instances for Common Types›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Compare_Order_Instances
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Compare_Instances.html">Compare_Instances</a>
  <span class="quoted">"<a href="../../HOL/HOL-Library/List_Lexorder.html">HOL-Library.List_Lexorder</a>"</span>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Product_Lexorder.html">HOL-Library.Product_Lexorder</a>"</span>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Option_ord.html">HOL-Library.Option_ord</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We now also instantiate class <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> compare_order<span class="antiquote"><span class="antiquote">}</span></span></span></span> and not only <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> compare<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  Here, we also prove that our definitions do not clash with existing orders on
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> list<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> option<span class="antiquote"><span class="antiquote">}</span></span></span></span>, and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> prod<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  
  For <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> sum<span class="antiquote"><span class="antiquote">}</span></span></span></span> we just define the linear orders via their comparator.›</span></span>

<span class="keyword1"><span class="command">derive</span></span> compare_order <span class="quoted">sum</span>

<span class="keyword1"><span class="command">instance</span></span> list <span class="main">::</span> <span class="main">(</span><span class="quoted">compare_order</span><span class="main">)</span><span class="quoted">compare_order</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> le_of_comp_def lt_of_comp_def comparator_of_def
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"le_of_comp <span class="main">(</span>compare <span class="main">::</span> <span class="tfree">'a</span> list comparator<span class="main">)</span> <span class="main">=</span> <span class="main">(≤)</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> compare_list_def compare_is_comparator_of 
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> ext<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="skolem">ys</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"le_of_comp <span class="main">(</span>comparator_list comparator_of<span class="main">)</span> <span class="skolem">xs</span> <span class="skolem">ys</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">xs</span> <span class="main">≤</span> <span class="skolem">ys</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">ys</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Nil <span class="skolem">ys</span><span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ys</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">x</span> <span class="skolem">xs</span> <span class="skolem">yys</span><span class="main">)</span> <span class="keyword1"><span class="command">note</span></span> IH <span class="main">=</span> this
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">yys</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> Nil
        <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">y</span> <span class="skolem">ys</span><span class="main">)</span>
        <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> Cons
          <span class="keyword1"><span class="command">using</span></span> IH<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">ys</span></span><span class="main">]</span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span> <span class="quoted"><span class="skolem">y</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> linorder_cases<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"lt_of_comp <span class="main">(</span>compare <span class="main">::</span> <span class="tfree">'a</span> list comparator<span class="main">)</span> <span class="main">=</span> <span class="main">(&lt;)</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> compare_list_def compare_is_comparator_of 
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> ext<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="skolem">ys</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"lt_of_comp <span class="main">(</span>comparator_list comparator_of<span class="main">)</span> <span class="skolem">xs</span> <span class="skolem">ys</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">xs</span> <span class="main">&lt;</span> <span class="skolem">ys</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">ys</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Nil <span class="skolem">ys</span><span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ys</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">x</span> <span class="skolem">xs</span> <span class="skolem">yys</span><span class="main">)</span> <span class="keyword1"><span class="command">note</span></span> IH <span class="main">=</span> this
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">yys</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> Nil
        <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">y</span> <span class="skolem">ys</span><span class="main">)</span>
        <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> Cons
          <span class="keyword1"><span class="command">using</span></span> IH<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">ys</span></span><span class="main">]</span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span> <span class="quoted"><span class="skolem">y</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> linorder_cases<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">instance</span></span> prod <span class="main">::</span> <span class="main">(</span><span class="quoted">compare_order</span><span class="main">,</span> <span class="quoted">compare_order</span><span class="main">)</span><span class="quoted">compare_order</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> le_of_comp_def lt_of_comp_def comparator_of_def
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"le_of_comp <span class="main">(</span>compare <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span>prod comparator<span class="main">)</span> <span class="main">=</span> <span class="main">(≤)</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> compare_prod_def compare_is_comparator_of 
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> ext<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xy1</span> <span class="skolem">xy2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span>prod"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"le_of_comp <span class="main">(</span>comparator_prod comparator_of comparator_of<span class="main">)</span> <span class="skolem">xy1</span> <span class="skolem">xy2</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">xy1</span> <span class="main">≤</span> <span class="skolem">xy2</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xy1</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">xy2</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"lt_of_comp <span class="main">(</span>compare <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span>prod comparator<span class="main">)</span> <span class="main">=</span> <span class="main">(&lt;)</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> compare_prod_def compare_is_comparator_of 
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> ext<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xy1</span> <span class="skolem">xy2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span>prod"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"lt_of_comp <span class="main">(</span>comparator_prod comparator_of comparator_of<span class="main">)</span> <span class="skolem">xy1</span> <span class="skolem">xy2</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">xy1</span> <span class="main">&lt;</span> <span class="skolem">xy2</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xy1</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">xy2</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">instance</span></span> option <span class="main">::</span> <span class="main">(</span><span class="quoted">compare_order</span><span class="main">)</span><span class="quoted">compare_order</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> le_of_comp_def lt_of_comp_def comparator_of_def
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"le_of_comp <span class="main">(</span>compare <span class="main">::</span> <span class="tfree">'a</span> option comparator<span class="main">)</span> <span class="main">=</span> <span class="main">(≤)</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> compare_option_def compare_is_comparator_of 
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> ext<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xy1</span> <span class="skolem">xy2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> option"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"le_of_comp <span class="main">(</span>comparator_option comparator_of<span class="main">)</span> <span class="skolem">xy1</span> <span class="skolem">xy2</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">xy1</span> <span class="main">≤</span> <span class="skolem">xy2</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xy1</span></span><span class="main"><span class="keyword3">,</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xy2</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"lt_of_comp <span class="main">(</span>compare <span class="main">::</span> <span class="tfree">'a</span> option comparator<span class="main">)</span> <span class="main">=</span> <span class="main">(&lt;)</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> compare_option_def compare_is_comparator_of 
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> ext<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xy1</span> <span class="skolem">xy2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> option"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"lt_of_comp <span class="main">(</span>comparator_option comparator_of<span class="main">)</span> <span class="skolem">xy1</span> <span class="skolem">xy2</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">xy1</span> <span class="main">&lt;</span> <span class="skolem">xy2</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xy1</span></span><span class="main"><span class="keyword3">,</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xy2</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Compare_Rat">
<div class="head">
<h1>Theory Compare_Rat</h1>
</div>
<pre class="source"><span class="comment1">(*  
    Author:      René Thiemann 
    License:     LGPL
*)</span>
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Compare Instance for Rational Numbers›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Compare_Rat
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Compare_Generator.html">Compare_Generator</a>
  <a href="../../HOL/HOL/Rat.html">HOL.Rat</a>
<span class="keyword2"><span class="keyword">begin</span></span>
  
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>linorder<span class="main">)</span> compare_order <span class="quoted">rat</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Compare_Real">
<div class="head">
<h1>Theory Compare_Real</h1>
</div>
<pre class="source"><span class="comment1">(*
    Author:      René Thiemann
    License:     LGPL
*)</span>
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Compare Instance for Real Numbers›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Compare_Real
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Compare_Generator.html">Compare_Generator</a>
  <a href="../../HOL/HOL/Real.html">HOL.Real</a>
<span class="keyword2"><span class="keyword">begin</span></span>
  
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>linorder<span class="main">)</span> compare_order <span class="quoted">real</span>

<span class="keyword1" id="Compare_Real-invert_order_compare_real"><span class="command">lemma</span></span> invert_order_compare_real<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">::</span> real<span class="main">.</span> invert_order <span class="main">(</span>compare <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span> <span class="main">=</span> compare <span class="bound">y</span> <span class="bound">x</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> comparator_of_def compare_is_comparator_of<span class="main">)</span>


<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Equality_Generator">
<div class="head">
<h1>Theory Equality_Generator</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Deriving class instances for datatypes
    Author:      Christian Sternagel and René Thiemann  &lt;christian.sternagel|rene.thiemann@uibk.ac.at&gt;
    Maintainer:  Christian Sternagel and René Thiemann 
    License:     LGPL
*)</span>
<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Checking Equality Without "="›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Equality_Generator
<span class="keyword2"><span class="keyword">imports</span></span>
  <span class="quoted">"<a href="Generator_Aux.html">../Generator_Aux</a>"</span>
  <span class="quoted">"<a href="Derive_Manager.html">../Derive_Manager</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">typedecl</span></span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">,</span><span class="tfree">'c</span><span class="main">,</span><span class="tfree">'z</span><span class="main">)</span>type

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In the following, we define a generator which for a given datatype <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">,</span></span><span class="tfree"><span class="tfree">'b</span></span><span class="main"><span class="main">,</span></span><span class="tfree"><span class="tfree">'c</span></span><span class="main"><span class="main">,</span></span><span class="tfree"><span class="tfree">'z</span></span><span class="main"><span class="main">)</span></span>type"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
  constructs an equality-test function of type 
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span> <span class="main"><span class="main">⇒</span></span> <span class="tfree"><span class="tfree">'a</span></span> <span class="main"><span class="main">⇒</span></span> bool<span class="main"><span class="main">)</span></span> <span class="main"><span class="main">⇒</span></span> <span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'b</span></span> <span class="main"><span class="main">⇒</span></span> <span class="tfree"><span class="tfree">'b</span></span> <span class="main"><span class="main">⇒</span></span> bool<span class="main"><span class="main">)</span></span> <span class="main"><span class="main">⇒</span></span> <span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'c</span></span> <span class="main"><span class="main">⇒</span></span> <span class="tfree"><span class="tfree">'c</span></span> <span class="main"><span class="main">⇒</span></span> bool<span class="main"><span class="main">)</span></span> <span class="main"><span class="main">⇒</span></span> <span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'z</span></span> <span class="main"><span class="main">⇒</span></span> <span class="tfree"><span class="tfree">'z</span></span> <span class="main"><span class="main">⇒</span></span> bool<span class="main"><span class="main">)</span></span> <span class="main"><span class="main">⇒</span></span> 
    <span class="main"><span class="main">(</span></span><span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">,</span></span><span class="tfree"><span class="tfree">'b</span></span><span class="main"><span class="main">,</span></span><span class="tfree"><span class="tfree">'c</span></span><span class="main"><span class="main">,</span></span><span class="tfree"><span class="tfree">'z</span></span><span class="main"><span class="main">)</span></span>type <span class="main"><span class="main">⇒</span></span> <span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">,</span></span><span class="tfree"><span class="tfree">'b</span></span><span class="main"><span class="main">,</span></span><span class="tfree"><span class="tfree">'c</span></span><span class="main"><span class="main">,</span></span><span class="tfree"><span class="tfree">'z</span></span><span class="main"><span class="main">)</span></span>type <span class="main"><span class="main">⇒</span></span> bool<span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  These functions are essential to synthesize conditional equality functions in the container framework,
  where a strict membership in the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> equal<span class="antiquote"><span class="antiquote">}</span></span></span></span>-class must not be enforced.
›</span></span>

<span class="keyword1"><span class="command">hide_type</span></span> <span class="quoted">"type"</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Just a constant to define conjunction on lists of booleans, which will
  be used to merge the results when having compared the arguments of identical
  constructors.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">list_all_eq</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"bool list <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">list_all_eq</span> <span class="main">=</span> list_all id "</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Improved Code for Non-Lazy Languages›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The following equations will eliminate all occurrences of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">list_all_eq</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
  in the generated code of the equality functions.›</span></span>

<span class="keyword1" id="Equality_Generator-list_all_eq_unfold"><span class="command">lemma</span></span> list_all_eq_unfold<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"list_all_eq <span class="main">[]</span> <span class="main">=</span> True"</span></span>
  <span class="quoted"><span class="quoted">"list_all_eq <span class="main">[</span><span class="free">b</span><span class="main">]</span> <span class="main">=</span> <span class="free">b</span>"</span></span>
  <span class="quoted"><span class="quoted">"list_all_eq <span class="main">(</span><span class="free">b1</span> <span class="main">#</span> <span class="free">b2</span> <span class="main">#</span> <span class="free">bs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">b1</span> <span class="main">∧</span> list_all_eq <span class="main">(</span><span class="free">b2</span> <span class="main">#</span> <span class="free">bs</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> list_all_eq_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Equality_Generator-list_all_eq"><span class="command">lemma</span></span> list_all_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"list_all_eq <span class="free">bs</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">b</span> <span class="main">∈</span> set <span class="free">bs</span><span class="main">.</span> <span class="bound">b</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> list_all_eq_def list_all_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Partial Equality Property›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We require a partial property which can be used in inductive proofs.›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'a</span> equality <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">pequality</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> equality <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">pequality</span> <span class="free"><span class="bound"><span class="entity">aeq</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">y</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">aeq</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="bound">y</span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="bound">y</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Equality_Generator-pequalityD"><span class="command">lemma</span></span> pequalityD<span class="main">:</span> <span class="quoted"><span class="quoted">"pequality <span class="free">aeq</span> <span class="free">x</span> <span class="main">⟹</span> <span class="free">aeq</span> <span class="free">x</span> <span class="free">y</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> pequality_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Equality_Generator-pequalityI"><span class="command">lemma</span></span> pequalityI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span> <span class="bound">y</span><span class="main">.</span> <span class="free">aeq</span> <span class="free">x</span> <span class="bound">y</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">=</span> <span class="bound">y</span><span class="main">)</span> <span class="main">⟹</span> pequality <span class="free">aeq</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> pequality_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Global equality property›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">equality</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> equality <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">equality</span> <span class="free"><span class="bound"><span class="entity">aeq</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">x</span><span class="main">.</span> pequality <span class="free"><span class="bound"><span class="entity">aeq</span></span></span> <span class="bound">x</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Equality_Generator-equalityD2"><span class="command">lemma</span></span> equalityD2<span class="main">:</span> <span class="quoted"><span class="quoted">"equality <span class="free">aeq</span> <span class="main">⟹</span> pequality <span class="free">aeq</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> equality_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="Equality_Generator-equalityI2"><span class="command">lemma</span></span> equalityI2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span> <span class="bound">x</span><span class="main">.</span> pequality <span class="free">aeq</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⟹</span> equality <span class="free">aeq</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> equality_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    
<span class="keyword1" id="Equality_Generator-equalityD"><span class="command">lemma</span></span> equalityD<span class="main">:</span> <span class="quoted"><span class="quoted">"equality <span class="free">aeq</span> <span class="main">⟹</span> <span class="free">aeq</span> <span class="free">x</span> <span class="free">y</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> pequalityD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> equalityD2<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Equality_Generator-equalityI"><span class="command">lemma</span></span> equalityI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">aeq</span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">⟷</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">y</span><span class="main">)</span> <span class="main">⟹</span> equality <span class="free">aeq</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> equalityI2 pequalityI<span class="main">)</span>

<span class="keyword1" id="Equality_Generator-equality_imp_eq"><span class="command">lemma</span></span> equality_imp_eq<span class="main">:</span>
  <span class="quoted"><span class="quoted">"equality <span class="free">aeq</span> <span class="main">⟹</span> <span class="free">aeq</span> <span class="main">=</span> <span class="main">(=)</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> ext<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> equalityD<span class="main">)</span>

<span class="keyword1" id="Equality_Generator-eq_equality"><span class="command">lemma</span></span> eq_equality<span class="main">:</span> <span class="quoted"><span class="quoted">"equality <span class="main">(=)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> equalityI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Equality_Generator-equality_def'"><span class="command">lemma</span></span> equality_def'<span class="main">:</span> <span class="quoted"><span class="quoted">"equality <span class="free">f</span> <span class="main">=</span> <span class="main">(</span><span class="free">f</span> <span class="main">=</span> <span class="main">(=)</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">using</span></span> equality_imp_eq eq_equality <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹The Generator›</span></span>

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹equality_generator.ML›</span>

<span class="keyword1"><span class="command">hide_fact</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> equalityI

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/equality_generator.ML">
<div class="head">
<h1>File ‹equality_generator.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Deriving class instances for datatypes
    Author:      Christian Sternagel and René Thiemann  &lt;christian.sternagel|rene.thiemann@uibk.ac.at&gt;
    Maintainer:  Christian Sternagel and René Thiemann
    License:     LGPL
*)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">EQUALITY_GENERATOR</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>

  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">info</span> <span class="main">=</span>
   <span class="main">{</span>map <span class="main">:</span> term<span class="main">,</span>                    <span class="comment1">(* take % x. x, if there is no map *)</span>
    pequality <span class="main">:</span> term<span class="main">,</span>                  <span class="comment1">(* partial equality *)</span>
    equality <span class="main">:</span> term<span class="main">,</span>                   <span class="comment1">(* full equality *)</span>
    equality_def <span class="main">:</span> thm option<span class="main">,</span>         <span class="comment1">(* definition of equality, important for nesting *)</span>
    map_comp <span class="main">:</span> thm option<span class="main">,</span>         <span class="comment1">(* compositionality of map, important for nesting *)</span>
    partial_equality_thm <span class="main">:</span> thm<span class="main">,</span>       <span class="comment1">(* partial version of equality thm *)</span>
    equality_thm <span class="main">:</span> thm<span class="main">,</span>               <span class="comment1">(* equality acomp ⟹ … ⟹ equality (full_comp acomp …) *)</span>
    used_positions <span class="main">:</span> bool list<span class="main">}</span>

  <span class="comment1">(* registers @{term equality_of :: "some_type :: linorder equality"}
     where some_type must just be a type without type-arguments *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> register_equality_of <span class="main">:</span> string <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span> local_theory

  <span class="keyword1"><span class="keyword">val</span></span> register_foreign_equality <span class="main">:</span>
    typ <span class="main">-&gt;</span> <span class="comment1">(* type-constant without type-variables *)</span>
    term <span class="main">-&gt;</span> <span class="comment1">(* equality for type *)</span>
    thm <span class="main">-&gt;</span> <span class="comment1">(* equality thm for provided equality *)</span>
    local_theory <span class="main">-&gt;</span> local_theory



  <span class="keyword1"><span class="keyword">val</span></span> register_foreign_partial_and_full_equality <span class="main">:</span>
    string <span class="main">-&gt;</span> <span class="comment1">(* long type name *)</span>
    term <span class="main">-&gt;</span> <span class="comment1">(* map function, should be λx. x, if there is no map *)</span>
    term <span class="main">-&gt;</span> <span class="comment1">(* partial equality of type ('a =&gt; order, 'b)ty =&gt; ('a,'b)ty =&gt; order,
      where 'a is used, 'b is unused *)</span>
    term <span class="main">-&gt;</span> <span class="comment1">(* (full) equality of type ('a ⇒ 'a ⇒ order) ⇒ ('a,'b)ty ⇒ ('a,'b)ty ⇒ order,
      where 'a is used, 'b is unused *)</span>
    thm option <span class="main">-&gt;</span> <span class="comment1">(* comp_def, should be full_comp = pcomp o map acomp ..., important for nesting *)</span>
    thm option <span class="main">-&gt;</span> <span class="comment1">(* map compositionality, important for nesting *)</span>
    thm <span class="main">-&gt;</span> <span class="comment1">(* partial eq thm for full equality *)</span>
    thm <span class="main">-&gt;</span> <span class="comment1">(* full thm: equality a-comp =&gt; equality (full_comp a-comp) *)</span>
    bool list <span class="main">-&gt;</span> <span class="comment1">(*used positions*)</span>
    local_theory <span class="main">-&gt;</span> local_theory

  <span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">equality_type</span> <span class="main">=</span> <span class="entity">EQ</span> <span class="main">|</span> <span class="entity">BNF</span>

  <span class="keyword1"><span class="keyword">val</span></span> generate_equalitys_from_bnf_fp <span class="main">:</span>
    string <span class="main">-&gt;</span>                 <span class="comment1">(* name of type *)</span>
    local_theory <span class="main">-&gt;</span>
    <span class="main">(</span><span class="main">(</span>term * thm list<span class="main">)</span> list * <span class="comment1">(* partial equalitys + simp-rules *)</span>
    <span class="main">(</span>term * thm<span class="main">)</span> list<span class="main">)</span> *      <span class="comment1">(* non-partial equality + def_rule *)</span>
    local_theory

  <span class="keyword1"><span class="keyword">val</span></span> generate_equality <span class="main">:</span>
    <span class="entity">equality_type</span> <span class="main">-&gt;</span>
    string <span class="main">-&gt;</span> <span class="comment1">(* name of type *)</span>
    local_theory <span class="main">-&gt;</span> local_theory

  <span class="keyword1"><span class="keyword">val</span></span> get_info <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string <span class="main">-&gt;</span> <span class="entity">info</span> option

  <span class="comment1">(* ensures that the info will be available on later requests *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> ensure_info <span class="main">:</span> <span class="entity">equality_type</span> <span class="main">-&gt;</span> string <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span> local_theory

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Equality_Generator</span> <span class="main">:</span> <span class="entity">EQUALITY_GENERATOR</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword3"><span class="keyword">open</span></span> Generator_Aux

<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">equality_type</span> <span class="main">=</span> <span class="entity">BNF</span> <span class="main">|</span> <span class="entity">EQ</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">debug</span> <span class="main">=</span> false
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">debug_out</span> <span class="entity">s</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">debug</span> <span class="keyword2"><span class="keyword">then</span></span> writeln <span class="entity">s</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">boolT</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">bool</span><span class="antiquote">}</span></span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">compT</span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">T</span> --&gt; <span class="entity">T</span> --&gt; <span class="entity">boolT</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">orderify</span> <span class="main">=</span> map_atyps <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">T</span> <span class="main">=&gt;</span> <span class="entity">T</span> --&gt; <span class="entity">boolT</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pcompT</span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">orderify</span> <span class="entity">T</span> --&gt; <span class="entity">T</span> --&gt; <span class="entity">boolT</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">info</span> <span class="main">=</span>
 <span class="main">{</span>map <span class="main">:</span> term<span class="main">,</span>
  pequality <span class="main">:</span> term<span class="main">,</span>
  equality <span class="main">:</span> term<span class="main">,</span>
  equality_def <span class="main">:</span> thm option<span class="main">,</span>
  map_comp <span class="main">:</span> thm option<span class="main">,</span>
  partial_equality_thm <span class="main">:</span> thm<span class="main">,</span>
  equality_thm <span class="main">:</span> thm<span class="main">,</span>
  used_positions <span class="main">:</span> bool list<span class="main">}</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Data</span> <span class="main">=</span> Generic_Data <span class="main">(</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">info</span> Symtab.table<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">empty</span> <span class="main">=</span> Symtab.empty<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">extend</span> <span class="main">=</span> I<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">merge</span> <span class="main">=</span> Symtab.merge <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">info1</span> <span class="main">:</span> <span class="entity">info</span><span class="main">,</span> <span class="entity">info2</span> <span class="main">:</span> <span class="entity">info</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">#</span>equality <span class="entity">info1</span> <span class="main">=</span> <span class="main">#</span>equality <span class="entity">info2</span><span class="main">)</span><span class="main">;</span>
<span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_info</span> <span class="entity">T</span> <span class="entity">info</span> <span class="main">=</span> Data.map <span class="main">(</span>Symtab.update_new <span class="main">(</span><span class="entity">T</span><span class="main">,</span> <span class="entity">info</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">get_info</span> <span class="main">=</span> Context.Proof #&gt; Data.get #&gt; Symtab.lookup

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">the_info</span> <span class="entity">ctxt</span> <span class="entity">tyco</span> <span class="main">=</span>
     <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">get_info</span> <span class="entity">ctxt</span> <span class="entity">tyco</span> <span class="keyword2"><span class="keyword">of</span></span>
        SOME <span class="entity">info</span> <span class="main">=&gt;</span> <span class="entity">info</span>
      <span class="main">|</span> NONE <span class="main">=&gt;</span> error <span class="main">(</span><span class="inner_quoted">"no equality information available for type "</span> ^ quote <span class="entity">tyco</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">declare_info</span> <span class="entity">tyco</span> <span class="entity">m</span> <span class="entity">p</span> <span class="entity">c</span> <span class="entity">c_def</span> <span class="entity">m_comp</span> <span class="entity">p_thm</span> <span class="entity">c_thm</span> <span class="entity">used_pos</span> <span class="main">=</span>
  Local_Theory.declaration <span class="main">{</span>syntax <span class="main">=</span> false<span class="main">,</span> pervasive <span class="main">=</span> false<span class="main">}</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">phi</span> <span class="main">=&gt;</span>
    <span class="entity">add_info</span> <span class="entity">tyco</span>
     <span class="main">{</span>map <span class="main">=</span> Morphism.term <span class="entity">phi</span> <span class="entity">m</span><span class="main">,</span>
      pequality <span class="main">=</span> Morphism.term <span class="entity">phi</span> <span class="entity">p</span><span class="main">,</span>
      equality <span class="main">=</span> Morphism.term <span class="entity">phi</span> <span class="entity">c</span><span class="main">,</span>
      equality_def <span class="main">=</span> Option.map <span class="main">(</span>Morphism.thm <span class="entity">phi</span><span class="main">)</span> <span class="entity">c_def</span><span class="main">,</span>
      map_comp <span class="main">=</span> Option.map <span class="main">(</span>Morphism.thm <span class="entity">phi</span><span class="main">)</span> <span class="entity">m_comp</span><span class="main">,</span>
      partial_equality_thm <span class="main">=</span> Morphism.thm <span class="entity">phi</span> <span class="entity">p_thm</span><span class="main">,</span>
      equality_thm <span class="main">=</span> Morphism.thm <span class="entity">phi</span> <span class="entity">c_thm</span><span class="main">,</span>
      used_positions <span class="main">=</span> <span class="entity">used_pos</span><span class="main">}</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">register_foreign_partial_and_full_equality</span> <span class="entity">tyco</span> <span class="entity">m</span> <span class="entity">p</span> <span class="entity">c</span> <span class="entity">c_def</span> <span class="entity">m_comp</span> <span class="entity">eq_thm</span> <span class="entity">c_thm</span> <span class="main">=</span>
  <span class="entity">declare_info</span> <span class="entity">tyco</span> <span class="entity">m</span> <span class="entity">p</span> <span class="entity">c</span> <span class="entity">c_def</span> <span class="entity">m_comp</span> <span class="entity">eq_thm</span> <span class="entity">c_thm</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mk_equality</span> <span class="main">=</span> <span class="entity">mk_infer_const</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> equality<span class="antiquote">}</span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mk_pequality</span> <span class="main">=</span> <span class="entity">mk_infer_const</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> pequality<span class="antiquote">}</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">default_comp</span> <span class="entity">T</span> <span class="main">=</span> absdummy <span class="entity">T</span> <span class="main">(</span>absdummy <span class="entity">T</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">True</span><span class="antiquote">}</span></span><span class="main">)</span> <span class="comment1">(*%_ _. True*)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">register_foreign_equality</span> <span class="entity">T</span> <span class="entity">comp</span> <span class="entity">comp_thm</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tyco</span> <span class="main">=</span> <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">T</span> <span class="keyword2"><span class="keyword">of</span></span> Type <span class="main">(</span><span class="entity">tyco</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">tyco</span> <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> error <span class="inner_quoted">"expected type constant with no arguments"</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> equalityD2<span class="antiquote">}</span></span></span> OF <span class="main">[</span><span class="entity">comp_thm</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">register_foreign_partial_and_full_equality</span>
      <span class="entity">tyco</span> <span class="main">(</span><span class="entity">HOLogic.id_const</span> <span class="entity">T</span><span class="main">)</span> <span class="entity">comp</span> <span class="entity">comp</span> NONE NONE <span class="entity">eq</span> <span class="entity">comp_thm</span> <span class="main">[</span><span class="main">]</span> <span class="entity">lthy</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">register_equality_of</span> <span class="entity">tyco</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">T</span><span class="main">,</span><span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">typ_and_vs_of_typname</span> <span class="main">(</span>Proof_Context.theory_of <span class="entity">lthy</span><span class="main">)</span> <span class="entity">tyco</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">type</span><span class="antiquote">}</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">comp</span> <span class="main">=</span> <span class="entity">HOLogic.eq_const</span> <span class="entity">T</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">comp_thm</span> <span class="main">=</span> Thm.instantiate' <span class="main">[</span>SOME <span class="main">(</span>Thm.ctyp_of <span class="entity">lthy</span> <span class="entity">T</span><span class="main">)</span><span class="main">]</span>
      <span class="main">[</span><span class="main">]</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> eq_equality<span class="antiquote">}</span></span></span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">register_foreign_equality</span> <span class="entity">T</span> <span class="entity">comp</span> <span class="entity">comp_thm</span> <span class="entity">lthy</span> <span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">generate_equalitys_from_bnf_fp</span> <span class="entity">tyco</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">tycos</span><span class="main">,</span> <span class="entity">Ts</span><span class="main">)</span> <span class="main">=</span> <span class="entity">mutual_recursive_types</span> <span class="entity">tyco</span> <span class="entity">lthy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">tyco</span> <span class="main">=&gt;</span> <span class="inner_quoted">"generating equality for type "</span> ^ quote <span class="entity">tyco</span><span class="main">)</span> <span class="entity">tycos</span>
      |&gt; cat_lines |&gt; writeln
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">tfrees</span><span class="main">,</span> <span class="entity">used_tfrees</span><span class="main">)</span> <span class="main">=</span> <span class="entity">type_parameters</span> <span class="main">(</span>hd <span class="entity">Ts</span><span class="main">)</span> <span class="entity">lthy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">used_positions</span> <span class="main">=</span> map <span class="main">(</span>member <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">used_tfrees</span> o TFree<span class="main">)</span> <span class="entity">tfrees</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cs</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">subT</span> <span class="inner_quoted">"eq"</span><span class="main">)</span> <span class="entity">used_tfrees</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">comp_Ts</span> <span class="main">=</span> map <span class="entity">compT</span> <span class="entity">used_tfrees</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg_comps</span> <span class="main">=</span> map Free <span class="main">(</span><span class="entity">cs</span> ~~ <span class="entity">comp_Ts</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dep_tycos</span> <span class="main">=</span> fold <span class="main">(</span><span class="entity">add_used_tycos</span> <span class="entity">lthy</span><span class="main">)</span> <span class="entity">tycos</span> <span class="main">[</span><span class="main">]</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">XTys</span> <span class="main">=</span> <span class="entity">Bnf_Access.bnf_types</span> <span class="entity">lthy</span> <span class="entity">tycos</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inst_types</span> <span class="main">=</span> typ_subst_atomic <span class="main">(</span><span class="entity">XTys</span> ~~ <span class="entity">Ts</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cTys</span> <span class="main">=</span> map <span class="main">(</span>map <span class="main">(</span>map <span class="entity">inst_types</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="entity">Bnf_Access.constr_argument_types</span> <span class="entity">lthy</span> <span class="entity">tycos</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">map_simps</span> <span class="main">=</span> <span class="entity">Bnf_Access.map_simps</span> <span class="entity">lthy</span> <span class="entity">tycos</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">case_simps</span> <span class="main">=</span> <span class="entity">Bnf_Access.case_simps</span> <span class="entity">lthy</span> <span class="entity">tycos</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">maps</span> <span class="main">=</span> <span class="entity">Bnf_Access.map_terms</span> <span class="entity">lthy</span> <span class="entity">tycos</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">map_comp_thms</span> <span class="main">=</span> <span class="entity">Bnf_Access.map_comps</span> <span class="entity">lthy</span> <span class="entity">tycos</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t_ixs</span> <span class="main">=</span> <span class="inner_numeral">0</span> upto <span class="main">(</span>length <span class="entity">Ts</span> - <span class="inner_numeral">1</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">compNs</span> <span class="main">=</span>
      <span class="comment1">(*TODO: clashes in presence of same type names in different theories*)</span>
      map <span class="main">(</span>Long_Name.base_name<span class="main">)</span> <span class="entity">tycos</span>
      |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">s</span> <span class="main">=&gt;</span> <span class="inner_quoted">"equality_"</span> ^ <span class="entity">s</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">gen_vars</span> <span class="entity">prefix</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span> <span class="entity">pty</span><span class="main">)</span> <span class="main">=&gt;</span> Free <span class="main">(</span><span class="entity">prefix</span> ^ <span class="entity">ints_to_subscript</span> <span class="main">[</span><span class="entity">i</span><span class="main">]</span><span class="main">,</span> <span class="entity">pty</span><span class="main">)</span><span class="main">)</span>
      <span class="main">(</span><span class="entity">t_ixs</span> ~~ <span class="entity">Ts</span><span class="main">)</span>

    <span class="comment1">(* primrec definitions of partial equalitys *)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_pcomp</span> <span class="main">(</span><span class="entity">tyco</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="inner_quoted">"partial_equality_"</span> ^ Long_Name.base_name <span class="entity">tyco</span><span class="main">,</span> <span class="entity">pcompT</span> <span class="entity">T</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">constr_terms</span> <span class="entity">lthy</span> <span class="main">=</span>
      <span class="entity">Bnf_Access.constr_terms</span> <span class="entity">lthy</span>
      #&gt; map <span class="main">(</span>apsnd <span class="main">(</span>map <span class="entity">freeify_tvars</span> o fst o strip_type<span class="main">)</span> o dest_Const<span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">generate_pcomp_eqs</span> <span class="entity">lthy</span> <span class="main">(</span><span class="entity">tyco</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">constrs</span> <span class="main">=</span> <span class="entity">constr_terms</span> <span class="entity">lthy</span> <span class="entity">tyco</span>

        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">comp_arg</span> <span class="entity">T</span> <span class="entity">x</span> <span class="entity">y</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">m</span> <span class="main">=</span> <span class="entity">Generator_Aux.create_map</span> <span class="entity">default_comp</span> <span class="main">(</span>K o Free o <span class="entity">mk_pcomp</span><span class="main">)</span> <span class="main">(</span><span class="main">)</span> <span class="main">(</span>K false<span class="main">)</span>
              <span class="main">(</span><span class="main">#</span>used_positions oo <span class="entity">the_info</span><span class="main">)</span> <span class="main">(</span><span class="main">#</span>map oo <span class="entity">the_info</span><span class="main">)</span> <span class="main">(</span>K o <span class="main">#</span>pequality oo <span class="entity">the_info</span><span class="main">)</span>
              <span class="entity">tycos</span> <span class="main">(</span><span class="main">(</span>K o K<span class="main">)</span> <span class="main">(</span><span class="main">)</span><span class="main">)</span> <span class="entity">T</span> <span class="entity">lthy</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">p</span> <span class="main">=</span> <span class="entity">Generator_Aux.create_partial</span> <span class="main">(</span><span class="main">)</span> <span class="main">(</span>K false<span class="main">)</span>
              <span class="main">(</span><span class="main">#</span>used_positions oo <span class="entity">the_info</span><span class="main">)</span> <span class="main">(</span><span class="main">#</span>map oo <span class="entity">the_info</span><span class="main">)</span> <span class="main">(</span>K o <span class="main">#</span>pequality oo <span class="entity">the_info</span><span class="main">)</span>
              <span class="entity">tycos</span> <span class="main">(</span><span class="main">(</span>K o K<span class="main">)</span> <span class="main">(</span><span class="main">)</span><span class="main">)</span> <span class="entity">T</span> <span class="entity">lthy</span>
          <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">p</span> $ <span class="main">(</span><span class="entity">m</span> $ <span class="entity">x</span><span class="main">)</span> $ <span class="entity">y</span> |&gt; <span class="entity">infer_type</span> <span class="entity">lthy</span> <span class="keyword2"><span class="keyword">end</span></span>

        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">generate_eq</span> <span class="entity">lthy</span> <span class="main">(</span><span class="entity">c_T</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">(</span><span class="entity">cN</span><span class="main">,</span> <span class="entity">Ts</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg_Ts'</span> <span class="main">=</span> map <span class="entity">orderify</span> <span class="entity">Ts</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">c</span> <span class="main">=</span> Const <span class="main">(</span><span class="entity">cN</span><span class="main">,</span> <span class="entity">arg_Ts'</span> ---&gt; <span class="entity">orderify</span> <span class="entity">T</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">y</span><span class="main">,</span> <span class="main">(</span><span class="entity">xs</span><span class="main">,</span> <span class="entity">ys</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Name.variant <span class="inner_quoted">"y"</span> <span class="main">(</span>Variable.names_of <span class="entity">lthy</span><span class="main">)</span> |&gt;&gt; Free o rpair <span class="entity">T</span>
              ||&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> Name.invent_names <span class="entity">ctxt</span> <span class="inner_quoted">"x"</span> <span class="main">(</span><span class="entity">arg_Ts'</span> @ <span class="entity">Ts</span><span class="main">)</span> |&gt; map Free<span class="main">)</span>
              ||&gt; chop <span class="main">(</span>length <span class="entity">Ts</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">k</span> <span class="main">=</span> find_index <span class="main">(</span>curry <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">c_T</span><span class="main">)</span> <span class="entity">constrs</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cases</span> <span class="main">=</span> <span class="entity">constrs</span> |&gt; map_index <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">Ts'</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span>
              <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">i</span> &lt; <span class="entity">k</span> <span class="keyword2"><span class="keyword">then</span></span> fold_rev absdummy <span class="entity">Ts'</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">False</span><span class="antiquote">}</span></span>
              <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">k</span> &lt; <span class="entity">i</span> <span class="keyword2"><span class="keyword">then</span></span> fold_rev absdummy <span class="entity">Ts'</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">False</span><span class="antiquote">}</span></span>
              <span class="keyword2"><span class="keyword">else</span></span>
                <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">list_all_eq</span><span class="antiquote">}</span></span> $ <span class="entity">HOLogic.mk_list</span> <span class="entity">boolT</span> <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">map</span> 3<span class="antiquote">}</span></span></span> <span class="entity">comp_arg</span> <span class="entity">Ts</span> <span class="entity">xs</span> <span class="entity">ys</span><span class="main">)</span>
                |&gt; <span class="entity">lambdas</span> <span class="entity">ys</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs</span> <span class="main">=</span> Free <span class="main">(</span><span class="entity">mk_pcomp</span> <span class="main">(</span><span class="entity">tyco</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span> $ list_comb <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">xs</span><span class="main">)</span> $ <span class="entity">y</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span> list_comb <span class="main">(</span>singleton <span class="main">(</span><span class="entity">Bnf_Access.case_consts</span> <span class="entity">lthy</span><span class="main">)</span> <span class="entity">tyco</span><span class="main">,</span> <span class="entity">cases</span><span class="main">)</span> $ <span class="entity">y</span>
          <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span><span class="main">)</span> |&gt; <span class="entity">infer_type</span> <span class="entity">lthy</span> <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword2"><span class="keyword">in</span></span> map <span class="main">(</span><span class="entity">generate_eq</span> <span class="entity">lthy</span><span class="main">)</span> <span class="entity">constrs</span> <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eqs</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">generate_pcomp_eqs</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">(</span><span class="entity">tycos</span> ~~ <span class="entity">Ts</span><span class="main">)</span> |&gt; flat
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">bindings</span> <span class="main">=</span> <span class="entity">tycos</span> ~~ <span class="entity">Ts</span> |&gt; map <span class="entity">mk_pcomp</span>
      |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span>Binding.name <span class="entity">name</span><span class="main">,</span> SOME <span class="entity">T</span><span class="main">,</span> NoSyn<span class="main">)</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">pcomps</span><span class="main">,</span> <span class="entity">pcomp_simps</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">lthy</span>
      |&gt; Local_Theory.begin_nested
      |&gt; snd
      |&gt; <span class="main">(</span><span class="entity">BNF_LFP_Rec_Sugar.primrec</span> false <span class="main">[</span><span class="main">]</span> <span class="entity">bindings</span>
          <span class="main">(</span>map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">(</span>Binding.empty_atts<span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="entity">eqs</span><span class="main">)</span><span class="main">)</span>
      |&gt; Local_Theory.end_nested_result
          <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">phi</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">pcomps</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">pcomp_simps</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span>map <span class="main">(</span>Morphism.term <span class="entity">phi</span><span class="main">)</span> <span class="entity">pcomps</span><span class="main">,</span> map <span class="main">(</span>Morphism.fact <span class="entity">phi</span><span class="main">)</span> <span class="entity">pcomp_simps</span><span class="main">)</span><span class="main">)</span>

    <span class="comment1">(* definitions of equalitys via partial equalitys and maps *)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">generate_comp_def</span> <span class="entity">tyco</span> <span class="entity">lthy</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cs</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">subT</span> <span class="inner_quoted">"eq"</span><span class="main">)</span> <span class="entity">used_tfrees</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg_Ts</span> <span class="main">=</span> map <span class="entity">compT</span> <span class="entity">used_tfrees</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span> map Free <span class="main">(</span><span class="entity">cs</span> ~~ <span class="entity">arg_Ts</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">pcomp</span><span class="main">,</span> <span class="entity">m</span><span class="main">)</span> <span class="main">=</span> AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">(</span><span class="entity">tycos</span> ~~ <span class="main">(</span><span class="entity">pcomps</span> ~~ <span class="entity">maps</span><span class="main">)</span><span class="main">)</span> <span class="entity">tyco</span> |&gt; the
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ts</span> <span class="main">=</span> <span class="entity">tfrees</span> |&gt; map TFree |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">T</span> <span class="main">=&gt;</span>
          AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">(</span><span class="entity">used_tfrees</span> ~~ <span class="entity">args</span><span class="main">)</span> <span class="entity">T</span> |&gt; the_default <span class="main">(</span><span class="entity">default_comp</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span> <span class="entity">HOLogic.mk_comp</span> <span class="main">(</span><span class="entity">pcomp</span><span class="main">,</span> list_comb <span class="main">(</span><span class="entity">m</span><span class="main">,</span> <span class="entity">ts</span><span class="main">)</span><span class="main">)</span> |&gt; <span class="entity">infer_type</span> <span class="entity">lthy</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">abs_def</span> <span class="main">=</span> <span class="entity">lambdas</span> <span class="entity">args</span> <span class="entity">rhs</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">name</span> <span class="main">=</span> <span class="inner_quoted">"equality_"</span> ^ Long_Name.base_name <span class="entity">tyco</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">comp</span><span class="main">,</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">prethm</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span>
          Local_Theory.define <span class="main">(</span><span class="main">(</span>Binding.name <span class="entity">name</span><span class="main">,</span> NoSyn<span class="main">)</span><span class="main">,</span> <span class="main">(</span>Binding.empty_atts<span class="main">,</span> <span class="entity">abs_def</span><span class="main">)</span><span class="main">)</span> <span class="entity">lthy</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq</span> <span class="main">=</span> Logic.mk_equals <span class="main">(</span>list_comb <span class="main">(</span><span class="entity">comp</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm</span> <span class="main">=</span> Goal.prove <span class="entity">lthy</span> <span class="main">(</span>map <span class="main">(</span>fst o dest_Free<span class="main">)</span> <span class="entity">args</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span> <span class="entity">eq</span> <span class="main">(</span>K <span class="main">(</span><span class="entity">unfold_tac</span> <span class="entity">lthy</span> <span class="main">[</span><span class="entity">prethm</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        Local_Theory.note <span class="main">(</span><span class="main">(</span>Binding.name <span class="main">(</span><span class="entity">name</span> ^ <span class="inner_quoted">"_def"</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="entity">thm</span><span class="main">]</span><span class="main">)</span> <span class="entity">lthy</span>
        |&gt;&gt; the_single o snd
        |&gt;&gt; `<span class="main">(</span>K <span class="entity">comp</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">comps</span><span class="main">,</span> <span class="entity">comp_defs</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">lthy</span>
      |&gt; Local_Theory.begin_nested
      |&gt; snd
      |&gt; fold_map <span class="entity">generate_comp_def</span> <span class="entity">tycos</span>
      |&gt;&gt; split_list
      |&gt; Local_Theory.end_nested_result
        <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">phi</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">comps</span><span class="main">,</span> <span class="entity">comp_defs</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span>map <span class="main">(</span>Morphism.term <span class="entity">phi</span><span class="main">)</span> <span class="entity">comps</span><span class="main">,</span> map <span class="main">(</span>Morphism.thm <span class="entity">phi</span><span class="main">)</span> <span class="entity">comp_defs</span><span class="main">)</span><span class="main">)</span>

    <span class="comment1">(* alternative simp-rules for equalitys *)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">full_comps</span> <span class="main">=</span> map <span class="main">(</span>list_comb o rpair <span class="entity">arg_comps</span><span class="main">)</span> <span class="entity">comps</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">generate_comp_simps</span> <span class="main">(</span><span class="entity">tyco</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="entity">lthy</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">constrs</span> <span class="main">=</span> <span class="entity">constr_terms</span> <span class="entity">lthy</span> <span class="entity">tyco</span>

        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">comp_arg</span> <span class="entity">T</span> <span class="entity">x</span> <span class="entity">y</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">create_comp</span> <span class="main">(</span><span class="entity">T</span> <span class="keyword1"><span class="keyword">as</span></span> TFree <span class="main">_</span><span class="main">)</span> <span class="main">=</span>
                  AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">(</span><span class="entity">used_tfrees</span> ~~ <span class="entity">arg_comps</span><span class="main">)</span> <span class="entity">T</span>
                  |&gt; the_default <span class="main">(</span><span class="entity">HOLogic.id_const</span> dummyT<span class="main">)</span>
              <span class="main">|</span> <span class="entity">create_comp</span> <span class="main">(</span>Type <span class="main">(</span><span class="entity">tyco</span><span class="main">,</span> <span class="entity">Ts</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
                  <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">(</span><span class="entity">tycos</span> ~~ <span class="entity">comps</span><span class="main">)</span> <span class="entity">tyco</span> <span class="keyword2"><span class="keyword">of</span></span>
                    SOME <span class="entity">c</span> <span class="main">=&gt;</span> list_comb <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">arg_comps</span><span class="main">)</span>
                  <span class="main">|</span> NONE <span class="main">=&gt;</span>
                      <span class="keyword2"><span class="keyword">let</span></span>
                        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span>equality <span class="main">=</span> <span class="entity">c</span><span class="main">,</span> used_positions <span class="main">=</span> <span class="entity">up</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">the_info</span> <span class="entity">lthy</span> <span class="entity">tyco</span>
                        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ts</span> <span class="main">=</span> <span class="main">(</span><span class="entity">up</span> ~~ <span class="entity">Ts</span><span class="main">)</span> |&gt; map_filter <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">b</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="main">=&gt;</span>
                          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">b</span> <span class="keyword2"><span class="keyword">then</span></span> SOME <span class="main">(</span><span class="entity">create_comp</span> <span class="entity">T</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> NONE<span class="main">)</span>
                      <span class="keyword2"><span class="keyword">in</span></span> list_comb <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">ts</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>
              <span class="main">|</span> <span class="entity">create_comp</span> <span class="entity">T</span> <span class="main">=</span>
                  error <span class="main">(</span><span class="inner_quoted">"unexpected schematic variable "</span> ^ quote <span class="main">(</span>Syntax.string_of_typ <span class="entity">lthy</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">comp</span> <span class="main">=</span> <span class="entity">create_comp</span> <span class="entity">T</span>
          <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">comp</span> $ <span class="entity">x</span> $ <span class="entity">y</span> |&gt; <span class="entity">infer_type</span> <span class="entity">lthy</span> <span class="keyword2"><span class="keyword">end</span></span>

        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">generate_eq_thm</span> <span class="entity">lthy</span> <span class="main">(</span><span class="entity">c_T</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">Ts</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">xs</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="main">=</span> Variable.names_of <span class="entity">lthy</span>
              |&gt; fold_map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">T</span> <span class="main">=&gt;</span> Name.variant <span class="inner_quoted">"x"</span> #&gt;&gt; Free o rpair <span class="entity">T</span><span class="main">)</span> <span class="entity">Ts</span>
            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_const</span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">Ts</span><span class="main">)</span> <span class="main">=</span> Const <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">Ts</span> ---&gt; <span class="entity">T</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">comp_const</span> <span class="main">=</span> AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">(</span><span class="entity">tycos</span> ~~ <span class="entity">comps</span><span class="main">)</span> <span class="entity">tyco</span> |&gt; the
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs</span> <span class="main">=</span> list_comb <span class="main">(</span><span class="entity">comp_const</span><span class="main">,</span> <span class="entity">arg_comps</span><span class="main">)</span> $ list_comb <span class="main">(</span><span class="entity">mk_const</span> <span class="entity">c_T</span><span class="main">,</span> <span class="entity">xs</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">k</span> <span class="main">=</span> find_index <span class="main">(</span>curry <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">c_T</span><span class="main">)</span> <span class="entity">constrs</span>

            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_eq</span> <span class="entity">c</span> <span class="entity">ys</span> <span class="entity">rhs</span> <span class="main">=</span>
              <span class="keyword2"><span class="keyword">let</span></span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">y</span> <span class="main">=</span> list_comb <span class="main">(</span><span class="entity">mk_const</span> <span class="entity">c</span><span class="main">,</span> <span class="entity">ys</span><span class="main">)</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq</span> <span class="main">=</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">lhs</span> $ <span class="entity">y</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span><span class="main">)</span>
              <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">ys</span><span class="main">,</span> <span class="entity">eq</span> |&gt; <span class="entity">infer_type</span> <span class="entity">lthy</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>

            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">ys</span><span class="main">,</span> <span class="entity">eqs</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> fold_map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span> <span class="entity">c</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">Ts'</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span>
              <span class="keyword2"><span class="keyword">let</span></span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">ys</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="main">=</span> fold_map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">T</span> <span class="main">=&gt;</span> Name.variant <span class="inner_quoted">"y"</span> #&gt;&gt; Free o rpair <span class="entity">T</span><span class="main">)</span> <span class="entity">Ts'</span> <span class="entity">ctxt</span>
              <span class="keyword2"><span class="keyword">in</span></span>
                <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">i</span> &lt; <span class="entity">k</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">mk_eq</span> <span class="entity">c</span> <span class="entity">ys</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">False</span><span class="antiquote">}</span></span>
                <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">k</span> &lt; <span class="entity">i</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">mk_eq</span> <span class="entity">c</span> <span class="entity">ys</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">False</span><span class="antiquote">}</span></span>
                <span class="keyword2"><span class="keyword">else</span></span>
                  <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">list_all_eq</span><span class="antiquote">}</span></span> $ <span class="entity">HOLogic.mk_list</span> <span class="entity">boolT</span> <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">map</span> 3<span class="antiquote">}</span></span></span> <span class="entity">comp_arg</span> <span class="entity">Ts</span> <span class="entity">xs</span> <span class="entity">ys</span><span class="main">)</span>
                  |&gt; <span class="entity">mk_eq</span> <span class="entity">c</span> <span class="entity">ys</span><span class="main">,</span>
                <span class="entity">ctxt</span><span class="main">)</span>
              <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span> <span class="main">(</span>tag_list <span class="inner_numeral">0</span> <span class="entity">constrs</span><span class="main">)</span> <span class="entity">ctxt</span>
              |&gt; apfst <span class="main">(</span>apfst flat o split_list<span class="main">)</span>

            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dep_comp_defs</span> <span class="main">=</span> map_filter <span class="main">(</span><span class="main">#</span>equality_def o <span class="entity">the_info</span> <span class="entity">lthy</span><span class="main">)</span> <span class="entity">dep_tycos</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dep_map_comps</span> <span class="main">=</span> map_filter <span class="main">(</span><span class="main">#</span>map_comp o <span class="entity">the_info</span> <span class="entity">lthy</span><span class="main">)</span> <span class="entity">dep_tycos</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thms</span> <span class="main">=</span> <span class="entity">prove_multi_future</span> <span class="entity">lthy</span> <span class="main">(</span>map <span class="main">(</span>fst o dest_Free<span class="main">)</span> <span class="main">(</span><span class="entity">xs</span> @ <span class="entity">ys</span><span class="main">)</span> @ <span class="entity">cs</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span> <span class="entity">eqs</span>
              <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
                Goal.conjunction_tac <span class="inner_numeral">1</span>
                THEN <span class="entity">unfold_tac</span> <span class="entity">ctxt</span>
                  <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> id_apply o_def<span class="antiquote">}</span></span></span> @
                    flat <span class="entity">case_simps</span> @
                    flat <span class="entity">pcomp_simps</span> @
                    <span class="entity">dep_map_comps</span> @ <span class="entity">comp_defs</span> @ <span class="entity">dep_comp_defs</span> @ flat <span class="entity">map_simps</span><span class="main">)</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">thms</span> <span class="keyword2"><span class="keyword">end</span></span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thms</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">generate_eq_thm</span> <span class="entity">lthy</span><span class="main">)</span> <span class="entity">constrs</span> |&gt; flat
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simp_thms</span> <span class="main">=</span> map <span class="main">(</span>Local_Defs.unfold <span class="entity">lthy</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> list_all_eq_unfold<span class="antiquote">}</span></span></span><span class="main">)</span> <span class="entity">thms</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">name</span> <span class="main">=</span> <span class="inner_quoted">"equality_"</span> ^ Long_Name.base_name <span class="entity">tyco</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="entity">lthy</span>
        |&gt; Local_Theory.note <span class="main">(</span><span class="main">(</span>Binding.name <span class="main">(</span><span class="entity">name</span> ^ <span class="inner_quoted">"_simps"</span><span class="main">)</span><span class="main">,</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">attributes</span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">code</span><span class="main">]</span><span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">,</span> <span class="entity">simp_thms</span><span class="main">)</span>
        |&gt; snd
        |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">lthy</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">thms</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">comp_simps</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">lthy</span>
      |&gt; Local_Theory.begin_nested
      |&gt; snd
      |&gt; fold_map <span class="entity">generate_comp_simps</span> <span class="main">(</span><span class="entity">tycos</span> ~~ <span class="entity">Ts</span><span class="main">)</span>
      |&gt; Local_Theory.end_nested_result <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">phi</span> <span class="main">=&gt;</span> map <span class="main">(</span>Morphism.fact <span class="entity">phi</span><span class="main">)</span><span class="main">)</span>

    <span class="comment1">(* partial theorems *)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">set_funs</span> <span class="main">=</span> <span class="entity">Bnf_Access.set_terms</span> <span class="entity">lthy</span> <span class="entity">tycos</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">x_vars</span> <span class="main">=</span> <span class="entity">gen_vars</span> <span class="inner_quoted">"x"</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">free_names</span> <span class="main">=</span> map <span class="main">(</span>fst o dest_Free<span class="main">)</span> <span class="main">(</span><span class="entity">x_vars</span> @ <span class="entity">arg_comps</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">xi_vars</span> <span class="main">=</span> map_index <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span>
      map_index <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">j</span><span class="main">,</span> <span class="entity">pty</span><span class="main">)</span> <span class="main">=&gt;</span> Free <span class="main">(</span><span class="inner_quoted">"x"</span> ^ <span class="entity">ints_to_subscript</span> <span class="main">[</span><span class="entity">i</span><span class="main">,</span> <span class="entity">j</span><span class="main">]</span><span class="main">,</span> <span class="entity">pty</span><span class="main">)</span><span class="main">)</span> <span class="entity">used_tfrees</span><span class="main">)</span> <span class="entity">Ts</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_eq_thm'</span> <span class="entity">mk_eq'</span> <span class="main">=</span> map_index <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span> <span class="main">(</span><span class="main">(</span><span class="entity">set_funs</span><span class="main">,</span> <span class="entity">x</span><span class="main">)</span><span class="main">,</span> <span class="entity">xis</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">create_cond</span> <span class="main">(</span><span class="main">(</span><span class="entity">set_t</span><span class="main">,</span> <span class="entity">xi</span><span class="main">)</span><span class="main">,</span> <span class="entity">c</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span> <span class="entity">mk_eq'</span> <span class="entity">lthy</span> <span class="entity">c</span> $ <span class="entity">xi</span> |&gt; <span class="entity">HOLogic.mk_Trueprop</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs</span> <span class="main">=</span> <span class="entity">HOLogic.mk_mem</span> <span class="main">(</span><span class="entity">xi</span><span class="main">,</span> <span class="entity">set_t</span> $ <span class="entity">x</span><span class="main">)</span> |&gt; <span class="entity">HOLogic.mk_Trueprop</span>
          <span class="keyword2"><span class="keyword">in</span></span> Logic.all <span class="entity">xi</span> <span class="main">(</span>Logic.mk_implies <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">used_sets</span> <span class="main">=</span> map <span class="main">(</span>the o AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">(</span>map TFree <span class="entity">tfrees</span> ~~ <span class="entity">set_funs</span><span class="main">)</span><span class="main">)</span> <span class="entity">used_tfrees</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">conds</span> <span class="main">=</span> map <span class="entity">create_cond</span> <span class="main">(</span><span class="entity">used_sets</span> ~~ <span class="entity">xis</span> ~~ <span class="entity">arg_comps</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">concl</span> <span class="main">=</span> <span class="entity">mk_eq'</span> <span class="entity">lthy</span> <span class="main">(</span>nth <span class="entity">full_comps</span> <span class="entity">i</span><span class="main">)</span> $ <span class="entity">x</span> |&gt; <span class="entity">HOLogic.mk_Trueprop</span>
      <span class="keyword2"><span class="keyword">in</span></span> Logic.list_implies <span class="main">(</span><span class="entity">conds</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span> |&gt; <span class="entity">infer_type</span> <span class="entity">lthy</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span> <span class="main">(</span><span class="entity">set_funs</span> ~~ <span class="entity">x_vars</span> ~~ <span class="entity">xi_vars</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">induct_thms</span> <span class="main">=</span> <span class="entity">Bnf_Access.induct_thms</span> <span class="entity">lthy</span> <span class="entity">tycos</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">set_simps</span> <span class="main">=</span> <span class="entity">Bnf_Access.set_simps</span> <span class="entity">lthy</span> <span class="entity">tycos</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">case_thms</span> <span class="main">=</span> <span class="entity">Bnf_Access.case_thms</span> <span class="entity">lthy</span> <span class="entity">tycos</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">distinct_thms</span> <span class="main">=</span> <span class="entity">Bnf_Access.distinct_thms</span> <span class="entity">lthy</span> <span class="entity">tycos</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inject_thms</span> <span class="main">=</span> <span class="entity">Bnf_Access.inject_thms</span> <span class="entity">lthy</span> <span class="entity">tycos</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rec_info</span> <span class="main">=</span> <span class="main">(</span><span class="entity">the_info</span> <span class="entity">lthy</span><span class="main">,</span> <span class="main">#</span>used_positions<span class="main">,</span> <span class="entity">tycos</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">split_IHs</span> <span class="main">=</span> <span class="entity">split_IHs</span> <span class="entity">rec_info</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">unknown_value</span> <span class="main">=</span> false <span class="comment1">(* effect of choosing false / true not yet visible *)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">induct_tac</span> <span class="entity">ctxt</span> <span class="entity">f</span> <span class="main">=</span>
      <span class="main">(</span><span class="main">(</span>DETERM o <span class="entity">Induction.induction_tac</span> <span class="entity">ctxt</span> false
        <span class="main">(</span>map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span> <span class="main">[</span>SOME <span class="main">(</span>NONE<span class="main">,</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">unknown_value</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="entity">x_vars</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span>SOME <span class="entity">induct_thms</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
      THEN_ALL_NEW <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">i</span> <span class="main">=&gt;</span>
        <span class="entity">Subgoal.SUBPROOF</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> prems <span class="main">=</span> <span class="entity">prems</span><span class="main">,</span> params <span class="main">=</span> <span class="entity">iparams</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
          <span class="entity">f</span> <span class="main">(</span><span class="entity">i</span> - <span class="inner_numeral">1</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="entity">prems</span> <span class="entity">iparams</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="entity">i</span><span class="main">)</span><span class="main">)</span> <span class="inner_numeral">1</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">recursor_tac</span> <span class="main">=</span> <span class="entity">std_recursor_tac</span> <span class="entity">rec_info</span> <span class="entity">used_tfrees</span>
      <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">info</span> <span class="main">=&gt;</span> <span class="main">#</span>partial_equality_thm <span class="entity">info</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">instantiate_IHs</span> <span class="entity">IHs</span> <span class="entity">pre_conds</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">IH</span> <span class="main">=&gt;</span>
      <span class="entity">OF_option</span> <span class="entity">IH</span> <span class="main">(</span>replicate <span class="main">(</span>Thm.nprems_of <span class="entity">IH</span> - length <span class="entity">pre_conds</span><span class="main">)</span> NONE @ map SOME <span class="entity">pre_conds</span><span class="main">)</span><span class="main">)</span> <span class="entity">IHs</span>


    <span class="comment1">(* partial eq-theorem *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">debug_out</span> <span class="inner_quoted">"Partial equality"</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq_thms'</span> <span class="main">=</span> <span class="entity">mk_eq_thm'</span> <span class="entity">mk_pequality</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">eq_solve_tac</span> <span class="entity">i</span> <span class="entity">ctxt</span> <span class="entity">IH_prems</span> <span class="entity">xs</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span> <span class="entity">j</span><span class="main">)</span> <span class="main">=</span> <span class="entity">ind_case_to_idxs</span> <span class="entity">cTys</span> <span class="entity">i</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">k</span> <span class="main">=</span> length <span class="entity">IH_prems</span> - length <span class="entity">arg_comps</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pre_conds</span> <span class="main">=</span> drop <span class="entity">k</span> <span class="entity">IH_prems</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">IH</span> <span class="main">=</span> take <span class="entity">k</span> <span class="entity">IH_prems</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">comp_simps</span> <span class="main">=</span> nth <span class="entity">comp_simps</span> <span class="entity">i</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">case_thm</span> <span class="main">=</span> nth <span class="entity">case_thms</span> <span class="entity">i</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">distinct_thms</span> <span class="main">=</span> nth <span class="entity">distinct_thms</span> <span class="entity">i</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inject_thms</span> <span class="main">=</span> nth <span class="entity">inject_thms</span> <span class="entity">i</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">set_thms</span> <span class="main">=</span> nth <span class="entity">set_simps</span> <span class="entity">i</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="comment1">(* after induction *)</span>
        resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> pequalityI<span class="antiquote">}</span></span></span> <span class="inner_numeral">1</span>
        THEN <span class="entity">Subgoal.FOCUS</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">focus</span> <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">y</span> <span class="main">=</span> <span class="main">#</span>params <span class="entity">focus</span> |&gt; hd
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">yt</span> <span class="main">=</span> <span class="entity">y</span> |&gt; snd |&gt; Thm.term_of
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="main">#</span>context <span class="entity">focus</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pre_cond</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">pre_cond</span> <span class="main">=&gt;</span> Local_Defs.unfold <span class="entity">ctxt</span> <span class="entity">set_thms</span> <span class="entity">pre_cond</span><span class="main">)</span> <span class="entity">pre_conds</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">IH</span> <span class="main">=</span> <span class="entity">instantiate_IHs</span> <span class="entity">IH</span> <span class="entity">pre_cond</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">xs_tys</span> <span class="main">=</span> map <span class="main">(</span>fastype_of o Thm.term_of o snd<span class="main">)</span> <span class="entity">xs</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">IHs</span> <span class="main">=</span> <span class="entity">split_IHs</span> <span class="entity">xs_tys</span> <span class="entity">IH</span>

            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">sub_case_tac</span> <span class="entity">j'</span> <span class="main">(</span><span class="entity">ctxt</span><span class="main">,</span> <span class="entity">y_simp</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span>
              <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">j</span> <span class="main">=</span> <span class="entity">j'</span> <span class="keyword2"><span class="keyword">then</span></span>
                <span class="entity">unfold_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">y_simp</span> @ <span class="entity">comp_simps</span><span class="main">)</span>
                THEN <span class="entity">unfold_tac</span> <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> list_all_eq<span class="antiquote">}</span></span></span>
                THEN <span class="entity">unfold_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> in_set_simps<span class="antiquote">}</span></span></span> @ <span class="entity">inject_thms</span> @ <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> refl_True<span class="antiquote">}</span></span></span><span class="main">)</span>
                THEN <span class="entity">conjI_tac</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> conj_weak_cong<span class="antiquote">}</span></span></span> <span class="entity">ctxt</span> <span class="entity">xs</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt'</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">k</span> <span class="main">=&gt;</span>
                  resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> pequalityD<span class="antiquote">}</span></span></span> <span class="inner_numeral">1</span>
                  THEN <span class="entity">recursor_tac</span> <span class="entity">pre_cond</span> <span class="main">(</span>nth <span class="entity">xs_tys</span> <span class="entity">k</span><span class="main">)</span> <span class="main">(</span>nth <span class="entity">IHs</span> <span class="entity">k</span><span class="main">)</span> <span class="entity">ctxt'</span><span class="main">)</span>
              <span class="keyword2"><span class="keyword">else</span></span>
                <span class="comment1">(* different constructors *)</span>
                <span class="entity">unfold_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">y_simp</span> @ <span class="entity">distinct_thms</span> @ <span class="entity">comp_simps</span> @ <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> bool.simps<span class="antiquote">}</span></span></span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="entity">mk_case_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">[</span>SOME <span class="entity">yt</span><span class="main">]</span><span class="main">]</span> <span class="entity">case_thm</span> <span class="entity">sub_case_tac</span>
          <span class="keyword2"><span class="keyword">end</span></span>
        <span class="main">)</span> <span class="entity">ctxt</span> <span class="inner_numeral">1</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq_thms'</span> <span class="main">=</span> <span class="entity">prove_multi_future</span> <span class="entity">lthy</span> <span class="entity">free_names</span> <span class="main">[</span><span class="main">]</span> <span class="entity">eq_thms'</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
      <span class="entity">induct_tac</span> <span class="entity">ctxt</span> <span class="entity">eq_solve_tac</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">debug_out</span> <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="entity"><span class="antiquote">@{</span><span class="operator">make_string</span><span class="antiquote">}</span></span></span></span> <span class="entity">eq_thms'</span><span class="main">)</span>

    <span class="comment1">(* total theorems *)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_eq_sym_trans_thm</span> <span class="entity">mk_eq_sym_trans</span> <span class="entity">compI2</span> <span class="entity">compE2</span> <span class="entity">thms'</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">conds</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">c</span> <span class="main">=&gt;</span> <span class="entity">mk_eq_sym_trans</span> <span class="entity">lthy</span> <span class="entity">c</span> |&gt; <span class="entity">HOLogic.mk_Trueprop</span><span class="main">)</span> <span class="entity">arg_comps</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thms</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">i</span> <span class="main">=&gt;</span>
           <span class="entity">mk_eq_sym_trans</span> <span class="entity">lthy</span> <span class="main">(</span>nth <span class="entity">full_comps</span> <span class="entity">i</span><span class="main">)</span>
           |&gt; <span class="entity">HOLogic.mk_Trueprop</span>
           |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">concl</span> <span class="main">=&gt;</span> Logic.list_implies <span class="main">(</span><span class="entity">conds</span><span class="main">,</span><span class="entity">concl</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
           <span class="entity">t_ixs</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thms</span> <span class="main">=</span> <span class="entity">prove_multi_future</span> <span class="entity">lthy</span> <span class="entity">free_names</span> <span class="main">[</span><span class="main">]</span> <span class="entity">thms</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
          ALLGOALS Goal.conjunction_tac
          THEN <span class="entity">Method.intros_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> conjI<span class="antiquote">}</span></span></span> :: <span class="entity">compI2</span> :: <span class="entity">thms'</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span>
          THEN ALLGOALS <span class="main">(</span>eresolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">compE2</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">thms</span> <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq_thms</span> <span class="main">=</span> <span class="entity">mk_eq_sym_trans_thm</span> <span class="entity">mk_equality</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> equalityI2<span class="antiquote">}</span></span></span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> equalityD2<span class="antiquote">}</span></span></span> <span class="entity">eq_thms'</span>


    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">debug_out</span> <span class="inner_quoted">"full equality thms"</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_comp_thm</span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span> <span class="entity">e</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">conds</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">c</span> <span class="main">=&gt;</span> <span class="entity">mk_equality</span> <span class="entity">lthy</span> <span class="entity">c</span> |&gt; <span class="entity">HOLogic.mk_Trueprop</span><span class="main">)</span> <span class="entity">arg_comps</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">nearly_thm</span> <span class="main">=</span> <span class="entity">e</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm</span> <span class="main">=</span>
           <span class="entity">mk_equality</span> <span class="entity">lthy</span> <span class="main">(</span>nth <span class="entity">full_comps</span> <span class="entity">i</span><span class="main">)</span>
           |&gt; <span class="entity">HOLogic.mk_Trueprop</span>
           |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">concl</span> <span class="main">=&gt;</span> Logic.list_implies <span class="main">(</span><span class="entity">conds</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        Goal.prove_future <span class="entity">lthy</span> <span class="entity">free_names</span> <span class="main">[</span><span class="main">]</span> <span class="entity">thm</span>
          <span class="main">(</span>K <span class="main">(</span>resolve_tac <span class="entity">lthy</span> <span class="main">[</span><span class="entity">nearly_thm</span><span class="main">]</span> <span class="inner_numeral">1</span> THEN ALLGOALS <span class="main">(</span>assume_tac <span class="entity">lthy</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">comp_thms</span> <span class="main">=</span> map_index <span class="entity">mk_comp_thm</span> <span class="entity">eq_thms</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span> fold_map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">thm</span><span class="main">,</span> <span class="entity">cname</span><span class="main">)</span> <span class="main">=&gt;</span>
      Local_Theory.note <span class="main">(</span><span class="main">(</span>Binding.name <span class="entity">cname</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="entity">thm</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="entity">comp_thms</span> ~~ <span class="entity">compNs</span><span class="main">)</span> <span class="entity">lthy</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">debug_out</span> <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="entity"><span class="antiquote">@{</span><span class="operator">make_string</span><span class="antiquote">}</span></span></span></span> <span class="entity">comp_thms</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span> fold_map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">thm</span><span class="main">,</span> <span class="entity">cname</span><span class="main">)</span> <span class="main">=&gt;</span>
      Local_Theory.note <span class="main">(</span><span class="main">(</span>Binding.name <span class="main">(</span><span class="entity">cname</span> ^ <span class="inner_quoted">"_pointwise"</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="entity">thm</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="entity">eq_thms'</span> ~~ <span class="entity">compNs</span><span class="main">)</span> <span class="entity">lthy</span>

  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="main">(</span><span class="entity">pcomps</span> ~~ <span class="entity">pcomp_simps</span><span class="main">,</span> <span class="entity">comps</span> ~~ <span class="entity">comp_defs</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span>
    ||&gt; fold <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">tyco</span><span class="main">,</span> <span class="entity">map</span><span class="main">)</span><span class="main">,</span> <span class="entity">pcomp</span><span class="main">)</span><span class="main">,</span> <span class="entity">comp</span><span class="main">)</span><span class="main">,</span> <span class="entity">comp_def</span><span class="main">)</span><span class="main">,</span> <span class="entity">map_comp</span><span class="main">)</span> <span class="main">,</span> <span class="entity">peq_thm</span><span class="main">)</span><span class="main">,</span> <span class="entity">comp_thm</span><span class="main">)</span> <span class="main">=&gt;</span>
          <span class="entity">declare_info</span> <span class="entity">tyco</span> <span class="entity">map</span> <span class="entity">pcomp</span> <span class="entity">comp</span> <span class="main">(</span>SOME <span class="entity">comp_def</span><span class="main">)</span> <span class="main">(</span>SOME <span class="entity">map_comp</span><span class="main">)</span>
            <span class="entity">peq_thm</span> <span class="entity">comp_thm</span> <span class="entity">used_positions</span><span class="main">)</span>
         <span class="main">(</span><span class="entity">tycos</span> ~~ <span class="entity">maps</span> ~~ <span class="entity">pcomps</span> ~~ <span class="entity">comps</span> ~~ <span class="entity">comp_defs</span> ~~ <span class="entity">map_comp_thms</span> ~~ <span class="entity">eq_thms'</span> ~~ <span class="entity">comp_thms</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">generate_equality</span> <span class="entity">gen_type</span> <span class="entity">tyco</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> is_some <span class="main">(</span><span class="entity">get_info</span> <span class="entity">lthy</span> <span class="entity">tyco</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">andalso</span></span> error <span class="main">(</span><span class="inner_quoted">"type "</span> ^ quote <span class="entity">tyco</span> ^ <span class="inner_quoted">" does already have a equality"</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">gen_type</span> <span class="keyword2"><span class="keyword">of</span></span>
      <span class="entity">BNF</span> <span class="main">=&gt;</span> <span class="entity">generate_equalitys_from_bnf_fp</span> <span class="entity">tyco</span> <span class="entity">lthy</span> |&gt; snd
    <span class="main">|</span> <span class="entity">EQ</span> <span class="main">=&gt;</span> <span class="entity">register_equality_of</span> <span class="entity">tyco</span> <span class="entity">lthy</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ensure_info</span> <span class="entity">gen_type</span> <span class="entity">tyco</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">get_info</span> <span class="entity">lthy</span> <span class="entity">tyco</span> <span class="keyword2"><span class="keyword">of</span></span>
    SOME <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">lthy</span>
  <span class="main">|</span> NONE <span class="main">=&gt;</span> <span class="entity">generate_equality</span> <span class="entity">gen_type</span> <span class="entity">tyco</span> <span class="entity">lthy</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">generate_equality_cmd</span> <span class="entity">tyco</span> <span class="entity">param</span> <span class="main">=</span> <span class="entity">Named_Target.theory_map</span> <span class="main">(</span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">param</span> <span class="main">=</span> <span class="inner_quoted">"eq"</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">generate_equality</span> <span class="entity">EQ</span> <span class="entity">tyco</span>
  <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">param</span> <span class="main">=</span> <span class="inner_quoted">""</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">generate_equality</span> <span class="entity">BNF</span> <span class="entity">tyco</span>
  <span class="keyword2"><span class="keyword">else</span></span> error <span class="main">(</span><span class="inner_quoted">"unknown parameter, expecting no parameter for BNF-datatypes, "</span> ^
         <span class="inner_quoted">"or \"eq\" for types where the built-in equality \"=\" should be used."</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  Theory.setup
    <span class="main">(</span><span class="entity">Derive_Manager.register_derive</span> <span class="inner_quoted">"equality"</span> <span class="inner_quoted">"generate an equality function, options are () and (eq)"</span> <span class="entity">generate_equality_cmd</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Equality_Instances">
<div class="head">
<h1>Theory Equality_Instances</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Deriving class instances for datatypes
    Author:      Christian Sternagel and René Thiemann  &lt;christian.sternagel|rene.thiemann@uibk.ac.at&gt;
    Maintainer:  Christian Sternagel and René Thiemann 
    License:     LGPL
*)</span>
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Defining Equality-Functions for Common Types›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Equality_Instances
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Equality_Generator.html">Equality_Generator</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹For all of the following types, we register equality-functions.
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> int<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> integer<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> nat<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> char<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> bool<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> unit<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> sum<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> option<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> list<span class="antiquote"><span class="antiquote">}</span></span></span></span>,
  and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> prod<span class="antiquote"><span class="antiquote">}</span></span></span></span>. For types without type parameters, we use plain <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(=)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, and for the 
  others we use generated ones. These functions will be essential, when the generator is later on
  invoked on types, which in their definition use one these types.›</span></span>

<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>eq<span class="main">)</span> equality <span class="quoted">int</span> <span class="quoted">integer</span> <span class="quoted">nat</span> <span class="quoted">char</span> <span class="quoted">bool</span> <span class="quoted">unit</span>
<span class="keyword1"><span class="command">derive</span></span> equality <span class="quoted">sum</span> <span class="quoted">list</span> <span class="quoted">prod</span> <span class="quoted">option</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Hash_Generator">
<div class="head">
<h1>Theory Hash_Generator</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Deriving class instances for datatypes
    Author:      Christian Sternagel and René Thiemann  &lt;christian.sternagel|rene.thiemann@uibk.ac.at&gt;
    Maintainer:  Christian Sternagel and René Thiemann 
    License:     LGPL
*)</span>
<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Generating Hash-Functions›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Hash_Generator
<span class="keyword2"><span class="keyword">imports</span></span>
  <span class="quoted">"<a href="Generator_Aux.html">../Generator_Aux</a>"</span>
  <span class="quoted">"<a href="Derive_Manager.html">../Derive_Manager</a>"</span>
  <a href="../Collections/HashCode.html">Collections.HashCode</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹As usual, in the generator we use a dedicated function to combine the results
  from evaluating the hash-function of the arguments of a constructor, to deliver
  the global hash-value.›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">hash_combine</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"hashcode list <span class="main">⇒</span> hashcode list <span class="main">⇒</span> hashcode"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">hash_combine</span> <span class="main">[]</span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">]</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">hash_combine</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">z</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">zs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">*</span> <span class="free"><span class="bound"><span class="entity">z</span></span></span> <span class="main">+</span> <span class="free">hash_combine</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="free"><span class="bound"><span class="entity">zs</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">hash_combine</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> <span class="main">0</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The first argument of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> hash_combine<span class="antiquote"><span class="antiquote">}</span></span></span></span> originates from evaluating the hash-function 
  on the arguments of a constructor, and the second argument of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> hash_combine<span class="antiquote"><span class="antiquote">}</span></span></span></span> will be static \emph{magic} numbers
  which are generated within the generator.›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Improved Code for Non-Lazy Languages›</span></span>

<span class="keyword1" id="Hash_Generator-hash_combine_unfold"><span class="command">lemma</span></span> hash_combine_unfold<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"hash_combine <span class="main">[]</span> <span class="main">[</span><span class="free">x</span><span class="main">]</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="quoted"><span class="quoted">"hash_combine <span class="main">(</span><span class="free">y</span> <span class="main">#</span> <span class="free">ys</span><span class="main">)</span> <span class="main">(</span><span class="free">z</span> <span class="main">#</span> <span class="free">zs</span><span class="main">)</span> <span class="main">=</span> <span class="free">y</span> <span class="main">*</span> <span class="free">z</span> <span class="main">+</span> hash_combine <span class="free">ys</span> <span class="free">zs</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹The Generator›</span></span>

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹hash_generator.ML›</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/hash_generator.ML">
<div class="head">
<h1>File ‹hash_generator.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Deriving class instances for datatypes
    Author:      Christian Sternagel and René Thiemann  &lt;christian.sternagel|rene.thiemann@uibk.ac.at&gt;
    Maintainer:  Christian Sternagel and René Thiemann 
    License:     LGPL
*)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">HASHCODE_GENERATOR</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>

  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">info</span> <span class="main">=</span>
   <span class="main">{</span>map <span class="main">:</span> term<span class="main">,</span>                    <span class="comment1">(* take % x. x, if there is no map *)</span>
    phash <span class="main">:</span> term<span class="main">,</span>                  <span class="comment1">(* partial hash *)</span>
    hash <span class="main">:</span> term<span class="main">,</span>                   <span class="comment1">(* full hash *)</span>
    hash_def <span class="main">:</span> thm option<span class="main">,</span>         <span class="comment1">(* definition of hash, important for nesting *)</span> 
    map_comp <span class="main">:</span> thm option<span class="main">,</span>         <span class="comment1">(* hashositionality of map, important for nesting *)</span>
    used_positions <span class="main">:</span> bool list<span class="main">}</span>

  <span class="comment1">(* registers some type which is already instance of hashcode class in hash generator
     where some type must just be a type without type-arguments *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> register_hash_of <span class="main">:</span> string <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span> local_theory

  <span class="keyword1"><span class="keyword">val</span></span> register_foreign_hash <span class="main">:</span>
    typ <span class="main">-&gt;</span> <span class="comment1">(* type-constant without type-variables *)</span>
    term <span class="main">-&gt;</span> <span class="comment1">(* hash-function for type *)</span>
    local_theory <span class="main">-&gt;</span> local_theory


  <span class="keyword1"><span class="keyword">val</span></span> register_foreign_partial_and_full_hash <span class="main">:</span>
    string <span class="main">-&gt;</span> <span class="comment1">(* long type name *)</span>
    term <span class="main">-&gt;</span> <span class="comment1">(* map function, should be λx. x, if there is no map *)</span>
    term <span class="main">-&gt;</span> <span class="comment1">(* partial hash-function of type (hashcode, 'b)ty =&gt; hashcode, 
      where 'a is used, 'b is unused *)</span>
    term <span class="main">-&gt;</span> <span class="comment1">(* (full) hash-function of type ('a ⇒ hashcode) ⇒ ('a,'b)ty ⇒ hashcode,
      where 'a is used, 'b is unused *)</span>
    thm option <span class="main">-&gt;</span> <span class="comment1">(* hash_def, should be full_hash = phash o map ahash ..., important for nesting *)</span>
    thm option <span class="main">-&gt;</span> <span class="comment1">(* map compositionality, important for nesting *)</span>
    bool list <span class="main">-&gt;</span> <span class="comment1">(*used positions*)</span>
    local_theory <span class="main">-&gt;</span> local_theory

  <span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">hash_type</span> <span class="main">=</span> <span class="entity">HASHCODE</span> <span class="main">|</span> <span class="entity">BNF</span>

  <span class="keyword1"><span class="keyword">val</span></span> generate_hashs_from_bnf_fp <span class="main">:</span> 
    string <span class="main">-&gt;</span>                 <span class="comment1">(* name of type *)</span>
    local_theory <span class="main">-&gt;</span> 
    <span class="main">(</span><span class="main">(</span>term * thm list<span class="main">)</span> list * <span class="comment1">(* partial hashs + simp-rules *)</span>
    <span class="main">(</span>term * thm<span class="main">)</span> list<span class="main">)</span> *      <span class="comment1">(* non-partial hash + def_rule *)</span>
    local_theory

  <span class="keyword1"><span class="keyword">val</span></span> generate_hash <span class="main">:</span> 
    <span class="entity">hash_type</span> <span class="main">-&gt;</span> 
    string <span class="main">-&gt;</span> <span class="comment1">(* name of type *)</span>
    local_theory <span class="main">-&gt;</span> local_theory

  <span class="comment1">(* construct hashcode instance for datatype *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> hashable_instance <span class="main">:</span> string <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory

  <span class="keyword1"><span class="keyword">val</span></span> get_info <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string <span class="main">-&gt;</span> <span class="entity">info</span> option

  <span class="comment1">(* ensures that the info will be available on later requests *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> ensure_info <span class="main">:</span> <span class="entity">hash_type</span> <span class="main">-&gt;</span> string <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span> local_theory
    
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Hashcode_Generator</span> <span class="main">:</span> <span class="entity">HASHCODE_GENERATOR</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword3"><span class="keyword">open</span></span> Generator_Aux

<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">hash_type</span> <span class="main">=</span> <span class="entity">BNF</span> <span class="main">|</span> <span class="entity">HASHCODE</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">hash_name</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "hashcode"<span class="antiquote">}</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">hashS</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">hashable</span><span class="antiquote">}</span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">hashT</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">hashcode</span><span class="antiquote">}</span></span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">hashfunT</span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">T</span> --&gt; <span class="entity">hashT</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">hashify</span> <span class="main">=</span> map_atyps <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">hashT</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">phashfunT</span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">hashify</span> <span class="entity">T</span> --&gt; <span class="entity">hashT</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">max_int</span> <span class="main">=</span> <span class="inner_numeral">2147483648</span> <span class="comment1">(* 2 ^^ 31 *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">int_of_string</span> <span class="entity">s</span> <span class="main">=</span> fold
  <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">c</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">i</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="inner_numeral">1792318057</span> * <span class="entity">i</span> + Char.ord <span class="entity">c</span><span class="main">)</span> mod <span class="entity">max_int</span><span class="main">)</span>
  <span class="main">(</span>String.explode <span class="entity">s</span><span class="main">)</span>
  <span class="inner_numeral">0</span>

<span class="comment1">(* all numbers in int_of_string and create_factors are primes (31-bit) *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">create_factor</span> <span class="entity">ty_name</span> <span class="entity">con_name</span> <span class="entity">i</span> <span class="main">=</span>
  <span class="main">(</span><span class="inner_numeral">1444315237</span> * <span class="entity">int_of_string</span> <span class="entity">ty_name</span> +
  <span class="inner_numeral">1336760419</span> * <span class="entity">int_of_string</span> <span class="entity">con_name</span> +
  <span class="inner_numeral">2044890737</span> * <span class="main">(</span><span class="entity">i</span> + <span class="inner_numeral">1</span><span class="main">)</span> 
  <span class="main">)</span> mod <span class="entity">max_int</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">create_hashes</span> <span class="entity">ty_name</span> <span class="entity">con_name</span> <span class="entity">Ts</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">i</span> <span class="main">=&gt;</span>
  <span class="entity">HOLogic.mk_number</span> <span class="entity">hashT</span> <span class="main">(</span><span class="entity">create_factor</span> <span class="entity">ty_name</span> <span class="entity">con_name</span> <span class="entity">i</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="inner_numeral">0</span> upto length <span class="entity">Ts</span><span class="main">)</span>
  |&gt; <span class="entity">HOLogic.mk_list</span> <span class="entity">hashT</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">create_def_size</span> <span class="main">_</span> <span class="main">=</span> <span class="inner_numeral">10</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">info</span> <span class="main">=</span>
 <span class="main">{</span>map <span class="main">:</span> term<span class="main">,</span>
  phash <span class="main">:</span> term<span class="main">,</span>
  hash <span class="main">:</span> term<span class="main">,</span>
  hash_def <span class="main">:</span> thm option<span class="main">,</span>
  map_comp <span class="main">:</span> thm option<span class="main">,</span>
  used_positions <span class="main">:</span> bool list<span class="main">}</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Data</span> <span class="main">=</span> Generic_Data <span class="main">(</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">info</span> Symtab.table<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">empty</span> <span class="main">=</span> Symtab.empty<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">extend</span> <span class="main">=</span> I<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">merge</span> <span class="main">=</span> Symtab.merge <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">info1</span> <span class="main">:</span> <span class="entity">info</span><span class="main">,</span> <span class="entity">info2</span> <span class="main">:</span> <span class="entity">info</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">#</span>hash <span class="entity">info1</span> <span class="main">=</span> <span class="main">#</span>hash <span class="entity">info2</span><span class="main">)</span><span class="main">;</span>
<span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_info</span> <span class="entity">T</span> <span class="entity">info</span> <span class="main">=</span> Data.map <span class="main">(</span>Symtab.update_new <span class="main">(</span><span class="entity">T</span><span class="main">,</span> <span class="entity">info</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">get_info</span> <span class="main">=</span> Context.Proof #&gt; Data.get #&gt; Symtab.lookup

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">the_info</span> <span class="entity">ctxt</span> <span class="entity">tyco</span> <span class="main">=</span>
     <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">get_info</span> <span class="entity">ctxt</span> <span class="entity">tyco</span> <span class="keyword2"><span class="keyword">of</span></span>
        SOME <span class="entity">info</span> <span class="main">=&gt;</span> <span class="entity">info</span>
      <span class="main">|</span> NONE <span class="main">=&gt;</span> error <span class="main">(</span><span class="inner_quoted">"no hash_code information available for type "</span> ^ quote <span class="entity">tyco</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">declare_info</span> <span class="entity">tyco</span> <span class="entity">m</span> <span class="entity">p</span> <span class="entity">c</span> <span class="entity">c_def</span> <span class="entity">m_hash</span> <span class="entity">used_pos</span> <span class="main">=</span>
  Local_Theory.declaration <span class="main">{</span>syntax <span class="main">=</span> false<span class="main">,</span> pervasive <span class="main">=</span> false<span class="main">}</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">phi</span> <span class="main">=&gt;</span>
    <span class="entity">add_info</span> <span class="entity">tyco</span>
     <span class="main">{</span>map <span class="main">=</span> Morphism.term <span class="entity">phi</span> <span class="entity">m</span><span class="main">,</span>
      phash <span class="main">=</span> Morphism.term <span class="entity">phi</span> <span class="entity">p</span><span class="main">,</span>
      hash <span class="main">=</span> Morphism.term <span class="entity">phi</span> <span class="entity">c</span><span class="main">,</span>
      hash_def <span class="main">=</span> Option.map <span class="main">(</span>Morphism.thm <span class="entity">phi</span><span class="main">)</span> <span class="entity">c_def</span><span class="main">,</span>
      map_comp <span class="main">=</span> Option.map <span class="main">(</span>Morphism.thm <span class="entity">phi</span><span class="main">)</span> <span class="entity">m_hash</span><span class="main">,</span>
      used_positions <span class="main">=</span> <span class="entity">used_pos</span><span class="main">}</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">register_foreign_partial_and_full_hash</span> <span class="entity">tyco</span> <span class="entity">m</span> <span class="entity">p</span> <span class="entity">c</span> <span class="entity">c_def</span> <span class="entity">m_hash</span> <span class="entity">eq_thm</span> <span class="entity">c_thm</span> <span class="main">=</span>
  <span class="entity">declare_info</span> <span class="entity">tyco</span> <span class="entity">m</span> <span class="entity">p</span> <span class="entity">c</span> <span class="entity">c_def</span> <span class="entity">m_hash</span> <span class="entity">eq_thm</span> <span class="entity">c_thm</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">default_hash</span> <span class="entity">T</span> <span class="main">=</span> absdummy <span class="entity">T</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="main">0</span> <span class="main">::</span> hashcode"</span><span class="antiquote">}</span></span> <span class="comment1">(*%_. 0*)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">register_foreign_hash</span> <span class="entity">T</span> <span class="entity">hash</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span> 
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tyco</span> <span class="main">=</span> <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">T</span> <span class="keyword2"><span class="keyword">of</span></span> Type <span class="main">(</span><span class="entity">tyco</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">tyco</span> <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> error <span class="inner_quoted">"expected type constant with no arguments"</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">register_foreign_partial_and_full_hash</span> 
      <span class="entity">tyco</span> <span class="main">(</span><span class="entity">HOLogic.id_const</span> <span class="entity">T</span><span class="main">)</span> <span class="entity">hash</span> <span class="entity">hash</span> NONE NONE <span class="main">[</span><span class="main">]</span> <span class="entity">lthy</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">register_hash_of</span> <span class="entity">tyco</span> <span class="entity">lthy</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span> 
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">is_class_instance</span> <span class="main">(</span>Proof_Context.theory_of <span class="entity">lthy</span><span class="main">)</span> <span class="entity">tyco</span> <span class="entity">hashS</span>
      <span class="keyword1"><span class="keyword">orelse</span></span> error <span class="main">(</span><span class="inner_quoted">"type "</span> ^ quote <span class="entity">tyco</span> ^ <span class="inner_quoted">" is not an instance of class \"hashable\""</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">T</span><span class="main">,</span><span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">typ_and_vs_of_typname</span> <span class="main">(</span>Proof_Context.theory_of <span class="entity">lthy</span><span class="main">)</span> <span class="entity">tyco</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">type</span><span class="antiquote">}</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">hash</span> <span class="main">=</span> Const <span class="main">(</span><span class="entity">hash_name</span><span class="main">,</span> <span class="entity">hashfunT</span> <span class="entity">T</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">register_foreign_hash</span> <span class="entity">T</span> <span class="entity">hash</span> <span class="entity">lthy</span> <span class="keyword2"><span class="keyword">end</span></span>
                       

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">generate_hashs_from_bnf_fp</span> <span class="entity">tyco</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">tycos</span><span class="main">,</span> <span class="entity">Ts</span><span class="main">)</span> <span class="main">=</span> <span class="entity">mutual_recursive_types</span> <span class="entity">tyco</span> <span class="entity">lthy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">tyco</span> <span class="main">=&gt;</span> <span class="inner_quoted">"generating hash-function for type "</span> ^ quote <span class="entity">tyco</span><span class="main">)</span> <span class="entity">tycos</span>
      |&gt; cat_lines |&gt; writeln
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">tfrees</span><span class="main">,</span> <span class="entity">used_tfrees</span><span class="main">)</span> <span class="main">=</span> <span class="entity">type_parameters</span> <span class="main">(</span>hd <span class="entity">Ts</span><span class="main">)</span> <span class="entity">lthy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">used_positions</span> <span class="main">=</span> map <span class="main">(</span>member <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">used_tfrees</span> o TFree<span class="main">)</span> <span class="entity">tfrees</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cs</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">subT</span> <span class="inner_quoted">"h"</span><span class="main">)</span> <span class="entity">used_tfrees</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">hash_Ts</span> <span class="main">=</span> map <span class="entity">hashfunT</span> <span class="entity">used_tfrees</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg_hashs</span> <span class="main">=</span> map Free <span class="main">(</span><span class="entity">cs</span> ~~ <span class="entity">hash_Ts</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dep_tycos</span> <span class="main">=</span> fold <span class="main">(</span><span class="entity">add_used_tycos</span> <span class="entity">lthy</span><span class="main">)</span> <span class="entity">tycos</span> <span class="main">[</span><span class="main">]</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">map_simps</span> <span class="main">=</span> <span class="entity">Bnf_Access.map_simps</span> <span class="entity">lthy</span> <span class="entity">tycos</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">case_simps</span> <span class="main">=</span> <span class="entity">Bnf_Access.case_simps</span> <span class="entity">lthy</span> <span class="entity">tycos</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">maps</span> <span class="main">=</span> <span class="entity">Bnf_Access.map_terms</span> <span class="entity">lthy</span> <span class="entity">tycos</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">map_comp_thms</span> <span class="main">=</span> <span class="entity">Bnf_Access.map_comps</span> <span class="entity">lthy</span> <span class="entity">tycos</span>
    

    <span class="comment1">(* primrec definitions of partial hashs *)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_phash</span> <span class="main">(</span><span class="entity">tyco</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="inner_quoted">"partial_hash_code_"</span> ^ Long_Name.base_name <span class="entity">tyco</span><span class="main">,</span> <span class="entity">phashfunT</span> <span class="entity">T</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">constr_terms</span> <span class="entity">lthy</span> <span class="main">=</span>  
      <span class="entity">Bnf_Access.constr_terms</span> <span class="entity">lthy</span> 
      #&gt; map <span class="main">(</span>apsnd <span class="main">(</span>map <span class="entity">freeify_tvars</span> o fst o strip_type<span class="main">)</span> o dest_Const<span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">generate_phash_eqs</span> <span class="entity">lthy</span> <span class="main">(</span><span class="entity">tyco</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">constrs</span> <span class="main">=</span> <span class="entity">constr_terms</span> <span class="entity">lthy</span> <span class="entity">tyco</span> 

        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">hash_arg</span> <span class="entity">T</span> <span class="entity">x</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">m</span> <span class="main">=</span> <span class="entity">Generator_Aux.create_map</span> <span class="entity">default_hash</span> <span class="main">(</span>K o Free o <span class="entity">mk_phash</span><span class="main">)</span> <span class="main">(</span><span class="main">)</span> <span class="main">(</span>K false<span class="main">)</span>
              <span class="main">(</span><span class="main">#</span>used_positions oo <span class="entity">the_info</span><span class="main">)</span> <span class="main">(</span><span class="main">#</span>map oo <span class="entity">the_info</span><span class="main">)</span> <span class="main">(</span>K o <span class="main">#</span>phash oo <span class="entity">the_info</span><span class="main">)</span>
              <span class="entity">tycos</span> <span class="main">(</span><span class="main">(</span>K o K<span class="main">)</span> <span class="main">(</span><span class="main">)</span><span class="main">)</span> <span class="entity">T</span> <span class="entity">lthy</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">p</span> <span class="main">=</span> <span class="entity">Generator_Aux.create_partial</span> <span class="main">(</span><span class="main">)</span> <span class="main">(</span>K false<span class="main">)</span>
              <span class="main">(</span><span class="main">#</span>used_positions oo <span class="entity">the_info</span><span class="main">)</span> <span class="main">(</span><span class="main">#</span>map oo <span class="entity">the_info</span><span class="main">)</span> <span class="main">(</span>K o <span class="main">#</span>phash oo <span class="entity">the_info</span><span class="main">)</span>
              <span class="entity">tycos</span> <span class="main">(</span><span class="main">(</span>K o K<span class="main">)</span> <span class="main">(</span><span class="main">)</span><span class="main">)</span> <span class="entity">T</span> <span class="entity">lthy</span>
          <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">p</span> $ <span class="main">(</span><span class="entity">m</span> $ <span class="entity">x</span><span class="main">)</span> |&gt; <span class="entity">infer_type</span> <span class="entity">lthy</span> <span class="keyword2"><span class="keyword">end</span></span>

        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">generate_eq</span> <span class="entity">lthy</span> <span class="main">(</span><span class="entity">cN</span><span class="main">,</span> <span class="entity">Ts</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg_Ts'</span> <span class="main">=</span> map <span class="entity">hashify</span> <span class="entity">Ts</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">c</span> <span class="main">=</span> Const <span class="main">(</span><span class="entity">cN</span><span class="main">,</span> <span class="entity">arg_Ts'</span> ---&gt; <span class="entity">hashify</span> <span class="entity">T</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">xs</span> <span class="main">=</span> Name.invent_names <span class="main">(</span>Variable.names_of <span class="entity">lthy</span><span class="main">)</span> <span class="inner_quoted">"x"</span> <span class="main">(</span><span class="entity">arg_Ts'</span><span class="main">)</span> |&gt; map Free
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs</span> <span class="main">=</span> Free <span class="main">(</span><span class="entity">mk_phash</span> <span class="main">(</span><span class="entity">tyco</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span> $ list_comb <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">xs</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">hash_combine</span><span class="antiquote">}</span></span> $ <span class="entity">HOLogic.mk_list</span> <span class="entity">hashT</span> <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">map</span> 2<span class="antiquote">}</span></span></span> <span class="entity">hash_arg</span> <span class="entity">Ts</span> <span class="entity">xs</span><span class="main">)</span> $ <span class="entity">create_hashes</span> <span class="entity">tyco</span> <span class="entity">cN</span> <span class="entity">Ts</span>
          <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span><span class="main">)</span> |&gt; <span class="entity">infer_type</span> <span class="entity">lthy</span> <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword2"><span class="keyword">in</span></span> map <span class="main">(</span><span class="entity">generate_eq</span> <span class="entity">lthy</span><span class="main">)</span> <span class="entity">constrs</span> <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eqs</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">generate_phash_eqs</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">(</span><span class="entity">tycos</span> ~~ <span class="entity">Ts</span><span class="main">)</span> |&gt; flat
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">bindings</span> <span class="main">=</span> <span class="entity">tycos</span> ~~ <span class="entity">Ts</span> |&gt; map <span class="entity">mk_phash</span>
      |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span>Binding.name <span class="entity">name</span><span class="main">,</span> SOME <span class="entity">T</span><span class="main">,</span> NoSyn<span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">phashs</span><span class="main">,</span> <span class="entity">phash_simps</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">lthy</span>
      |&gt; Local_Theory.begin_nested
      |&gt; snd
      |&gt; <span class="entity">BNF_LFP_Rec_Sugar.primrec</span> false <span class="main">[</span><span class="main">]</span> <span class="entity">bindings</span>
          <span class="main">(</span>map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">(</span>Binding.empty_atts<span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="entity">eqs</span><span class="main">)</span>
      |&gt; Local_Theory.end_nested_result
          <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">phi</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">phashs</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">phash_simps</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span>map <span class="main">(</span>Morphism.term <span class="entity">phi</span><span class="main">)</span> <span class="entity">phashs</span><span class="main">,</span> map <span class="main">(</span>Morphism.fact <span class="entity">phi</span><span class="main">)</span> <span class="entity">phash_simps</span><span class="main">)</span><span class="main">)</span>

    <span class="comment1">(* definitions of hashs via partial hashs and maps *)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">generate_hash_def</span> <span class="entity">tyco</span> <span class="entity">lthy</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cs</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">subT</span> <span class="inner_quoted">"h"</span><span class="main">)</span> <span class="entity">used_tfrees</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg_Ts</span> <span class="main">=</span> map <span class="entity">hashfunT</span> <span class="entity">used_tfrees</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span> map Free <span class="main">(</span><span class="entity">cs</span> ~~ <span class="entity">arg_Ts</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">phash</span><span class="main">,</span> <span class="entity">m</span><span class="main">)</span> <span class="main">=</span> AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">(</span><span class="entity">tycos</span> ~~ <span class="main">(</span><span class="entity">phashs</span> ~~ <span class="entity">maps</span><span class="main">)</span><span class="main">)</span> <span class="entity">tyco</span> |&gt; the
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ts</span> <span class="main">=</span> <span class="entity">tfrees</span> |&gt; map TFree |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">T</span> <span class="main">=&gt;</span>
          AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">(</span><span class="entity">used_tfrees</span> ~~ <span class="entity">args</span><span class="main">)</span> <span class="entity">T</span> |&gt; the_default <span class="main">(</span><span class="entity">default_hash</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span> <span class="entity">HOLogic.mk_comp</span> <span class="main">(</span><span class="entity">phash</span><span class="main">,</span> list_comb <span class="main">(</span><span class="entity">m</span><span class="main">,</span> <span class="entity">ts</span><span class="main">)</span><span class="main">)</span> |&gt; <span class="entity">infer_type</span> <span class="entity">lthy</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">abs_def</span> <span class="main">=</span> <span class="entity">lambdas</span> <span class="entity">args</span> <span class="entity">rhs</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">name</span> <span class="main">=</span> <span class="inner_quoted">"hash_code_"</span> ^ Long_Name.base_name <span class="entity">tyco</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">hash</span><span class="main">,</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">prethm</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span>
          Local_Theory.define <span class="main">(</span><span class="main">(</span>Binding.name <span class="entity">name</span><span class="main">,</span> NoSyn<span class="main">)</span><span class="main">,</span> <span class="main">(</span>Binding.empty_atts<span class="main">,</span> <span class="entity">abs_def</span><span class="main">)</span><span class="main">)</span> <span class="entity">lthy</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq</span> <span class="main">=</span> Logic.mk_equals <span class="main">(</span>list_comb <span class="main">(</span><span class="entity">hash</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm</span> <span class="main">=</span> Goal.prove <span class="entity">lthy</span> <span class="main">(</span>map <span class="main">(</span>fst o dest_Free<span class="main">)</span> <span class="entity">args</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span> <span class="entity">eq</span> <span class="main">(</span>K <span class="main">(</span><span class="entity">unfold_tac</span> <span class="entity">lthy</span> <span class="main">[</span><span class="entity">prethm</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        Local_Theory.note <span class="main">(</span><span class="main">(</span>Binding.name <span class="main">(</span><span class="entity">name</span> ^ <span class="inner_quoted">"_def"</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="entity">thm</span><span class="main">]</span><span class="main">)</span> <span class="entity">lthy</span>
        |&gt;&gt; the_single o snd
        |&gt;&gt; `<span class="main">(</span>K <span class="entity">hash</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">hashs</span><span class="main">,</span> <span class="entity">hash_defs</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">lthy</span>
      |&gt; Local_Theory.begin_nested
      |&gt; snd
      |&gt; fold_map <span class="entity">generate_hash_def</span> <span class="entity">tycos</span>
      |&gt;&gt; split_list
      |&gt; Local_Theory.end_nested_result
          <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">phi</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">hashs</span><span class="main">,</span> <span class="entity">hash_defs</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span>map <span class="main">(</span>Morphism.term <span class="entity">phi</span><span class="main">)</span> <span class="entity">hashs</span><span class="main">,</span> map <span class="main">(</span>Morphism.thm <span class="entity">phi</span><span class="main">)</span> <span class="entity">hash_defs</span><span class="main">)</span><span class="main">)</span>

    <span class="comment1">(* alternative simp-rules for hashs *)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">generate_hash_simps</span> <span class="main">(</span><span class="entity">tyco</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="entity">lthy</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">constrs</span> <span class="main">=</span> <span class="entity">constr_terms</span> <span class="entity">lthy</span> <span class="entity">tyco</span>

        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">hash_arg</span> <span class="entity">T</span> <span class="entity">x</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">create_hash</span> <span class="main">(</span><span class="entity">T</span> <span class="keyword1"><span class="keyword">as</span></span> TFree <span class="main">_</span><span class="main">)</span> <span class="main">=</span>
                  AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">(</span><span class="entity">used_tfrees</span> ~~ <span class="entity">arg_hashs</span><span class="main">)</span> <span class="entity">T</span>
                  |&gt; the_default <span class="main">(</span><span class="entity">HOLogic.id_const</span> dummyT<span class="main">)</span>
              <span class="main">|</span> <span class="entity">create_hash</span> <span class="main">(</span>Type <span class="main">(</span><span class="entity">tyco</span><span class="main">,</span> <span class="entity">Ts</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
                  <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">(</span><span class="entity">tycos</span> ~~ <span class="entity">hashs</span><span class="main">)</span> <span class="entity">tyco</span> <span class="keyword2"><span class="keyword">of</span></span>
                    SOME <span class="entity">c</span> <span class="main">=&gt;</span> list_comb <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">arg_hashs</span><span class="main">)</span>
                  <span class="main">|</span> NONE <span class="main">=&gt;</span>
                      <span class="keyword2"><span class="keyword">let</span></span>
                        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span>hash <span class="main">=</span> <span class="entity">c</span><span class="main">,</span> used_positions <span class="main">=</span> <span class="entity">up</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">the_info</span> <span class="entity">lthy</span> <span class="entity">tyco</span>
                        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ts</span> <span class="main">=</span> <span class="main">(</span><span class="entity">up</span> ~~ <span class="entity">Ts</span><span class="main">)</span> |&gt; map_filter <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">b</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="main">=&gt;</span>
                          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">b</span> <span class="keyword2"><span class="keyword">then</span></span> SOME <span class="main">(</span><span class="entity">create_hash</span> <span class="entity">T</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> NONE<span class="main">)</span>
                      <span class="keyword2"><span class="keyword">in</span></span> list_comb <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">ts</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>
              <span class="main">|</span> <span class="entity">create_hash</span> <span class="entity">T</span> <span class="main">=</span>
                  error <span class="main">(</span><span class="inner_quoted">"unexpected schematic variable "</span> ^ quote <span class="main">(</span>Syntax.string_of_typ <span class="entity">lthy</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">hash</span> <span class="main">=</span> <span class="entity">create_hash</span> <span class="entity">T</span>
          <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">hash</span> $ <span class="entity">x</span> |&gt; <span class="entity">infer_type</span> <span class="entity">lthy</span> <span class="keyword2"><span class="keyword">end</span></span>

        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">generate_eq_thm</span> <span class="entity">lthy</span> <span class="main">(</span><span class="entity">c_T</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">(</span><span class="entity">cN</span><span class="main">,</span> <span class="entity">Ts</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">xs</span> <span class="main">=</span> Variable.names_of <span class="entity">lthy</span>
              |&gt; fold_map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">T</span> <span class="main">=&gt;</span> Name.variant <span class="inner_quoted">"x"</span> #&gt;&gt; Free o rpair <span class="entity">T</span><span class="main">)</span> <span class="entity">Ts</span> |&gt; fst
            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_const</span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">Ts</span><span class="main">)</span> <span class="main">=</span> Const <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">Ts</span> ---&gt; <span class="entity">T</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">hash_const</span> <span class="main">=</span> AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">(</span><span class="entity">tycos</span> ~~ <span class="entity">hashs</span><span class="main">)</span> <span class="entity">tyco</span> |&gt; the
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs</span> <span class="main">=</span> list_comb <span class="main">(</span><span class="entity">hash_const</span><span class="main">,</span> <span class="entity">arg_hashs</span><span class="main">)</span> $ list_comb <span class="main">(</span><span class="entity">mk_const</span> <span class="entity">c_T</span><span class="main">,</span> <span class="entity">xs</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">hash_combine</span><span class="antiquote">}</span></span> $ <span class="entity">HOLogic.mk_list</span> <span class="entity">hashT</span> <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">map</span> 2<span class="antiquote">}</span></span></span> <span class="entity">hash_arg</span> <span class="entity">Ts</span> <span class="entity">xs</span><span class="main">)</span> $ <span class="entity">create_hashes</span> <span class="entity">tyco</span> <span class="entity">cN</span> <span class="entity">Ts</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq</span> <span class="main">=</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span><span class="main">)</span> |&gt; <span class="entity">infer_type</span> <span class="entity">lthy</span>

            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dep_hash_defs</span> <span class="main">=</span> map_filter <span class="main">(</span><span class="main">#</span>hash_def o <span class="entity">the_info</span> <span class="entity">lthy</span><span class="main">)</span> <span class="entity">dep_tycos</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dep_map_comps</span> <span class="main">=</span> map_filter <span class="main">(</span><span class="main">#</span>map_comp o <span class="entity">the_info</span> <span class="entity">lthy</span><span class="main">)</span> <span class="entity">dep_tycos</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thms</span> <span class="main">=</span> <span class="entity">prove_multi_future</span> <span class="entity">lthy</span> <span class="main">(</span>map <span class="main">(</span>fst o dest_Free<span class="main">)</span> <span class="entity">xs</span> @ <span class="entity">cs</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="entity">eq</span><span class="main">]</span>
              <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
                Goal.conjunction_tac <span class="inner_numeral">1</span>
                THEN <span class="entity">unfold_tac</span> <span class="entity">ctxt</span>
                  <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> id_apply o_def<span class="antiquote">}</span></span></span> @
                    flat <span class="entity">case_simps</span> @
                    flat <span class="entity">phash_simps</span> @
                    <span class="entity">dep_map_comps</span> @ <span class="entity">hash_defs</span> @ <span class="entity">dep_hash_defs</span> @ flat <span class="entity">map_simps</span><span class="main">)</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">thms</span> <span class="keyword2"><span class="keyword">end</span></span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thms</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">generate_eq_thm</span> <span class="entity">lthy</span><span class="main">)</span> <span class="entity">constrs</span> |&gt; flat
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simp_thms</span> <span class="main">=</span> map <span class="main">(</span>Local_Defs.unfold <span class="entity">lthy</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> hash_combine_unfold<span class="antiquote">}</span></span></span><span class="main">)</span> <span class="entity">thms</span>
        
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">name</span> <span class="main">=</span> <span class="inner_quoted">"hash_code_"</span> ^ Long_Name.base_name <span class="entity">tyco</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="entity">lthy</span>
        |&gt; Local_Theory.note <span class="main">(</span><span class="main">(</span>Binding.name <span class="main">(</span><span class="entity">name</span> ^ <span class="inner_quoted">"_simps"</span><span class="main">)</span><span class="main">,</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">attributes</span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">code</span><span class="main">]</span><span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">,</span> <span class="entity">simp_thms</span><span class="main">)</span>
        |&gt; snd
        |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">lthy</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">thms</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lthy</span> <span class="main">=</span>
      <span class="entity">lthy</span>
      |&gt; Local_Theory.begin_nested
      |&gt; snd
      |&gt; fold_map <span class="entity">generate_hash_simps</span> <span class="main">(</span><span class="entity">tycos</span> ~~ <span class="entity">Ts</span><span class="main">)</span>
      |&gt; snd
      |&gt; Local_Theory.end_nested

  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="main">(</span><span class="entity">phashs</span> ~~ <span class="entity">phash_simps</span><span class="main">,</span> <span class="entity">hashs</span> ~~ <span class="entity">hash_defs</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span>
    ||&gt; fold <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">tyco</span><span class="main">,</span> <span class="entity">map</span><span class="main">)</span><span class="main">,</span> <span class="entity">phash</span><span class="main">)</span><span class="main">,</span> <span class="entity">hash</span><span class="main">)</span><span class="main">,</span> <span class="entity">hash_def</span><span class="main">)</span><span class="main">,</span> <span class="entity">map_comp</span><span class="main">)</span> <span class="main">=&gt;</span>
          <span class="entity">declare_info</span> <span class="entity">tyco</span> <span class="entity">map</span> <span class="entity">phash</span> <span class="entity">hash</span> <span class="main">(</span>SOME <span class="entity">hash_def</span><span class="main">)</span> <span class="main">(</span>SOME <span class="entity">map_comp</span><span class="main">)</span> 
            <span class="entity">used_positions</span><span class="main">)</span>
         <span class="main">(</span><span class="entity">tycos</span> ~~ <span class="entity">maps</span> ~~ <span class="entity">phashs</span> ~~ <span class="entity">hashs</span> ~~ <span class="entity">hash_defs</span> ~~ <span class="entity">map_comp_thms</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">generate_hash</span> <span class="entity">gen_type</span> <span class="entity">tyco</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span> 
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> is_some <span class="main">(</span><span class="entity">get_info</span> <span class="entity">lthy</span> <span class="entity">tyco</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">andalso</span></span> error <span class="main">(</span><span class="inner_quoted">"type "</span> ^ quote <span class="entity">tyco</span> ^ <span class="inner_quoted">" does already have a hash"</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">gen_type</span> <span class="keyword2"><span class="keyword">of</span></span> 
      <span class="entity">BNF</span> <span class="main">=&gt;</span> <span class="entity">generate_hashs_from_bnf_fp</span> <span class="entity">tyco</span> <span class="entity">lthy</span> |&gt; snd
    <span class="main">|</span> <span class="entity">HASHCODE</span> <span class="main">=&gt;</span> <span class="entity">register_hash_of</span> <span class="entity">tyco</span> <span class="entity">lthy</span>
  <span class="keyword2"><span class="keyword">end</span></span>
  
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ensure_info</span> <span class="entity">gen_type</span> <span class="entity">tyco</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">get_info</span> <span class="entity">lthy</span> <span class="entity">tyco</span> <span class="keyword2"><span class="keyword">of</span></span>
    SOME <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">lthy</span>
  <span class="main">|</span> NONE <span class="main">=&gt;</span> <span class="entity">generate_hash</span> <span class="entity">gen_type</span> <span class="entity">tyco</span> <span class="entity">lthy</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_hash</span> <span class="entity">ctxt</span> <span class="entity">tname</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">get_info</span> <span class="entity">ctxt</span> <span class="entity">tname</span> <span class="keyword2"><span class="keyword">of</span></span>
    SOME <span class="main">{</span>hash <span class="main">=</span> <span class="entity">c</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Ts</span> <span class="main">=</span> fastype_of <span class="entity">c</span> |&gt; strip_type |&gt; fst |&gt; `<span class="main">(</span><span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span> <span class="entity">x</span> - <span class="inner_numeral">1</span><span class="main">)</span> o length<span class="main">)</span> |&gt; uncurry take
      <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">Ts</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>
  <span class="main">|</span> NONE <span class="main">=&gt;</span> error <span class="main">(</span><span class="inner_quoted">"no hash info for type "</span> ^ quote <span class="entity">tname</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">all_tys</span> <span class="entity">hash</span> <span class="entity">free_types</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Ts</span> <span class="main">=</span> fastype_of <span class="entity">hash</span> |&gt; strip_type |&gt; fst |&gt; List.last |&gt; dest_Type |&gt; snd
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">rename_types</span> <span class="main">(</span><span class="entity">Ts</span> ~~ <span class="entity">free_types</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_hash_rhs</span> <span class="entity">c</span> <span class="entity">Ts</span> <span class="main">=</span>
  list_comb <span class="main">(</span><span class="entity">c</span><span class="main">,</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">T</span> <span class="main">=&gt;</span> Const <span class="main">(</span><span class="entity">hash_name</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span> <span class="entity">Ts</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_hash_def</span> <span class="entity">T</span> <span class="entity">rhs</span> <span class="main">=</span>
  Logic.mk_equals <span class="main">(</span>Const <span class="main">(</span><span class="entity">hash_name</span><span class="main">,</span> <span class="entity">hashfunT</span> <span class="entity">T</span><span class="main">)</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">hashable_instance</span> <span class="entity">tname</span> <span class="entity">thy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">is_class_instance</span> <span class="entity">thy</span> <span class="entity">tname</span> <span class="entity">hashS</span>
      <span class="keyword1"><span class="keyword">andalso</span></span> error <span class="main">(</span><span class="inner_quoted">"type "</span> ^ quote <span class="entity">tname</span> ^ <span class="inner_quoted">" is already an instance of class \"hashcode\""</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> writeln <span class="main">(</span><span class="inner_quoted">"deriving \"hashable\" instance for type "</span> ^ quote <span class="entity">tname</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> <span class="entity">Named_Target.theory_map</span> <span class="main">(</span><span class="entity">ensure_info</span> <span class="entity">BNF</span> <span class="entity">tname</span><span class="main">)</span> <span class="entity">thy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span>used_positions <span class="main">=</span> <span class="entity">us</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> the <span class="main">(</span><span class="entity">get_info</span> 
        <span class="main">(</span><span class="entity">Named_Target.theory_init</span> <span class="entity">thy</span><span class="main">)</span> <span class="entity">tname</span><span class="main">)</span> 

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">xs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">typ_and_vs_of_used_typname</span> <span class="entity">tname</span> <span class="entity">us</span> <span class="entity">hashS</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">(</span><span class="entity">hashs_thm</span><span class="main">,</span><span class="entity">lthy</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">Class.instantiation</span> <span class="main">(</span><span class="main">[</span><span class="entity">tname</span><span class="main">]</span><span class="main">,</span> <span class="entity">xs</span><span class="main">,</span> <span class="entity">hashS</span><span class="main">)</span> <span class="entity">thy</span>
      |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">Ts</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dest_hash</span> <span class="entity">ctxt</span> <span class="entity">tname</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">typ_mapping</span> <span class="main">=</span> <span class="entity">all_tys</span> <span class="entity">c</span> <span class="main">(</span>map TFree <span class="entity">xs</span><span class="main">)</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">hash_rhs</span> <span class="main">=</span> <span class="entity">mk_hash_rhs</span> <span class="entity">c</span> <span class="entity">Ts</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">hash_def</span> <span class="main">=</span> <span class="entity">mk_hash_def</span> dummyT <span class="entity">hash_rhs</span> |&gt; <span class="entity">typ_mapping</span> |&gt; <span class="entity">infer_type</span> <span class="entity">ctxt</span>

          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty</span> <span class="main">=</span> Term.fastype_of <span class="main">(</span>snd <span class="main">(</span>Logic.dest_equals <span class="entity">hash_def</span><span class="main">)</span><span class="main">)</span> |&gt; Term.dest_Type |&gt; snd |&gt; hd
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty_it</span> <span class="main">=</span> Type <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_name</span> itself<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">[</span><span class="entity">ty</span><span class="main">]</span><span class="main">)</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">hashs_rhs</span> <span class="main">=</span> lambda <span class="main">(</span>Free <span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span><span class="entity">ty_it</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="entity">HOLogic.mk_number</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">nat</span><span class="antiquote">}</span></span> <span class="main">(</span><span class="entity">create_def_size</span> <span class="entity">tname</span><span class="main">)</span><span class="main">)</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">hashs_def</span> <span class="main">=</span> <span class="entity">mk_def</span> <span class="main">(</span><span class="entity">ty_it</span> --&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">nat</span><span class="antiquote">}</span></span><span class="main">)</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> def_hashmap_size<span class="antiquote">}</span></span> <span class="entity">hashs_rhs</span>

          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">basename</span> <span class="main">=</span> Long_Name.base_name <span class="entity">tname</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="entity">Generator_Aux.define_overloaded_generic</span>
           <span class="main">(</span><span class="main">(</span>Binding.name <span class="main">(</span><span class="inner_quoted">"hashcode_"</span> ^ <span class="entity">basename</span> ^ <span class="inner_quoted">"_def"</span><span class="main">)</span><span class="main">,</span>
            <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">attributes</span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">,</span>
            <span class="entity">hash_def</span><span class="main">)</span> <span class="entity">ctxt</span>
          ||&gt; <span class="entity">define_overloaded</span> <span class="main">(</span><span class="inner_quoted">"def_hashmap_size_"</span> ^ <span class="entity">basename</span> ^ <span class="inner_quoted">"_def"</span><span class="main">,</span> <span class="entity">hashs_def</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">Class.prove_instantiation_exit</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span>
      <span class="entity">Class.intro_classes_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span>
      THEN <span class="entity">unfold_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">hashs_thm</span><span class="main">]</span>
      THEN <span class="entity">simp_tac</span> <span class="entity">ctxt</span> <span class="inner_numeral">1</span>
      <span class="main">)</span> <span class="entity">lthy</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">generate_hash_cmd</span> <span class="entity">tyco</span> <span class="entity">param</span> <span class="main">=</span> <span class="entity">Named_Target.theory_map</span> <span class="main">(</span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">param</span> <span class="main">=</span> <span class="inner_quoted">"hashcode"</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">generate_hash</span> <span class="entity">HASHCODE</span> <span class="entity">tyco</span>
  <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">param</span> <span class="main">=</span> <span class="inner_quoted">""</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">generate_hash</span> <span class="entity">BNF</span> <span class="entity">tyco</span>
  <span class="keyword2"><span class="keyword">else</span></span> error <span class="main">(</span><span class="inner_quoted">"unknown parameter, expecting no parameter for BNF-datatypes, "</span> ^
         <span class="inner_quoted">"or \"hashcode\" for types where the class-instance hashcode should be used."</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  Theory.setup
    <span class="main">(</span><span class="entity">Derive_Manager.register_derive</span> 
      <span class="inner_quoted">"hash_code"</span> <span class="inner_quoted">"generate a hash function, options are () and (hashcode)"</span> <span class="entity">generate_hash_cmd</span>
    #&gt; <span class="entity">Derive_Manager.register_derive</span> 
      <span class="inner_quoted">"hashable"</span> 
      <span class="inner_quoted">"register types in class hashable"</span> 
      <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">tyname</span> <span class="main">=&gt;</span> K <span class="main">(</span><span class="entity">hashable_instance</span> <span class="entity">tyname</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Hash_Instances">
<div class="head">
<h1>Theory Hash_Instances</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Deriving class instances for datatypes
    Author:      Christian Sternagel and René Thiemann  &lt;christian.sternagel|rene.thiemann@uibk.ac.at&gt;
    Maintainer:  Christian Sternagel and René Thiemann 
    License:     LGPL
*)</span>
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Defining Hash-Functions for Common Types›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Hash_Instances
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Hash_Generator.html">Hash_Generator</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹For all of the following types, we register hashcode-functions.
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> int<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> integer<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> nat<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> char<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> bool<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> unit<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> sum<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> option<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> list<span class="antiquote"><span class="antiquote">}</span></span></span></span>,
  and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> prod<span class="antiquote"><span class="antiquote">}</span></span></span></span>. For types without type parameters, we use plain <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "hashcode"<span class="antiquote"><span class="antiquote">}</span></span></span></span>, and for the 
  others we use generated ones.›</span></span>

<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>hashcode<span class="main">)</span> hash_code <span class="quoted">int</span> <span class="quoted">integer</span> <span class="quoted">bool</span> <span class="quoted">char</span> <span class="quoted">unit</span> <span class="quoted">nat</span>

<span class="keyword1"><span class="command">derive</span></span> hash_code <span class="quoted">prod</span> <span class="quoted">sum</span> <span class="quoted">option</span> <span class="quoted">list</span> 

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹There is no need to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>derive hashable prod sum option list›</span></span></span></span> since all of these types 
  are already instances of class <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> hashable<span class="antiquote"><span class="antiquote">}</span></span></span></span>. Still the above command is necessary to register
  these types in the generator.›</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Countable_Generator">
<div class="head">
<h1>Theory Countable_Generator</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Deriving class instances for datatypes
    Author:      Christian Sternagel and René Thiemann  &lt;christian.sternagel|rene.thiemann@uibk.ac.at&gt;
    Maintainer:  Christian Sternagel and René Thiemann 
    License:     LGPL
*)</span>
<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Countable Datatypes›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Countable_Generator
<span class="keyword2"><span class="keyword">imports</span></span> 
  <span class="quoted">"<a href="../../HOL/HOL-Library/Countable.html">HOL-Library.Countable</a>"</span>
  <span class="quoted">"<a href="Derive_Manager.html">../Derive_Manager</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
Brian Huffman and Alexander Krauss (old datatype), and Jasmin Blanchette (BNF datatype) 
have developed tactics which automatically can prove that a datatype is countable.
We just make this tactic available in the derive-manager so that
one can conveniently write \texttt{derive countable some-datatype}.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Installing the tactic"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
There is nothing more to do, then to write some boiler-plate ML-code
for class-instantiation.
›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹
  <span class="keyword2"><span class="keyword">let</span></span> 
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">derive</span> <span class="entity">dtyp_name</span> <span class="main">_</span> <span class="entity">thy</span> <span class="main">=</span> 
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">base_name</span> <span class="main">=</span> Long_Name.base_name <span class="entity">dtyp_name</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> writeln <span class="main">(</span><span class="inner_quoted">"proving that datatype "</span> ^ <span class="entity">base_name</span> ^ <span class="inner_quoted">" is countable"</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sort</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">countable</span><span class="antiquote">}</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">vs</span> <span class="main">=</span> 
          <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">i</span> <span class="main">=</span> <span class="entity">BNF_LFP_Compat.the_spec</span> <span class="entity">thy</span> <span class="entity">dtyp_name</span> |&gt; <span class="main">#</span><span class="inner_numeral">1</span> 
          <span class="keyword2"><span class="keyword">in</span></span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">n</span><span class="main">,</span><span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">n</span><span class="main">,</span> <span class="entity">sort</span><span class="main">)</span><span class="main">)</span> <span class="entity">i</span> <span class="keyword2"><span class="keyword">end</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy'</span> <span class="main">=</span> <span class="entity">Class.instantiation</span> <span class="main">(</span><span class="main">[</span><span class="entity">dtyp_name</span><span class="main">]</span><span class="main">,</span><span class="entity">vs</span><span class="main">,</span><span class="entity">sort</span><span class="main">)</span> <span class="entity">thy</span>
          |&gt; <span class="entity">Class.prove_instantiation_exit</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> <span class="entity">countable_tac</span> <span class="entity">ctxt</span> <span class="inner_numeral">1</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> writeln <span class="main">(</span><span class="inner_quoted">"registered "</span> ^ <span class="entity">base_name</span> ^ <span class="inner_quoted">" in class countable"</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">thy'</span> <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword2"><span class="keyword">in</span></span> 
    <span class="entity">Derive_Manager.register_derive</span> <span class="inner_quoted">"countable"</span> <span class="inner_quoted">"register datatypes is class countable"</span> <span class="entity">derive</span>
  <span class="keyword2"><span class="keyword">end</span></span>
›</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Derive">
<div class="head">
<h1>Theory Derive</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Deriving class instances for datatypes
    Author:      Christian Sternagel and René Thiemann  &lt;christian.sternagel|rene.thiemann@uibk.ac.at&gt;
    Maintainer:  Christian Sternagel and René Thiemann 
    License:     LGPL
*)</span>
<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Loading Existing Derive-Commands›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Derive
<span class="keyword2"><span class="keyword">imports</span></span> 
  <span class="quoted">"<a href="Compare_Instances.html">Comparator_Generator/Compare_Instances</a>"</span>
  <span class="quoted">"<a href="Equality_Instances.html">Equality_Generator/Equality_Instances</a>"</span>
  <span class="quoted">"<a href="Hash_Instances.html">Hash_Generator/Hash_Instances</a>"</span>
  <span class="quoted">"<a href="Countable_Generator.html">Countable_Generator/Countable_Generator</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
We just load the commands to derive comparators, equality-functions, hash-functions, and the
command to show that a datatype is countable, so that now all of them are available.
There are further generators available in the AFP entries Containers and Show.
›</span></span>

<span class="keyword1"><span class="command">print_derives</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Derive_Examples">
<div class="head">
<h1>Theory Derive_Examples</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Deriving class instances for datatypes
    Author:      Christian Sternagel and René Thiemann  &lt;christian.sternagel|rene.thiemann@uibk.ac.at&gt;
    Maintainer:  Christian Sternagel and René Thiemann 
    License:     LGPL
*)</span>
<span class="keyword1"><span class="command">section</span></span> <span class="plain_text">Examples</span>

<span class="keyword1"><span class="command">theory</span></span> Derive_Examples
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="Derive.html">Derive</a>
  <span class="quoted">"<a href="Compare_Order_Instances.html">Comparator_Generator/Compare_Order_Instances</a>"</span>
  <span class="quoted">"<a href="Equality_Instances.html">Equality_Generator/Equality_Instances</a>"</span>
  <a href="../../HOL/HOL/Rat.html">HOL.Rat</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Rational Numbers"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The rational numbers are not a datatype, so it will not be possible to derive 
  corresponding instances of comparators, hashcodes, etc. via the generators. But we can and should
  still register the existing instances, so that later datatypes are supported 
  which use rational numbers.›</span></span> 

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Use the linear order on rationals to define the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> compare_order<span class="antiquote"><span class="antiquote">}</span></span></span></span>-instance.›</span></span>
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>linorder<span class="main">)</span> compare_order <span class="quoted">rat</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Use <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(=)</span></span> <span class="main"><span class="main">::</span></span> rat <span class="main"><span class="main">=&gt;</span></span> rat <span class="main"><span class="main">=&gt;</span></span> bool"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> as equality function.›</span></span>
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>eq<span class="main">)</span> equality <span class="quoted">rat</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹First manually define a hashcode function.›</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> rat <span class="main">::</span> <span class="quoted">hashable</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"def_hashmap_size <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main">::</span> rat itself<span class="main">.</span> <span class="numeral">10</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"hashcode <span class="main">(</span><span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">::</span> rat<span class="main">)</span> <span class="main">=</span> hashcode <span class="main">(</span>quotient_of <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro_classes</span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> def_hashmap_size_rat_def<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹And then register it at the generator.›</span></span>

<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>hashcode<span class="main">)</span> hash_code <span class="quoted">rat</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"A Datatype Without Nested Recursion"</span></span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="tfree">'a</span> bintree <span class="main">=</span> BEmpty <span class="main">|</span> BNode <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> bintree"</span></span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> bintree"</span></span>

<span class="keyword1"><span class="command">derive</span></span> compare_order <span class="quoted">bintree</span>
<span class="keyword1"><span class="command">derive</span></span> countable <span class="quoted">bintree</span>
<span class="keyword1"><span class="command">derive</span></span> equality <span class="quoted">bintree</span>
<span class="keyword1"><span class="command">derive</span></span> hashable <span class="quoted">bintree</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Using Other datatypes"</span></span>

<span class="keyword1"><span class="command">datatype</span></span> nat_list_list <span class="main">=</span> NNil <span class="main">|</span> CCons <span class="quoted"><span class="quoted">"nat list <span class="main">×</span> rat option"</span></span> <span class="quoted">nat_list_list</span>

<span class="keyword1"><span class="command">derive</span></span> compare_order <span class="quoted">nat_list_list</span>
<span class="keyword1"><span class="command">derive</span></span> countable <span class="quoted">nat_list_list</span>
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>eq<span class="main">)</span> equality <span class="quoted">nat_list_list</span>
<span class="keyword1"><span class="command">derive</span></span> hashable <span class="quoted">nat_list_list</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Mutual Recursion"</span></span>

<span class="keyword1"><span class="command">datatype</span></span>
  <span class="tfree">'a</span> mtree <span class="main">=</span> MEmpty <span class="main">|</span> MNode <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> mtree_list"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="tfree">'a</span> mtree_list <span class="main">=</span> MNil <span class="main">|</span> MCons <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> mtree"</span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> mtree_list"</span></span>

<span class="keyword1"><span class="command">derive</span></span> compare_order <span class="quoted">mtree</span> <span class="quoted">mtree_list</span>
<span class="keyword1"><span class="command">derive</span></span> countable <span class="quoted">mtree</span> <span class="quoted">mtree_list</span>
<span class="keyword1"><span class="command">derive</span></span> hashable <span class="quoted">mtree</span> <span class="quoted">mtree_list</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹For <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>derive (equality|comparator|hash_code) mutual_recursive_type›</span></span></span></span> 
  there is the speciality that only one of the mutual recursive types has to be mentioned in
  order to register all of them. So one of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> mtree<span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> mtree_list<span class="antiquote"><span class="antiquote">}</span></span></span></span> suffices.›</span></span>

<span class="keyword1"><span class="command">derive</span></span> equality <span class="quoted">mtree</span> 
 
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Nested recursion"</span></span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="tfree">'a</span> tree <span class="main">=</span> Empty <span class="main">|</span> Node <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> tree list"</span></span>
<span class="keyword1"><span class="command">datatype</span></span> <span class="tfree">'a</span> ttree <span class="main">=</span> TEmpty <span class="main">|</span> TNode <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> ttree list tree"</span></span>

<span class="keyword1"><span class="command">derive</span></span> compare_order <span class="quoted">tree</span> <span class="quoted">ttree</span>
<span class="keyword1"><span class="command">derive</span></span> countable <span class="quoted">tree</span> <span class="quoted">ttree</span>
<span class="keyword1"><span class="command">derive</span></span> equality <span class="quoted">tree</span> <span class="quoted">ttree</span>
<span class="keyword1"><span class="command">derive</span></span> hashable <span class="quoted">tree</span> <span class="quoted">ttree</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Examples from \isafor›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="main">(</span><span class="tfree">'f</span><span class="main">,</span><span class="tfree">'v</span><span class="main">)</span> <span class="quoted">"term"</span> <span class="main">=</span> Var <span class="tfree"><span class="quoted"><span class="tfree">'v</span></span></span> <span class="main">|</span> Fun <span class="tfree"><span class="quoted"><span class="tfree">'f</span></span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'f</span><span class="main">,</span><span class="tfree">'v</span><span class="main">)</span> term list"</span></span>
<span class="keyword1"><span class="command">datatype</span></span> <span class="main">(</span><span class="tfree">'f</span><span class="main">,</span> <span class="tfree">'l</span><span class="main">)</span> lab <span class="main">=</span>
  Lab <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'f</span><span class="main">,</span> <span class="tfree">'l</span><span class="main">)</span> lab"</span></span> <span class="tfree"><span class="quoted"><span class="tfree">'l</span></span></span>
<span class="main">|</span> FunLab <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'f</span><span class="main">,</span> <span class="tfree">'l</span><span class="main">)</span> lab"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'f</span><span class="main">,</span> <span class="tfree">'l</span><span class="main">)</span> lab list"</span></span>
<span class="main">|</span> UnLab <span class="tfree"><span class="quoted"><span class="tfree">'f</span></span></span>
<span class="main">|</span> Sharp <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'f</span><span class="main">,</span> <span class="tfree">'l</span><span class="main">)</span> lab"</span></span>

<span class="keyword1"><span class="command">derive</span></span> compare_order <span class="quoted"><span class="quoted">"term"</span></span> <span class="quoted">lab</span>
<span class="keyword1"><span class="command">derive</span></span> countable <span class="quoted"><span class="quoted">"term"</span></span> <span class="quoted">lab</span>
<span class="keyword1"><span class="command">derive</span></span> equality <span class="quoted"><span class="quoted">"term"</span></span> <span class="quoted">lab</span>
<span class="keyword1"><span class="command">derive</span></span> hashable <span class="quoted"><span class="quoted">"term"</span></span> <span class="quoted">lab</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"A Complex Datatype"</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
The following datatype has nested and mutual recursion, and
uses other datatypes.
›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> complex <span class="main">=</span> 
  C1 <span class="quoted">nat</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> ttree <span class="main">×</span> rat <span class="main">+</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> complex list"</span></span> <span class="main">|</span>
  C2 <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> complex list tree tree"</span></span> <span class="tfree"><span class="quoted"><span class="tfree">'b</span></span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> complex"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> complex2 ttree list"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> complex2 <span class="main">=</span> D1 <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> complex ttree"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹On this last example type we illustrate the difference of the various comparator- and order-generators.

  For <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> complex<span class="antiquote"><span class="antiquote">}</span></span></span></span> we create an instance of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> compare_order<span class="antiquote"><span class="antiquote">}</span></span></span></span> which also defines
  a linear order. Note however that the instance will 
  be <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> complex<span class="antiquote"><span class="antiquote">}</span></span></span></span> :: (<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> compare<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> compare<span class="antiquote"><span class="antiquote">}</span></span></span></span>) <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> compare_order<span class="antiquote"><span class="antiquote">}</span></span></span></span>, i.e., the 
  argument types have to be in class <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> compare<span class="antiquote"><span class="antiquote">}</span></span></span></span>. 

  For <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> complex2<span class="antiquote"><span class="antiquote">}</span></span></span></span> we only derive <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> compare<span class="antiquote"><span class="antiquote">}</span></span></span></span> which is not a subclass of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> linorder<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  The instance will be <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> complex2<span class="antiquote"><span class="antiquote">}</span></span></span></span> :: (<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> compare<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> compare<span class="antiquote"><span class="antiquote">}</span></span></span></span>) <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> compare<span class="antiquote"><span class="antiquote">}</span></span></span></span>, i.e., 
  again the argument types have to be in class <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> compare<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

  To avoid the dependence on <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> compare<span class="antiquote"><span class="antiquote">}</span></span></span></span>, we can also instruct <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>derive›</span></span></span></span> to be based on 
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> linorder<span class="antiquote"><span class="antiquote">}</span></span></span></span>. Here, the command <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>derive linorder complex2›</span></span></span></span> will create the instance
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> complex2<span class="antiquote"><span class="antiquote">}</span></span></span></span> :: (<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> linorder<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> linorder<span class="antiquote"><span class="antiquote">}</span></span></span></span>) <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> linorder<span class="antiquote"><span class="antiquote">}</span></span></span></span>, i.e., 
  here the argument types have to be in class <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> linorder<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  ›</span></span>
<span class="keyword1"><span class="command">derive</span></span> compare_order <span class="quoted">complex</span> 
<span class="keyword1"><span class="command">derive</span></span> compare <span class="quoted">complex2</span>
<span class="keyword1"><span class="command">derive</span></span> linorder <span class="quoted">complex2</span>
<span class="keyword1"><span class="command">derive</span></span> countable <span class="quoted">complex</span> <span class="quoted">complex2</span>
<span class="keyword1"><span class="command">derive</span></span> equality <span class="quoted">complex</span>
<span class="keyword1"><span class="command">derive</span></span> hashable <span class="quoted">complex</span> <span class="quoted">complex2</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div>