<div id="Derive_Manager">
<div class="head"><h1>Theory Derive_Manager</h1>
<span class="command">theory</span> <span class="name">Derive_Manager</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:       Deriving class instances for datatypes
    Author:      Christian Sternagel and René Thiemann  &lt;christian.sternagel|rene.thiemann@uibk.ac.at&gt;
    Maintainer:  Christian Sternagel and René Thiemann 
    License:     LGPL
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Derive Manager›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Derive_Manager</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span>
</span><span class="keyword2"><span class="keyword">keywords</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"print_derives"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span>diag</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"derive"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span>thy_decl</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  The derive manager allows the user to register various derive-hooks, e.g., for orders,
  pretty-printers, hash-functions, etc. All registered hooks are accessible via the derive command.

  @{rail ‹
    @'derive' ('(' param ')')? sort (datatype+)
  ›}

  \begin{description}
  \item ‹<span class="hidden">❙</span><span class="bold">d</span><span class="hidden">❙</span><span class="bold">e</span><span class="hidden">❙</span><span class="bold">r</span><span class="hidden">❙</span><span class="bold">i</span><span class="hidden">❙</span><span class="bold">v</span><span class="hidden">❙</span><span class="bold">e</span> (param) sort datatype› calls the hook for deriving ‹sort› (that
  may depend on the optional ‹param›) on ‹datatype› (if such a hook is registered).

  E.g., ‹<span class="hidden">❙</span><span class="bold">d</span><span class="hidden">❙</span><span class="bold">e</span><span class="hidden">❙</span><span class="bold">r</span><span class="hidden">❙</span><span class="bold">i</span><span class="hidden">❙</span><span class="bold">v</span><span class="hidden">❙</span><span class="bold">e</span> compare_order list› will derive a comparator for datatype @{type list}
  which is also used to define a linear order on @{type list}s.
  \end{description}

  There is also the diagnostic command ‹<span class="hidden">❙</span><span class="bold">p</span><span class="hidden">❙</span><span class="bold">r</span><span class="hidden">❙</span><span class="bold">i</span><span class="hidden">❙</span><span class="bold">n</span><span class="hidden">❙</span><span class="bold">t</span><span class="hidden">❙</span><span class="bold">_</span><span class="hidden">❙</span><span class="bold">d</span><span class="hidden">❙</span><span class="bold">e</span><span class="hidden">❙</span><span class="bold">r</span><span class="hidden">❙</span><span class="bold">i</span><span class="hidden">❙</span><span class="bold">v</span><span class="hidden">❙</span><span class="bold">e</span><span class="hidden">❙</span><span class="bold">s</span>› that shows the list of currently
  registered hooks.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹derive_manager.ML›</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Generator_Aux">
<div class="head"><h1>Theory Generator_Aux</h1>
<span class="command">theory</span> <span class="name">Generator_Aux</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Shared Utilities for all Generator›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹In this theory we mainly provide some Isabelle/ML infrastructure
  that is used by several generators. It consists of a uniform interface
  to access all the theorems, terms, etc.\ from the BNF package, and 
  some auxiliary functions which provide recursors on datatypes, common tactics, etc.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Generator_Aux</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> 
</span><span>  </span><span>Main</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹bnf_access.ML›</span></span></span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹generator_aux.ML›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_set_simps</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"x ∈ set (y # z # ys) = (x = y ∨ x ∈ set (z # ys))"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"x ∈ set ([y]) = (x = y)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"x ∈ set [] = False"</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Ball (set []) P = True"</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Ball (set [x]) P = P x"</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Ball (set (x # y # zs)) P = (P x ∧ Ball (set (y # zs)) P)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conj_weak_cong</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a = b ⟹ c = d ⟹ (a ∧ c) = (b ∧ d)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>refl_True</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x = x) = True"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Comparator">
<div class="head"><h1>Theory Comparator</h1>
<span class="command">theory</span> <span class="name">Comparator</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:       Deriving class instances for datatypes
    Author:      Christian Sternagel and René Thiemann  &lt;christian.sternagel|rene.thiemann@uibk.ac.at&gt;
    Maintainer:  Christian Sternagel and René Thiemann 
    License:     LGPL
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Comparisons›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Comparators and Linear Orders›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Comparator</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Instead of having to define a strict and a weak linear order, @{term "((&lt;), (≤))"},
 one can alternative use a comparator to define the linear order, which may deliver 
 three possible outcomes when comparing two values.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>order</span><span> </span><span class="delimiter">=</span><span> </span><span>Eq</span><span> </span><span class="delimiter">|</span><span> </span><span>Lt</span><span> </span><span class="delimiter">|</span><span> </span><span>Gt</span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'a</span><span> </span><span>comparator</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ order"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹In the following, we provide the obvious definitions how to switch between 
  linear orders and comparators.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>lt_of_comp</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a comparator ⇒ 'a ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"lt_of_comp acomp x y = (case acomp x y of Lt ⇒ True | _ ⇒ False)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>le_of_comp</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a comparator ⇒ 'a ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"le_of_comp acomp x y = (case acomp x y of Gt ⇒ False | _ ⇒ True)"</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>comp_of_ords</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'a ⇒ bool) ⇒ ('a ⇒ 'a ⇒ bool) ⇒ 'a comparator"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"comp_of_ords le lt x y = (if lt x y then Lt else if le x y then Eq else Gt)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comp_of_ords_of_le_lt</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"comp_of_ords (le_of_comp c) (lt_of_comp c) = c"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>comp_of_ords_def</span><span> </span><span>le_of_comp_def</span><span> </span><span>lt_of_comp_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>order.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lt_of_comp_of_ords</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lt_of_comp (comp_of_ords le lt) = lt"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>comp_of_ords_def</span><span> </span><span>le_of_comp_def</span><span> </span><span>lt_of_comp_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>order.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>le_of_comp_of_ords_gen</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀ x y. lt x y ⟹ le x y) ⟹ le_of_comp (comp_of_ords le lt) = le"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>comp_of_ords_def</span><span> </span><span>le_of_comp_def</span><span> </span><span>lt_of_comp_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>order.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>le_of_comp_of_ords_linorder</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"class.linorder le lt"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"le_of_comp (comp_of_ords le lt) = le"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>linorder</span><span> </span><span>le</span><span> </span><span>lt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>le_of_comp_of_ords_gen</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>invert_order</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"order ⇒ order"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"invert_order Lt = Gt"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"invert_order Gt = Lt"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"invert_order Eq = Eq"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>comparator</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>comp</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a comparator"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>sym</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invert_order (comp x y) = comp y x"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>weak_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"comp x y = Eq ⟹ x = y"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"comp x y = Lt ⟹ comp y z = Lt ⟹ comp x z = Lt"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(comp x y = Eq) = (x = y)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>sym</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>y</span><span> </span><span>y</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"comp x y = Eq"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"comp x y"</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>weak_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comp_same</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"comp x x = Eq"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lt ≡ lt_of_comp comp"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"le ≡ le_of_comp comp"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>linorder</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"class.linorder le lt"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>lt_of_comp_def</span><span> </span><span>le_of_comp_def</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'a</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lt x y = (le x y ∧ ¬ le y x)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sym</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"comp x y"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"le x y ∨ le y x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sym</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"comp x y"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"le x x"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eq</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span>x</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"le x y ⟹ le y x ⟹ x = y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sym</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"comp x y"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"le x y ⟹ le y z ⟹ le x z"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"comp x y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"comp y z"</span></span></span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>order.exhaust</span><span> </span><span class="delimiter">[</span><span>case_product</span><span> </span><span>order.exhaust</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>trans</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eq</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>linorder</span><span> </span><span>le</span><span> </span><span>lt</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>linorder</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Gt_lt_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"comp x y = Gt ⟷ lt y x"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lt_of_comp_def</span><span> </span><span>sym</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"comp x y"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Lt_lt_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"comp x y = Lt ⟷ lt x y"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lt_of_comp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"comp x y"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eq_Eq_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"comp x y = Eq ⟷ x = y"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>eq</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nGt_le_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"comp x y ≠ Gt ⟷ le x y"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>le_of_comp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"comp x y"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nLt_le_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"comp x y ≠ Lt ⟷ le y x"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>le_of_comp_def</span><span> </span><span>sym</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"comp x y"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nEq_neq_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"comp x y ≠ Eq ⟷ x ≠ y"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eq_Eq_conv</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>le_lt_convs</span><span> </span><span class="delimiter">=</span><span>  </span><span>nLt_le_conv</span><span> </span><span>nGt_le_conv</span><span> </span><span>Gt_lt_conv</span><span> </span><span>Lt_lt_conv</span><span> </span><span>eq_Eq_conv</span><span> </span><span>nEq_neq_conv</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>two_comparisons_into_case_order</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(if le x y then (if x = y then P else Q) else R) = (case_order P Q R (comp x y))"</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(if le x y then (if y = x then P else Q) else R) = (case_order P Q R (comp x y))"</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(if le x y then (if le y x then P else Q) else R) = (case_order P Q R (comp x y))"</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(if le x y then (if lt x y then Q else P) else R) = (case_order P Q R (comp x y))"</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(if lt x y then Q else (if le x y then P else R)) = (case_order P Q R (comp x y))"</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(if lt x y then Q else (if lt y x then R else P)) = (case_order P Q R (comp x y))"</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(if lt x y then Q else (if x = y then P else R)) = (case_order P Q R (comp x y))"</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(if lt x y then Q else (if y = x then P else R)) = (case_order P Q R (comp x y))"</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(if x = y then P else (if lt y x then R else Q)) = (case_order P Q R (comp x y))"</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(if x = y then P else (if lt x y then Q else R)) = (case_order P Q R (comp x y))"</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(if x = y then P else (if le y x then R else Q)) = (case_order P Q R (comp x y))"</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(if x = y then P else (if le x y then Q else R)) = (case_order P Q R (comp x y))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>le_lt_convs</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>order.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comp_of_ords</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"class.linorder le lt"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"comparator (comp_of_ords le lt)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>linorder</span><span> </span><span>le</span><span> </span><span>lt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>comp_of_ords_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>linorder</span><span class="delimiter">)</span><span> </span><span>comparator_of</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a comparator"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"comparator_of x y = (if x &lt; y then Lt else if x = y then Eq else Gt)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comparator_of</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"comparator comparator_of"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>comparator_of_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Compare">
<div class="head"><h1>Theory Compare</h1>
<span class="command">theory</span> <span class="name">Compare</span><br/>
<span class="keyword">imports</span> <a href="Comparator.html"><span class="name">Comparator</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:       Deriving class instances for datatypes
    Author:      Christian Sternagel and René Thiemann  &lt;christian.sternagel|rene.thiemann@uibk.ac.at&gt;
    Maintainer:  Christian Sternagel and René Thiemann 
    License:     LGPL
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Compare›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Compare</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Comparator</span><span>
</span><span class="keyword2"><span class="keyword">keywords</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"compare_code"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span>thy_decl</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹This introduces a type class for having a proper comparator, similar to @{class linorder}.
  Since most of the Isabelle/HOL algorithms work on the latter, we also provide a method which 
  turns linear-order based algorithms into comparator-based algorithms, where two consecutive 
  invocations of linear orders and equality are merged into one comparator invocation.
  We further define a class which both define a linear order and a comparator, and where the
  induces orders coincide.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>compare</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>compare</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a comparator"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>comparator_compare</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"comparator compare"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>compare_Eq_is_eq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"compare x y = Eq ⟷ x = y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>comparator.eq</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>comparator_compare</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>compare_refl</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"compare x x = Eq"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>linorder</span><span class="delimiter">)</span><span> </span><span>le_lt_comparator_of</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"le_of_comp comparator_of = (≤)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lt_of_comp comparator_of = (&lt;)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>comparator_of_def</span><span> </span><span>le_of_comp_def</span><span> </span><span>lt_of_comp_def</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>compare_order</span><span> </span><span class="delimiter">=</span><span> </span><span>ord</span><span> </span><span class="delimiter">+</span><span> </span><span>compare</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>ord_defs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"le_of_comp compare = (≤) "</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lt_of_comp compare = (&lt;)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ @{class compare_order} is @{class compare} and @{class linorder}, where comparator and orders 
  define the same ordering.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subclass</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>compare_order</span><span class="delimiter">)</span><span> </span><span>linorder</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>ord_defs</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>comparator.linorder</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>comparator_compare</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>compare_order</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>compare_is_comparator_of</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"compare = comparator_of"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'a</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"compare x y = comparator_of x y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span>  </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>comparator_of_def</span><span class="delimiter">,</span><span> </span><span>unfold</span><span> </span><span>ord_defs</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>lt_of_comp_def</span><span class="delimiter">,</span><span> 
</span><span>      </span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"compare x y"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>two_comparisons_into_compare</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span>comparator.two_comparisons_into_case_order</span><span class="delimiter">[</span><span>OF</span><span> </span><span>comparator_compare</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>ord_defs</span><span class="delimiter">]</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>two_comparisons_into_compare</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹compare_code.ML›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹‹Compare_Code.change_compare_code const ty-vars› changes the code equations of some constant such that
  two consecutive comparisons via @{term "(&lt;=)"}, @{term "(&lt;)"}", or @{term "(=)"} are turned into one
  invocation of @{const compare}. 
  The difference to a standard ‹code_unfold› is that here we change the code-equations
  where an additional sort-constraint on @{class compare_order} can be added. Otherwise, there would
  be no @{const compare}-function.›</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="RBT_Compare_Order_Impl">
<div class="head"><h1>Theory RBT_Compare_Order_Impl</h1>
<span class="command">theory</span> <span class="name">RBT_Compare_Order_Impl</span><br/>
<span class="keyword">imports</span> <a href="Compare.html"><span class="name">Compare</span></a> <a href="../../HOL/HOL-Library/RBT_Impl.html"><span class="name">RBT_Impl</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Example: Modifying the Code-Equations of Red-Black-Trees›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>RBT_Compare_Order_Impl</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Compare</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.RBT_Impl"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹In the following, we modify all code-equations of the red-black-tree 
  implementation that perform comparisons. As a positive result, they now all require
  one invocation of comparator, where before two comparisons have been performed.
  The disadvantage of this simple solution is the additional class constraint on
  @{class compare_order}.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">compare_code</span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"'a"</span></span></span><span class="delimiter">)</span><span> </span><span>rbt_ins</span><span>
</span><span class="keyword1"><span class="command">compare_code</span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"'a"</span></span></span><span class="delimiter">)</span><span> </span><span>rbt_lookup</span><span>
</span><span class="keyword1"><span class="command">compare_code</span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"'a"</span></span></span><span class="delimiter">)</span><span> </span><span>rbt_del</span><span>
</span><span class="keyword1"><span class="command">compare_code</span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"'a"</span></span></span><span class="delimiter">)</span><span> </span><span>rbt_map_entry</span><span>
</span><span class="keyword1"><span class="command">compare_code</span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"'a"</span></span></span><span class="delimiter">)</span><span> </span><span>sunion_with</span><span>
</span><span class="keyword1"><span class="command">compare_code</span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"'a"</span></span></span><span class="delimiter">)</span><span> </span><span>sinter_with</span><span>
</span><span>
</span><span class="keyword1"><span class="command">export_code</span></span><span> </span><span>rbt_ins</span><span> </span><span>rbt_lookup</span><span> </span><span>rbt_del</span><span> </span><span>rbt_map_entry</span><span> </span><span>rbt_union_with_key</span><span> </span><span>rbt_inter_with_key</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>Haskell</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="RBT_Comparator_Impl">
<div class="head"><h1>Theory RBT_Comparator_Impl</h1>
<span class="command">theory</span> <span class="name">RBT_Comparator_Impl</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL-Library/RBT_Impl.html"><span class="name">RBT_Impl</span></a> <a href="Comparator.html"><span class="name">Comparator</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A Comparator-Interface to Red-Black-Trees›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>RBT_Comparator_Impl</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.RBT_Impl"</span></span></span><span>
</span><span>  </span><span>Comparator</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹For all of the main algorithms of red-black trees, we
  provide alternatives which are completely based on comparators,
  and which are provable equivalent. At the time of writing,
  this interface is used in the Container AFP-entry.
  
  It does not rely on the modifications of code-equations as in 
  the previous subsection.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>c</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a comparator"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>rbt_comp_lookup</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) rbt ⇒ 'a ⇀ 'b"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rbt_comp_lookup RBT_Impl.Empty k = None"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"rbt_comp_lookup (Branch _ l x y r) k = 
   (case c k x of Lt ⇒ rbt_comp_lookup l k 
     | Gt ⇒ rbt_comp_lookup r k 
     | Eq ⇒ Some y)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span>
</span><span>  </span><span>rbt_comp_ins</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b ⇒ 'b ⇒ 'b) ⇒ 'a ⇒ 'b ⇒ ('a,'b) rbt ⇒ ('a,'b) rbt"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rbt_comp_ins f k v RBT_Impl.Empty = Branch RBT_Impl.R RBT_Impl.Empty k v  RBT_Impl.Empty"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rbt_comp_ins f k v (Branch RBT_Impl.B l x y r) = (case c k x of 
      Lt ⇒ balance (rbt_comp_ins f k v l) x y r
    | Gt ⇒ balance l x y (rbt_comp_ins f k v r)
    | Eq ⇒ Branch RBT_Impl.B l x (f k y v) r)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rbt_comp_ins f k v (Branch RBT_Impl.R l x y r) = (case c k x of 
      Lt ⇒ Branch RBT_Impl.R (rbt_comp_ins f k v l) x y r
    | Gt ⇒ Branch RBT_Impl.R l x y (rbt_comp_ins f k v r)
    | Eq ⇒ Branch RBT_Impl.R l x (f k y v) r)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>rbt_comp_insert_with_key</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b ⇒ 'b ⇒ 'b) ⇒ 'a ⇒ 'b ⇒ ('a,'b) rbt ⇒ ('a,'b) rbt"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rbt_comp_insert_with_key f k v t = paint RBT_Impl.B (rbt_comp_ins f k v t)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>rbt_comp_insert</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'b ⇒ ('a, 'b) rbt ⇒ ('a, 'b) rbt"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rbt_comp_insert = rbt_comp_insert_with_key (λ_ _ nv. nv)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span>
</span><span>  </span><span>rbt_comp_del_from_left</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ ('a,'b) rbt ⇒ 'a ⇒ 'b ⇒ ('a,'b) rbt ⇒ ('a,'b) rbt"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>rbt_comp_del_from_right</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ ('a,'b) rbt ⇒ 'a ⇒ 'b ⇒ ('a,'b) rbt ⇒ ('a,'b) rbt"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>rbt_comp_del</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a⇒ ('a,'b) rbt ⇒ ('a,'b) rbt"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rbt_comp_del x RBT_Impl.Empty = RBT_Impl.Empty"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rbt_comp_del x (Branch _ a y s b) = 
   (case c x y of 
        Lt ⇒ rbt_comp_del_from_left x a y s b 
      | Gt ⇒ rbt_comp_del_from_right x a y s b
      | Eq ⇒ combine a b)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rbt_comp_del_from_left x (Branch RBT_Impl.B lt z v rt) y s b = balance_left (rbt_comp_del x (Branch RBT_Impl.B lt z v rt)) y s b"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rbt_comp_del_from_left x a y s b = Branch RBT_Impl.R (rbt_comp_del x a) y s b"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rbt_comp_del_from_right x a y s (Branch RBT_Impl.B lt z v rt) = balance_right a y s (rbt_comp_del x (Branch RBT_Impl.B lt z v rt))"</span></span></span><span> </span><span class="delimiter">|</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rbt_comp_del_from_right x a y s b = Branch RBT_Impl.R a y s (rbt_comp_del x b)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rbt_comp_delete k t = paint RBT_Impl.B (rbt_comp_del k t)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rbt_comp_bulkload xs = foldr (λ(k, v). rbt_comp_insert k v) xs RBT_Impl.Empty"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span>
</span><span>  </span><span>rbt_comp_map_entry</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ ('b ⇒ 'b) ⇒ ('a, 'b) rbt ⇒ ('a, 'b) rbt"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rbt_comp_map_entry k f RBT_Impl.Empty = RBT_Impl.Empty"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"rbt_comp_map_entry k f (Branch cc lt x v rt) =
    (case c k x of 
        Lt ⇒ Branch cc (rbt_comp_map_entry k f lt) x v rt
      | Gt ⇒ Branch cc lt x v (rbt_comp_map_entry k f rt)
      | Eq ⇒ Branch cc lt x (f v) rt)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">function</span></span><span> </span><span>comp_sunion_with</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b ⇒ 'b ⇒ 'b) ⇒ ('a × 'b) list ⇒ ('a × 'b) list ⇒ ('a × 'b) list"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"comp_sunion_with f ((k, v) # as) ((k', v') # bs) =
   (case c k' k of 
        Lt ⇒ (k', v') # comp_sunion_with f ((k, v) # as) bs
      | Gt ⇒ (k, v) # comp_sunion_with f as ((k', v') # bs)
      | Eq ⇒ (k, f k v v') # comp_sunion_with f as bs)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"comp_sunion_with f [] bs = bs"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"comp_sunion_with f as [] = as"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>pat_completeness</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">termination</span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">function</span></span><span> </span><span>comp_sinter_with</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b ⇒ 'b ⇒ 'b) ⇒ ('a × 'b) list ⇒ ('a × 'b) list ⇒ ('a × 'b) list"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"comp_sinter_with f ((k, v) # as) ((k', v') # bs) =
  (case c k' k of 
      Lt ⇒ comp_sinter_with f ((k, v) # as) bs
    | Gt ⇒ comp_sinter_with f as ((k', v') # bs)
    | Eq ⇒ (k, f k v v') # comp_sinter_with f as bs)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"comp_sinter_with f [] _ = []"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"comp_sinter_with f _ [] = []"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>pat_completeness</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">termination</span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>rbt_comp_union_with_key</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b ⇒ 'b ⇒ 'b) ⇒ ('a, 'b) rbt ⇒ ('a, 'b) rbt ⇒ ('a, 'b) rbt"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rbt_comp_union_with_key f t1 t2 =
  (case RBT_Impl.compare_height t1 t1 t2 t2
   of compare.EQ ⇒ rbtreeify (comp_sunion_with f (RBT_Impl.entries t1) (RBT_Impl.entries t2))
    | compare.LT ⇒ RBT_Impl.fold (rbt_comp_insert_with_key (λk v w. f k w v)) t1 t2
    | compare.GT ⇒ RBT_Impl.fold (rbt_comp_insert_with_key f) t2 t1)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>rbt_comp_inter_with_key</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b ⇒ 'b ⇒ 'b) ⇒ ('a, 'b) rbt ⇒ ('a, 'b) rbt ⇒ ('a, 'b) rbt"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rbt_comp_inter_with_key f t1 t2 =
  (case RBT_Impl.compare_height t1 t1 t2 t2 
   of compare.EQ ⇒ rbtreeify (comp_sinter_with f (RBT_Impl.entries t1) (RBT_Impl.entries t2))
    | compare.LT ⇒ rbtreeify (List.map_filter (λ(k, v). map_option (λw. (k, f k v w)) (rbt_comp_lookup t2 k)) (RBT_Impl.entries t1))
    | compare.GT ⇒ rbtreeify (List.map_filter (λ(k, v). map_option (λw. (k, f k w v)) (rbt_comp_lookup t1 k)) (RBT_Impl.entries t2)))"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"comparator c"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rbt_comp_lookup</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rbt_comp_lookup = ord.rbt_lookup (lt_of_comp c)"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>k</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,'b)rbt"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rbt_comp_lookup t k = ord.rbt_lookup (lt_of_comp c) t k"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span class="delimiter">,</span><span> </span><span>unfold</span><span> </span><span>rbt_comp_lookup.simps</span><span> </span><span>ord.rbt_lookup.simps</span><span>
</span><span>      </span><span>comparator.two_comparisons_into_case_order</span><span class="delimiter">[</span><span>OF</span><span> </span><span>c</span><span class="delimiter">]</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>order.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rbt_comp_ins</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rbt_comp_ins = ord.rbt_ins (lt_of_comp c)"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>f</span><span> </span><span>k</span><span> </span><span>v</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,'b)rbt"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rbt_comp_ins f k v t = ord.rbt_ins (lt_of_comp c) f k v t"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>f</span><span> </span><span>k</span><span> </span><span>v</span><span> </span><span>t</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rbt_comp_ins.induct</span><span class="delimiter">,</span><span> </span><span>unfold</span><span> </span><span>rbt_comp_ins.simps</span><span> </span><span>ord.rbt_ins.simps</span><span>
</span><span>      </span><span>comparator.two_comparisons_into_case_order</span><span class="delimiter">[</span><span>OF</span><span> </span><span>c</span><span class="delimiter">]</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>order.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rbt_comp_insert_with_key</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rbt_comp_insert_with_key = ord.rbt_insert_with_key (lt_of_comp c)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rbt_comp_insert_with_key_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>ord.rbt_insert_with_key_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rbt_comp_ins</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rbt_comp_insert</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rbt_comp_insert = ord.rbt_insert (lt_of_comp c)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rbt_comp_insert_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>ord.rbt_insert_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rbt_comp_insert_with_key</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rbt_comp_del</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rbt_comp_del = ord.rbt_del (lt_of_comp c)"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>k</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,'b)rbt"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"rbt_comp_del_from_left k t a b s = ord.rbt_del_from_left (lt_of_comp c) k t a b s"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"rbt_comp_del_from_right k t a b s = ord.rbt_del_from_right (lt_of_comp c) k t a b s"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"rbt_comp_del k t = ord.rbt_del (lt_of_comp c) k t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>k</span><span> </span><span>t</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>s</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>k</span><span> </span><span>t</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>s</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>k</span><span> </span><span>t</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rbt_comp_del_from_left_rbt_comp_del_from_right_rbt_comp_del.induct</span><span class="delimiter">,</span><span>
</span><span>    </span><span>unfold</span><span> 
</span><span>      </span><span>rbt_comp_del.simps</span><span> </span><span>ord.rbt_del.simps</span><span>
</span><span>      </span><span>rbt_comp_del_from_left.simps</span><span> </span><span>ord.rbt_del_from_left.simps</span><span>
</span><span>      </span><span>rbt_comp_del_from_right.simps</span><span> </span><span>ord.rbt_del_from_right.simps</span><span>
</span><span>      </span><span>comparator.two_comparisons_into_case_order</span><span class="delimiter">[</span><span>OF</span><span> </span><span>c</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>    </span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>order.split</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rbt_comp_delete</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rbt_comp_delete = ord.rbt_delete (lt_of_comp c)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rbt_comp_delete_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>ord.rbt_delete_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rbt_comp_del</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rbt_comp_bulkload</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rbt_comp_bulkload = ord.rbt_bulkload (lt_of_comp c)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rbt_comp_bulkload_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>ord.rbt_bulkload_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rbt_comp_insert</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rbt_comp_map_entry</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rbt_comp_map_entry = ord.rbt_map_entry (lt_of_comp c)"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>f</span><span> </span><span>k</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,'b)rbt"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rbt_comp_map_entry f k t = ord.rbt_map_entry (lt_of_comp c) f k t"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span class="delimiter">,</span><span> </span><span>unfold</span><span> </span><span>rbt_comp_map_entry.simps</span><span> </span><span>ord.rbt_map_entry.simps</span><span>
</span><span>      </span><span>comparator.two_comparisons_into_case_order</span><span class="delimiter">[</span><span>OF</span><span> </span><span>c</span><span class="delimiter">]</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>order.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comp_sunion_with</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"comp_sunion_with = ord.sunion_with (lt_of_comp c)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a × 'b)list"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"comp_sunion_with f as bs = ord.sunion_with (lt_of_comp c) f as bs"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>f</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>comp_sunion_with.induct</span><span class="delimiter">,</span><span>
</span><span>      </span><span>unfold</span><span> </span><span>comp_sunion_with.simps</span><span> </span><span>ord.sunion_with.simps</span><span>
</span><span>      </span><span>comparator.two_comparisons_into_case_order</span><span class="delimiter">[</span><span>OF</span><span> </span><span>c</span><span class="delimiter">]</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>order.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comp_sinter_with</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"comp_sinter_with = ord.sinter_with (lt_of_comp c)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a × 'b)list"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"comp_sinter_with f as bs = ord.sinter_with (lt_of_comp c) f as bs"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>f</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>comp_sinter_with.induct</span><span class="delimiter">,</span><span>
</span><span>      </span><span>unfold</span><span> </span><span>comp_sinter_with.simps</span><span> </span><span>ord.sinter_with.simps</span><span>
</span><span>      </span><span>comparator.two_comparisons_into_case_order</span><span class="delimiter">[</span><span>OF</span><span> </span><span>c</span><span class="delimiter">]</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>order.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rbt_comp_union_with_key</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rbt_comp_union_with_key = ord.rbt_union_with_key (lt_of_comp c)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rbt_comp_union_with_key_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>ord.rbt_union_with_key_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rbt_comp_insert_with_key</span><span> </span><span>comp_sunion_with</span><span> </span><span class="keyword1"><span class="command">..</span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rbt_comp_inter_with_key</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rbt_comp_inter_with_key = ord.rbt_inter_with_key (lt_of_comp c)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rbt_comp_inter_with_key_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>ord.rbt_inter_with_key_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rbt_comp_insert_with_key</span><span> </span><span>comp_sinter_with</span><span> </span><span>rbt_comp_lookup</span><span> </span><span class="keyword1"><span class="command">..</span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>rbt_comp_simps</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span>rbt_comp_insert</span><span>
</span><span>  </span><span>rbt_comp_lookup</span><span>
</span><span>  </span><span>rbt_comp_delete</span><span>
</span><span>  </span><span>rbt_comp_bulkload</span><span>
</span><span>  </span><span>rbt_comp_map_entry</span><span>
</span><span>  </span><span>rbt_comp_union_with_key</span><span>
</span><span>  </span><span>rbt_comp_inter_with_key</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Comparator_Generator">
<div class="head"><h1>Theory Comparator_Generator</h1>
<span class="command">theory</span> <span class="name">Comparator_Generator</span><br/>
<span class="keyword">imports</span> <a href="Generator_Aux.html"><span class="name">Generator_Aux</span></a> <a href="Derive_Manager.html"><span class="name">Derive_Manager</span></a> <a href="Comparator.html"><span class="name">Comparator</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:       Deriving class instances for datatypes
    Author:      Christian Sternagel and René Thiemann  &lt;christian.sternagel|rene.thiemann@uibk.ac.at&gt;
    Maintainer:  Christian Sternagel and René Thiemann 
    License:     LGPL
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Generating Comparators›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Comparator_Generator</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"../Generator_Aux"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"../Derive_Manager"</span></span></span><span>
</span><span>  </span><span>Comparator</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">typedecl</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'a</span><span class="delimiter">,</span><span class="tfree">'b</span><span class="delimiter">,</span><span class="tfree">'c</span><span class="delimiter">,</span><span class="tfree">'z</span><span class="delimiter">)</span><span>type</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹In the following, we define a generator which for a given datatype @{typ "('a,'b,'c,'z)type"}
  constructs a comparator of type 
  @{typ "'a comparator ⇒ 'b comparator ⇒ 'c comparator ⇒ 'z comparator ⇒ ('a,'b,'c,'z)type"}.
  To this end, we first compare the index of the constructors, then for equal constructors, we
  compare the arguments recursively and combine the results lexicographically.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">hide_type</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"type"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Lexicographic combination of @{typ order}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>comp_lex</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"order list ⇒ order"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"comp_lex (c # cs) = (case c of Eq ⇒ comp_lex cs | _ ⇒ c)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"comp_lex [] = Eq"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Improved code for non-lazy languages›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The following equations will eliminate all occurrences of @{term comp_lex}
  in the generated code of the comparators.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comp_lex_unfolds</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"comp_lex [] = Eq"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"comp_lex [c] = c"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"comp_lex (c # d # cs) = (case c of Eq ⇒ comp_lex (d # cs) | z ⇒ z)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Pointwise properties for equality, symmetry, and transitivity›</span></span></span><span> 
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The pointwise properties are important during inductive proofs of soundness of comparators.
  They are defined in a way that are combinable with @{const comp_lex}.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comp_lex_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"comp_lex os = Eq ⟷ (∀ ord ∈ set os. ord = Eq)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>os</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>order.splits</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>trans_order</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"order ⇒ order ⇒ order ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"trans_order x y z ⟷ x ≠ Gt ⟶ y ≠ Gt ⟶ z ≠ Gt ∧ ((x = Lt ∨ y = Lt) ⟶ z = Lt)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trans_orderI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(x ≠ Gt ⟹ y ≠ Gt ⟹ z ≠ Gt ∧ ((x = Lt ∨ y = Lt) ⟶ z = Lt)) ⟹ trans_order x y z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>trans_order_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trans_orderD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans_order x y z"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≠ Gt"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ≠ Gt"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ≠ Gt"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = Lt ∨ y = Lt ⟹ z = Lt"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trans_order_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>All_less_Suc</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(∀i &lt; Suc x. P i) ⟷ P 0 ∧ (∀i &lt; x. P (Suc i))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>less_Suc_eq_0_disj</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comp_lex_trans</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length xs = length ys"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length ys = length zs"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ i &lt; length zs. trans_order (xs ! i) (ys ! i) (zs ! i)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans_order (comp_lex xs) (comp_lex ys) (comp_lex zs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span> </span><span>ys</span><span> </span><span>zs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>list_induct3</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>xs</span><span> </span><span>y</span><span> </span><span>ys</span><span> </span><span>z</span><span> </span><span>zs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>trans_orderI</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>order.exhaust</span><span> </span><span class="delimiter">[</span><span>case_product</span><span> </span><span>order.exhaust</span><span> </span><span>order.exhaust</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>        </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>All_less_Suc</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>trans_orderD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>trans_order_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comp_lex_sym</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length xs = length ys"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ i &lt; length ys. invert_order (xs ! i) = ys ! i"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invert_order (comp_lex xs) = comp_lex ys"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span> </span><span>ys</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>list_induct2</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>case_tac</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span>fastforce</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>comp_lex.simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>peq_comp</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a comparator ⇒ 'a ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"peq_comp acomp x ⟷ (∀ y. acomp x y = Eq ⟷ x = y)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>peq_compD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"peq_comp acomp x ⟹ acomp x y = Eq ⟷ x = y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>peq_comp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>peq_compI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀ y. acomp x y = Eq ⟷ x = y) ⟹ peq_comp acomp x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>peq_comp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>psym_comp</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a comparator ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"psym_comp acomp x ⟷ (∀ y. invert_order (acomp x y) = (acomp y x))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>psym_compD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"psym_comp acomp x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invert_order (acomp x y) = (acomp y x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>psym_comp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>psym_compI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ y. invert_order (acomp x y) = (acomp y x)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"psym_comp acomp x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>psym_comp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ptrans_comp</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a comparator ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ptrans_comp acomp x ⟷ (∀ y z. trans_order (acomp x y) (acomp y z) (acomp x z))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ptrans_compD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ptrans_comp acomp x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans_order (acomp x y) (acomp y z) (acomp x z)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ptrans_comp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ptrans_compI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ y z. trans_order (acomp x y) (acomp y z) (acomp x z)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ptrans_comp acomp x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ptrans_comp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Separate properties of comparators›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>eq_comp</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a comparator ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eq_comp acomp ⟷ (∀ x. peq_comp acomp x)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eq_compD2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"eq_comp acomp ⟹ peq_comp acomp x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eq_comp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eq_compI2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀ x. peq_comp acomp x) ⟹ eq_comp acomp"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eq_comp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>trans_comp</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a comparator ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"trans_comp acomp ⟷ (∀ x. ptrans_comp acomp x)"</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trans_compD2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"trans_comp acomp ⟹ ptrans_comp acomp x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>trans_comp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trans_compI2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀ x. ptrans_comp acomp x) ⟹ trans_comp acomp"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>trans_comp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>sym_comp</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a comparator ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sym_comp acomp ⟷ (∀ x. psym_comp acomp x)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sym_compD2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sym_comp acomp ⟹ psym_comp acomp x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sym_comp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sym_compI2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀ x. psym_comp acomp x) ⟹ sym_comp acomp"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sym_comp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eq_compD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"eq_comp acomp ⟹ acomp x y = Eq ⟷ x = y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>peq_compD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>eq_compD2</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eq_compI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀ x y. acomp x y = Eq ⟷ x = y) ⟹ eq_comp acomp"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>eq_compI2</span><span> </span><span>peq_compI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trans_compD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"trans_comp acomp ⟹ trans_order (acomp x y) (acomp y z) (acomp x z)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ptrans_compD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>trans_compD2</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trans_compI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀ x y z. trans_order (acomp x y) (acomp y z) (acomp x z)) ⟹ trans_comp acomp"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>trans_compI2</span><span> </span><span>ptrans_compI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sym_compD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sym_comp acomp ⟹ invert_order (acomp x y) = (acomp y x)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>psym_compD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>sym_compD2</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sym_compI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀ x y. invert_order (acomp x y) = (acomp y x)) ⟹ sym_comp acomp"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>sym_compI2</span><span> </span><span>psym_compI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eq_sym_trans_imp_comparator</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eq_comp acomp"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sym_comp acomp"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans_comp acomp"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"comparator acomp"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invert_order (acomp x y) = acomp y x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sym_compD</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sym_comp acomp›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"acomp x y = Eq"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>eq_compD</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹eq_comp acomp›</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"acomp x y = Lt"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"acomp y z = Lt"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>trans_orderD</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>trans_compD</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹trans_comp acomp›</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"acomp x z = Lt"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comparator_imp_eq_sym_trans</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"comparator acomp"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eq_comp acomp"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sym_comp acomp"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans_comp acomp"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>comparator</span><span> </span><span>acomp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eq_comp acomp"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>eq_compI</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sym_comp acomp"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>sym_compI</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans_comp acomp"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>trans_compI</span><span> </span><span>trans_orderI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"acomp x y ≠ Gt"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"acomp y z ≠ Gt"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"acomp x z ≠ Gt ∧ (acomp x y = Lt ∨ acomp y z = Lt ⟶ acomp x z = Lt)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>trans</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eq</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eq</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>y</span><span> </span><span>z</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"acomp x y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"acomp y z"</span></span></span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>order.exhaust</span><span> </span><span class="delimiter">[</span><span>case_product</span><span> </span><span>order.exhaust</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>acomp</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a comparator"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"comparator acomp"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comp_to_psym_comp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"psym_comp acomp x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comparator_imp_eq_sym_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>c</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>sym_compD2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comp_to_peq_comp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"peq_comp acomp x"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comparator_imp_eq_sym_trans</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>c</span><span class="delimiter">]</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>eq_compD2</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comp_to_ptrans_comp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ptrans_comp acomp x"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comparator_imp_eq_sym_trans</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>c</span><span class="delimiter">]</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>trans_compD2</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Auxiliary Lemmas for Comparator Generator›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>forall_finite</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀ i &lt; (0 :: nat). P i) = True"</span></span></span><span>
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"(∀ i &lt; Suc 0. P i) = P 0"</span></span></span><span>
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"(∀ i &lt; Suc (Suc x). P i) = (P 0 ∧ (∀ i &lt; Suc x. P (Suc i)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">,</span><span> </span><span>case_tac</span><span> </span><span>i</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trans_order_different</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"trans_order a b Lt"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"trans_order Gt b c"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"trans_order a Gt c"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>trans_orderI</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>length_nth_simps</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"length [] = 0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (x # xs) = Suc (length xs)"</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(x # xs) ! 0 = x"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x # xs) ! (Suc n) = xs ! n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The Comparator Generator›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹comparator_generator.ML›</span></span></span><span>
</span><span>                 
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Compare_Generator">
<div class="head"><h1>Theory Compare_Generator</h1>
<span class="command">theory</span> <span class="name">Compare_Generator</span><br/>
<span class="keyword">imports</span> <a href="Comparator_Generator.html"><span class="name">Comparator_Generator</span></a> <a href="Compare.html"><span class="name">Compare</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:       Deriving class instances for datatypes
    Author:      Christian Sternagel and René Thiemann  &lt;christian.sternagel|rene.thiemann@uibk.ac.at&gt;
    Maintainer:  Christian Sternagel and René Thiemann 
    License:     LGPL
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Compare Generator›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Compare_Generator</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> 
</span><span>  </span><span>Comparator_Generator</span><span>
</span><span>  </span><span>Compare</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We provide a generator which takes the comparators of the comparator generator
  to synthesize suitable @{const compare}-functions from the @{class compare}-class.

One can further also use these comparison functions to derive an instance of the
@{class compare_order}-class, and therefore also for @{class linorder}. In total, we provide the three
‹derive›-methods where the example type @{type prod} can be replaced by any other datatype.

\begin{itemize}
\item ‹derive compare prod› creates an instance @{type prod} :: (@{class compare}, @{class compare}) @{class compare}.
\item ‹derive compare_order prod› creates an instance @{type prod} :: (@{class compare}, @{class compare}) @{class compare_order}.
\item ‹derive linorder prod› creates an instance @{type prod} :: (@{class linorder}, @{class linorder}) @{class linorder}.
\end{itemize}

Usually, the use of ‹derive linorder› is not recommended if there are comparators available:
Internally, the linear orders will directly be converted into comparators, so a direct use of the
comparators will result in more efficient generated code. This command is mainly provided as a convenience method
where comparators are not yet present. For example, at the time of writing, the Container Framework
has partly been adapted to internally use comparators, whereas in other AFP-entries, we did not
integrate comparators.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>linorder_axiomsD</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"class.linorder le lt"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"lt x y = (le x y ∧ ¬ le y x)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?a</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"le x x"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?b</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"le x y ⟹ le y z ⟹ le x z"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?c1 ⟹ ?c2 ⟹ ?c3"</span></span></span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"le x y ⟹ le y x ⟹ x = y"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?d1 ⟹ ?d2 ⟹ ?d3"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"le x y ∨ le y x"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?e</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>linorder</span><span> </span><span>le</span><span> </span><span>lt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?a</span><span> </span><span class="var">?b</span><span> </span><span class="string"><span class="delete"><span class="delete">"?c1 ⟹ ?c2 ⟹ ?c3"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?d1 ⟹ ?d2 ⟹ ?d3"</span></span></span><span> </span><span class="var">?e</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> 
</span><span class="keyword1"><span class="command">named_theorems</span></span><span> </span><span>compare_simps</span><span> </span><span class="string"><span class="delete"><span class="delete"><span class="delete"><span class="delete">"simp theorems to derive \"compare = comparator_of\""</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹compare_generator.ML›</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Compare_Instances">
<div class="head"><h1>Theory Compare_Instances</h1>
<span class="command">theory</span> <span class="name">Compare_Instances</span><br/>
<span class="keyword">imports</span> <a href="Compare_Generator.html"><span class="name">Compare_Generator</span></a> <a href="../../HOL/HOL-Library/Char_ord.html"><span class="name">Char_ord</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:       Deriving class instances for datatypes
    Author:      Christian Sternagel and René Thiemann  &lt;christian.sternagel|rene.thiemann@uibk.ac.at&gt;
    Maintainer:  Christian Sternagel and René Thiemann 
    License:     LGPL
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Defining Comparators and Compare-Instances for Common Types›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Compare_Instances</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Compare_Generator</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Char_ord"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹For all of the following types, we define comparators and register them in the class 
  @{class compare}:
  @{type int}, @{type integer}, @{type nat}, @{type char}, @{type bool}, @{type unit}, @{type sum}, @{type option}, @{type list},
  and @{type prod}. We do not register those classes in @{class compare_order} where
  so far no linear order is defined, in particular if there are conflicting orders, like pair-wise or
  lexicographic comparison on pairs.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹For @{type int}, @{type nat}, @{type integer} and @{type char} we just use their linear orders as comparators.›</span></span></span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span class="delimiter">(</span><span>linorder</span><span class="delimiter">)</span><span> </span><span>compare_order</span><span> </span><span>int</span><span> </span><span>integer</span><span> </span><span>nat</span><span> </span><span>char</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹For @{type sum}, @{type list}, @{type prod}, and @{type option} we generate comparators 
  which are however are not used to instantiate @{class linorder}.›</span></span></span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span>compare</span><span> </span><span>sum</span><span> </span><span>list</span><span> </span><span>prod</span><span> </span><span>option</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We do not use the linear order to define the comparator for @{typ bool} and @{typ unit}, 
  but implement more efficient ones.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>comparator_unit</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"unit comparator"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"comparator_unit x y = Eq"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>comparator_bool</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"bool comparator"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"comparator_bool False False = Eq"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"comparator_bool False True = Lt"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"comparator_bool True True = Eq"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"comparator_bool True False = Gt"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comparator_unit</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"comparator comparator_unit"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comparator_bool</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"comparator comparator_bool"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span> </span><span class="delimiter">::</span><span> </span><span>bool</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invert_order (comparator_bool x y) = comparator_bool y x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>y</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"comparator_bool x y = Eq ⟹ x = y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>y</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"comparator_bool x y = Lt ⟹ comparator_bool y z = Lt ⟹ comparator_bool x z = Lt"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>y</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span>y</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>z</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">local_setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Comparator_Generator.register_foreign_comparator @{typ unit}
    @{term comparator_unit}
    @{thm comparator_unit}
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">local_setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Comparator_Generator.register_foreign_comparator @{typ bool}
    @{term comparator_bool}
    @{thm comparator_bool}
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span>compare</span><span> </span><span>bool</span><span> </span><span>unit</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹It is not directly possible to ‹derive (linorder) bool unit›, since 
  @{term "compare :: bool comparator"}
  was not defined as @{term "comparator_of :: bool comparator"}, but as
  @{const comparator_bool}.
  However, we can manually prove this equivalence
  and then use this knowledge to prove the instance of @{class compare_order}.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comparator_bool_comparator_of</span><span> </span><span class="delimiter">[</span><span>compare_simps</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"comparator_bool = comparator_of"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>b</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"comparator_bool a b = comparator_of a b"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>comparator_of_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comparator_unit_comparator_of</span><span> </span><span class="delimiter">[</span><span>compare_simps</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"comparator_unit = comparator_of"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>b</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"comparator_unit a b = comparator_of a b"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>comparator_of_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span class="delimiter">(</span><span>linorder</span><span class="delimiter">)</span><span> </span><span>compare_order</span><span> </span><span>bool</span><span> </span><span>unit</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Compare_Order_Instances">
<div class="head"><h1>Theory Compare_Order_Instances</h1>
<span class="command">theory</span> <span class="name">Compare_Order_Instances</span><br/>
<span class="keyword">imports</span> <a href="Compare_Instances.html"><span class="name">Compare_Instances</span></a> <a href="../../HOL/HOL-Library/List_Lexorder.html"><span class="name">List_Lexorder</span></a> <a href="../../HOL/HOL-Library/Product_Lexorder.html"><span class="name">Product_Lexorder</span></a> <a href="../../HOL/HOL-Library/Option_ord.html"><span class="name">Option_ord</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:       Deriving class instances for datatypes
    Author:      Christian Sternagel and René Thiemann  &lt;christian.sternagel|rene.thiemann@uibk.ac.at&gt;
    Maintainer:  Christian Sternagel and René Thiemann 
    License:     LGPL
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Defining Compare-Order-Instances for Common Types›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Compare_Order_Instances</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Compare_Instances</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.List_Lexorder"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Product_Lexorder"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Option_ord"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We now also instantiate class @{class compare_order} and not only @{class compare}.
  Here, we also prove that our definitions do not clash with existing orders on
  @{type list}, @{type option}, and @{type prod}.
  
  For @{type sum} we just define the linear orders via their comparator.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span>compare_order</span><span> </span><span>sum</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>list</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>compare_order</span><span class="delimiter">)</span><span>compare_order</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>le_of_comp_def</span><span> </span><span>lt_of_comp_def</span><span> </span><span>comparator_of_def</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"le_of_comp (compare :: 'a list comparator) = (≤)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>compare_list_def</span><span> </span><span>compare_is_comparator_of</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>xs</span><span> </span><span>ys</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"le_of_comp (comparator_list comparator_of) xs ys = (xs ≤ ys)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>ys</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Nil</span><span> </span><span>ys</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ys</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>xs</span><span> </span><span>yys</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>IH</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>yys</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>y</span><span> </span><span>ys</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cons</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span class="delimiter">[</span><span>of</span><span> </span><span>ys</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>linorder_cases</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lt_of_comp (compare :: 'a list comparator) = (&lt;)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>compare_list_def</span><span> </span><span>compare_is_comparator_of</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>xs</span><span> </span><span>ys</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lt_of_comp (comparator_list comparator_of) xs ys = (xs &lt; ys)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>ys</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Nil</span><span> </span><span>ys</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ys</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>xs</span><span> </span><span>yys</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>IH</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>yys</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>y</span><span> </span><span>ys</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cons</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span class="delimiter">[</span><span>of</span><span> </span><span>ys</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>linorder_cases</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>prod</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>compare_order</span><span class="delimiter">,</span><span> </span><span>compare_order</span><span class="delimiter">)</span><span>compare_order</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>le_of_comp_def</span><span> </span><span>lt_of_comp_def</span><span> </span><span>comparator_of_def</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"le_of_comp (compare :: ('a,'b)prod comparator) = (≤)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>compare_prod_def</span><span> </span><span>compare_is_comparator_of</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>xy1</span><span> </span><span>xy2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,'b)prod"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"le_of_comp (comparator_prod comparator_of comparator_of) xy1 xy2 = (xy1 ≤ xy2)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xy1</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span>xy2</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lt_of_comp (compare :: ('a,'b)prod comparator) = (&lt;)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>compare_prod_def</span><span> </span><span>compare_is_comparator_of</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>xy1</span><span> </span><span>xy2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,'b)prod"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lt_of_comp (comparator_prod comparator_of comparator_of) xy1 xy2 = (xy1 &lt; xy2)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xy1</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span>xy2</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>option</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>compare_order</span><span class="delimiter">)</span><span>compare_order</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>le_of_comp_def</span><span> </span><span>lt_of_comp_def</span><span> </span><span>comparator_of_def</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"le_of_comp (compare :: 'a option comparator) = (≤)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>compare_option_def</span><span> </span><span>compare_is_comparator_of</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>xy1</span><span> </span><span>xy2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a option"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"le_of_comp (comparator_option comparator_of) xy1 xy2 = (xy1 ≤ xy2)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xy1</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xy2</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lt_of_comp (compare :: 'a option comparator) = (&lt;)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>compare_option_def</span><span> </span><span>compare_is_comparator_of</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>xy1</span><span> </span><span>xy2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a option"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lt_of_comp (comparator_option comparator_of) xy1 xy2 = (xy1 &lt; xy2)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xy1</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xy2</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Compare_Rat">
<div class="head"><h1>Theory Compare_Rat</h1>
<span class="command">theory</span> <span class="name">Compare_Rat</span><br/>
<span class="keyword">imports</span> <a href="Compare_Generator.html"><span class="name">Compare_Generator</span></a> <a href="../../HOL/HOL/Rat.html"><span class="name">Rat</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  
    Author:      René Thiemann 
    License:     LGPL
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Compare Instance for Rational Numbers›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Compare_Rat</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Compare_Generator</span><span>
</span><span>  </span><span>HOL.Rat</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span class="delimiter">(</span><span>linorder</span><span class="delimiter">)</span><span> </span><span>compare_order</span><span> </span><span>rat</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Compare_Real">
<div class="head"><h1>Theory Compare_Real</h1>
<span class="command">theory</span> <span class="name">Compare_Real</span><br/>
<span class="keyword">imports</span> <a href="Compare_Generator.html"><span class="name">Compare_Generator</span></a> <a href="../../HOL/HOL/Real.html"><span class="name">Real</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
    Author:      René Thiemann
    License:     LGPL
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Compare Instance for Real Numbers›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Compare_Real</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Compare_Generator</span><span>
</span><span>  </span><span>HOL.Real</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span class="delimiter">(</span><span>linorder</span><span class="delimiter">)</span><span> </span><span>compare_order</span><span> </span><span>real</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>invert_order_compare_real</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ x y :: real. invert_order (compare x y) = compare y x"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>comparator_of_def</span><span> </span><span>compare_is_comparator_of</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Equality_Generator">
<div class="head"><h1>Theory Equality_Generator</h1>
<span class="command">theory</span> <span class="name">Equality_Generator</span><br/>
<span class="keyword">imports</span> <a href="Generator_Aux.html"><span class="name">Generator_Aux</span></a> <a href="Derive_Manager.html"><span class="name">Derive_Manager</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:       Deriving class instances for datatypes
    Author:      Christian Sternagel and René Thiemann  &lt;christian.sternagel|rene.thiemann@uibk.ac.at&gt;
    Maintainer:  Christian Sternagel and René Thiemann 
    License:     LGPL
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Checking Equality Without "="›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Equality_Generator</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"../Generator_Aux"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"../Derive_Manager"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">typedecl</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'a</span><span class="delimiter">,</span><span class="tfree">'b</span><span class="delimiter">,</span><span class="tfree">'c</span><span class="delimiter">,</span><span class="tfree">'z</span><span class="delimiter">)</span><span>type</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹In the following, we define a generator which for a given datatype @{typ "('a,'b,'c,'z)type"}
  constructs an equality-test function of type 
  @{typ "('a ⇒ 'a ⇒ bool) ⇒ ('b ⇒ 'b ⇒ bool) ⇒ ('c ⇒ 'c ⇒ bool) ⇒ ('z ⇒ 'z ⇒ bool) ⇒ 
    (('a,'b,'c,'z)type ⇒ ('a,'b,'c,'z)type ⇒ bool)"}.
  These functions are essential to synthesize conditional equality functions in the container framework,
  where a strict membership in the @{class equal}-class must not be enforced.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">hide_type</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"type"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Just a constant to define conjunction on lists of booleans, which will
  be used to merge the results when having compared the arguments of identical
  constructors.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>list_all_eq</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"bool list ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"list_all_eq = list_all id "</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Improved Code for Non-Lazy Languages›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The following equations will eliminate all occurrences of @{term list_all_eq}
  in the generated code of the equality functions.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_all_eq_unfold</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"list_all_eq [] = True"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"list_all_eq [b] = b"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"list_all_eq (b1 # b2 # bs) = (b1 ∧ list_all_eq (b2 # bs))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>list_all_eq_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_all_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"list_all_eq bs ⟷ (∀ b ∈ set bs. b)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>list_all_eq_def</span><span> </span><span>list_all_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Partial Equality Property›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We require a partial property which can be used in inductive proofs.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'a</span><span> </span><span>equality</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ bool"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>pequality</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a equality ⇒ 'a ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"pequality aeq x ⟷ (∀ y. aeq x y ⟷ x = y)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pequalityD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pequality aeq x ⟹ aeq x y ⟷ x = y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pequality_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pequalityI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀ y. aeq x y ⟷ x = y) ⟹ pequality aeq x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pequality_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Global equality property›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>equality</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a equality ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"equality aeq ⟷ (∀ x. pequality aeq x)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>equalityD2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"equality aeq ⟹ pequality aeq x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>equality_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>equalityI2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀ x. pequality aeq x) ⟹ equality aeq"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>equality_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>equalityD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"equality aeq ⟹ aeq x y ⟷ x = y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>pequalityD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>equalityD2</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>equalityI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀ x y. aeq x y ⟷ x = y) ⟹ equality aeq"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>equalityI2</span><span> </span><span>pequalityI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>equality_imp_eq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"equality aeq ⟹ aeq = (=)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>equalityD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eq_equality</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"equality (=)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>equalityI</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>equality_def'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"equality f = (f = (=))"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>equality_imp_eq</span><span> </span><span>eq_equality</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The Generator›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹equality_generator.ML›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">hide_fact</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="delimiter">)</span><span> </span><span>equalityI</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Equality_Instances">
<div class="head"><h1>Theory Equality_Instances</h1>
<span class="command">theory</span> <span class="name">Equality_Instances</span><br/>
<span class="keyword">imports</span> <a href="Equality_Generator.html"><span class="name">Equality_Generator</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:       Deriving class instances for datatypes
    Author:      Christian Sternagel and René Thiemann  &lt;christian.sternagel|rene.thiemann@uibk.ac.at&gt;
    Maintainer:  Christian Sternagel and René Thiemann 
    License:     LGPL
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Defining Equality-Functions for Common Types›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Equality_Instances</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Equality_Generator</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹For all of the following types, we register equality-functions.
  @{type int}, @{type integer}, @{type nat}, @{type char}, @{type bool}, @{type unit}, @{type sum}, @{type option}, @{type list},
  and @{type prod}. For types without type parameters, we use plain @{term "(=)"}, and for the 
  others we use generated ones. These functions will be essential, when the generator is later on
  invoked on types, which in their definition use one these types.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span class="delimiter">(</span><span>eq</span><span class="delimiter">)</span><span> </span><span>equality</span><span> </span><span>int</span><span> </span><span>integer</span><span> </span><span>nat</span><span> </span><span>char</span><span> </span><span>bool</span><span> </span><span>unit</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span>equality</span><span> </span><span>sum</span><span> </span><span>list</span><span> </span><span>prod</span><span> </span><span>option</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Hash_Generator">
<div class="head"><h1>Theory Hash_Generator</h1>
<span class="command">theory</span> <span class="name">Hash_Generator</span><br/>
<span class="keyword">imports</span> <a href="Generator_Aux.html"><span class="name">Generator_Aux</span></a> <a href="Derive_Manager.html"><span class="name">Derive_Manager</span></a> <a href="HashCode.html"><span class="name">HashCode</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:       Deriving class instances for datatypes
    Author:      Christian Sternagel and René Thiemann  &lt;christian.sternagel|rene.thiemann@uibk.ac.at&gt;
    Maintainer:  Christian Sternagel and René Thiemann 
    License:     LGPL
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Generating Hash-Functions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Hash_Generator</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"../Generator_Aux"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"../Derive_Manager"</span></span></span><span>
</span><span>  </span><span>Collections.HashCode</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹As usual, in the generator we use a dedicated function to combine the results
  from evaluating the hash-function of the arguments of a constructor, to deliver
  the global hash-value.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>hash_combine</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hashcode list ⇒ hashcode list ⇒ hashcode"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hash_combine [] [x] = x"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"hash_combine (y # ys) (z # zs) = y * z + hash_combine ys zs"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"hash_combine _ _ = 0"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The first argument of @{const hash_combine} originates from evaluating the hash-function 
  on the arguments of a constructor, and the second argument of @{const hash_combine} will be static \emph{magic} numbers
  which are generated within the generator.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Improved Code for Non-Lazy Languages›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hash_combine_unfold</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hash_combine [] [x] = x"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hash_combine (y # ys) (z # zs) = y * z + hash_combine ys zs"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The Generator›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹hash_generator.ML›</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Hash_Instances">
<div class="head"><h1>Theory Hash_Instances</h1>
<span class="command">theory</span> <span class="name">Hash_Instances</span><br/>
<span class="keyword">imports</span> <a href="Hash_Generator.html"><span class="name">Hash_Generator</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:       Deriving class instances for datatypes
    Author:      Christian Sternagel and René Thiemann  &lt;christian.sternagel|rene.thiemann@uibk.ac.at&gt;
    Maintainer:  Christian Sternagel and René Thiemann 
    License:     LGPL
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Defining Hash-Functions for Common Types›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Hash_Instances</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Hash_Generator</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹For all of the following types, we register hashcode-functions.
  @{type int}, @{type integer}, @{type nat}, @{type char}, @{type bool}, @{type unit}, @{type sum}, @{type option}, @{type list},
  and @{type prod}. For types without type parameters, we use plain @{const "hashcode"}, and for the 
  others we use generated ones.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span class="delimiter">(</span><span>hashcode</span><span class="delimiter">)</span><span> </span><span>hash_code</span><span> </span><span>int</span><span> </span><span>integer</span><span> </span><span>bool</span><span> </span><span>char</span><span> </span><span>unit</span><span> </span><span>nat</span><span>
</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span>hash_code</span><span> </span><span>prod</span><span> </span><span>sum</span><span> </span><span>option</span><span> </span><span>list</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹There is no need to ‹derive hashable prod sum option list› since all of these types 
  are already instances of class @{class hashable}. Still the above command is necessary to register
  these types in the generator.›</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Countable_Generator">
<div class="head"><h1>Theory Countable_Generator</h1>
<span class="command">theory</span> <span class="name">Countable_Generator</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL-Library/Countable.html"><span class="name">Countable</span></a> <a href="Derive_Manager.html"><span class="name">Derive_Manager</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:       Deriving class instances for datatypes
    Author:      Christian Sternagel and René Thiemann  &lt;christian.sternagel|rene.thiemann@uibk.ac.at&gt;
    Maintainer:  Christian Sternagel and René Thiemann 
    License:     LGPL
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Countable Datatypes›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Countable_Generator</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Countable"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"../Derive_Manager"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
Brian Huffman and Alexander Krauss (old datatype), and Jasmin Blanchette (BNF datatype) 
have developed tactics which automatically can prove that a datatype is countable.
We just make this tactic available in the derive-manager so that
one can conveniently write \texttt{derive countable some-datatype}.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Installing the tactic"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
There is nothing more to do, then to write some boiler-plate ML-code
for class-instantiation.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  let 
    fun derive dtyp_name _ thy = 
      let
        val base_name = Long_Name.base_name dtyp_name
        val _ = writeln ("proving that datatype " ^ base_name ^ " is countable")
        val sort = @{sort countable}
        val vs = 
          let val i = BNF_LFP_Compat.the_spec thy dtyp_name |&gt; #1 
          in map (fn (n,_) =&gt; (n, sort)) i end
        val thy' = Class.instantiation ([dtyp_name],vs,sort) thy
          |&gt; Class.prove_instantiation_exit (fn ctxt =&gt; countable_tac ctxt 1)
        val _ = writeln ("registered " ^ base_name ^ " in class countable")
      in thy' end
  in 
    Derive_Manager.register_derive "countable" "register datatypes is class countable" derive
  end
›</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Derive">
<div class="head"><h1>Theory Derive</h1>
<span class="command">theory</span> <span class="name">Derive</span><br/>
<span class="keyword">imports</span> <a href="Compare_Instances.html"><span class="name">Compare_Instances</span></a> <a href="Equality_Instances.html"><span class="name">Equality_Instances</span></a> <a href="Hash_Instances.html"><span class="name">Hash_Instances</span></a> <a href="Countable_Generator.html"><span class="name">Countable_Generator</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:       Deriving class instances for datatypes
    Author:      Christian Sternagel and René Thiemann  &lt;christian.sternagel|rene.thiemann@uibk.ac.at&gt;
    Maintainer:  Christian Sternagel and René Thiemann 
    License:     LGPL
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Loading Existing Derive-Commands›</span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Derive</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Comparator_Generator/Compare_Instances"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Equality_Generator/Equality_Instances"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Hash_Generator/Hash_Instances"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Countable_Generator/Countable_Generator"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹
We just load the commands to derive comparators, equality-functions, hash-functions, and the
command to show that a datatype is countable, so that now all of them are available.
There are further generators available in the AFP entries Containers and Show.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">print_derives</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Derive_Examples">
<div class="head"><h1>Theory Derive_Examples</h1>
<span class="command">theory</span> <span class="name">Derive_Examples</span><br/>
<span class="keyword">imports</span> <a href="Derive.html"><span class="name">Derive</span></a> <a href="Compare_Order_Instances.html"><span class="name">Compare_Order_Instances</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:       Deriving class instances for datatypes
    Author:      Christian Sternagel and René Thiemann  &lt;christian.sternagel|rene.thiemann@uibk.ac.at&gt;
    Maintainer:  Christian Sternagel and René Thiemann 
    License:     LGPL
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span>Examples</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Derive_Examples</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> 
</span><span>  </span><span>Derive</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Comparator_Generator/Compare_Order_Instances"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Equality_Generator/Equality_Instances"</span></span></span><span>
</span><span>  </span><span>HOL.Rat</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Rational Numbers"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The rational numbers are not a datatype, so it will not be possible to derive 
  corresponding instances of comparators, hashcodes, etc. via the generators. But we can and should
  still register the existing instances, so that later datatypes are supported 
  which use rational numbers.›</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Use the linear order on rationals to define the @{class compare_order}-instance.›</span></span></span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span class="delimiter">(</span><span>linorder</span><span class="delimiter">)</span><span> </span><span>compare_order</span><span> </span><span>rat</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Use @{term "(=) :: rat =&gt; rat =&gt; bool"} as equality function.›</span></span></span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span class="delimiter">(</span><span>eq</span><span class="delimiter">)</span><span> </span><span>equality</span><span> </span><span>rat</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹First manually define a hashcode function.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>rat</span><span> </span><span class="delimiter">::</span><span> </span><span>hashable</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"def_hashmap_size = (λ_ :: rat itself. 10)"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hashcode (r :: rat) = hashcode (quotient_of r)"</span></span></span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro_classes</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>def_hashmap_size_rat_def</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹And then register it at the generator.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span class="delimiter">(</span><span>hashcode</span><span class="delimiter">)</span><span> </span><span>hash_code</span><span> </span><span>rat</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A Datatype Without Nested Recursion"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="tfree">'a</span><span> </span><span>bintree</span><span> </span><span class="delimiter">=</span><span> </span><span>BEmpty</span><span> </span><span class="delimiter">|</span><span> </span><span>BNode</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a bintree"</span></span></span><span> </span><span class="tfree">'a</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a bintree"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span>compare_order</span><span> </span><span>bintree</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span>countable</span><span> </span><span>bintree</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span>equality</span><span> </span><span>bintree</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span>hashable</span><span> </span><span>bintree</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Using Other datatypes"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>nat_list_list</span><span> </span><span class="delimiter">=</span><span> </span><span>NNil</span><span> </span><span class="delimiter">|</span><span> </span><span>CCons</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat list × rat option"</span></span></span><span> </span><span>nat_list_list</span><span>
</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span>compare_order</span><span> </span><span>nat_list_list</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span>countable</span><span> </span><span>nat_list_list</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span class="delimiter">(</span><span>eq</span><span class="delimiter">)</span><span> </span><span>equality</span><span> </span><span>nat_list_list</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span>hashable</span><span> </span><span>nat_list_list</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Mutual Recursion"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span>
</span><span>  </span><span class="tfree">'a</span><span> </span><span>mtree</span><span> </span><span class="delimiter">=</span><span> </span><span>MEmpty</span><span> </span><span class="delimiter">|</span><span> </span><span>MNode</span><span> </span><span class="tfree">'a</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a mtree_list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="tfree">'a</span><span> </span><span>mtree_list</span><span> </span><span class="delimiter">=</span><span> </span><span>MNil</span><span> </span><span class="delimiter">|</span><span> </span><span>MCons</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a mtree"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"'a mtree_list"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span>compare_order</span><span> </span><span>mtree</span><span> </span><span>mtree_list</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span>countable</span><span> </span><span>mtree</span><span> </span><span>mtree_list</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span>hashable</span><span> </span><span>mtree</span><span> </span><span>mtree_list</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹For ‹derive (equality|comparator|hash_code) mutual_recursive_type› 
  there is the speciality that only one of the mutual recursive types has to be mentioned in
  order to register all of them. So one of @{type mtree} and @{type mtree_list} suffices.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span>equality</span><span> </span><span>mtree</span><span> 
</span><span> 
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Nested recursion"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="tfree">'a</span><span> </span><span>tree</span><span> </span><span class="delimiter">=</span><span> </span><span>Empty</span><span> </span><span class="delimiter">|</span><span> </span><span>Node</span><span> </span><span class="tfree">'a</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a tree list"</span></span></span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="tfree">'a</span><span> </span><span>ttree</span><span> </span><span class="delimiter">=</span><span> </span><span>TEmpty</span><span> </span><span class="delimiter">|</span><span> </span><span>TNode</span><span> </span><span class="tfree">'a</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ttree list tree"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span>compare_order</span><span> </span><span>tree</span><span> </span><span>ttree</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span>countable</span><span> </span><span>tree</span><span> </span><span>ttree</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span>equality</span><span> </span><span>tree</span><span> </span><span>ttree</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span>hashable</span><span> </span><span>tree</span><span> </span><span>ttree</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Examples from \isafor›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'f</span><span class="delimiter">,</span><span class="tfree">'v</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"term"</span></span></span><span> </span><span class="delimiter">=</span><span> </span><span>Var</span><span> </span><span class="tfree">'v</span><span> </span><span class="delimiter">|</span><span> </span><span>Fun</span><span> </span><span class="tfree">'f</span><span> </span><span class="string"><span class="delete"><span class="delete">"('f,'v) term list"</span></span></span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'f</span><span class="delimiter">,</span><span> </span><span class="tfree">'l</span><span class="delimiter">)</span><span> </span><span>lab</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>Lab</span><span> </span><span class="string"><span class="delete"><span class="delete">"('f, 'l) lab"</span></span></span><span> </span><span class="tfree">'l</span><span>
</span><span class="delimiter">|</span><span> </span><span>FunLab</span><span> </span><span class="string"><span class="delete"><span class="delete">"('f, 'l) lab"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"('f, 'l) lab list"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>UnLab</span><span> </span><span class="tfree">'f</span><span>
</span><span class="delimiter">|</span><span> </span><span>Sharp</span><span> </span><span class="string"><span class="delete"><span class="delete">"('f, 'l) lab"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span>compare_order</span><span> </span><span class="string"><span class="delete"><span class="delete">"term"</span></span></span><span> </span><span>lab</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span>countable</span><span> </span><span class="string"><span class="delete"><span class="delete">"term"</span></span></span><span> </span><span>lab</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span>equality</span><span> </span><span class="string"><span class="delete"><span class="delete">"term"</span></span></span><span> </span><span>lab</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span>hashable</span><span> </span><span class="string"><span class="delete"><span class="delete">"term"</span></span></span><span> </span><span>lab</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A Complex Datatype"</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The following datatype has nested and mutual recursion, and
uses other datatypes.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'a</span><span class="delimiter">,</span><span> </span><span class="tfree">'b</span><span class="delimiter">)</span><span> </span><span>complex</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span>C1</span><span> </span><span>nat</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ttree × rat + ('a,'b) complex list"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>C2</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) complex list tree tree"</span></span></span><span> </span><span class="tfree">'b</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) complex"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) complex2 ttree list"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'a</span><span class="delimiter">,</span><span> </span><span class="tfree">'b</span><span class="delimiter">)</span><span> </span><span>complex2</span><span> </span><span class="delimiter">=</span><span> </span><span>D1</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) complex ttree"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹On this last example type we illustrate the difference of the various comparator- and order-generators.

  For @{type complex} we create an instance of @{class compare_order} which also defines
  a linear order. Note however that the instance will 
  be @{type complex} :: (@{class compare}, @{class compare}) @{class compare_order}, i.e., the 
  argument types have to be in class @{class compare}. 

  For @{type complex2} we only derive @{class compare} which is not a subclass of @{class linorder}.
  The instance will be @{type complex2} :: (@{class compare}, @{class compare}) @{class compare}, i.e., 
  again the argument types have to be in class @{class compare}.

  To avoid the dependence on @{class compare}, we can also instruct ‹derive› to be based on 
  @{class linorder}. Here, the command ‹derive linorder complex2› will create the instance
  @{type complex2} :: (@{class linorder}, @{class linorder}) @{class linorder}, i.e., 
  here the argument types have to be in class @{class linorder}.
  ›</span></span></span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span>compare_order</span><span> </span><span>complex</span><span> 
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span>compare</span><span> </span><span>complex2</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span>linorder</span><span> </span><span>complex2</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span>countable</span><span> </span><span>complex</span><span> </span><span>complex2</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span>equality</span><span> </span><span>complex</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span>hashable</span><span> </span><span>complex</span><span> </span><span>complex2</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div>