<div id="FOL_Harrison">
<div class="head"><h1>Theory FOL_Harrison</h1>
<span class="command">theory</span> <span class="name">FOL_Harrison</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  FOL-Harrison - First-Order Logic According to Harrison

  Authors: Alexander Birch Jensen, Anders Schlichtkrull, Jørgen Villadsen

  Acknowledgement: The SML code is based on the OCaml code accompanying John Harrison's
  Handbook of Practical Logic and Automated Reasoning, Cambridge University Press, 2009
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">chapter</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹FOL-Harrison›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>FOL_Harrison</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Main</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Module Proven›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Syntax of first-order logic›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>id</span><span> </span><span class="delimiter">=</span><span> </span><span>String.literal</span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>tm</span><span> </span><span class="delimiter">=</span><span> </span><span>Var</span><span> </span><span>id</span><span> </span><span class="delimiter">|</span><span> </span><span>Fn</span><span> </span><span>id</span><span> </span><span class="string"><span class="delete"><span class="delete">"tm list"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="tfree">'a</span><span> </span><span>fm</span><span> </span><span class="delimiter">=</span><span> </span><span>Truth</span><span> </span><span class="delimiter">|</span><span> </span><span>Falsity</span><span> </span><span class="delimiter">|</span><span> </span><span>Atom</span><span> </span><span class="tfree">'a</span><span> </span><span class="delimiter">|</span><span> </span><span>Imp</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a fm"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"'a fm"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span>Iff</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a fm"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"'a fm"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span>And</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a fm"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"'a fm"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span>Or</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a fm"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"'a fm"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span>Not</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a fm"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span>Exists</span><span> </span><span>id</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a fm"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span>Forall</span><span> </span><span>id</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a fm"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>fol</span><span> </span><span class="delimiter">=</span><span> </span><span>Rl</span><span> </span><span>id</span><span> </span><span class="string"><span class="delete"><span class="delete">"tm list"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"thm"</span></span></span><span> </span><span class="delimiter">=</span><span> </span><span>Thm</span><span> </span><span class="delimiter">(</span><span>concl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fol fm"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Definition of rules and axioms›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"fail_thm ≡ Thm Truth"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>fol_equal</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fol fm ⇒ fol fm ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fol_equal p q ≡ p = q"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>zip_eq</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"tm list ⇒ tm list ⇒ fol fm list"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"zip_eq l l' ≡ map (λ(t, t'). Atom (Rl (STR ''='') [t, t'])) (zip l l')"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>occurs_in</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"id ⇒ tm ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>occurs_in_list</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"id ⇒ tm list ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"occurs_in i (Var x) = (i = x)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"occurs_in i (Fn _ l) = occurs_in_list i l"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"occurs_in_list _ [] = False"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"occurs_in_list i (h # t) = (occurs_in i h ∨ occurs_in_list i t)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>free_in</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"id ⇒ fol fm ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"free_in _ Truth = False"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"free_in _ Falsity = False"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"free_in i (Atom a) = (case a of Rl _ l ⇒ occurs_in_list i l)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"free_in i (Imp p q) = (free_in i p ∨ free_in i q)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"free_in i (Iff p q) = (free_in i p ∨ free_in i q)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"free_in i (And p q) = (free_in i p ∨ free_in i q)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"free_in i (Or p q) = (free_in i p ∨ free_in i q)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"free_in i (Not p) = free_in i p"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"free_in i (Exists x p) = (i ≠ x ∧ free_in i p)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"free_in i (Forall x p) = (i ≠ x ∧ free_in i p)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>equal_length</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"tm list ⇒ tm list ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"equal_length l [] = (case l of [] ⇒ True | _ # _ ⇒ False)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"equal_length l (_ # r') = (case l of [] ⇒ False | _ # l' ⇒ equal_length l' r')"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>modusponens</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"thm ⇒ thm ⇒ thm"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"modusponens s s' ≡ case concl s of Imp p q ⇒
      let p' = concl s' in if fol_equal p p' then Thm q else fail_thm | _ ⇒ fail_thm"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>gen</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"id ⇒ thm ⇒ thm"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"gen x s ≡ Thm (Forall x (concl s))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>axiom_addimp</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fol fm ⇒ fol fm ⇒ thm"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"axiom_addimp p q ≡ Thm (Imp p (Imp q p))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>axiom_distribimp</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fol fm ⇒ fol fm ⇒ fol fm ⇒ thm"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"axiom_distribimp p q r ≡ Thm (Imp (Imp p (Imp q r)) (Imp (Imp p q) (Imp p r )))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>axiom_doubleneg</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fol fm ⇒ thm"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"axiom_doubleneg p ≡ Thm (Imp (Imp (Imp p Falsity) Falsity) p)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>axiom_allimp</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"id ⇒ fol fm ⇒ fol fm ⇒ thm"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"axiom_allimp x p q ≡ Thm (Imp (Forall x (Imp p q)) (Imp (Forall x p) (Forall x q)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>axiom_impall</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"id ⇒ fol fm ⇒ thm"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"axiom_impall x p ≡ if ¬ free_in x p then Thm (Imp p (Forall x p)) else fail_thm"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>axiom_existseq</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"id ⇒ tm ⇒ thm"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"axiom_existseq x t ≡ if ¬ occurs_in x t
      then Thm (Exists x (Atom (Rl (STR ''='') [Var x, t]))) else fail_thm"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>axiom_eqrefl</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"tm ⇒ thm"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"axiom_eqrefl t ≡ Thm (Atom (Rl (STR ''='') [t, t]))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>axiom_funcong</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"id ⇒ tm list ⇒ tm list ⇒ thm"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"axiom_funcong i l l' ≡ if equal_length l l'
      then Thm (foldr Imp (zip_eq l l') (Atom (Rl (STR ''='') [Fn i l, Fn i l']))) else fail_thm"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>axiom_predcong</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"id ⇒ tm list ⇒ tm list ⇒ thm"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"axiom_predcong i l l' ≡ if equal_length l l'
      then Thm (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l')))) else fail_thm"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>axiom_iffimp1</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fol fm ⇒ fol fm ⇒ thm"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"axiom_iffimp1 p q ≡ Thm (Imp (Iff p q) (Imp p q))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>axiom_iffimp2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fol fm ⇒ fol fm ⇒ thm"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"axiom_iffimp2 p q ≡ Thm (Imp (Iff p q) (Imp q p))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>axiom_impiff</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fol fm ⇒ fol fm ⇒ thm"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"axiom_impiff p q ≡ Thm (Imp (Imp p q) (Imp (Imp q p) (Iff p q)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>axiom_true</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"thm"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"axiom_true ≡ Thm (Iff Truth (Imp Falsity Falsity))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>axiom_not</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fol fm ⇒ thm"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"axiom_not p ≡ Thm (Iff (Not p) (Imp p Falsity))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>axiom_and</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fol fm ⇒ fol fm ⇒ thm"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"axiom_and p q ≡ Thm (Iff (And p q) (Imp (Imp p (Imp q Falsity)) Falsity))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>axiom_or</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fol fm ⇒ fol fm ⇒ thm"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"axiom_or p q ≡ Thm (Iff (Or p q) (Not (And (Not p) (Not q))))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>axiom_exists</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"id ⇒ fol fm ⇒ thm"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"axiom_exists x p ≡ Thm (Iff (Exists x p) (Not (Forall x (Not p))))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Code generation for rules and axioms›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* The following export_code's are only for inspection purposes *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">export_code</span></span><span>
</span><span>  </span><span>modusponens</span><span> </span><span>gen</span><span> </span><span>axiom_addimp</span><span> </span><span>axiom_distribimp</span><span> </span><span>axiom_doubleneg</span><span> </span><span>axiom_allimp</span><span> </span><span>axiom_impall</span><span>
</span><span>  </span><span>axiom_existseq</span><span> </span><span>axiom_eqrefl</span><span> </span><span>axiom_funcong</span><span> </span><span>axiom_predcong</span><span> </span><span>axiom_iffimp1</span><span> </span><span>axiom_iffimp2</span><span>
</span><span>  </span><span>axiom_impiff</span><span> </span><span>axiom_true</span><span> </span><span>axiom_not</span><span> </span><span>axiom_and</span><span> </span><span>axiom_or</span><span> </span><span>axiom_exists</span><span> </span><span>concl</span><span>
</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>SML</span><span> </span><span class="keyword2"><span class="keyword">module_name</span></span><span> </span><span>Proven</span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span>fol_equal</span><span> </span><span class="delimiter">⇀</span><span> </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"_ = _"</span></span></span><span> </span><span class="comment">― ‹More efficient›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">export_code</span></span><span>
</span><span>  </span><span>modusponens</span><span> </span><span>gen</span><span> </span><span>axiom_addimp</span><span> </span><span>axiom_distribimp</span><span> </span><span>axiom_doubleneg</span><span> </span><span>axiom_allimp</span><span> </span><span>axiom_impall</span><span>
</span><span>  </span><span>axiom_existseq</span><span> </span><span>axiom_eqrefl</span><span> </span><span>axiom_funcong</span><span> </span><span>axiom_predcong</span><span> </span><span>axiom_iffimp1</span><span> </span><span>axiom_iffimp2</span><span>
</span><span>  </span><span>axiom_impiff</span><span> </span><span>axiom_true</span><span> </span><span>axiom_not</span><span> </span><span>axiom_and</span><span> </span><span>axiom_or</span><span> </span><span>axiom_exists</span><span> </span><span>concl</span><span>
</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>SML</span><span> </span><span class="keyword2"><span class="keyword">module_name</span></span><span> </span><span>Proven</span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span>fol_equal</span><span> </span><span class="delimiter">⇀</span><span> </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="comment">― ‹Delete›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">export_code</span></span><span>
</span><span>  </span><span>modusponens</span><span> </span><span>gen</span><span> </span><span>axiom_addimp</span><span> </span><span>axiom_distribimp</span><span> </span><span>axiom_doubleneg</span><span> </span><span>axiom_allimp</span><span> </span><span>axiom_impall</span><span>
</span><span>  </span><span>axiom_existseq</span><span> </span><span>axiom_eqrefl</span><span> </span><span>axiom_funcong</span><span> </span><span>axiom_predcong</span><span> </span><span>axiom_iffimp1</span><span> </span><span>axiom_iffimp2</span><span>
</span><span>  </span><span>axiom_impiff</span><span> </span><span>axiom_true</span><span> </span><span>axiom_not</span><span> </span><span>axiom_and</span><span> </span><span>axiom_or</span><span> </span><span>axiom_exists</span><span> </span><span>concl</span><span>
</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>SML</span><span> </span><span class="keyword2"><span class="keyword">module_name</span></span><span> </span><span>Proven</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Semantics of first-order logic›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>length2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"tm list ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"length2 l ≡ case l of [_,_] ⇒ True | _ ⇒ False"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span class="comment">― ‹Semantics of terms›</span><span>
</span><span>  </span><span>semantics_term</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(id ⇒ 'a) ⇒ (id ⇒ 'a list ⇒ 'a) ⇒ tm ⇒ 'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>semantics_list</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(id ⇒ 'a) ⇒ (id ⇒ 'a list ⇒ 'a) ⇒ tm list ⇒ 'a list"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"semantics_term e _ (Var x) = e x"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"semantics_term e f (Fn i l) = f i (semantics_list e f l)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"semantics_list _ _ [] = []"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"semantics_list e f (t # l) = semantics_term e f t # semantics_list e f l"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span class="comment">― ‹Semantics of formulas›</span><span>
</span><span>  </span><span>semantics</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(id ⇒ 'a) ⇒ (id ⇒ 'a list ⇒ 'a) ⇒ (id ⇒ 'a list ⇒ bool) ⇒ fol fm ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"semantics _ _ _ Truth = True"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"semantics _ _ _ Falsity = False"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"semantics e f g (Atom a) = (case a of Rl i l ⇒ if i = STR ''='' ∧ length2 l
      then (semantics_term e f (hd l) = semantics_term e f (hd (tl l)))
      else g i (semantics_list e f l))"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"semantics e f g (Imp p q) = (semantics e f g p ⟶ semantics e f g q)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"semantics e f g (Iff p q) = (semantics e f g p ⟷ semantics e f g q)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"semantics e f g (And p q) = (semantics e f g p ∧ semantics e f g q)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"semantics e f g (Or p q) = (semantics e f g p ∨ semantics e f g q)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"semantics e f g (Not p) = (¬ semantics e f g p)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"semantics e f g (Exists x p) = (∃v. semantics (e(x := v)) f g p)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"semantics e f g (Forall x p) = (∀v. semantics (e(x := v)) f g p)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Definition of proof system›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>OK</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fol fm ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⊢ _"</span></span></span><span> </span><span>0</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>modusponens</span><span class="delimiter">:</span><span>
</span><span>                    </span><span class="string"><span class="delete"><span class="delete">"⊢ concl s ⟹ ⊢ concl s' ⟹ ⊢ concl (modusponens s s')"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>gen</span><span class="delimiter">:</span><span>
</span><span>                    </span><span class="string"><span class="delete"><span class="delete">"⊢ concl s ⟹ ⊢ concl (gen _ s)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>axiom_addimp</span><span class="delimiter">:</span><span>
</span><span>                    </span><span class="string"><span class="delete"><span class="delete">"⊢ concl (axiom_addimp _ _)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>axiom_distribimp</span><span class="delimiter">:</span><span>
</span><span>                    </span><span class="string"><span class="delete"><span class="delete">"⊢ concl (axiom_distribimp _ _ _)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>axiom_doubleneg</span><span class="delimiter">:</span><span>
</span><span>                    </span><span class="string"><span class="delete"><span class="delete">"⊢ concl (axiom_doubleneg _)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>axiom_allimp</span><span class="delimiter">:</span><span>
</span><span>                    </span><span class="string"><span class="delete"><span class="delete">"⊢ concl (axiom_allimp _ _ _)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>axiom_impall</span><span class="delimiter">:</span><span>
</span><span>                    </span><span class="string"><span class="delete"><span class="delete">"⊢ concl (axiom_impall _ _)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>axiom_existseq</span><span class="delimiter">:</span><span>
</span><span>                    </span><span class="string"><span class="delete"><span class="delete">"⊢ concl (axiom_existseq _ _)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>axiom_eqrefl</span><span class="delimiter">:</span><span>
</span><span>                    </span><span class="string"><span class="delete"><span class="delete">"⊢ concl (axiom_eqrefl _)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>axiom_funcong</span><span class="delimiter">:</span><span>
</span><span>                    </span><span class="string"><span class="delete"><span class="delete">"⊢ concl (axiom_funcong _ _ _)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>axiom_predcong</span><span class="delimiter">:</span><span>
</span><span>                    </span><span class="string"><span class="delete"><span class="delete">"⊢ concl (axiom_predcong _ _ _)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>axiom_iffimp1</span><span class="delimiter">:</span><span>
</span><span>                    </span><span class="string"><span class="delete"><span class="delete">"⊢ concl (axiom_iffimp1 _ _)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>axiom_iffimp2</span><span class="delimiter">:</span><span>
</span><span>                    </span><span class="string"><span class="delete"><span class="delete">"⊢ concl (axiom_iffimp2 _ _)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>axiom_impiff</span><span class="delimiter">:</span><span>
</span><span>                    </span><span class="string"><span class="delete"><span class="delete">"⊢ concl (axiom_impiff _ _)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>axiom_true</span><span class="delimiter">:</span><span>
</span><span>                    </span><span class="string"><span class="delete"><span class="delete">"⊢ concl axiom_true"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>axiom_not</span><span class="delimiter">:</span><span>
</span><span>                    </span><span class="string"><span class="delete"><span class="delete">"⊢ concl (axiom_not _)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>axiom_and</span><span class="delimiter">:</span><span>
</span><span>                    </span><span class="string"><span class="delete"><span class="delete">"⊢ concl (axiom_and _ _)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>axiom_or</span><span class="delimiter">:</span><span>
</span><span>                    </span><span class="string"><span class="delete"><span class="delete">"⊢ concl (axiom_or _ _)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>axiom_exists</span><span class="delimiter">:</span><span>
</span><span>                    </span><span class="string"><span class="delete"><span class="delete">"⊢ concl (axiom_exists _ _)"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Example *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">proposition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊢ Imp p p"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⊢ concl (Thm (Imp (Imp p (Imp (Imp p p) p)) (Imp (Imp p (Imp p p)) (Imp p p))))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>axiom_distribimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>axiom_distribimp_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⊢ concl (Thm (Imp p (Imp (Imp p p) p)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>axiom_addimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>axiom_addimp_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⊢ concl (Thm (Imp (Imp p (Imp p p)) (Imp p p)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span>modusponens</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>modusponens_def</span><span> </span><span>fol_equal_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⊢ concl (Thm (Imp p (Imp p p)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>axiom_addimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>axiom_addimp_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⊢ concl (Thm (Imp p p))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>3</span><span> </span><span>4</span><span> </span><span>modusponens</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>modusponens_def</span><span> </span><span>fol_equal_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>5</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Soundness of proof system›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map'</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"¬ occurs_in x t ⟹ semantics_term e f t = semantics_term (e(x := v)) f t"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"¬ occurs_in_list x l ⟹ semantics_list e f l = semantics_list (e(x := v)) f l"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>l</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>semantics_term.induct</span><span> </span><span>semantics_list.induct</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"¬ free_in x p ⟹ semantics e f g p ⟷ semantics (e(x := v)) f g p"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>p</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>e</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ free_in x Truth ⟹ semantics e f g Truth ⟷ semantics (e(x := v)) f g Truth"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>e</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ free_in x Falsity ⟹ semantics e f g Falsity ⟷ semantics (e(x := v)) f g Falsity"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>e</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ free_in x (Atom a) ⟹ semantics e f g (Atom a) ⟷ semantics (e(x := v)) f g (Atom a)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span> </span><span>l</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ free_in x (Atom a) ⟹ a = Rl i l ⟹
        semantics e f g (Atom a) ⟷ semantics (e(x := v)) f g (Atom a)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>assm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ free_in x (Atom a)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a = Rl i l"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fresh</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ occurs_in_list x l"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"semantics e f g (Atom a) ⟷ semantics (e(x := v)) f g (Atom a)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i = STR ''='' ∧ length2 l"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"semantics e f g (Atom (Rl i l)) ⟷
            semantics_term e f (hd l) = semantics_term e f (hd (tl l))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ⟷
            semantics_term (e(x := v)) f (hd l) = semantics_term (e(x := v)) f (hd (tl l))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>map'</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>fresh</span><span> </span><span>occurs_in_list.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>eq</span><span> </span><span>list.case_eq_if</span><span> </span><span>list.collapse</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>length2_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eq</span><span> </span><span>assm</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>not_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ (i = STR ''='' ∧ length2 l)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"semantics e f g (Atom (Rl i l)) ⟷ g i (semantics_list e f l)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span>iprover</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ⟷ g i (semantics_list (e(x := v)) f l)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>map'</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>fresh</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_eq</span><span> </span><span>assm</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span>iprover</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>p1</span><span> </span><span>p2</span><span> </span><span>e</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>assm1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ free_in x p1 ⟹ semantics e f g p1 ⟷ semantics (e(x := v)) f g p1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>e</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>assm2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ free_in x p2 ⟹ semantics e f g p2 ⟷ semantics (e(x := v)) f g p2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>e</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ free_in x (Imp p1 p2) ⟹
      semantics e f g (Imp p1 p2) ⟷ semantics (e(x := v)) f g (Imp p1 p2)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assm1</span><span> </span><span>assm2</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>p1</span><span> </span><span>p2</span><span> </span><span>e</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>assm1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ free_in x p1 ⟹ semantics e f g p1 ⟷ semantics (e(x := v)) f g p1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>e</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>assm2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ free_in x p2 ⟹ semantics e f g p2 ⟷ semantics (e(x := v)) f g p2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>e</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ free_in x (Iff p1 p2) ⟹
      semantics e f g (Iff p1 p2) ⟷ semantics (e(x := v)) f g (Iff p1 p2)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assm1</span><span> </span><span>assm2</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>p1</span><span> </span><span>p2</span><span> </span><span>e</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>assm1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ free_in x p1 ⟹ semantics e f g p1 ⟷ semantics (e(x := v)) f g p1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>e</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>assm2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ free_in x p2 ⟹ semantics e f g p2 ⟷ semantics (e(x := v)) f g p2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>e</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ free_in x (And p1 p2) ⟹
      semantics e f g (And p1 p2) ⟷ semantics (e(x := v)) f g (And p1 p2)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assm1</span><span> </span><span>assm2</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>p1</span><span> </span><span>p2</span><span> </span><span>e</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>assm1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ free_in x p1 ⟹ semantics e f g p1 ⟷ semantics (e(x := v)) f g p1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>e</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>assm2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ free_in x p2 ⟹ semantics e f g p2 ⟷ semantics (e(x := v)) f g p2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>e</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ free_in x (Or p1 p2) ⟹
      semantics e f g (Or p1 p2) ⟷ semantics (e(x := v)) f g (Or p1 p2)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assm1</span><span> </span><span>assm2</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>p</span><span> </span><span>e</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ free_in x p ⟹ semantics e f g p ⟷ semantics (e(x := v)) f g p"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>e</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ free_in x (Not p) ⟹ semantics e f g (Not p) ⟷ semantics (e(x := v)) f g (Not p)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x1</span><span> </span><span>p</span><span> </span><span>e</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ free_in x p ⟹ semantics e f g p ⟷ semantics (e(x := v)) f g p"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>e</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ free_in x (Exists x1 p) ⟹
      semantics e f g (Exists x1 p) ⟷ semantics (e(x := v)) f g (Exists x1 p)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fun_upd_twist</span><span> </span><span>fun_upd_upd</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x1</span><span> </span><span>p</span><span> </span><span>e</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ free_in x p ⟹ semantics e f g p ⟷ semantics (e(x := v)) f g p"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>e</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ free_in x (Forall x1 p) ⟹
      semantics e f g (Forall x1 p) ⟷ semantics (e(x := v)) f g (Forall x1 p)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fun_upd_twist</span><span> </span><span>fun_upd_upd</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>length2_equiv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"length2 l ⟷ [hd l, hd (tl l)] = l"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length2 l ⟹ [hd l, hd (tl l)] = l"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>length2_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>list.case_eq_if</span><span> </span><span>list.exhaust_sel</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>length2_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>list.case</span><span> </span><span>list.case_eq_if</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>equal_length_sym</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"equal_length l l' ⟹ equal_length l' l"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>l'</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>l</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>l</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"equal_length l []"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"equal_length [] l"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>equal_length.simps</span><span> </span><span>list.case_eq_if</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>l</span><span> </span><span>l'</span><span> </span><span>a</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>sym</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"equal_length l l' ⟹ equal_length l' l"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>l</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"equal_length l (a # l')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"equal_length (a # l') l"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>equal_length.simps</span><span> </span><span>list.case_eq_if</span><span> </span><span>list.collapse</span><span> </span><span>list.inject</span><span> </span><span>sym</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>equal_length2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"equal_length l l' ⟹ length2 l ⟷ length2 l'"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>assm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"equal_length l l'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"equal_length l [t, t'] ⟹ length2 l"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>t</span><span> </span><span>t'</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>length2_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>equal_length.simps</span><span> </span><span>list.case_eq_if</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"equal_length [t, t'] l' ⟹ length2 l'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>t</span><span> </span><span>t'</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>length2_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>equal_length.simps</span><span> </span><span>list.case_eq_if</span><span> </span><span>equal_length_sym</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assm</span><span> </span><span>length2_equiv</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>imp_chain_equiv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"semantics e f g (foldr Imp l p) ⟷ (∀q ∈ set l. semantics e f g q) ⟶ semantics e f g p"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>imp_conjL</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>l</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>imp_chain_zip_eq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"equal_length l l' ⟹
      semantics e f g (foldr Imp (zip_eq l l') p) ⟷
      semantics_list e f l = semantics_list e f l' ⟶ semantics e f g p"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"equal_length l l'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀q ∈ set (zip_eq l l'). semantics e f g q) ⟷
      semantics_list e f l = semantics_list e f l'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>zip_eq_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>length2_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>l</span><span> </span><span>l'</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>list_induct2'</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>imp_chain_equiv</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>iprover</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>funcong</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"equal_length l l' ⟹
      semantics e f g (foldr Imp (zip_eq l l') (Atom (Rl (STR ''='') [Fn i l, Fn i l'])))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>assm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"equal_length l l'"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"semantics_list e f l = semantics_list e f l'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"semantics e f g (Atom (Rl (STR ''='') [Fn i l, Fn i l']))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>length2_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>imp_chain_equiv</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>iprover</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"semantics_list e f l ≠ semantics_list e f l'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assm</span><span> </span><span>imp_chain_zip_eq</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>iprover</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>predcong</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"equal_length l l' ⟹
      semantics e f g (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>assm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"equal_length l l'"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i = STR ''='' ∧ length2 l ∧ length2 l'"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"semantics_list e f l = semantics_list e f l'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"semantics_list e f [hd l, hd (tl l)] = semantics_list e f [hd l', hd (tl l')]"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eq</span><span> </span><span>length2_equiv</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"semantics e f g (Imp (Atom (Rl (STR ''='') l)) (Atom (Rl (STR ''='') l')))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eq</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eq</span><span> </span><span>imp_chain_equiv</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>iprover</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"semantics_list e f l ≠ semantics_list e f l'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assm</span><span> </span><span>imp_chain_zip_eq</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>iprover</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>not_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ (i = STR ''='' ∧ length2 l ∧ length2 l')"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"semantics_list e f l = semantics_list e f l'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"semantics e f g (Imp (Atom (Rl i l)) (Atom (Rl i l')))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assm</span><span> </span><span>not_eq</span><span> </span><span>equal_length2</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span>iprover</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>imp_chain_equiv</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>iprover</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"semantics_list e f l ≠ semantics_list e f l'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assm</span><span> </span><span>imp_chain_zip_eq</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>iprover</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>soundness</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⊢ p ⟹ semantics e f g p"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>e</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>OK.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>e</span><span> </span><span>s</span><span> </span><span>s'</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"semantics e f g (concl s)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"semantics e f g (concl s')"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>e</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"semantics e f g (concl (modusponens s s'))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>modusponens_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>r</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"semantics e f g (concl s)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"semantics e f g (concl s')"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s = Thm r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>e</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"semantics e f g (concl (case (concl s) of Imp p q ⇒
        let p' = concl s' in if fol_equal p p' then Thm q else fail_thm | _ ⇒ fail_thm))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fol_equal_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>r</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>e</span><span> </span><span>x</span><span> </span><span>s</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"semantics e f g (concl s)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>e</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"semantics e f g (concl (gen x s))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gen_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>e</span><span> </span><span>p</span><span> </span><span>q</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"semantics e f g (concl (axiom_addimp p q))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>axiom_addimp_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>e</span><span> </span><span>p</span><span> </span><span>q</span><span> </span><span>r</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"semantics e f g (concl (axiom_distribimp p q r))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>axiom_distribimp_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>e</span><span> </span><span>g</span><span> </span><span>p</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"semantics e f g (concl (axiom_doubleneg p))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>axiom_doubleneg_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>e</span><span> </span><span>x</span><span> </span><span>p</span><span> </span><span>q</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"semantics e f g (concl (axiom_allimp x p q))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>axiom_allimp_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>e</span><span> </span><span>x</span><span> </span><span>p</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"semantics e f g (concl (axiom_impall x p))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>axiom_impall_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>map</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span>iprover</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>e</span><span> </span><span>x</span><span> </span><span>t</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"semantics e f g (concl (axiom_existseq x t))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>axiom_existseq_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>map'</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>length2_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span>iprover</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>e</span><span> </span><span>t</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"semantics e f g (concl (axiom_eqrefl t))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>axiom_eqrefl_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>length2_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>e</span><span> </span><span>i</span><span> </span><span>l</span><span> </span><span>l'</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"semantics e f g (concl (axiom_funcong i l l'))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>axiom_funcong_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>funcong</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span>standard</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>e</span><span> </span><span>i</span><span> </span><span>l</span><span> </span><span>l'</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"semantics e f g (concl (axiom_predcong i l l'))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>axiom_predcong_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>predcong</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span>standard</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>e</span><span> </span><span>p</span><span> </span><span>q</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"semantics e f g (concl (axiom_iffimp1 p q))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>axiom_iffimp1_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>e</span><span> </span><span>p</span><span> </span><span>q</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"semantics e f g (concl (axiom_iffimp2 p q))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>axiom_iffimp2_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>e</span><span> </span><span>p</span><span> </span><span>q</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"semantics e f g (concl (axiom_impiff p q))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>axiom_impiff_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>e</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"semantics e f g (concl (axiom_true))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>axiom_true_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>e</span><span> </span><span>p</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"semantics e f g (concl (axiom_not p))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>axiom_not_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>e</span><span> </span><span>p</span><span> </span><span>q</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"semantics e f g (concl (axiom_and p q))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>axiom_and_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>e</span><span> </span><span>p</span><span> </span><span>q</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"semantics e f g (concl (axiom_or p q))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>axiom_or_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>e</span><span> </span><span>x</span><span> </span><span>p</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"semantics e f g (concl (axiom_exists x p))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>axiom_exists_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ (⊢ Falsity)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>soundness</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ML Code Reflection›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_reflect</span></span><span>
</span><span>  </span><span>Proven</span><span>
</span><span class="keyword2"><span class="keyword">datatypes</span></span><span>
</span><span>  </span><span>fm</span><span> </span><span class="delimiter">=</span><span> </span><span>Falsity</span><span> </span><span class="delimiter">|</span><span> </span><span>Truth</span><span> </span><span class="delimiter">|</span><span> </span><span>Atom</span><span> </span><span class="delimiter">|</span><span> </span><span>Imp</span><span> </span><span class="delimiter">|</span><span> </span><span>Iff</span><span> </span><span class="delimiter">|</span><span> </span><span>And</span><span> </span><span class="delimiter">|</span><span> </span><span>Or</span><span> </span><span class="delimiter">|</span><span> </span><span>Not</span><span> </span><span class="delimiter">|</span><span> </span><span>Exists</span><span> </span><span class="delimiter">|</span><span> </span><span>Forall</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>tm</span><span> </span><span class="delimiter">=</span><span> </span><span>Var</span><span> </span><span class="delimiter">|</span><span> </span><span>Fn</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>fol</span><span> </span><span class="delimiter">=</span><span> </span><span>Rl</span><span>
</span><span class="keyword2"><span class="keyword">functions</span></span><span>
</span><span>  </span><span>modusponens</span><span> </span><span>gen</span><span> </span><span>axiom_addimp</span><span> </span><span>axiom_distribimp</span><span> </span><span>axiom_doubleneg</span><span> </span><span>axiom_allimp</span><span> </span><span>axiom_impall</span><span>
</span><span>  </span><span>axiom_existseq</span><span> </span><span>axiom_eqrefl</span><span> </span><span>axiom_funcong</span><span> </span><span>axiom_predcong</span><span> </span><span>axiom_iffimp1</span><span> </span><span>axiom_iffimp2</span><span>
</span><span>  </span><span>axiom_impiff</span><span> </span><span>axiom_true</span><span> </span><span>axiom_not</span><span> </span><span>axiom_and</span><span> </span><span>axiom_or</span><span> </span><span>axiom_exists</span><span> </span><span>concl</span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹open Proven›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹val print = writeln (* Should not add newline but only used for testing (see XXX label) *)›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹"format_simple.sml";

fun set_margin _ = ();

fun print_string x = print x;

fun open_box _ = ();

fun close_box () = ();

fun print_space () = print " ";

fun print_break _ _ = ();

fun open_hbox () = ();

fun print_flush () = ();

fun print_newline () = print "\n";

fun print_int n = print (Int.toString n);

fun open_hvbox _ = ();

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹"lib.sml";

(* ========================================================================= *)
(* Misc library functions to set up a nice environment.                      *)
(* ========================================================================= *)

fun str_ord s1 s2 =
    case String.compare(s1,s2) of
      EQUAL =&gt; 0    | GREATER =&gt; 1    | LESS  =&gt; ~1;

fun sip_ord (f1,a1) (f2,a2) =
    case str_ord f1 f2 of
      0 =&gt; if a1&gt;a2 then 1 else ~1
    | n =&gt; n
;

infix 6 lxor
infix 6 land

fun to_int_fun f = fn a =&gt; fn b =&gt; Word.toIntX (f ((Word.fromInt a),(Word.fromInt b) ) );

fun a lxor b = to_int_fun Word.xorb a b;
fun a land b = to_int_fun Word.andb a b;

fun list_hash elem_hash l=
  let fun hash_code sval l =
        case l of
         [] =&gt; sval
        | e::l' =&gt;
          let val e_hash = Word.fromInt (elem_hash e) in
          hash_code (Word.+(Word.*(sval,0wx31),(e_hash))) l'
          end
  in
  Word.toIntX(hash_code 0wx0 l)
  end
;

fun str_hash str = list_hash Char.ord (String.explode str);

fun fst (x,_) = x;
fun snd (_,y) = y;

(* ========================================================================= *)
(* Misc library functions to set up a nice environment.                      *)
(* ========================================================================= *)

fun identity x = x;

(* ------------------------------------------------------------------------- *)
(* A useful idiom for "non contradictory" etc.                               *)
(* ------------------------------------------------------------------------- *)

fun non p x = not(p x);

(* ------------------------------------------------------------------------- *)
(* Kind of assertion checking.                                               *)
(* ------------------------------------------------------------------------- *)

fun check p x = if p(x) then x else raise Fail "check";

(* ------------------------------------------------------------------------- *)
(* Repetition of a function.                                                 *)
(* ------------------------------------------------------------------------- *)

fun funpow n f x =
    if n &lt; 1 then x
    else funpow (n - 1) f (f x);

fun can f x = (f x; true) handle Fail _ =&gt; false;

fun repeat f x = repeat f (f x) handle Fail _ =&gt; x;

(* ------------------------------------------------------------------------- *)
(* Handy list operations.                                                    *)
(* ------------------------------------------------------------------------- *)

infix 6 --
fun m -- n = if m &gt; n then [] else m::((m + 1) -- n);

fun map2 f l1 l2 =
  case (l1,l2) of
    ([],[]) =&gt; []
  | ((h1::t1),(h2::t2)) =&gt; let val h = f h1 h2 in h::(map2 f t1 t2) end
  | _ =&gt; raise Fail "map2: length mismatch";

fun itlist f l b = List.foldr (fn (x,y) =&gt; f x y) b l;

fun end_itlist f l =
  case l of
        []     =&gt; raise Fail "end_itlist"
      | [x]    =&gt; x
      | (h::t) =&gt; f h (end_itlist f t);

fun itlist2 f l1 l2 b =
  case (l1,l2) of
    ([],[]) =&gt; b
  | (h1::t1,h2::t2) =&gt; f h1 h2 (itlist2 f t1 t2 b)
  | _ =&gt; raise Fail "itlist2";

fun zip l1 l2 =
  case (l1,l2) of
        ([],[]) =&gt; []
      | (h1::t1,h2::t2) =&gt; (h1,h2)::(zip t1 t2)
      | _ =&gt; raise Fail "zip";

fun chop_list n l =
  if n = 0 then ([],l) else
  let val (m,l') = chop_list (n-1) (tl l) in ((hd l)::m,l') end
  handle Fail _ =&gt; raise Fail "chop_list";

fun index x =
  let fun ind n l =
    case l of
      [] =&gt; raise Fail "index"
    | (h::t) =&gt; if x = h then n else ind (n + 1) t
  in
    ind 0
  end;

fun unzip l =
  case l of
    [] =&gt; ([],[])
  | (x,y)::t =&gt;
      let val (xs,ys) = unzip t in (x::xs,y::ys) end;

(* ------------------------------------------------------------------------- *)
(* Association lists.                                                        *)
(* ------------------------------------------------------------------------- *)

fun assoc a l =
  case l of
    (x,y)::t =&gt; if x = a then y else assoc a t
  | [] =&gt; raise Fail "find";

(* ------------------------------------------------------------------------- *)
(* Merging of sorted lists (maintaining repetitions).                        *)
(* ------------------------------------------------------------------------- *)

fun merge ord l1 l2 =
  case l1 of
    [] =&gt; l2
  | h1::t1 =&gt; case l2 of
                [] =&gt; l1
              | h2::t2 =&gt; if ord h1 h2 then h1::(merge ord t1 l2)
                          else h2::(merge ord l1 t2);

(* ------------------------------------------------------------------------- *)
(* Bottom-up mergesort.                                                      *)
(* ------------------------------------------------------------------------- *)

fun sort ord =
  let fun mergepairs l1 l2 =
    case (l1,l2) of
        ([s],[]) =&gt; s
      | (l,[]) =&gt; mergepairs [] l
      | (l,[s1]) =&gt; mergepairs (s1::l) []
      | (l,(s1::s2::ss)) =&gt; mergepairs ((merge ord s1 s2)::l) ss in
  fn l =&gt; if l = [] then [] else mergepairs [] (List.map (fn x =&gt; [x]) l)
  end;

(* ------------------------------------------------------------------------- *)
(* Common measure predicates to use with "sort".                             *)
(* ------------------------------------------------------------------------- *)

fun increasing f x y = (f x) &lt; (f y);

fun decreasing f x y = (f x) &gt; (f y) ;

(* ------------------------------------------------------------------------- *)
(* Eliminate repetitions of adjacent elements, with and without counting.    *)
(* ------------------------------------------------------------------------- *)

fun uniq l =
    case l of
      x :: (t as y :: ys ) =&gt;
        let val t' = uniq t in
            if x = y then t'
            else
                x :: t'
        end
    | _ =&gt; l;

fun tryfind f l =
  case l of
      [] =&gt; raise Fail "tryfind"
    | (h::t) =&gt;
      ((f h) handle Fail _ =&gt; tryfind f t);

(* ------------------------------------------------------------------------- *)
(* Set operations on ordered lists.                                          *)
(* ------------------------------------------------------------------------- *)

fun setify ord l=
  let fun canonical lis =
     case lis of
       x::(rest as y::_) =&gt; ord x y &lt; 0 andalso canonical rest
     | _ =&gt; true in
  if canonical l then l
  else uniq (sort (fn x =&gt; fn y =&gt; ord x y &lt;= 0) l)
  end;

fun union ord s1 s2=
  let fun union l1 l2 =
    case (l1,l2) of
        ([],l2) =&gt; l2
      | (l1,[]) =&gt; l1
      | ((l1 as h1::t1),(l2 as h2::t2)) =&gt;
          if h1 = h2 then h1::(union t1 t2)
          else if ord h1 h2 = ~1 then h1::(union t1 l2)
          else h2::(union l1 t2) in
  union (setify ord s1) (setify ord s2)
  end;

 fun union_str s1 s2 = union str_ord s1 s2;
 fun union_sip p1 p2 = union sip_ord p1 p2;

fun subtract ord s1 s2=
  let fun subtract l1 l2 =
    case (l1,l2) of
        ([],l2) =&gt; []
      | (l1,[]) =&gt; l1
      | ((l1 as h1::t1),(l2 as h2::t2)) =&gt;
          if h1 = h2 then subtract t1 t2
          else if ord h1 h2 = ~1 then h1::(subtract t1 l2)
          else subtract l1 t2 in
  subtract (setify ord s1) (setify ord s2)
  end;

fun subtract_str s1 s2 = subtract str_ord s1 s2;

fun insert ord x s = union ord [x] s;

fun insert_str x s = insert str_ord x s;

(* ------------------------------------------------------------------------- *)
(* Union of a family of sets.                                                *)
(* ------------------------------------------------------------------------- *)

fun unions ord s =
   let fun concat a b = a @ b in
   setify ord (itlist concat s [])
   end;

fun unions_str s = unions str_ord s;

(* ------------------------------------------------------------------------- *)
(* List membership. This does *not* assume the list is a set.                *)
(* ------------------------------------------------------------------------- *)

fun mem x lis =
    case lis of
      [] =&gt; false
    | hd :: tl =&gt; hd = x orelse mem x tl;

(* ------------------------------------------------------------------------- *)
(* Timing; useful for documentation but not logically necessary.             *)
(* ------------------------------------------------------------------------- *)

fun time f x =
    let val timer = Timer.startRealTimer()
        val result = f x
        val time = Timer.checkRealTimer timer
    in (
    (* XXX print_string ("CPU time (user): " ^ (Real.toString (Time.toReal time)));
    print_newline(); *)
    result
    ) end;

(* ------------------------------------------------------------------------- *)
(* Polymorphic finite partial functions via Patricia trees.                  *)
(*                                                                           *)
(* The point of this strange representation is that it is canonical (equal   *)
(* functions have the same encoding) yet reasonably efficient on average.    *)
(*                                                                           *)
(* Idea due to Diego Olivier Fernandez Pons (OCaml list, 2003/11/10).        *)
(* ------------------------------------------------------------------------- *)

datatype ('a,'b)func =
   Empty
 | Leaf of int * ('a*'b)list
 | Branch of int * int * ('a,'b)func * ('a,'b)func;

(* ------------------------------------------------------------------------- *)
(* Undefined function.                                                       *)
(* ------------------------------------------------------------------------- *)

val undefined = Empty;

(* ------------------------------------------------------------------------- *)
(* In case of equality comparison worries, better use this.                  *)
(* ------------------------------------------------------------------------- *)

fun is_undefined f =
  case f of
    Empty =&gt; true
  | _ =&gt; false;

(* ------------------------------------------------------------------------- *)
(* Operation analogous to "map" for lists.                                   *)
(* ------------------------------------------------------------------------- *)

local
  fun map_list f l =
        case l of
          [] =&gt; []
        | (x,y)::t =&gt; (x,f(y))::(map_list f t)
in
  fun mapf f t =
        case t of
          Empty =&gt; Empty
        | Leaf(h,l) =&gt; Leaf(h,map_list f l)
        | Branch(p,b,l,r) =&gt; Branch(p,b,mapf f l,mapf f r)
end;

(* ------------------------------------------------------------------------- *)
(* Application.                                                              *)
(* ------------------------------------------------------------------------- *)

fun applyd ord hash f d x=
  let fun apply_listd l d x =
        case l of
          (a,b)::t =&gt; if x = a then b else if ord x a &gt; 0 then apply_listd t d x else d x
        | [] =&gt; d x
      val k = hash x
      fun look t =
        case t of
          Leaf(h,l) =&gt;
            if (h = k) then
              apply_listd l d x
            else d x
        | Branch(p,b,l,r) =&gt;
            if ((k lxor p) land (b - 1)) = 0 then
              look (if k land b = 0 then l else r)
            else d x
        | _ =&gt; d x
  in
  look f
  end
;

fun apply ord hash f = applyd ord hash f (fn x =&gt; raise Fail "apply");

fun apply_str f = apply str_ord str_hash f;

fun tryapplyd ord hash f a d = applyd ord hash f (fn x =&gt; d) a;

fun tryapplyd_str f a d = tryapplyd str_ord str_hash f a d;

fun tryapplyl ord hash f x = tryapplyd ord hash f x [];

fun defined ord hash f x = (apply ord hash f x; true) handle Fail _ =&gt; false;

fun defined_str f x = defined str_ord str_hash f x;

(* ------------------------------------------------------------------------- *)
(* Undefinition.                                                             *)
(* ------------------------------------------------------------------------- *)

local
  fun undefine_list ord x l =
    case l of
      (ab as (a,b))::t =&gt;
          let val c = ord x a in
          if c = 0 then
            t
          else if c &lt; 0 then
            l
          else
            let val t' = undefine_list ord x t in
            ab::t'
            end
          end
    | [] =&gt; []
in
  fun undefine ord hash x =
    let val k = hash x
        fun und t =
          case t of
            Leaf(h,l) =&gt;
              if h=k then (
                let val l' = undefine_list ord x l in
                if l' = l then t
                else if l' = [] then Empty
                else Leaf(h,l')
                end
              ) else t
          | Branch(p,b,l,r) =&gt;
              if k land (b - 1) = p then (
                if k land b = 0 then
                  let val l' = und l in
                  if l' = l then t
                  else (case l' of Empty =&gt; r | _ =&gt; Branch(p,b,l',r))
                  end
                else
                  let val r' = und r in
                  if r' = r then t
                  else (case r' of Empty =&gt; l | _ =&gt; Branch(p,b,l,r'))
                  end
              ) else t
          | _ =&gt; t
    in
    und
    end
end;

fun undefine_str x t = undefine str_ord str_hash x t

(* ------------------------------------------------------------------------- *)
(* Redefinition and combination.                                             *)
(* ------------------------------------------------------------------------- *)

infix 6 |-&gt;

local
  fun newbranch p1 t1 p2 t2 =
        let val zp = p1 lxor p2
            val b = zp land (~zp)
            val p = p1 land (b - 1) in
        if p1 land b = 0 then Branch(p,b,t1,t2)
        else Branch(p,b,t2,t1)
        end
  fun define_list ord (xy as (x,y)) l =
        case l of
          (ab as (a,b))::t =&gt;
              let val c = ord x a in
              if c = 0 then xy::t
              else if c &lt; 0 then xy::l
              else ab::(define_list ord xy t)
              end
        | [] =&gt; [xy]
  fun combine_list ord op' z l1 l2 =
        case (l1,l2) of
          ([],_) =&gt; l2
        | (_,[]) =&gt; l1
        | ((xy1 as (x1,y1))::t1,(xy2 as (x2,y2))::t2) =&gt;
              let val c = ord x1 x2 in
              if c &lt; 0 then
                xy1::(combine_list ord op' z t1 l2)
              else if c &gt; 0 then
                xy2::(combine_list ord op' z l1 t2)
              else
                let val y = op' y1 y2
                    val l = combine_list ord op' z t1 t2 in
                if z(y) then l else (x1,y)::l
                end
              end
  in
  fun (x |-&gt; y) t ord hash =
        let val k = hash x
            fun upd t =
              case t of
                Empty =&gt; Leaf (k,[(x,y)])
              | Leaf(h,l) =&gt;
                   if h = k then Leaf(h,define_list ord (x,y) l)
                   else newbranch h t k (Leaf(k,[(x,y)]))
              | Branch(p,b,l,r) =&gt;
                  if k land (b - 1) &lt;&gt; p then newbranch p t k (Leaf(k,[(x,y)]))
                  else if k land b = 0 then Branch(p,b,upd l,r)
                  else Branch(p,b,l,upd r) in
        upd t
        end
  fun combine ord op' z t1 t2 =
        case (t1,t2) of
          (Empty,_) =&gt; t2
        | (_,Empty) =&gt; t1
        | (Leaf(h1,l1),Leaf(h2,l2)) =&gt;
              if h1 = h2 then
                let val l = combine_list ord op' z l1 l2 in
                if l = [] then Empty else Leaf(h1,l)
                end
              else newbranch h1 t1 h2 t2
        | ((lf as Leaf(k,lis)),(br as Branch(p,b,l,r))) =&gt;
              if k land (b - 1) = p then
                if k land b = 0 then
                  (case combine ord op' z lf l of
                     Empty =&gt; r | l' =&gt; Branch(p,b,l',r))
                else
                  (case combine ord op' z lf r of
                     Empty =&gt; l | r' =&gt; Branch(p,b,l,r'))
              else
                newbranch k lf p br
        | ((br as Branch(p,b,l,r)),(lf as Leaf(k,lis))) =&gt;
              if k land (b - 1) = p then
                if k land b = 0 then
                  (case combine ord op' z l lf of
                    Empty =&gt; r | l' =&gt; Branch(p,b,l',r))
                else
                  (case combine ord op' z r lf of
                     Empty =&gt; l | r' =&gt; Branch(p,b,l,r'))
              else
                newbranch p br k lf
        | (Branch(p1,b1,l1,r1),Branch(p2,b2,l2,r2)) =&gt;
              if b1 &lt; b2 then
                if p2 land (b1 - 1) &lt;&gt; p1 then newbranch p1 t1 p2 t2
                else if p2 land b1 = 0 then
                  (case combine ord op' z l1 t2 of
                     Empty =&gt; r1 | l =&gt; Branch(p1,b1,l,r1))
                else
                  (case combine ord op' z r1 t2 of
                     Empty =&gt; l1 | r =&gt; Branch(p1,b1,l1,r))
              else if b2 &lt; b1 then
                if p1 land (b2 - 1) &lt;&gt; p2 then newbranch p1 t1 p2 t2
                else if p1 land b2 = 0 then
                  (case combine ord op' z t1 l2 of
                     Empty =&gt; r2 | l =&gt; Branch(p2,b2,l,r2))
                else
                  (case combine ord op' z t1 r2 of
                     Empty =&gt; l2 | r =&gt; Branch(p2,b2,l2,r))
              else if p1 = p2 then
               (case (combine ord op' z l1 l2,combine ord op' z r1 r2) of
                  (Empty,r) =&gt; r | (l,Empty) =&gt; l | (l,r) =&gt; Branch(p1,b1,l,r))
              else
                newbranch p1 t1 p2 t2
end ;

infix 6 |--&gt; (* For strings *)

fun (x |--&gt; y) t = (x |-&gt; y) t str_ord str_hash;

(* ------------------------------------------------------------------------- *)
(* Special case of point function.                                           *)
(* ------------------------------------------------------------------------- *)

infix 6 |=&gt;

fun x |=&gt; y = (x |-&gt; y) undefined;

infix 6 |==&gt; (* For strings *)

fun x |==&gt; y = (x |=&gt; y) str_ord str_hash;

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹"intro.sml";

(* ========================================================================= *)
(* Simple algebraic expression example from the introductory chapter.        *)
(* ========================================================================= *)

(* ------------------------------------------------------------------------- *)
(* Lexical analysis.                                                         *)
(* ------------------------------------------------------------------------- *)

fun matches s =
    let val chars = String.explode s in
    fn c =&gt; mem c chars
    end;

val space = matches " \t\n\r";
val punctuation = matches "()[]{},";
val symbolic = matches "~`!@#$%^&amp;*-+=|\\:;&lt;&gt;.?/";
val numeric = matches "0123456789";
val alphanumeric = matches
  "abcdefghijklmnopqrstuvwxyz_'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

fun lexwhile prop inp =
  if inp &lt;&gt; [] andalso prop (List.hd inp) then
     let val (tok,rest) = lexwhile prop (List.tl inp) in
     ((str (List.hd inp))^tok,rest)
     end
  else
     ("",inp);

fun lex inp =
  case snd(lexwhile space inp) of
    [] =&gt; []
  | c::cs =&gt; let val prop = if alphanumeric(c) then alphanumeric
                        else if symbolic(c) then symbolic
                        else fn c =&gt; false
                 val (toktl,rest) = lexwhile prop cs in
             ((str c)^toktl)::lex rest
             end;

(* ------------------------------------------------------------------------- *)
(* Generic function to impose lexing and exhaustion checking on a parser.    *)
(* ------------------------------------------------------------------------- *)

fun make_parser pfn s =
  let val (expr,rest) = pfn (lex(String.explode s)) in
  if rest = [] then expr else raise Fail "Unparsed input"
  end;

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹"formulas.sml";

(* ========================================================================= *)
(* Polymorphic type of formulas with parser and printer.                     *)
(* ========================================================================= *)

fun fm_ord at_ord fm1 fm2 =
    case (fm1,fm2) of
      (Falsity,Falsity) =&gt; 0
    | (Falsity,_) =&gt;  1
    | (_,Falsity) =&gt; ~1

    | (Truth,Truth) =&gt; 0
    | (Truth,_)  =&gt;  1
    | (_,Truth)  =&gt; ~1

    | (Atom a, Atom b) =&gt; at_ord a b
    | (Atom(_),_) =&gt; 1
    | (_,Atom(_)) =&gt; ~1

    | (Not a,Not b) =&gt; fm_ord at_ord a b
    | (Not(_),_) =&gt; 1
    | (_,Not(_)) =&gt; ~1

    | (And(a1,a2),And(b1,b2)) =&gt; fm_pair_ord at_ord (a1,a2) (b1,b2)
    | (And(_,_),_) =&gt;  1
    | (_,And(_,_)) =&gt; ~1

    | (Or(a1,a2),Or(b1,b2)) =&gt; fm_pair_ord at_ord (a1,a2) (b1,b2)
    | (Or(_,_),_) =&gt;  1
    | (_,Or(_,_)) =&gt; ~1

    | (Imp(a1,a2),Imp(b1,b2)) =&gt; fm_pair_ord at_ord (a1,a2) (b1,b2)
    | (Imp(_,_),_) =&gt;  1
    | (_,Imp(_,_)) =&gt; ~1

    | (Iff(a1,a2),Iff(b1,b2)) =&gt; fm_pair_ord at_ord (a1,a2) (b1,b2)
    | (Iff(_,_),_) =&gt;  1
    | (_,Iff(_,_)) =&gt; ~1

    | (Forall(x1,a),Forall(x2,b)) =&gt; fm_quant_ord at_ord (x1,a) (x2,b)
    | (Forall (_,_), _) =&gt; 1
    | (_, Forall (_,_)) =&gt; ~1

    | (Exists(x1,a),Exists(x2,b)) =&gt; fm_quant_ord at_ord (x1,a) (x2,b)
and fm_pair_ord at_ord (a1,a2) (b1,b2) =
    case fm_ord at_ord a1 b1 of
     0 =&gt; fm_ord at_ord a2 b2
    |n =&gt; n
and fm_quant_ord at_ord (x1,a) (x2,b) =
    case str_ord x1 x2 of
     0 =&gt; fm_ord at_ord a b
    |n =&gt; n
;

(* ------------------------------------------------------------------------- *)
(* General parsing of iterated infixes.                                      *)
(* ------------------------------------------------------------------------- *)

fun parse_ginfix opsym opupdate sof subparser inp =
  let val (e1,inp1) = subparser inp in
  if inp1 &lt;&gt; [] andalso List.hd inp1 = opsym then
     parse_ginfix opsym opupdate (opupdate sof e1) subparser (List.tl inp1)
  else (sof e1,inp1)
  end;

fun parse_left_infix opsym opcon =
  parse_ginfix opsym (fn f =&gt; fn e1 =&gt; fn e2 =&gt; opcon(f e1,e2)) (fn x =&gt; x);

fun parse_right_infix opsym opcon =
  parse_ginfix opsym (fn f =&gt; fn e1 =&gt; fn e2 =&gt; f(opcon(e1,e2))) (fn x =&gt; x);

fun parse_list opsym =
  parse_ginfix opsym (fn f =&gt; fn e1 =&gt; fn e2 =&gt; (f e1)@[e2]) (fn x =&gt; [x]);

(* ------------------------------------------------------------------------- *)
(* Other general parsing combinators.                                        *)
(* ------------------------------------------------------------------------- *)

fun papply f (ast,rest) = (f ast,rest);

fun nextin inp tok = inp &lt;&gt; [] andalso List.hd inp = tok;

fun parse_bracketed subparser cbra inp =
  let val(ast,rest) = subparser inp in
  if nextin rest cbra then (ast,List.tl rest)
  else raise Fail "Closing bracket expected"
  end;

(* ------------------------------------------------------------------------- *)
(* Parsing of formulas, parametrized by atom parser "pfn".                   *)
(* ------------------------------------------------------------------------- *)

fun parse_atomic_formula (ifn,afn) vs inp =
  case inp of
    [] =&gt; raise Fail "formula expected"
  | "false"::rest =&gt; (Falsity,rest)
  | "true"::rest =&gt; (Truth,rest)
  | "("::rest =&gt; ( (ifn vs inp) handle Fail _ =&gt;
                  parse_bracketed (parse_formula (ifn,afn) vs) ")" rest)
  | "~"::rest =&gt; papply (fn p =&gt; Not p)
                        (parse_atomic_formula (ifn,afn) vs rest)
  | "forall"::x::rest =&gt;
        parse_quant (ifn,afn) (x::vs) (fn (x,p) =&gt; Forall(x,p)) x rest
  | "exists"::x::rest =&gt;
        parse_quant (ifn,afn) (x::vs) (fn (x,p) =&gt; Exists(x,p)) x rest
  | _ =&gt; afn vs inp

and parse_quant (ifn,afn) vs qcon x inp =
   case inp of
     [] =&gt; raise Fail "Body of quantified term expected"
   | y::rest =&gt;
        papply (fn fm =&gt; qcon(x,fm))
               (if y = "." then parse_formula (ifn,afn) vs rest
                else parse_quant (ifn,afn) (y::vs) qcon y rest)

and parse_formula (ifn,afn) vs inp =
   parse_right_infix "&lt;=&gt;" (fn (p,q) =&gt; Iff(p,q))
     (parse_right_infix "==&gt;" (fn (p,q) =&gt; Imp(p,q))
         (parse_right_infix "\\/" (fn (p,q) =&gt; Or(p,q))
             (parse_right_infix "/\\" (fn (p,q) =&gt; And(p,q))
                  (parse_atomic_formula (ifn,afn) vs)))) inp;

(* ------------------------------------------------------------------------- *)
(* Printing of formulas, parametrized by atom printer.                       *)
(* ------------------------------------------------------------------------- *)

fun bracket p n f x y = (
    (if p then print_string "(" else ());
    open_box n; f x y; close_box();
    (if p then print_string ")" else ())
);

fun strip_quant fm =
    case fm of
      Forall (x, (Forall (y, p))) =&gt;
        let val (xs, q) = strip_quant (Forall (y, p)) in
        ((x :: xs), q)
        end
    | Exists (x, (Exists (y, p))) =&gt;
        let val (xs, q) = strip_quant (Exists (y, p)) in
        ((x :: xs), q)
        end
    | Forall (x, p) =&gt;
        ([x],p)
    | Exists (x, p) =&gt;
        ([x],p)
    | _ =&gt;
        ([], fm);

fun print_formula_aux pfn =
    let fun print_formula pr fm =
        case fm of
          Falsity =&gt;
            print_string "false"
        | Truth =&gt;
            print_string "true"
        | Atom pargs =&gt;
            pfn pr pargs
        | Not p =&gt;
            bracket (pr &gt; 10) 1 (print_prefix 10) "~" p
        | And (p, q) =&gt;
            bracket (pr &gt; 8) 0 (print_infix 8 "/\\") p q
        | Or (p, q) =&gt;
            bracket (pr &gt; 6) 0 (print_infix 6 "\\/") p q
        | Imp (p, q) =&gt;
            bracket (pr &gt; 4) 0 (print_infix 4 "==&gt;") p q
        | Iff (p, q) =&gt;
            bracket (pr &gt; 2) 0 (print_infix 2 "&lt;=&gt;") p q
        | Forall (x, p) =&gt;
            bracket (pr &gt; 0) 2 print_qnt "forall" (strip_quant fm)
        | Exists (x, p) =&gt;
            bracket (pr &gt; 0) 2 print_qnt "exists" (strip_quant fm)

    and print_qnt qname (bvs, bod) = (
        print_string qname;
        List.app (fn v =&gt; (print_string " "; print_string v)) bvs;
        print_string "."; print_space(); open_box 0;
        print_formula 0 bod;
        close_box()
    )

    and print_prefix newpr sym p = (
        print_string sym ; print_formula (newpr + 1) p
    )

    and print_infix newpr sym p q = (
        print_formula (newpr + 1) p ;
        print_string (" "^sym); print_space();
        print_formula newpr q
    ) in
    print_formula 0
    end
    ;

fun print_formula pfn fm = (print_formula_aux pfn fm; print_flush ());

fun print_qformula_aux pfn fm = (
  open_box 0; print_string "&lt;!";
  open_box 0; print_formula_aux pfn fm; close_box();
  print_string "!&gt;"; close_box()
);

fun print_qformula pfn fm = (print_qformula_aux pfn fm; print_flush ());

fun mk_and p q = And (p, q)

fun mk_or p q = Or (p, q)

fun mk_imp p q = Imp (p, q)

fun mk_iff p q = Iff (p, q)

fun mk_forall x p = Forall (x, p)

fun mk_exists x p = Exists (x, p)

(* ------------------------------------------------------------------------- *)
(* Destructors.                                                              *)
(* ------------------------------------------------------------------------- *)

fun dest_iff fm =
  case fm of Iff(p,q) =&gt; (p,q) | _ =&gt; raise Fail "dest_iff";

fun dest_and fm =
  case fm of And(p,q) =&gt; (p,q) | _ =&gt; raise Fail "dest_and";

fun conjuncts fm =
  case fm of And(p,q) =&gt; conjuncts p @ conjuncts q | _ =&gt; [fm];

fun dest_or fm =
  case fm of Or(p,q) =&gt; (p,q) | _ =&gt; raise Fail "dest_or";

fun disjuncts fm =
  case fm of Or(p,q) =&gt; disjuncts p @ disjuncts q | _ =&gt; [fm];

fun dest_imp fm =
  case fm of Imp(p,q) =&gt; (p,q) | _ =&gt; raise Fail "dest_imp";

fun antecedent fm = fst (dest_imp fm);
fun consequent fm = snd (dest_imp fm);

(* ------------------------------------------------------------------------- *)
(* Apply a function to the atoms, otherwise keeping structure.               *)
(* ------------------------------------------------------------------------- *)

fun onatoms f fm =
  case fm of
    Atom a =&gt; f a
  | Not(p) =&gt; Not(onatoms f p)
  | And(p,q) =&gt; And(onatoms f p,onatoms f q)
  | Or(p,q) =&gt; Or(onatoms f p,onatoms f q)
  | Imp(p,q) =&gt; Imp(onatoms f p,onatoms f q)
  | Iff(p,q) =&gt; Iff(onatoms f p,onatoms f q)
  | Forall(x,p) =&gt; Forall(x,onatoms f p)
  | Exists(x,p) =&gt; Exists(x,onatoms f p)
  | _ =&gt; fm;

(* ------------------------------------------------------------------------- *)
(* Formula analog of list iterator "itlist".                                 *)
(* ------------------------------------------------------------------------- *)

fun overatoms f fm b =
  case fm of
    Atom(a) =&gt; f a b
  | Not(p) =&gt; overatoms f p b
  | And(p,q) =&gt; overatoms f p (overatoms f q b)
  | Or(p,q)  =&gt; overatoms f p (overatoms f q b)
  | Imp(p,q) =&gt; overatoms f p (overatoms f q b)
  | Iff(p,q) =&gt; overatoms f p (overatoms f q b)
  | Forall(x,p) =&gt; overatoms f p b
  | Exists(x,p) =&gt; overatoms f p b
  | _ =&gt; b;

(* ------------------------------------------------------------------------- *)
(* Special case of a union of the results of a function over the atoms.      *)
(* ------------------------------------------------------------------------- *)

fun atom_union ord f fm = setify ord (overatoms (fn h =&gt; fn t =&gt; f(h)@t) fm []);

fun atom_union_sip f fm = atom_union sip_ord f fm;

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹"prop.sml";

(* ========================================================================= *)
(* Basic stuff for propositional logic: datatype, parsing and printing.      *)
(* ========================================================================= *)

(* ------------------------------------------------------------------------- *)
(* Disjunctive normal form (DNF) via truth tables.                           *)
(* ------------------------------------------------------------------------- *)

fun list_conj l = if l = [] then Truth else end_itlist mk_and l;

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹"fol.sml";

(* ========================================================================= *)
(* Basic stuff for first order logic.                                        *)
(* ========================================================================= *)

(* ------------------------------------------------------------------------- *)
(* Terms.                                                                    *)
(* ------------------------------------------------------------------------- *)

fun t_ord t1 t2 =
    case (t1,t2) of
      (Var x1, Var x2 ) =&gt; str_ord x1 x2
    | (Var _, _) =&gt; 1
    | (_, Var _) =&gt; ~1
    | (Fn(f1,tl1),Fn(f2,tl2)) =&gt;
       case str_ord f1 f2 of
         0 =&gt; tl_ord tl1 tl2
        |n =&gt; n
and tl_ord tl1 tl2 =
    case (tl1,tl2) of
      ([],[]) =&gt; 0
    | ([],_) =&gt; 1
    | (_,[]) =&gt; ~1
    | (t1::tl1',t2::tl2') =&gt;
        case t_ord t1 t2 of
         0 =&gt; tl_ord tl1' tl2'
       | n =&gt; n
;

fun t_hash t =
    case t of
      Var x =&gt; str_hash x
    | Fn (f,tl) =&gt; Word.toIntX(Word.+(Word.*(0wx31,Word.fromInt(str_hash f)),
                                      Word.fromInt(list_hash t_hash tl)))
;

infix 6 |---&gt; (* For terms *)

fun (x |---&gt; y) t = (x |-&gt; y) t t_ord t_hash;

infix 6 |===&gt; (* For terms *)
fun x |===&gt; y = (x |=&gt; y) t_ord t_hash;

fun apply_t f = apply t_ord t_hash f;

(* ------------------------------------------------------------------------- *)
(* Abbreviation for FOL formula.                                             *)
(* ------------------------------------------------------------------------- *)

fun fol_ord (r1 as Rl(s1,tl1)) (r2 as Rl(s2,tl2)) =
    case str_ord s1 s2 of
      0 =&gt; tl_ord tl1 tl2
    | n =&gt; n
;

fun folfm_ord fm1 fm2 = fm_ord fol_ord fm1 fm2;

fun union_folfm s1 s2 = union folfm_ord s1 s2;

fun ftp_ord (fm1,t1) (fm2,t2) =
    case folfm_ord fm1 fm2 of
      0 =&gt; t_ord t1 t2
    | n =&gt; n;

fun setify_ftp s = setify ftp_ord s;

(* ------------------------------------------------------------------------- *)
(* Special case of applying a subfunction to the top *terms*.                *)
(* ------------------------------------------------------------------------- *)

fun onformula f = onatoms(fn (Rl(p,a)) =&gt; Atom(Rl(p,List.map f a)));

(* ------------------------------------------------------------------------- *)
(* Parsing of terms.                                                         *)
(* ------------------------------------------------------------------------- *)

fun is_const_name s = List.all numeric (String.explode s) orelse s = "nil";

fun parse_atomic_term vs inp =
  case inp of
    [] =&gt; raise Fail "term expected"
  | "("::rest =&gt; parse_bracketed (parse_term vs) ")" rest
  | "-"::rest =&gt; papply (fn t =&gt; Fn("-",[t])) (parse_atomic_term vs rest)
  | f::"("::")"::rest =&gt; (Fn(f,[]),rest)
  | f::"("::rest =&gt;
      papply (fn args =&gt; Fn(f,args))
             (parse_bracketed (parse_list "," (parse_term vs)) ")" rest)
  | a::rest =&gt;
      ((if is_const_name a andalso not(mem a vs) then Fn(a,[]) else Var a),rest)

and parse_term vs inp =
  parse_right_infix "::" (fn (e1,e2) =&gt; Fn("::",[e1,e2]))
    (parse_right_infix "+" (fn (e1,e2) =&gt; Fn("+",[e1,e2]))
       (parse_left_infix "-" (fn (e1,e2) =&gt; Fn("-",[e1,e2]))
          (parse_right_infix "*" (fn (e1,e2) =&gt; Fn("*",[e1,e2]))
             (parse_left_infix "/" (fn (e1,e2) =&gt; Fn("/",[e1,e2]))
                (parse_left_infix "^" (fn (e1,e2) =&gt; Fn("^",[e1,e2]))
                   (parse_atomic_term vs)))))) inp;

val parset = make_parser (parse_term []);

(* ------------------------------------------------------------------------- *)
(* Parsing of formulas.                                                      *)
(* ------------------------------------------------------------------------- *)

fun parse_infix_atom vs inp =
  let val (tm,rest) = parse_term vs inp in
  if List.exists (nextin rest) ["=", "&lt;", "&lt;=", "&gt;", "&gt;="] then
        papply (fn tm' =&gt; Atom(Rl(List.hd rest,[tm,tm'])))
               (parse_term vs (List.tl rest))
  else raise Fail ""
  end;

fun parse_atom vs inp =
  (parse_infix_atom vs inp) handle Fail _ =&gt;
  case inp of
    p::"("::")"::rest =&gt; (Atom(Rl(p,[])),rest)
  | p::"("::rest =&gt;
      papply (fn args =&gt; Atom(Rl(p,args)))
             (parse_bracketed (parse_list "," (parse_term vs)) ")" rest)
  | p::rest =&gt;
      if p &lt;&gt; "(" then (Atom(Rl(p,[])),rest)
      else raise Fail "parse_atom"
  | _ =&gt; raise Fail "parse_atom";

val parse = make_parser
  (parse_formula (parse_infix_atom,parse_atom) []);

(* ------------------------------------------------------------------------- *)
(* Set up parsing of quotations.                                             *)
(* ------------------------------------------------------------------------- *)

val default_parser = parse;
datatype default_parser_end = !&gt;;
fun &lt;! s !&gt; = default_parser s;

val secondary_parser = parset;
datatype secondary_parser_end = |!&gt;;
fun &lt;!| s |!&gt; = secondary_parser s;

(* ------------------------------------------------------------------------- *)
(* Printing of terms.                                                        *)
(* ------------------------------------------------------------------------- *)

fun print_term_aux prec fm =
  case fm of
    Var x =&gt; print_string x
  | Fn("^",[tm1,tm2]) =&gt; print_infix_term_aux true prec 24 "^" tm1 tm2
  | Fn("/",[tm1,tm2]) =&gt; print_infix_term_aux true prec 22 " /" tm1 tm2
  | Fn("*",[tm1,tm2]) =&gt; print_infix_term_aux false prec 20 " *" tm1 tm2
  | Fn("-",[tm1,tm2]) =&gt; print_infix_term_aux true prec 18 " -" tm1 tm2
  | Fn("+",[tm1,tm2]) =&gt; print_infix_term_aux false prec 16 " +" tm1 tm2
  | Fn("::",[tm1,tm2]) =&gt; print_infix_term_aux false prec 14 "::" tm1 tm2
  | Fn(f,args) =&gt; print_fargs_aux f args

and print_fargs_aux f args = (
  print_string f;
  if args = [] then () else
   (print_string "(";
    open_box 0;
    print_term_aux 0 (List.hd args); print_break 0 0;
    List.app (fn t =&gt; (print_string ","; print_break 0 0 ; print_term_aux 0 t))
            (List.tl args);
    close_box ();
    print_string ")")
)

and print_infix_term_aux isleft oldprec newprec sym p q = (
  if oldprec &gt; newprec then (print_string "("; open_box 0) else ();
  print_term_aux (if isleft then newprec else newprec+1) p;
  print_string sym;
  print_break (if String.substring (sym, 0, 1) = " " then 1 else 0) 0;
  print_term_aux (if isleft then newprec+1 else newprec) q;
  if oldprec &gt; newprec then (close_box (); print_string ")") else ()
);

fun print_term prec fm = (print_term_aux prec fm; print_flush ())
and print_fargs f args = (print_fargs_aux f args; print_flush ())
and print_infix_term isleft oldprec newprec sym p q = (print_infix_term_aux isleft oldprec newprec sym p q; print_flush ());

fun printert_aux tm = (
  open_box 0; print_string "&lt;!|";
  open_box 0; print_term_aux 0 tm; close_box();
  print_string "|!&gt;"; close_box()
);

fun printert tm = (printert_aux tm; print_flush ());

(* ------------------------------------------------------------------------- *)
(* Printing of formulas.                                                     *)
(* ------------------------------------------------------------------------- *)

fun print_atom_aux prec (Rl (p, args)) =
    if mem p ["=", "&lt;", "&lt;=", "&gt;", "&gt;="] andalso List.length args = 2 then
        print_infix_term_aux false 12 12 (" " ^ p) (List.nth (args, 0)) (List.nth (args, 1))
    else
        print_fargs_aux p args;

fun print_atom prec rpa = (print_atom_aux prec rpa; print_flush ());

val print_fol_formula_aux = print_qformula_aux print_atom_aux;

fun print_fol_formula f = (print_fol_formula_aux f; print_flush ());

(* ------------------------------------------------------------------------- *)
(* Free variables in terms and formulas.                                     *)
(* ------------------------------------------------------------------------- *)

fun fvt tm =
    case tm of
      Var x =&gt; [x]
    | Fn (f, args) =&gt;
        unions_str (List.map fvt args)
;

fun var fm =
    case fm of
      Falsity =&gt; []
    | Truth =&gt; []
    | Atom (Rl (p, args)) =&gt;
        unions str_ord (List.map fvt args)
    | Not p =&gt; var p
    | And (p, q) =&gt; union_str (var p) (var q)
    | Or  (p, q) =&gt; union_str (var p) (var q)
    | Imp (p, q) =&gt; union_str (var p) (var q)
    | Iff (p, q) =&gt; union_str (var p) (var q)
    | Forall (x, p) =&gt; insert_str x (var p)
    | Exists (x, p) =&gt; insert_str x (var p)
;

fun fv fm =
    case fm of
      Falsity =&gt; []
    | Truth =&gt; []
    | Atom (Rl (p, args)) =&gt;
        unions_str (List.map fvt args)
    | Not p =&gt; fv p
    | And (p, q) =&gt; union_str (fv p) (fv q)
    | Or  (p, q) =&gt; union_str (fv p) (fv q)
    | Imp (p, q) =&gt; union_str (fv p) (fv q)
    | Iff (p, q) =&gt; union_str (fv p) (fv q)
    | Forall (x, p) =&gt; subtract_str (fv p) [x]
    | Exists (x, p) =&gt; subtract_str (fv p) [x]
;

(* ------------------------------------------------------------------------- *)
(* Substitution within terms.                                                *)
(* ------------------------------------------------------------------------- *)

fun tsubst sfn tm =
  case tm of
    Var x =&gt; tryapplyd_str sfn x tm
  | Fn(f,args) =&gt; Fn(f,List.map (tsubst sfn) args);

fun variant x vars =
  if mem x vars then variant (x^"'") vars else x;

(* ------------------------------------------------------------------------- *)
(* Substitution in formulas, with variable renaming.                         *)
(* ------------------------------------------------------------------------- *)

fun subst subfn fm =
    case fm of
      Falsity =&gt; Falsity
    | Truth =&gt; Truth
    | Atom (Rl (p, args)) =&gt;
        Atom (Rl (p, List.map (tsubst subfn) args))
    | Not p =&gt;
        Not (subst subfn p)
    | And (p, q) =&gt;
        And (subst subfn p, subst subfn q)
    | Or (p, q) =&gt;
        Or  (subst subfn p, subst subfn q)
    | Imp (p, q) =&gt;
        Imp (subst subfn p, subst subfn q)
    | Iff (p, q) =&gt;
        Iff (subst subfn p, subst subfn q)
    | Forall (x, p) =&gt;
        substq subfn mk_forall x p
    | Exists (x, p) =&gt;
        substq subfn mk_exists x p
and substq subfn quant x p =
    let val x' =
        if List.exists (fn y =&gt; mem x (fvt (tryapplyd_str subfn y (Var y))))
                       (subtract_str (fv p) [x]) then
            variant x (fv (subst (undefine_str x subfn) p))
        else x
    in
    quant x' (subst ((x |--&gt; Var x') subfn) p)
    end
;

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹"skolem.sml";

(* ========================================================================= *)
(* Prenex and Skolem normal forms.                                           *)
(* ========================================================================= *)

(* ------------------------------------------------------------------------- *)
(* Get the functions in a term and formula.                                  *)
(* ------------------------------------------------------------------------- *)

fun funcs tm =
  case tm of
    Var x =&gt; []
  | Fn(f,args) =&gt; itlist (union_sip o funcs) args [(f,List.length args)];

fun functions fm =
  atom_union_sip (fn (Rl(p,a)) =&gt; itlist (union_sip o funcs) a []) fm;

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹"unif.sml";

(* ========================================================================= *)
(* Unification for first order terms.                                        *)
(* ========================================================================= *)

fun istriv env x t =
  case t of
    Var y =&gt; y = x orelse defined_str env y andalso istriv env x (apply_str env y)
  | Fn(f,args) =&gt; List.exists (istriv env x) args andalso raise Fail "cyclic";

(* ------------------------------------------------------------------------- *)
(* Main unification procedure                                                *)
(* ------------------------------------------------------------------------- *)

fun unify env eqs =
  case eqs of
    [] =&gt; env
  | (Fn(f,fargs),Fn(g,gargs))::oth =&gt;
        if f = g andalso length fargs = length gargs
        then unify env (zip fargs gargs @ oth)
        else raise Fail "impossible unification"
  | (Var x,t)::oth =&gt;
        if defined_str env x then unify env ((apply_str env x,t)::oth)
        else unify (if istriv env x t then env else (x|--&gt;t) env) oth
  | (t,Var x)::oth =&gt;
        if defined_str env x then unify env ((apply_str env x,t)::oth)
        else unify (if istriv env x t then env else (x|--&gt;t) env) oth;

(* ------------------------------------------------------------------------- *)
(* Solve to obtain a single instantiation.                                   *)
(* ------------------------------------------------------------------------- *)

fun solve env =
  let val env' = mapf (tsubst env) env in
  if env' = env then env else solve env'
  end;

(* ------------------------------------------------------------------------- *)
(* Unification reaching a final solved form (often this isn't needed).       *)
(* ------------------------------------------------------------------------- *)

fun fullunify eqs = solve (unify undefined eqs);

fun unify_and_apply eqs =
  let val i = fullunify eqs
      fun apply (t1,t2) = (tsubst i t1,tsubst i t2) in
  map apply eqs
  end;

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹"tableaux.sml";

(* ========================================================================= *)
(* Tableaux, seen as an optimized version of a Prawitz-like procedure.       *)
(* ========================================================================= *)

fun deepen f n =
  ((* XXX print_string "Searching with depth limit ";
      print_int n; print_newline(); *) f n
  )
  handle Fail _ =&gt; deepen f (n + 1);

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹"resolution.sml";

(* ========================================================================= *)
(* Resolution.                                                               *)
(* ========================================================================= *)

(* ------------------------------------------------------------------------- *)
(* Matching of terms and literals.                                           *)
(* ------------------------------------------------------------------------- *)

fun term_match env eqs =
    case eqs of
      [] =&gt; env
    | (Fn (f, fa), Fn(g, ga)) :: oth =&gt;
        if (f = g andalso List.length fa = List.length ga) then
        term_match env (zip fa ga @ oth)
        else raise Fail "term_match"
    | (Var x, t) :: oth =&gt;
        if not (defined_str env x) then
            term_match ((x |--&gt; t) env) oth
        else if apply_str env x = t then
            term_match env oth
        else
            raise Fail "term_match"
    | _ =&gt;
        raise Fail "term_match";

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹"equal.sml";

(* ========================================================================= *)
(* First order logic with equality.                                          *)
(* ========================================================================= *)

fun mk_eq s t = Atom(Rl("=",[s,t]));

fun dest_eq fm =
  case fm of
    Atom(Rl("=",[s,t])) =&gt; (s,t)
  | _ =&gt; raise Fail "dest_eq: not an equation";

fun lhs eq = fst (dest_eq eq) and rhs eq = snd (dest_eq eq);

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹"order.sml";

(* ========================================================================= *)
(* Term orderings.                                                           *)
(* ========================================================================= *)

fun termsize tm =
  case tm of
    Var x =&gt; 1
  | Fn(f,args) =&gt; itlist (fn t =&gt; fn n =&gt; termsize t + n) args 1;

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹"eqelim.sml";

(* ========================================================================= *)
(* Equality elimination including Brand transformation and relatives.        *)
(* ========================================================================= *)

(* ------------------------------------------------------------------------- *)
(* Replacement (substitution for non-variable) in term and literal.          *)
(* ------------------------------------------------------------------------- *)

fun replacet rfn tm =
  apply_t rfn tm
  handle Fail _ =&gt;
  case tm of
    Fn(f,args) =&gt; Fn(f,List.map (replacet rfn) args)
  | _ =&gt; tm;

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹"lcf.sml";

fun print_thm_aux th = (
    open_box 0;
    print_string "|-"; print_space();
    open_box 0; print_formula_aux print_atom_aux (concl th); close_box();
    close_box()
)

fun print_thm th = (print_thm_aux th; print_flush ())

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹"lcfprop.sml";

(* ========================================================================= *)
(* Propositional reasoning by derived rules atop the LCF core.               *)
(* ========================================================================= *)

(* ------------------------------------------------------------------------- *)
(* |- p ==&gt; p                                                                *)
(* ------------------------------------------------------------------------- *)

fun imp_refl p =
  modusponens (modusponens (axiom_distribimp p (Imp(p,p)) p)
                           (axiom_addimp p (Imp(p,p))))
              (axiom_addimp p p);

(* ------------------------------------------------------------------------- *)
(*                 |- p ==&gt; p ==&gt; q                                          *)
(*               -------------------- imp_unduplicate                        *)
(*                 |- p ==&gt; q                                                *)
(* ------------------------------------------------------------------------- *)

fun imp_unduplicate th =
  let val (p,pq) = dest_imp(concl th)
      val q = consequent pq in
  modusponens (modusponens (axiom_distribimp p p q) th) (imp_refl p)
  end ;

(* ------------------------------------------------------------------------- *)
(* Some handy syntax operations.                                             *)
(* ------------------------------------------------------------------------- *)

fun negatef fm =
  case fm of
    Imp(p,Falsity) =&gt; p
  | p =&gt; Imp(p,Falsity);

fun negativef fm =
  case fm of
    Imp(p,Falsity) =&gt; true
  | _ =&gt; false;

(* ------------------------------------------------------------------------- *)
(*                           |- q                                            *)
(*         ------------------------------------------------ add_assum (p)    *)
(*                         |- p ==&gt; q                                        *)
(* ------------------------------------------------------------------------- *)

fun add_assum p th = modusponens (axiom_addimp (concl th) p) th;

(* ------------------------------------------------------------------------- *)
(*                   |- q ==&gt; r                                              *)
(*         --------------------------------------- imp_add_assum p           *)
(*           |- (p ==&gt; q) ==&gt; (p ==&gt; r)                                      *)
(* ------------------------------------------------------------------------- *)

fun imp_add_assum p th =
  let val (q,r) = dest_imp(concl th) in
  modusponens (axiom_distribimp p q r) (add_assum p th)
  end;

(* ------------------------------------------------------------------------- *)
(*            |- p ==&gt; q              |- q ==&gt; r                             *)
(*         ----------------------------------------- imp_trans               *)
(*                 |- p ==&gt; r                                                *)
(* ------------------------------------------------------------------------- *)

fun imp_trans th1 th2 =
  let val p = antecedent(concl th1) in
  modusponens (imp_add_assum p th2) th1
  end;

(* ------------------------------------------------------------------------- *)
(*                 |- p ==&gt; r                                                *)
(*         -------------------------- imp_insert q                           *)
(*              |- p ==&gt; q ==&gt; r                                             *)
(* ------------------------------------------------------------------------- *)

fun imp_insert q th =
  let val (p,r) = dest_imp(concl th) in
  imp_trans th (axiom_addimp r q)
  end ;

(* ------------------------------------------------------------------------- *)
(*                 |- p ==&gt; q ==&gt; r                                          *)
(*              ---------------------- imp_swap                              *)
(*                 |- q ==&gt; p ==&gt; r                                          *)
(* ------------------------------------------------------------------------- *)

fun imp_swap th =
  let val (p,qr) = dest_imp(concl th)
      val (q,r) = dest_imp qr in
  imp_trans (axiom_addimp q p)
            (modusponens (axiom_distribimp p q r) th)
  end;

(* ------------------------------------------------------------------------- *)
(* |- (q ==&gt; r) ==&gt; (p ==&gt; q) ==&gt; (p ==&gt; r)                                  *)
(* ------------------------------------------------------------------------- *)

fun imp_trans_th p q r =
   imp_trans (axiom_addimp (Imp(q,r)) p)
             (axiom_distribimp p q r);

(* ------------------------------------------------------------------------- *)
(*                 |- p ==&gt; q                                                *)
(*         ------------------------------- imp_add_concl r                   *)
(*          |- (q ==&gt; r) ==&gt; (p ==&gt; r)                                       *)
(* ------------------------------------------------------------------------- *)

fun imp_add_concl r th =
  let val (p,q) = dest_imp(concl th) in
  modusponens (imp_swap(imp_trans_th p q r)) th
  end;

(* ------------------------------------------------------------------------- *)
(* |- (p ==&gt; q ==&gt; r) ==&gt; (q ==&gt; p ==&gt; r)                                    *)
(* ------------------------------------------------------------------------- *)

fun imp_swap_th p q r =
  imp_trans (axiom_distribimp p q r)
            (imp_add_concl (Imp(p,r)) (axiom_addimp q p));

(* ------------------------------------------------------------------------- *)
(*  |- (p ==&gt; q ==&gt; r) ==&gt; (s ==&gt; t ==&gt; u)                                   *)
(* -----------------------------------------                                 *)
(*  |- (q ==&gt; p ==&gt; r) ==&gt; (t ==&gt; s ==&gt; u)                                   *)
(* ------------------------------------------------------------------------- *)

fun imp_swap2 th =
  case concl th of
    Imp(Imp(p,Imp(q,r)),Imp(s,Imp(t,u))) =&gt;
        imp_trans (imp_swap_th q p r) (imp_trans th (imp_swap_th s t u))
  | _ =&gt; raise Fail "imp_swap2";

(* ------------------------------------------------------------------------- *)
(* If |- p ==&gt; q ==&gt; r and |- p ==&gt; q then |- p ==&gt; r.                       *)
(* ------------------------------------------------------------------------- *)

fun right_mp ith th =
  imp_unduplicate(imp_trans th (imp_swap ith));

(* ------------------------------------------------------------------------- *)
(*                 |- p &lt;=&gt; q                                                *)
(*                ------------ iff_imp1                                      *)
(*                 |- p ==&gt; q                                                *)
(* ------------------------------------------------------------------------- *)

fun iff_imp1 th =
  let val (p,q) = dest_iff(concl th) in
  modusponens (axiom_iffimp1 p q) th
  end;

(* ------------------------------------------------------------------------- *)
(*                 |- p &lt;=&gt; q                                                *)
(*                ------------ iff_imp2                                      *)
(*                 |- q ==&gt; p                                                *)
(* ------------------------------------------------------------------------- *)

fun iff_imp2 th =
  let val (p,q) = dest_iff(concl th) in
  modusponens (axiom_iffimp2 p q) th
  end;

(* ------------------------------------------------------------------------- *)
(*         |- p ==&gt; q      |- q ==&gt; p                                        *)
(*        ---------------------------- imp_antisym                           *)
(*              |- p &lt;=&gt; q                                                   *)
(* ------------------------------------------------------------------------- *)

fun imp_antisym th1 th2 =
  let val (p,q) = dest_imp(concl th1) in
  modusponens (modusponens (axiom_impiff p q) th1) th2
  end;

(* ------------------------------------------------------------------------- *)
(*         |- p ==&gt; (q ==&gt; false) ==&gt; false                                  *)
(*       ----------------------------------- right_doubleneg                 *)
(*               |- p ==&gt; q                                                  *)
(* ------------------------------------------------------------------------- *)

fun right_doubleneg th =
  case concl th of
    Imp(_,Imp(Imp(p,Falsity),Falsity)) =&gt; imp_trans th (axiom_doubleneg p)
  | _ =&gt; raise Fail "right_doubleneg";

(* ------------------------------------------------------------------------- *)
(*                                                                           *)
(*         ------------------------------------------- ex_falso (p)          *)
(*                 |- false ==&gt; p                                            *)
(* ------------------------------------------------------------------------- *)

fun ex_falso p = right_doubleneg(axiom_addimp Falsity (Imp(p,Falsity)));

(* ------------------------------------------------------------------------- *)
(*  |- p ==&gt; q ==&gt; r        |- r ==&gt; s                                       *)
(* ------------------------------------ imp_trans2                           *)
(*      |- p ==&gt; q ==&gt; s                                                     *)
(* ------------------------------------------------------------------------- *)

fun imp_trans2 th1 th2 =
  let val Imp(p,Imp(q,r)) = concl th1
      val Imp(r',s) = concl th2
      val th = imp_add_assum p (modusponens (imp_trans_th q r s) th2) in
  modusponens th th1
  end;

(* ------------------------------------------------------------------------- *)
(*         |- p ==&gt; q1   ...   |- p ==&gt; qn   |- q1 ==&gt; ... ==&gt; qn ==&gt; r      *)
(*        --------------------------------------------------------------     *)
(*                             |- p ==&gt; r                                    *)
(* ------------------------------------------------------------------------- *)

fun imp_trans_chain ths th =
  itlist (fn a =&gt; fn b =&gt; imp_unduplicate (imp_trans a (imp_swap b)))
    (List.rev(List.tl ths)) (imp_trans (List.hd ths) th);

(* ------------------------------------------------------------------------- *)
(* |- (q ==&gt; false) ==&gt; p ==&gt; (p ==&gt; q) ==&gt; false                            *)
(* ------------------------------------------------------------------------- *)

fun imp_truefalse p q =
  imp_trans (imp_trans_th p q Falsity) (imp_swap_th (Imp(p,q)) p Falsity);

(* ------------------------------------------------------------------------- *)
(*  |- (p' ==&gt; p) ==&gt; (q ==&gt; q') ==&gt; (p ==&gt; q) ==&gt; (p' ==&gt; q')               *)
(* ------------------------------------------------------------------------- *)

fun imp_mono_th p p' q q' =
  let val th1 = imp_trans_th (Imp(p,q)) (Imp(p',q)) (Imp(p',q'))
      val th2 = imp_trans_th p' q q'
      val th3 = imp_swap(imp_trans_th p' p q) in
  imp_trans th3 (imp_swap(imp_trans th2 th1))
  end;

(* ------------------------------------------------------------------------- *)
(* |- true                                                                   *)
(* ------------------------------------------------------------------------- *)

val truth = modusponens (iff_imp2 axiom_true) (imp_refl Falsity);

(* ------------------------------------------------------------------------- *)
(*         |- p ==&gt; q                                                        *)
(*      ----------------- contrapos                                          *)
(*         |- ~q ==&gt; ~p                                                      *)
(* ------------------------------------------------------------------------- *)

fun contrapos th =
  let val (p,q) = dest_imp(concl th) in
  imp_trans (imp_trans (iff_imp1(axiom_not q)) (imp_add_concl Falsity th))
            (iff_imp2(axiom_not p))
  end;

(* ------------------------------------------------------------------------- *)
(* |- p /\ q ==&gt; p                                                           *)
(* ------------------------------------------------------------------------- *)

fun and_left p q =
  let val th1 = imp_add_assum p (axiom_addimp Falsity q)
      val th2 = right_doubleneg(imp_add_concl Falsity th1) in
  imp_trans (iff_imp1(axiom_and p q)) th2
  end;

(* ------------------------------------------------------------------------- *)
(* |- p /\ q ==&gt; q                                                           *)
(* ------------------------------------------------------------------------- *)

fun and_right p q =
  let val th1 = axiom_addimp (Imp(q,Falsity)) p
      val th2 = right_doubleneg(imp_add_concl Falsity th1) in
  imp_trans (iff_imp1(axiom_and p q)) th2
  end;

(* ------------------------------------------------------------------------- *)
(* |- p1 /\ ... /\ pn ==&gt; pi for each 1 &lt;= i &lt;= n (input term right assoc)   *)
(* ------------------------------------------------------------------------- *)

fun conjths fm =
  let val (p,q) = dest_and fm in
      (and_left p q)::List.map (imp_trans (and_right p q)) (conjths q)
  end handle Fail _ =&gt; [imp_refl fm];

(* ------------------------------------------------------------------------- *)
(* |- p ==&gt; q ==&gt; p /\ q                                                     *)
(* ------------------------------------------------------------------------- *)

fun and_pair p q =
  let val th1 = iff_imp2(axiom_and p q)
      val th2 = imp_swap_th (Imp(p,Imp(q,Falsity))) q Falsity
      val th3 = imp_add_assum p (imp_trans2 th2 th1) in
  modusponens th3 (imp_swap (imp_refl (Imp(p,Imp(q,Falsity)))))
  end;

(* ------------------------------------------------------------------------- *)
(* If |- p /\ q ==&gt; r then |- p ==&gt; q ==&gt; r                                  *)
(* ------------------------------------------------------------------------- *)

fun shunt th =
  let val (p,q) = dest_and(antecedent(concl th)) in
  modusponens (itlist imp_add_assum [p,q] th) (and_pair p q)
  end;

(* ------------------------------------------------------------------------- *)
(* If |- p ==&gt; q ==&gt; r then |- p /\ q ==&gt; r                                  *)
(* ------------------------------------------------------------------------- *)

fun unshunt th =
  let val (p,qr) = dest_imp(concl th)
      val (q,r) = dest_imp qr in
  imp_trans_chain [and_left p q, and_right p q] th
  end;

(* ------------------------------------------------------------------------- *)
(* Produce |- (p &lt;=&gt; q) &lt;=&gt; (p ==&gt; q) /\ (q ==&gt; p)                           *)
(* ------------------------------------------------------------------------- *)

fun iff_def p q = (* Not in the book *)
  let val th1 = and_pair (Imp(p,q)) (Imp(q,p))
      val th2 = imp_trans_chain [axiom_iffimp1 p q, axiom_iffimp2 p q] th1 in
  imp_antisym th2 (unshunt (axiom_impiff p q))
  end;

fun iff_def p q =
  let val th = and_pair (Imp(p,q)) (Imp(q,p))
      val thl = [axiom_iffimp1 p q, axiom_iffimp2 p q] in
  imp_antisym (imp_trans_chain thl th) (unshunt (axiom_impiff p q))
  end;

(* ------------------------------------------------------------------------- *)
(* Produce "expansion" theorem for defined connectives.                      *)
(* ------------------------------------------------------------------------- *)

fun expand_connective fm =
  case fm of
    Truth =&gt; axiom_true
  | Not p =&gt; axiom_not p
  | And(p,q) =&gt; axiom_and p q
  | Or(p,q) =&gt; axiom_or p q
  | Iff(p,q) =&gt; iff_def p q
  | Exists(x,p) =&gt; axiom_exists x p
  | _ =&gt; raise Fail "expand_connective";

fun eliminate_connective fm =
  if not(negativef fm) then iff_imp1(expand_connective fm)
  else imp_add_concl Falsity (iff_imp2(expand_connective(negatef fm)));

(* ------------------------------------------------------------------------- *)
(*                                                                           *)
(*   ------------------------------------------------- imp_false_conseqs     *)
(*      [|- ((p ==&gt; q) ==&gt; false) ==&gt; (q ==&gt; false);                         *)
(*       |- ((p ==&gt; q) ==&gt; false) ==&gt; p]                                     *)
(* ------------------------------------------------------------------------- *)

fun imp_false_conseqs p q =
 [right_doubleneg(imp_add_concl Falsity (imp_add_assum p (ex_falso q))),
  imp_add_concl Falsity (imp_insert p (imp_refl q))];

(* ------------------------------------------------------------------------- *)
(*         |- p ==&gt; (q ==&gt; false) ==&gt; r                                      *)
(*        ------------------------------------ imp_false_rule                *)
(*             |- ((p ==&gt; q) ==&gt; false) ==&gt; r                                *)
(* ------------------------------------------------------------------------- *)

fun imp_false_rule th =
  let val (p,r) = dest_imp (concl th) in
  imp_trans_chain (imp_false_conseqs p (funpow 2 antecedent r)) th
  end;

(* ------------------------------------------------------------------------- *)
(*         |- (p ==&gt; false) ==&gt; r          |- q ==&gt; r                        *)
(*       ---------------------------------------------- imp_true_rule        *)
(*                      |- (p ==&gt; q) ==&gt; r                                   *)
(* ------------------------------------------------------------------------- *)

fun imp_true_rule th1 th2 =
  let val p = funpow 2 antecedent (concl th1)
      val q = antecedent(concl th2)
      val th3 = right_doubleneg(imp_add_concl Falsity th1)
      val th4 = imp_add_concl Falsity th2
      val th5 = imp_swap(imp_truefalse p q)
      val th6 = imp_add_concl Falsity (imp_trans_chain [th3, th4] th5)
      val th7 = imp_swap(imp_refl(Imp(Imp(p,q),Falsity))) in
  right_doubleneg(imp_trans th7 th6)
  end;

(* ------------------------------------------------------------------------- *)
(*                                 *                                         *)
(*                 -------------------------------------- imp_contr          *)
(*                        |- p ==&gt; -p ==&gt; q                                  *)
(* ------------------------------------------------------------------------- *)

fun imp_contr p q =
  if negativef p then imp_add_assum (negatef p) (ex_falso q)
  else imp_swap (imp_add_assum p (ex_falso q));

(* ------------------------------------------------------------------------- *)
(*                                                                           *)
(* --------------------------------------------- imp_front (this antecedent) *)
(*  |- (p0 ==&gt; p1 ==&gt; ... ==&gt; pn ==&gt; q)                                      *)
(*     ==&gt; pn ==&gt; p0 ==&gt; p1 ==&gt; .. p(n-1) ==&gt; q                              *)
(* ------------------------------------------------------------------------- *)

fun imp_front_th n fm =
  if n = 0 then imp_refl fm else
  let val (p,qr) = dest_imp fm
      val th1 = imp_add_assum p (imp_front_th (n - 1) qr)
      val (q',r') = dest_imp(funpow 2 consequent(concl th1)) in
  imp_trans th1 (imp_swap_th p q' r')
  end;

(* ------------------------------------------------------------------------- *)
(*           |- p0 ==&gt; p1 ==&gt; ... ==&gt; pn ==&gt; q                               *)
(*         ------------------------------------------ imp_front n            *)
(*           |- pn ==&gt; p0 ==&gt; p1 ==&gt; .. p(n-1) ==&gt; q                         *)
(* ------------------------------------------------------------------------- *)

fun imp_front n th = modusponens (imp_front_th n (concl th)) th;

(* ------------------------------------------------------------------------- *)
(* Propositional tableaux procedure.                                         *)
(* ------------------------------------------------------------------------- *)

fun is_false Falsity = true
  | is_false _ = false;

fun is_true (Imp(p,q)) = (p = q)
  | is_true _ = false;

fun is_conj (Imp(Imp(p,q),Falsity)) = true
  | is_conj _ = false

fun dest_conj fm =
    case fm of
      (Imp(Imp(p,q),Falsity)) =&gt; (p,q)
    | _ =&gt; raise Fail "dest_conj"

fun is_disj (Imp(p,q)) = (q &lt;&gt; Falsity)
  | is_disj _ = false

fun dest_disj fm = dest_imp fm;

fun is_prop_lit p =
  case p of
     Atom(_) =&gt; true
   | Forall(_,_) =&gt; true
   | Imp(Atom(_),Falsity) =&gt; true
   | Imp(Forall(_),Falsity) =&gt; true
   | _ =&gt; false ;

fun lcfptab fms lits =
    case fms of
      []     =&gt; raise Fail "lcfptab: no contradiction"
    | fm::fl =&gt;
        if is_false fm then (
            ex_falso (itlist mk_imp (fl @ lits) Falsity)
        ) else if is_true fm then (
            add_assum fm (lcfptab fl lits)
        ) else if is_conj fm then (
            let val (p,q)=dest_conj fm in
            imp_false_rule(lcfptab (p::Imp(q,Falsity)::fl) lits)
            end
        ) else if is_disj fm then (
            let val (p,q)=dest_disj fm in
            imp_true_rule (lcfptab (Imp(p,Falsity)::fl) lits) (lcfptab (q::fl) lits)
            end
        ) else if is_prop_lit fm then (
            if mem (negatef fm) lits then
              let val (l1,l2) = chop_list (index (negatef fm) lits) lits
                  val th = imp_contr fm (itlist mk_imp (List.tl l2) Falsity ) in
              itlist imp_insert (fl @ l1) th
              end
            else imp_front (List.length fl) (lcfptab fl (fm::lits))
        ) else ( (* is nonprimitive *)
           let val th = eliminate_connective fm in
           imp_trans th (lcfptab (consequent(concl th)::fl) lits)
           end
        )
;

(* ------------------------------------------------------------------------- *)
(* In particular, this gives a tautology prover.                             *)
(* ------------------------------------------------------------------------- *)

fun lcftaut p =
  modusponens (axiom_doubleneg p) (lcfptab [negatef p] []);

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹"folderived.sml";

(* ========================================================================= *)
(* First-order derived rules in the LCF setup.                               *)
(* ========================================================================= *)

(* ------------------------------------------------------------------------- *)
(*                         ******                                            *)
(*         ------------------------------------------ eq_sym                 *)
(*                      |- s = t ==&gt; t = s                                   *)
(* ------------------------------------------------------------------------- *)

fun eq_sym s t =
  let val rth = axiom_eqrefl s in
  funpow 2 (fn th =&gt; (modusponens (imp_swap th) rth))
           (axiom_predcong "=" [s, s] [t, s])
  end;

(* ------------------------------------------------------------------------- *)
(* |- s = t ==&gt; t = u ==&gt; s = u.                                             *)
(* ------------------------------------------------------------------------- *)

fun eq_trans s t u =
  let val th1 = axiom_predcong "=" [t, u] [s, u]
      val th2 = modusponens (imp_swap th1) (axiom_eqrefl u) in
  imp_trans (eq_sym s t) th2
  end;

(* ------------------------------------------------------------------------- *)
(*         ---------------------------- icongruence                          *)
(*          |- s = t ==&gt; tm[s] = tm[t]                                       *)
(* ------------------------------------------------------------------------- *)

fun icongruence s t stm ttm =
  if stm = ttm then add_assum (mk_eq s t) (axiom_eqrefl stm)
  else if stm = s andalso ttm = t then imp_refl (mk_eq s t) else
  case (stm,ttm) of
   (Fn(fs,sa),Fn(ft,ta)) =&gt;
        if fs = ft andalso length sa = length ta then
            let val ths = map2 (icongruence s t) sa ta
                val ts = List.map (consequent o concl) ths in
            imp_trans_chain ths (axiom_funcong fs (List.map lhs ts) (List.map rhs ts))
            end
        else raise Fail "icongruence: not congruent"
  | _ =&gt; raise Fail "icongruence: not congruent";

(* ------------------------------------------------------------------------- *)
(* |- (forall x. p ==&gt; q(x)) ==&gt; p ==&gt; (forall x. q(x))                      *)
(* ------------------------------------------------------------------------- *)

fun gen_right_th x p q =
  imp_swap(imp_trans (axiom_impall x p) (imp_swap(axiom_allimp x p q)));

(* ------------------------------------------------------------------------- *)
(*                       |- p ==&gt; q                                          *)
(*         ------------------------------------- genimp "x"                  *)
(*           |- (forall x. p) ==&gt; (forall x. q)                              *)
(* ------------------------------------------------------------------------- *)

fun genimp x th =
  let val (p,q) = dest_imp(concl th) in
  modusponens (axiom_allimp x p q) (gen x th)
  end;

(* ------------------------------------------------------------------------- *)
(* If |- p ==&gt; q[x] then |- p ==&gt; forall x. q[x]                             *)
(* ------------------------------------------------------------------------- *)

fun gen_right x th =
  let val (p,q) = dest_imp(concl th) in
  modusponens (gen_right_th x p q) (gen x th)
  end;

(* ------------------------------------------------------------------------- *)
(* |- (forall x. p(x) ==&gt; q) ==&gt; (exists x. p(x)) ==&gt; q                      *)
(* ------------------------------------------------------------------------- *)

fun exists_left_th x p q =
  let val  p' = Imp(p,Falsity)
      val  q' = Imp(q,Falsity)
      val th1 = genimp x (imp_swap(imp_trans_th p q Falsity))
      val th2 = imp_trans th1 (gen_right_th x q' p')
      val th3 = imp_swap(imp_trans_th q' (Forall(x,p')) Falsity)
      val th4 = imp_trans2 (imp_trans th2 th3) (axiom_doubleneg q)
      val th5 = imp_add_concl Falsity (genimp x (iff_imp2 (axiom_not p)))
      val th6 = imp_trans (iff_imp1 (axiom_not (Forall(x,Not p)))) th5
      val th7 = imp_trans (iff_imp1(axiom_exists x p)) th6 in
  imp_swap(imp_trans th7 (imp_swap th4))
  end;

(* ------------------------------------------------------------------------- *)
(* If |- p(x) ==&gt; q then |- (exists x. p(x)) ==&gt; q                           *)
(* ------------------------------------------------------------------------- *)

fun exists_left x th =
  let val (p,q) = dest_imp(concl th) in
  modusponens (exists_left_th x p q) (gen x th)
  end;

(* ------------------------------------------------------------------------- *)
(*    |- x = t ==&gt; p ==&gt; q    [x not in t and not free in q]                 *)
(*  --------------------------------------------------------------- subspec  *)
(*                 |- (forall x. p) ==&gt; q                                    *)
(* ------------------------------------------------------------------------- *)

fun subspec th =
  case concl th of
    Imp(e as Atom(Rl("=",[Var x,t])),Imp(p,q)) =&gt;
        let val th1 = imp_trans (genimp x (imp_swap th))
                            (exists_left_th x e q) in
        modusponens (imp_swap th1) (axiom_existseq x t)
        end
  | _ =&gt; raise Fail "subspec: wrong sort of theorem";

(* ------------------------------------------------------------------------- *)
(*    |- x = y ==&gt; p[x] ==&gt; q[y]  [x not in FV(q); y not in FV(p) or x == y] *)
(*  --------------------------------------------------------- subalpha       *)
(*                 |- (forall x. p) ==&gt; (forall y. q)                        *)
(* ------------------------------------------------------------------------- *)

fun subalpha th =
   case concl th of
    Imp(Atom(Rl("=",[Var x,Var y])),Imp(p,q)) =&gt;
        if x = y then genimp x (modusponens th (axiom_eqrefl(Var x)))
        else gen_right y (subspec th)
  | _ =&gt; raise Fail "subalpha: wrong sort of theorem";

(* ------------------------------------------------------------------------- *)
(*         ---------------------------------- isubst                         *)
(*            |- s = t ==&gt; p[s] ==&gt; p[t]                                     *)
(* ------------------------------------------------------------------------- *)

fun isubst s t sfm tfm =
  if sfm = tfm then add_assum (mk_eq s t) (imp_refl tfm) else
  case (sfm,tfm) of
    (Atom(Rl(p,sa)),Atom(Rl(p',ta))) =&gt;
        if p = p' andalso List.length sa = List.length ta then
            let val ths = map2 (icongruence s t) sa ta
                val (ls,rs) = unzip (List.map (dest_eq o consequent o concl) ths) in
            imp_trans_chain ths (axiom_predcong p ls rs)
            end
        else
            raise Fail "isubst"
  | (Imp(sp,sq),Imp(tp,tq)) =&gt;
        let val th1 = imp_trans (eq_sym s t) (isubst t s tp sp)
            val th2 = isubst s t sq tq in
        imp_trans_chain [th1, th2] (imp_mono_th sp tp sq tq)
        end
  | (Forall(x,p),Forall(y,q)) =&gt;
        if x = y then
          imp_trans (gen_right x (isubst s t p q)) (axiom_allimp x p q)
        else
          let val z = Var(variant x (unions_str [fv p, fv q, fvt s, fvt t]))
              val th1 = isubst (Var x) z p (subst (x |==&gt; z) p)
              val th2 = isubst z (Var y) (subst (y |==&gt; z) q) q
              val th3 = subalpha th1
              val th4 = subalpha th2
              val th5 = isubst s t (consequent(concl th3))
                               (antecedent(concl th4)) in
          imp_swap (imp_trans2 (imp_trans th3 (imp_swap th5)) th4)
          end
  | _ =&gt;
        let val sth = iff_imp1(expand_connective sfm)
            val tth = iff_imp2(expand_connective tfm)
            val th1 = isubst s t (consequent(concl sth))
                             (antecedent(concl tth)) in
        imp_swap(imp_trans sth (imp_swap(imp_trans2 th1 tth)))
        end;

(* ------------------------------------------------------------------------- *)
(*                                                                           *)
(* -------------------------------------------- alpha "z" &lt;!forall x. p[x]!&gt; *)
(*   |- (forall x. p[x]) ==&gt; (forall z. p'[z])                               *)
(*                                                                           *)
(* [Restriction that z is not free in the initial p[x].]                     *)
(* ------------------------------------------------------------------------- *)

fun alpha z fm =
  case fm of
    Forall(x,p) =&gt; let val p' = subst (x |==&gt; Var z) p in
                   subalpha(isubst (Var x) (Var z) p p')
                   end
  | _ =&gt; raise Fail "alpha: not a universal formula";

(* ------------------------------------------------------------------------- *)
(*                                                                           *)
(* -------------------------------- ispec t &lt;!forall x. p[x]!&gt;               *)
(*   |- (forall x. p[x]) ==&gt; p'[t]                                           *)
(* ------------------------------------------------------------------------- *)

fun ispec t fm =
  case fm of
    Forall(x,p) =&gt;
      if mem x (fvt t) then
        let val th = alpha (variant x (union_str (fvt t) (var p))) fm in
        imp_trans th (ispec t (consequent(concl th)))
        end
      else subspec(isubst (Var x) t p (subst (x |==&gt; t) p))
  | _ =&gt; raise Fail "ispec: non-universal formula";

(* ------------------------------------------------------------------------- *)
(* Specialization rule.                                                      *)
(* ------------------------------------------------------------------------- *)

fun spec t th = modusponens (ispec t (concl th)) th;

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹"lcffol.sml";

(* ========================================================================= *)
(* First order tableau procedure using LCF setup.                            *)
(* ========================================================================= *)

(* ------------------------------------------------------------------------- *)
(* Unification of complementary literals.                                    *)
(* ------------------------------------------------------------------------- *)

fun unify_complementsf env =
  fn (Atom(Rl(p1,a1)),Imp(Atom(Rl(p2,a2)),Falsity)) =&gt; unify env [(Fn(p1,a1),Fn(p2,a2))]
   | (Imp(Atom(Rl(p1,a1)),Falsity),Atom(Rl(p2,a2))) =&gt; unify env [(Fn(p1,a1),Fn(p2,a2))]
   | _ =&gt; raise Fail "unify_complementsf";

(* ------------------------------------------------------------------------- *)
(*    |- (q ==&gt; f) ==&gt; ... ==&gt; (q ==&gt; p) ==&gt; r                               *)
(* --------------------------------------------- use_laterimp &lt;!q ==&gt; p!&gt;    *)
(*    |- (p ==&gt; f) ==&gt; ... ==&gt; (q ==&gt; p) ==&gt; r                               *)
(* ------------------------------------------------------------------------- *)

fun use_laterimp i fm =
  case fm of
    Imp(_,Imp(i',_)) =&gt;
      ( case (fm,i'=i) of
          (Imp(Imp(q',s),Imp(i' as Imp(q,p),r)),true) =&gt;
             let val th1 = axiom_distribimp i (Imp(Imp(q,s),r)) (Imp(Imp(p,s),r))
                 val th2 = imp_swap(imp_trans_th q p s)
                 val th3 = imp_swap(imp_trans_th (Imp(p,s)) (Imp(q,s)) r) in
             imp_swap2(modusponens th1 (imp_trans th2 th3))
             end
        | (Imp(qs,Imp(a,b)),_) =&gt;
             imp_swap2(imp_add_assum a (use_laterimp i (Imp(qs,b))))
      )
;

(* ------------------------------------------------------------------------- *)
(* The "closure" inference rules.                                            *)
(* ------------------------------------------------------------------------- *)

fun imp_false_rule' th es = imp_false_rule(th es);

fun imp_true_rule' th1 th2 es = imp_true_rule (th1 es) (th2 es);

fun imp_front' n thp es = imp_front n (thp es);

fun add_assum' fm thp (es as(e,s)) =
  add_assum (onformula e fm) (thp es);

fun eliminate_connective' fm thp (es as(e,s)) =
  imp_trans (eliminate_connective (onformula e fm)) (thp es);

fun spec' y fm n thp (e,s) =
  let val th = imp_swap(imp_front n (thp(e,s))) in
  imp_unduplicate(imp_trans (ispec (e y) (onformula e fm)) th)
  end;

fun ex_falso' fms (e,s) =
  ex_falso (itlist (mk_imp o onformula e) fms s);

fun complits' (p::fl,lits) i (e,s) =
  let val (l1,p'::l2) = chop_list i lits in
  itlist (imp_insert o onformula e) (fl @ l1)
         (imp_contr (onformula e p)
                    (itlist (mk_imp o onformula e) l2 s))
  end;

fun deskol' (skh:fol fm) thp (e,s) =
  let val th = thp (e,s) in
  modusponens (use_laterimp (onformula e skh) (concl th)) th
  end;

(* ------------------------------------------------------------------------- *)
(* Main refutation function.                                                 *)
(* ------------------------------------------------------------------------- *)

fun is_lit (Atom(_)) = true
  | is_lit (Imp(Atom(_),Falsity)) = true
  | is_lit _ = false;

fun is_uni (Forall(_,_)) = true
  | is_uni _ = false;

fun dest_uni (Forall(x,p)) = (x,p);

fun is_exi (Imp(Forall(_,_),Falsity)) = true
  | is_exi _ = false;

fun dest_exi (Imp(yp as Forall(y,p),Falsity)) = (y,p,yp);

fun lcftab skofun (fms,lits,n) cont (esk as (env,sks,k)) =
    if n &lt; 0 then raise Fail "lcftab: no proof" else
    case fms of
      []     =&gt; raise Fail "lcftab: No contradiction"
    | fm::fl =&gt;
        if is_false fm then (
            cont (ex_falso' (fl @ lits)) esk
        ) else if is_true fm then (
            lcftab skofun (fl,lits,n) (cont o add_assum' fm) esk
        ) else if is_conj fm then (
            let val (p,q)=dest_conj fm in
            lcftab skofun (p::Imp(q,Falsity)::fl,lits,n) (cont o imp_false_rule') esk
            end
        ) else if is_disj fm then (
            let val (p,q)=dest_disj fm in
            lcftab skofun (Imp(p,Falsity)::fl,lits,n) (fn th =&gt; lcftab skofun (q::fl,lits,n)
                                                                (cont o imp_true_rule' th)) esk
            end
        ) else if is_lit fm then (
            (tryfind (fn p' =&gt; (
                let val env' = unify_complementsf env (fm, p') in
                cont (complits' (fms, lits) (index p' lits)) (env', sks, k)
                end)) lits)
            handle Fail _ =&gt; (
                lcftab skofun (fl,fm::lits,n) (cont o imp_front' (List.length fl)) esk
            )
        ) else if is_uni fm then (
            let val (x,p) = dest_uni fm
                val y = Var("X_"^(Int.toString k)) in
            lcftab skofun ((subst (x |==&gt; y) p)::fl@[fm],lits,n-1)
                    (cont o spec' y fm (List.length fms)) (env,sks,k+1)
            end
        ) else if is_exi fm then (
            let val (y,p,yp) = dest_exi fm
                val fx = skofun yp
                val p' = subst(y |==&gt; fx) p
                val skh = Imp(p',Forall(y,p))
                val sks' = (Forall(y,p),fx)::sks in
            lcftab skofun (Imp(p',Falsity)::fl,lits,n) (cont o deskol' skh) (env,sks',k)
            end
        ) else ( (* is nonprimitive *)
           let val fm' = consequent(concl(eliminate_connective fm)) in
           lcftab skofun (fm'::fl,lits,n) (cont o eliminate_connective' fm) esk
           end
        )
;

(* ------------------------------------------------------------------------- *)
(* Identify quantified subformulas; true = exists, false = forall. This is   *)
(* taking into account the effective parity.                                 *)
(* ------------------------------------------------------------------------- *)

fun quantforms e fm =
  case fm of
    Not(p) =&gt; quantforms (not e) p
  | And(p,q) =&gt; union_folfm (quantforms e p) (quantforms e q)
  | Or(p,q)  =&gt; union_folfm (quantforms e p) (quantforms e q)
  | Imp(p,q) =&gt; quantforms e (Or(Not p,q))
  | Iff(p,q) =&gt; quantforms e (Or(And(p,q),And(Not p,Not q)))
  | Exists(x,p) =&gt; if e then fm::(quantforms e p) else quantforms e p
  | Forall(x,p) =&gt; if e then quantforms e p else fm::(quantforms e p)
  | _ =&gt; [];

(* ------------------------------------------------------------------------- *)
(* Now create some Skolem functions.                                         *)
(* ------------------------------------------------------------------------- *)

fun skolemfuns fm =
  let val fns = List.map (fn pr =&gt; fst pr) (functions fm)
      val skts = List.map (fn Exists(x,p) =&gt; Forall(x,Not p) | p =&gt; p)
                 (quantforms true fm)
      fun skofun i (ap as Forall(y,p)) =
            let val vars = List.map (fn v =&gt; Var v) (fv ap) in
            (ap,Fn(variant("f"^"_"^Int.toString i) fns,vars))
            end
  in
  map2 skofun (1--length skts) skts
  end;

(* ------------------------------------------------------------------------- *)
(* Matching.                                                                 *)
(* ------------------------------------------------------------------------- *)

fun form_match (fp as (f1,f2)) env =
  case fp of
    (Falsity,Falsity) =&gt; env
  | (Truth,Truth)     =&gt; env
  | (Atom(Rl(p,pa)),Atom(Rl(q,qa))) =&gt; term_match env [(Fn(p,pa),Fn(q,qa))]
  | (Not(p1),Not(p2)) =&gt; form_match (p1,p2) env
  | (And(p1,q1),And(p2,q2)) =&gt; form_match (p1,p2) (form_match (q1,q2) env)
  | (Or(p1,q1),Or(p2,q2))   =&gt; form_match (p1,p2) (form_match (q1,q2) env)
  | (Imp(p1,q1),Imp(p2,q2)) =&gt; form_match (p1,p2) (form_match (q1,q2) env)
  | (Iff(p1,q1),Iff(p2,q2)) =&gt; form_match (p1,p2) (form_match (q1,q2) env)
  | (Forall(x1,p1),Forall(x2,p2)) =&gt;
        if (x1=x2) then
          let val z = variant x1 (union_str (fv p1) (fv p2))
              val inst_fn = subst (x1 |==&gt; Var z) in
          undefine_str z (form_match (inst_fn p1,inst_fn p2) env)
          end
        else
          raise Fail "form_match"
  | (Exists(x1,p1),Exists(x2,p2)) =&gt;
        if (x1=x2) then
          let val z = variant x1 (union_str (fv p1) (fv p2))
              val inst_fn = subst (x1 |==&gt; Var z) in
          undefine_str z (form_match (inst_fn p1,inst_fn p2) env)
          end
        else
          raise Fail "form_match"
  | _ =&gt; raise Fail "form_match";

(* ------------------------------------------------------------------------- *)
(* With the current approach to picking Skolem functions.                    *)
(* ------------------------------------------------------------------------- *)

fun lcfrefute fm n cont =
  let val sl = skolemfuns fm
      fun find_skolem fm =
           tryfind(fn (f,t) =&gt; tsubst(form_match (f,fm) undefined) t) sl
  in
  lcftab find_skolem ([fm],[],n) cont (undefined,[],0)
  end;

fun mk_skol (Forall(y,p),fx) q =
  Imp(Imp(subst (y |==&gt; fx) p,Forall(y,p)),q);

fun simpcont thp (env,sks,k) =
  let val ifn = tsubst(solve env) in
  thp(ifn,onformula ifn (itlist mk_skol sks Falsity))
  end;

(* ------------------------------------------------------------------------- *)
(*         |- (p(v) ==&gt; forall x. p(x)) ==&gt; q                                *)
(*       -------------------------------------- elim_skolemvar               *)
(*                   |- q                                                    *)
(* ------------------------------------------------------------------------- *)

fun elim_skolemvar th =
  case concl th of
    Imp(Imp(pv,(apx as Forall(x,px))),q) =&gt;
        let val [th1,th2] = List.map (imp_trans(imp_add_concl Falsity th))
                            (imp_false_conseqs pv apx)
            val v = hd(subtract_str (fv pv) (fv apx) @ [x])
            val th3 = gen_right v th1
            val th4 = imp_trans th3 (alpha x (consequent(concl th3))) in
        modusponens (axiom_doubleneg q) (right_mp th2 th4)
        end
  | _ =&gt; raise Fail "elim_skolemvar";

(* ------------------------------------------------------------------------- *)
(* Top continuation with careful sorting and variable replacement.           *)
(* Also need to delete post-instantiation duplicates! This shows up more     *)
(* often now that we have adequate sharing.                                  *)
(* ------------------------------------------------------------------------- *)

fun deskolcont thp (env,sks,k) =
  let val ifn = tsubst(solve env)
      val isk = setify_ftp(List.map (fn (p,t) =&gt; (onformula ifn p,ifn t)) sks)
      val ssk = sort (decreasing (termsize o snd)) isk
      val vs  = List.map (fn i =&gt; Var("Y_"^Int.toString i)) (1--List.length ssk)
      val vfn = replacet(itlist2 (fn (p,t) =&gt; fn v =&gt; t |---&gt; v) ssk vs undefined)
      val th  = thp(vfn o ifn,onformula vfn (itlist mk_skol ssk Falsity)) in
  repeat (elim_skolemvar o imp_swap) th
  end;

(* ------------------------------------------------------------------------- *)
(* Overall first-order prover.                                               *)
(* ------------------------------------------------------------------------- *)

fun lcffol fm =
  let val fvs = fv fm
      val fm' = Imp(itlist mk_forall fvs fm,Falsity)
      val th1 = deepen (fn n =&gt; lcfrefute fm' n deskolcont) 0
      val th2 = modusponens (axiom_doubleneg (negatef fm')) th1 in
  itlist (fn v =&gt; spec(Var v)) (rev fvs) th2
  end;

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹"tactics.sml";

(* ========================================================================= *)
(* Goals, LCF-like tactics and Mizar-like proofs.                            *)
(* ========================================================================= *)

datatype goals =
  Goals of ((string * fol fm) list * fol fm)list *
           (thm list -&gt; thm);

(* ------------------------------------------------------------------------- *)
(* Printer for goals (just shows first goal plus total number).              *)
(* ------------------------------------------------------------------------- *)

val print_goal_aux =
    let fun print_hyp (l, fm) = (
        open_hbox();
        print_string (l^":");
        print_space ();
        print_formula_aux print_atom_aux fm;
        print_newline();
        close_box()
    ) in
    fn (Goals (gls, jfn)) =&gt;
        case gls of
          [] =&gt;
            print_string "No subgoals"
        | (asl, w) :: ogls =&gt;(
            print_newline ();
            if ogls = [] then
                print_string "1 subgoal:"
            else (
                print_int (List.length gls);
                print_string " subgoals starting with"
            )
            ;
            print_newline();
            List.app print_hyp (List.rev asl);
            print_string "---&gt; ";
            open_hvbox 0; print_formula_aux print_atom_aux w; close_box();
            print_newline ()
          )
    end;

fun print_goal g = (print_goal_aux g; print_flush ());

(* ------------------------------------------------------------------------- *)
(* Setting up goals and terminating them in a theorem.                       *)
(* ------------------------------------------------------------------------- *)

fun set_goal p =
  let fun chk th = if concl th = p then th else raise Fail "wrong theorem" in
  Goals([([],p)],fn [th] =&gt; chk(modusponens th truth))
  end;

fun extract_thm gls =
  case gls of
    Goals([],jfn) =&gt; jfn []
  | _ =&gt; raise Fail "extract_thm: unsolved goals";

fun tac_proof g prf = extract_thm(itlist (fn f =&gt; f) (List.rev prf) g);

fun prove p prf = tac_proof (set_goal p) prf;

(* ------------------------------------------------------------------------- *)
(* Conjunction introduction tactic.                                          *)
(* ------------------------------------------------------------------------- *)

fun conj_intro_tac (Goals((asl,And(p,q))::gls,jfn)) =
  let fun jfn' (thp::thq::ths) =
    jfn(imp_trans_chain [thp, thq] (and_pair p q)::ths) in
  Goals((asl,p)::(asl,q)::gls,jfn')
  end;

(* ------------------------------------------------------------------------- *)
(* Handy idiom for tactic that does not split subgoals.                      *)
(* ------------------------------------------------------------------------- *)

fun jmodify jfn tfn (th::oths) = jfn(tfn th :: oths);

(* ------------------------------------------------------------------------- *)
(* Version of gen_right with a bound variable change.                        *)
(* ------------------------------------------------------------------------- *)

fun gen_right_alpha y x th =
  let val th1 = gen_right y th in
  imp_trans th1 (alpha x (consequent(concl th1)))
  end;

(* ------------------------------------------------------------------------- *)
(* Universal introduction.                                                   *)
(* ------------------------------------------------------------------------- *)

fun forall_intro_tac y (Goals((asl,(fm as Forall(x,p)))::gls,jfn)) =
  if mem y (fv fm) orelse List.exists (mem y o fv o snd) asl
  then raise Fail "fix: variable already free in goal" else
  Goals((asl,subst(x |==&gt; Var y) p)::gls,
        jmodify jfn (gen_right_alpha y x));

(* ------------------------------------------------------------------------- *)
(* Another inference rule: |- P[t] ==&gt; exists x. P[x]                        *)
(* ------------------------------------------------------------------------- *)

fun right_exists x t p =
  let val th = contrapos(ispec t (Forall(x,Not p)))
      val Not(Not p') = antecedent(concl th) in
  end_itlist imp_trans
   [imp_contr p' Falsity, imp_add_concl Falsity (iff_imp1 (axiom_not p')),
    iff_imp2(axiom_not (Not p')), th, iff_imp2(axiom_exists x p)]
  end;

(* ------------------------------------------------------------------------- *)
(* Existential introduction.                                                 *)
(* ------------------------------------------------------------------------- *)

fun exists_intro_tac t (Goals((asl,Exists(x,p))::gls,jfn)) =
  Goals((asl,subst(x |==&gt; t) p)::gls,
        jmodify jfn (fn th =&gt; imp_trans th (right_exists x t p))) ;

(* ------------------------------------------------------------------------- *)
(* Implication introduction tactic.                                          *)
(* ------------------------------------------------------------------------- *)

fun imp_intro_tac s (Goals((asl,Imp(p,q))::gls,jfn)) =
  let val jmod = if asl = [] then add_assum Truth else imp_swap o shunt in
  Goals(((s,p)::asl,q)::gls,jmodify jfn jmod)
  end;

(* ------------------------------------------------------------------------- *)
(* Append contextual hypothesis to unconditional theorem.                    *)
(* ------------------------------------------------------------------------- *)

fun assumptate (Goals((asl,w)::gls,jfn)) th =
  add_assum (list_conj (map snd asl)) th;

(* ------------------------------------------------------------------------- *)
(* Get the first assumption (quicker than head of assumps result).           *)
(* ------------------------------------------------------------------------- *)

fun firstassum asl =
  let val p = snd(hd asl)
      val q = list_conj(List.map snd (List.tl asl)) in
  if tl asl = [] then imp_refl p else and_left p q
  end;

(* ------------------------------------------------------------------------- *)
(* Import "external" theorem.                                                *)
(* ------------------------------------------------------------------------- *)

fun using ths p g =
  let val ths' = map (fn th =&gt; itlist gen (fv(concl th)) th) ths in
  List.map (assumptate g) ths'
  end;

(* ------------------------------------------------------------------------- *)
(* Turn assumptions p1,...,pn into theorems |- p1 /\ ... /\ pn ==&gt; pi        *)
(* ------------------------------------------------------------------------- *)

fun assumps asl =
  case asl of
    [] =&gt; []
  | [(l,p)] =&gt; [(l,imp_refl p)]
  | (l,p)::lps =&gt;
        let val ths = assumps lps
            val q = antecedent(concl(snd(List.hd ths)))
            val rth = and_right p q in
        (l,and_left p q)::List.map (fn (l,th) =&gt; (l,imp_trans rth th)) ths
        end;

(* ------------------------------------------------------------------------- *)
(* Produce canonical theorem from list of theorems or assumption labels.     *)
(* ------------------------------------------------------------------------- *)

fun by hyps p (Goals((asl,w)::gls,jfn)) =
  let val ths = assumps asl in
  List.map (fn s =&gt; assoc s ths) hyps
  end;

(* ------------------------------------------------------------------------- *)
(* Main automatic justification step.                                        *)
(* ------------------------------------------------------------------------- *)

local
  fun singleton [_] = true
    | singleton _ = false
in
  fun justify byfn hyps p g =
    let val ths = byfn hyps p g in
    if singleton ths andalso consequent(concl (List.hd ths)) = p then (
      List.hd ths
    ) else (
      let val th = lcffol(itlist (mk_imp o consequent o concl) ths p) in
      case ths of
        [] =&gt; assumptate g th
      | _  =&gt; imp_trans_chain ths th
      end
    )
    end
end;

(* ------------------------------------------------------------------------- *)
(* Nested subproof.                                                          *)
(* ------------------------------------------------------------------------- *)

fun proof tacs p (Goals((asl,w)::gls,jfn)) =
  [tac_proof (Goals([(asl,p)],fn [th] =&gt; th)) tacs];

(* ------------------------------------------------------------------------- *)
(* Trivial justification, producing no hypotheses.                           *)
(* ------------------------------------------------------------------------- *)

fun at once p gl = [];
val once = [];

(* ------------------------------------------------------------------------- *)
(* Hence an automated terminal tactic.                                       *)
(* ------------------------------------------------------------------------- *)

fun auto_tac byfn hyps (g as Goals((asl,w)::gls,jfn)) =
  let val th = justify byfn hyps w g in
  Goals(gls,fn ths =&gt; jfn(th::ths))
  end;

(* ------------------------------------------------------------------------- *)
(* A "lemma" tactic.                                                         *)
(* ------------------------------------------------------------------------- *)

fun lemma_tac s p byfn hyps (g as Goals((asl,w)::gls,jfn)) =
  let val tr = imp_trans(justify byfn hyps p g)
      val mfn = if asl = [] then tr else imp_unduplicate o tr o shunt in
  Goals(((s,p)::asl,w)::gls,jmodify jfn mfn)
  end;

(* ------------------------------------------------------------------------- *)
(* Elimination tactic for existential quantification.                        *)
(* ------------------------------------------------------------------------- *)

fun exists_elim_tac l fm byfn hyps (g as Goals((asl,w)::gls,jfn)) =
  let val Exists(x,p) = fm in
  if List.exists (mem x o fv) (w::List.map snd asl)
  then raise Fail "exists_elim_tac: variable free in assumptions" else
  let val th = justify byfn hyps (Exists(x,p)) g
      fun jfn' pth = imp_unduplicate(imp_trans th (exists_left x (shunt pth)))
  in
  Goals(((l,p)::asl,w)::gls,jmodify jfn jfn')
  end end;

(* ------------------------------------------------------------------------- *)
(* If |- p ==&gt; r and |- q ==&gt; r then |- p \/ q ==&gt; r                         *)
(* ------------------------------------------------------------------------- *)

fun ante_disj th1 th2 =
  let val (p,r) = dest_imp(concl th1)
      val (q,s) = dest_imp(concl th2)
      val ths = map contrapos [th1, th2]
      val th3 = imp_trans_chain ths (and_pair (Not p) (Not q))
      val th4 = contrapos(imp_trans (iff_imp2(axiom_not r)) th3)
      val th5 = imp_trans (iff_imp1(axiom_or p q)) th4 in
  right_doubleneg(imp_trans th5 (iff_imp1(axiom_not(Imp(r,Falsity)))))
  end;

(* ------------------------------------------------------------------------- *)
(* Elimination tactic for disjunction.                                       *)
(* ------------------------------------------------------------------------- *)

fun disj_elim_tac l fm byfn hyps (g as Goals((asl,w)::gls,jfn) ) =
  let val th = justify byfn hyps fm g
      val Or(p,q) = fm
      fun jfn' (pth::qth::ths) =
         let val th1 = imp_trans th (ante_disj (shunt pth) (shunt qth)) in
         jfn(imp_unduplicate th1::ths)
         end
  in
  Goals(((l,p)::asl,w)::((l,q)::asl,w)::gls,jfn')
  end;

(* ------------------------------------------------------------------------- *)
(* Declarative proof.                                                        *)
(* ------------------------------------------------------------------------- *)

fun multishunt i th =
  let val th1 = imp_swap(funpow i (imp_swap o shunt) th) in
  imp_swap(funpow (i-1) (unshunt o imp_front 2) th1)
  end;

fun assume lps (Goals((asl,Imp(p,q))::gls,jfn)) =
  if end_itlist mk_and (map snd lps) &lt;&gt; p then raise Fail "assume" else
  let fun jfn' th =
    if asl = [] then add_assum Truth th else multishunt (length lps) th in
  Goals((lps@asl,q)::gls,jmodify jfn jfn')
  end;

fun note (l,p) = lemma_tac l p;

fun have p = note("",p);

fun so tac arg byfn =
  tac arg (fn hyps =&gt; fn p =&gt; fn (gl as Goals((asl,w)::_,_)) =&gt;
                     firstassum asl :: byfn hyps p gl);

val fix = forall_intro_tac;

fun consider (x,p) = exists_elim_tac "" (Exists(x,p));

fun take tm gls = exists_intro_tac tm gls;

fun cases fm byfn hyps g = disj_elim_tac "" fm byfn hyps g;

(* ------------------------------------------------------------------------- *)
(* Thesis modification.                                                      *)
(* ------------------------------------------------------------------------- *)

fun conclude p byfn hyps (gl as Goals((asl,w)::gls,jfn)) =
  let val th = justify byfn hyps p gl in
  if p = w then Goals((asl,Truth)::gls,jmodify jfn (fn _ =&gt; th)) else
  let val (p',q) = dest_and w in
  if p' &lt;&gt; p then raise Fail "conclude: bad conclusion" else
  let fun mfn th' = imp_trans_chain [th, th'] (and_pair p q) in
  Goals((asl,q)::gls,jmodify jfn mfn)
  end end end;

(* ------------------------------------------------------------------------- *)
(* A useful shorthand for solving the whole goal.                            *)
(* ------------------------------------------------------------------------- *)

fun our thesis byfn hyps (gl as Goals((asl,w)::gls,jfn)) =
  conclude w byfn hyps gl;
val thesis = "";

(* ------------------------------------------------------------------------- *)
(* Termination.                                                              *)
(* ------------------------------------------------------------------------- *)

fun qed (gl as Goals((asl,w)::gls,jfn)) =
  if w = Truth then Goals(gls,fn ths =&gt; jfn(assumptate gl truth :: ths))
  else raise Fail "qed: non-trivial goal";

(* ------------------------------------------------------------------------- *)
(* A simple example.                                                         *)
(* ------------------------------------------------------------------------- *)

val ewd954 = prove
 (&lt;!("(forall x y. x &lt;= y &lt;=&gt; x * y = x) /\\ " ^
   "(forall x y. f(x * y) = f(x) * f(y)) " ^
   "==&gt; forall x y. x &lt;= y ==&gt; f(x) &lt;= f(y)")!&gt;)
 [note("eq_sym",&lt;!"forall x y. x = y ==&gt; y = x"!&gt;)
    using [eq_sym (&lt;!|"x"|!&gt;) (&lt;!|"y"|!&gt;)],
  note("eq_trans",&lt;!"forall x y z. x = y /\\ y = z ==&gt; x = z"!&gt;)
    using [eq_trans (&lt;!|"x"|!&gt;) (&lt;!|"y"|!&gt;) (&lt;!|"z"|!&gt;)],
  note("eq_cong",&lt;!"forall x y. x = y ==&gt; f(x) = f(y)"!&gt;)
    using [axiom_funcong "f" [(&lt;!|"x"|!&gt;)] [(&lt;!|"y"|!&gt;)]],
  assume [("le",&lt;!"forall x y. x &lt;= y &lt;=&gt; x * y = x"!&gt;),
          ("hom",&lt;!"forall x y. f(x * y) = f(x) * f(y)"!&gt;)],
  fix "x", fix "y",
  assume [("xy",&lt;!"x &lt;= y"!&gt;)],
  so have (&lt;!"x * y = x"!&gt;) by ["le"],
  so have (&lt;!"f(x * y) = f(x)"!&gt;) by ["eq_cong"],
  so have (&lt;!"f(x) = f(x * y)"!&gt;) by ["eq_sym"],
  so have (&lt;!"f(x) = f(x) * f(y)"!&gt;) by ["eq_trans", "hom"],
  so have (&lt;!"f(x) * f(y) = f(x)"!&gt;) by ["eq_sym"],
  so conclude (&lt;!"f(x) &lt;= f(y)"!&gt;) by ["le"],
  qed];

(* ------------------------------------------------------------------------- *)
(* More examples not in the main text.                                       *)
(* ------------------------------------------------------------------------- *)

prove
 (&lt;!("(exists x. p(x)) ==&gt; (forall x. p(x) ==&gt; p(f(x))) " ^
   "==&gt; exists y. p(f(f(f(f(y)))))")!&gt;)
  [assume [("A",&lt;!"exists x. p(x)"!&gt;)],
   assume [("B",&lt;!"forall x. p(x) ==&gt; p(f(x))"!&gt;)],
   note ("C",&lt;!"forall x. p(x) ==&gt; p(f(f(f(f(x)))))"!&gt;)
   proof
    [have (&lt;!"forall x. p(x) ==&gt; p(f(f(x)))"!&gt;) by ["B"],
     so conclude (&lt;!"forall x. p(x) ==&gt; p(f(f(f(f(x)))))"!&gt;) at once,
     qed],
   consider ("a",&lt;!"p(a)"!&gt;) by ["A"],
   take (&lt;!|"a"|!&gt;),
   so conclude (&lt;!"p(f(f(f(f(a)))))"!&gt;) by ["C"],
   qed];

(* ------------------------------------------------------------------------- *)
(* Alternative formulation with lemma construct.                             *)
(* ------------------------------------------------------------------------- *)

let fun lemma (s,p) (gl as Goals((asl,w)::gls,jfn)) =
  Goals((asl,p)::((s,p)::asl,w)::gls,
        fn (thp::thw::oths) =&gt;
            jfn(imp_unduplicate(imp_trans thp (shunt thw)) :: oths)) in
prove
 (&lt;!("(exists x. p(x)) ==&gt; (forall x. p(x) ==&gt; p(f(x))) " ^
   "==&gt; exists y. p(f(f(f(f(y)))))")!&gt;)
  [assume [("A",&lt;!"exists x. p(x)"!&gt;)],
   assume [("B",&lt;!"forall x. p(x) ==&gt; p(f(x))"!&gt;)],
   lemma ("C",&lt;!"forall x. p(x) ==&gt; p(f(f(f(f(x)))))"!&gt;),
     have (&lt;!"forall x. p(x) ==&gt; p(f(f(x)))"!&gt;) by ["B"],
     so conclude (&lt;!"forall x. p(x) ==&gt; p(f(f(f(f(x)))))"!&gt;) at once,
     qed,
   consider ("a",&lt;!"p(a)"!&gt;) by ["A"],
   take (&lt;!|"a"|!&gt;),
   so conclude (&lt;!"p(f(f(f(f(a)))))"!&gt;) by ["C"],
   qed]
end;

(* ------------------------------------------------------------------------- *)
(* Examples.                                                                 *)
(* ------------------------------------------------------------------------- *)

prove (&lt;!("p(a) ==&gt; (forall x. p(x) ==&gt; p(f(x))) " ^
        "==&gt; exists y. p(y) /\\ p(f(y))")!&gt;)
      [our thesis at once,
       qed];

prove
 (&lt;!("(exists x. p(x)) ==&gt; (forall x. p(x) ==&gt; p(f(x))) " ^
   "==&gt; exists y. p(f(f(f(f(y)))))")!&gt;)
  [assume [("A",&lt;!"exists x. p(x)"!&gt;)],
   assume [("B",&lt;!"forall x. p(x) ==&gt; p(f(x))"!&gt;)],
   note ("C",&lt;!"forall x. p(x) ==&gt; p(f(f(f(f(x)))))"!&gt;) proof
    [have (&lt;!"forall x. p(x) ==&gt; p(f(f(x)))"!&gt;) by ["B"],
     so our thesis at once,
     qed],
   consider ("a",&lt;!"p(a)"!&gt;) by ["A"],
   take (&lt;!|"a"|!&gt;),
   so our thesis by ["C"],
   qed];

prove (&lt;!("forall a. p(a) ==&gt; (forall x. p(x) ==&gt; p(f(x))) " ^
                  "==&gt; exists y. p(y) /\\ p(f(y))")!&gt;)
      [fix "c",
       assume [("A",&lt;!"p(c)"!&gt;)],
       assume [("B",&lt;!"forall x. p(x) ==&gt; p(f(x))"!&gt;)],
       take (&lt;!|"c"|!&gt;),
       conclude (&lt;!"p(c)"!&gt;) by ["A"],
       note ("C",&lt;!"p(c) ==&gt; p(f(c))"!&gt;) by ["B"],
       so our thesis by ["C", "A"],
       qed];

prove (&lt;!("p(c) ==&gt; (forall x. p(x) ==&gt; p(f(x))) " ^
                  "==&gt; exists y. p(y) /\\ p(f(y))")!&gt;)
      [assume [("A",&lt;!"p(c)"!&gt;)],
       assume [("B",&lt;!"forall x. p(x) ==&gt; p(f(x))"!&gt;)],
       take (&lt;!|"c"|!&gt;),
       conclude (&lt;!"p(c)"!&gt;) by ["A"],
       our thesis by ["A", "B"],
       qed];

prove (&lt;!("forall a. p(a) ==&gt; (forall x. p(x) ==&gt; p(f(x))) " ^
                  "==&gt; exists y. p(y) /\\ p(f(y))")!&gt;)
      [fix "c",
       assume [("A",&lt;!"p(c)"!&gt;)],
       assume [("B",&lt;!"forall x. p(x) ==&gt; p(f(x))"!&gt;)],
       take (&lt;!|"c"|!&gt;),
       conclude (&lt;!"p(c)"!&gt;) by ["A"],
       note ("C",&lt;!"p(c) ==&gt; p(f(c))"!&gt;) by ["B"],
       our thesis by ["C", "A"],
       qed];

prove (&lt;!("forall a. p(a) ==&gt; (forall x. p(x) ==&gt; p(f(x))) " ^
                  "==&gt; exists y. p(y) /\\ p(f(y))")!&gt;)
      [fix "c",
       assume [("A",&lt;!"p(c)"!&gt;)],
       assume [("B",&lt;!"forall x. p(x) ==&gt; p(f(x))"!&gt;)],
       take (&lt;!|"c"|!&gt;),
       note ("D",&lt;!"p(c)"!&gt;) by ["A"],
       note ("C",&lt;!"p(c) ==&gt; p(f(c))"!&gt;) by ["B"],
       our thesis by ["C", "A", "D"],
       qed];

prove (&lt;!"(p(a) \\/ p(b)) ==&gt; q ==&gt; exists y. p(y)"!&gt;)
  [assume [("A",&lt;!"p(a) \\/ p(b)"!&gt;)],
   assume [("",&lt;!"q"!&gt;)],
   cases (&lt;!"p(a) \\/ p(b)"!&gt;) by ["A"],
     take (&lt;!|"a"|!&gt;),
     so our thesis at once,
     qed,

     take (&lt;!|"b"|!&gt;),
     so our thesis at once,
     qed];

prove
  (&lt;!"(p(a) \\/ p(b)) /\\ (forall x. p(x) ==&gt; p(f(x))) ==&gt; exists y. p(f(y))"!&gt;)
  [assume [("base",&lt;!"p(a) \\/ p(b)"!&gt;),
           ("Step",&lt;!"forall x. p(x) ==&gt; p(f(x))"!&gt;)],
   cases (&lt;!"p(a) \\/ p(b)"!&gt;) by ["base"],
     so note("A",&lt;!"p(a)"!&gt;) at once,
     note ("X",&lt;!"p(a) ==&gt; p(f(a))"!&gt;) by ["Step"],
     take (&lt;!|"a"|!&gt;),
     our thesis by ["A", "X"],
     qed,

     take (&lt;!|"b"|!&gt;),
     so our thesis by ["Step"],
     qed];

prove
 (&lt;!"(exists x. p(x)) ==&gt; (forall x. p(x) ==&gt; p(f(x))) ==&gt; exists y. p(f(y))"!&gt;)
  [assume [("A",&lt;!"exists x. p(x)"!&gt;)],
   assume [("B",&lt;!"forall x. p(x) ==&gt; p(f(x))"!&gt;)],
   consider ("a",&lt;!"p(a)"!&gt;) by ["A"],
   so note ("concl",&lt;!"p(f(a))"!&gt;) by ["B"],
   take (&lt;!|"a"|!&gt;),
   our thesis by ["concl"],
   qed];

prove (&lt;!("(forall x. p(x) ==&gt; q(x)) ==&gt; (forall x. q(x) ==&gt; p(x)) " ^
       "==&gt; (p(a) &lt;=&gt; q(a))")!&gt;)
  [assume [("A",&lt;!"forall x. p(x) ==&gt; q(x)"!&gt;)],
   assume [("B",&lt;!"forall x. q(x) ==&gt; p(x)"!&gt;)],
   note ("von",&lt;!"p(a) ==&gt; q(a)"!&gt;) by ["A"],
   note ("bis",&lt;!"q(a) ==&gt; p(a)"!&gt;) by ["B"],
   our thesis by ["von", "bis"],
   qed];

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Main Examples›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Hoare's Exercise ewd1062_1 &amp; ewd1062_2 (Harrison has only a proof with tactics) *)

prove
  (&lt;!("(forall x. x &lt;= x) /\\ " ^
      "(forall x y z. x &lt;= y /\\ y &lt;= z ==&gt; x &lt;= z) /\\ " ^
      "(forall x y. f(x) &lt;= y &lt;=&gt; x &lt;= g(y)) " ^
      "==&gt; (forall x y. x &lt;= y ==&gt; f(x) &lt;= f(y)) /\\ " ^
          "(forall x y. x &lt;= y ==&gt; g(x) &lt;= g(y))")!&gt;)
  [
    assume [("A", &lt;!("(forall x. x &lt;= x) /\\ " ^
             "(forall x y z. x &lt;= y /\\ y &lt;= z ==&gt; x &lt;= z) /\\ " ^
             "(forall x y. f(x) &lt;= y &lt;=&gt; x &lt;= g(y))")!&gt;)],
    conclude (&lt;!("(forall x y. x &lt;= y ==&gt; f(x) &lt;= f(y)) /\\ " ^
                 "(forall x y. x &lt;= y ==&gt; g(x) &lt;= g(y))")!&gt;) proof
    [
      conclude (&lt;!"(forall x y. x &lt;= y ==&gt; f(x) &lt;= f(y))"!&gt;) by ["A"],
      conclude (&lt;!"(forall x y. x &lt;= y ==&gt; g(x) &lt;= g(y))"!&gt;) by ["A"],
      qed
    ],
    qed
  ]

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p43 (Harrison has it in a comment but the proof seems not to finish) *)

prove
  (&lt;!"(forall x y. Q(x,y) &lt;=&gt; forall z. P(z,x) &lt;=&gt; P(z,y)) ==&gt; forall x y. Q(x,y) &lt;=&gt; Q(y,x)"!&gt;)
  [
    assume [("A", &lt;!"forall x y. Q(x,y) &lt;=&gt; forall z. P(z,x) &lt;=&gt; P(z,y)"!&gt;)],
    conclude (&lt;!"forall x y. Q(x,y) &lt;=&gt; Q(y,x)"!&gt;) proof
    [
      fix "x", fix "y",
      conclude (&lt;!"Q(x,y) &lt;=&gt; Q(y,x)"!&gt;) proof
      [
        have (&lt;!"(Q(x,y) ==&gt; Q(y,x)) /\\ (Q(y,x) ==&gt; Q(x,y))"!&gt;) proof
        [
          conclude (&lt;!"Q(x,y) ==&gt; Q(y,x)"!&gt;) proof
          [
            assume [("", &lt;!"Q(x,y)"!&gt;)],
            so have (&lt;!"forall z. P(z,x) &lt;=&gt; P(z,y)"!&gt;) by ["A"],
            so have (&lt;!"forall z. P(z,y) &lt;=&gt; P(z,x)"!&gt;) at once,
            so conclude (&lt;!"Q(y,x)"!&gt;) by ["A"],
            qed
          ],
          conclude (&lt;!"Q(y,x) ==&gt; Q(x,y)"!&gt;) proof
          [
            assume [("", &lt;!"Q(y,x)"!&gt;)],
            so have (&lt;!"forall z. P(z,y) &lt;=&gt; P(z,x)"!&gt;) by ["A"],
            so have (&lt;!"forall z. P(z,x) &lt;=&gt; P(z,y)"!&gt;) at once,
            so conclude (&lt;!"Q(x,y)"!&gt;) by ["A"],
            qed
          ],
          qed
        ],
        so our thesis at once,
        qed
      ],
      qed
    ],
    qed
  ]

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p46 (Harrison does not have it) *)

  prove
    (&lt;!("(forall x. P(x) /\\ (forall y. P(y) /\\ H(y,x) ==&gt; G(y)) ==&gt; G(x)) /\\ " ^
          "((exists x. P(x) /\\ ~G(x)) ==&gt; " ^
            "(exists x. P(x) /\\ ~G(x) /\\ (forall y. P(y) /\\ ~G(y) ==&gt; J(x,y)))) /\\ " ^
          "(forall x y. P(x) /\\ P(y) /\\ H(x,y) ==&gt; ~J(y,x)) ==&gt; " ^
          "(forall x. P(x) ==&gt; G(x))")!&gt;)
    [
      assume [("A", &lt;!("(forall x. P(x) /\\ (forall y. P(y) /\\ H(y,x) ==&gt; G(y)) ==&gt; G(x)) /\\ " ^
          "((exists x. P(x) /\\ ~G(x)) ==&gt; " ^
            "(exists x. P(x) /\\ ~G(x) /\\ (forall y. P(y) /\\ ~G(y) ==&gt; J(x,y)))) /\\ " ^
          "(forall x y. P(x) /\\ P(y) /\\ H(x,y) ==&gt; ~J(y,x))")!&gt;)],
      conclude (&lt;!"(forall x. P(x) ==&gt; G(x))"!&gt;) proof
      [
        fix "x",
        conclude (&lt;!"P(x) ==&gt; G(x)"!&gt;) proof
        [
          assume [("B", &lt;!"P(x)"!&gt;)],
          conclude (&lt;!"G(x)"!&gt;) by ["B","A"], qed
        ], qed
      ], qed
    ]

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Other Examples›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* For Pelletier's Problem 34 aka Andrews's Challenge *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹

fun by_mp (ab, a) p (Goals((asl,_)::_,_)) =
  let
    val ths = assumps asl
    val th = right_mp (assoc ab ths) (assoc a ths)
    handle Fail _ =&gt; raise Fail "by_mp: unapplicable assumptions"
  in
  if consequent (concl th) = p then [th] else raise Fail "by_mp: wrong conclusion"
  end
  | by_mp _ _ _ = raise Fail "Match by_mp"
;

›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Function auto as a basic declarative proof *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fun auto s = prove (&lt;!s!&gt;) [our thesis at once, qed]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹auto "A ==&gt; A"›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹auto "exists x. D(x) ==&gt; forall x. D(x)"›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹auto "(forall x. ~R(x) ==&gt; R(f(x))) ==&gt; exists x. R(x) /\\ R(f(f(x)))"›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Harrison p58 (as mentioned in the errata it is not Pelletier p58) *)

auto "forall x. exists v w. forall y z. P(x) /\\ Q(y) ==&gt; (P(v) \\/ R(w)) /\\ (R(z) ==&gt; Q(v))"

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p1 *)

auto "p ==&gt; q &lt;=&gt; ~q ==&gt; ~p"

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p2 *)

auto "~ ~p &lt;=&gt; p"

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p3 *)

auto "~(p ==&gt; q) ==&gt; q ==&gt; p"

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p4 *)

auto "~p ==&gt; q &lt;=&gt; ~q ==&gt; p"

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p5 *)

auto "(p \\/ q ==&gt; p \\/ r) ==&gt; p \\/ (q ==&gt; r)"

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p6 *)

auto "p \\/ ~p"

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p7 *)

auto "p \\/ ~ ~ ~p"

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p8 *)

auto "((p ==&gt; q) ==&gt; p) ==&gt; p"

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p9 *)

auto "(p \\/ q) /\\ (~p \\/ q) /\\ (p \\/ ~q) ==&gt; ~(~q \\/ ~q)"

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p10 *)

auto "(q ==&gt; r) /\\ (r ==&gt; p /\\ q) /\\ (p ==&gt; q /\\ r) ==&gt; (p &lt;=&gt; q)"

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p11 *)

auto "p &lt;=&gt; p"

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p12 *)

auto "((p &lt;=&gt; q) &lt;=&gt; r) &lt;=&gt; (p &lt;=&gt; (q &lt;=&gt; r))"

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p13 *)

auto "p \\/ q /\\ r &lt;=&gt; (p \\/ q) /\\ (p \\/ r)"

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p14 *)

auto "(p &lt;=&gt; q) &lt;=&gt; (q \\/ ~p) /\\ (~q \\/ p)"

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p15 *)

auto "p ==&gt; q &lt;=&gt; ~p \\/ q"

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p16 *)

auto "(p ==&gt; q) \\/ (q ==&gt; p)"

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p17 *)

auto "p /\\ (q ==&gt; r) ==&gt; s &lt;=&gt; (~p \\/ q \\/ s) /\\ (~p \\/ ~r \\/ s)"

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p18 *)

auto "exists y. forall x. P(y) ==&gt; P(x)"

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p19 *)

auto "exists x. forall y z. (P(y) ==&gt; Q(z)) ==&gt; P(x) ==&gt; Q(x)"

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p20 *)

auto ("(forall x y. exists z. forall w. P(x) /\\ Q(y) ==&gt; R(z) /\\ U(w)) " ^
      "==&gt; (exists x y. P(x) /\\ Q(y)) ==&gt; (exists z. R(z))")

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p21 *)

auto "(exists x. P ==&gt; Q(x)) /\\ (exists x. Q(x) ==&gt; P) ==&gt; (exists x. P &lt;=&gt; Q(x))"

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p22 *)

auto "(forall x. P &lt;=&gt; Q(x)) ==&gt; (P &lt;=&gt; (forall x. Q(x)))"

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p23 *)

auto "(forall x. P \\/ Q(x)) &lt;=&gt; P \\/ (forall x. Q(x))"

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p24 *)

auto ("~(exists x. U(x) /\\ Q(x)) /\\ " ^
      "(forall x. P(x) ==&gt; Q(x) \\/ R(x)) /\\ " ^
      "~(exists x. P(x) ==&gt; (exists x. Q(x))) /\\ " ^
      "(forall x. Q(x) /\\ R(x) ==&gt; U(x)) " ^
      "==&gt; (exists x. P(x) /\\ R(x))")

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p25 *)

auto ("(exists x. P(x)) /\\ " ^
      "(forall x. U(x) ==&gt; ~G(x) /\\ R(x)) /\\ " ^
      "(forall x. P(x) ==&gt; G(x) /\\ U(x)) /\\ " ^
      "((forall x. P(x) ==&gt; Q(x)) \\/ (exists x. Q(x) /\\ P(x))) " ^
      "==&gt; (exists x. Q(x) /\\ P(x))")

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p26 *)

auto ("((exists x. P(x)) &lt;=&gt; (exists x. Q(x))) /\\ " ^
      "(forall x y. P(x) /\\ Q(y) ==&gt; (R(x) &lt;=&gt; U(y))) " ^
      "==&gt; ((forall x. P(x) ==&gt; R(x)) &lt;=&gt; (forall x. Q(x) ==&gt; U(x)))")

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p27 *)

auto ("(exists x. P(x) /\\ ~Q(x)) /\\ " ^
      "(forall x. P(x) ==&gt; R(x)) /\\ " ^
      "(forall x. U(x) /\\ V(x) ==&gt; P(x)) /\\ " ^
      "(exists x. R(x) /\\ ~Q(x)) " ^
      "==&gt; (forall x. V(x) ==&gt; ~R(x)) ==&gt; (forall x. U(x) ==&gt; ~V(x))")

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p28 *)

auto ("(forall x. P(x) ==&gt; (forall x. Q(x))) /\\ " ^
      "((forall x. Q(x) \\/ R(x)) ==&gt; (exists x. Q(x) /\\ R(x))) /\\ " ^
      "((exists x. R(x)) ==&gt; (forall x. L(x) ==&gt; M(x))) " ^
      "==&gt; (forall x. P(x) /\\ L(x) ==&gt; M(x))")

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p29 *)

auto ("(exists x. P(x)) /\\ (exists x. G(x)) ==&gt; " ^
      "((forall x. P(x) ==&gt; H(x)) /\\ (forall x. G(x) ==&gt; J(x)) " ^
      "&lt;=&gt; (forall x y. P(x) /\\ G(y) ==&gt; H(x) /\\ J(y)))")

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p30 *)

auto ("(forall x. P(x) \\/ G(x) ==&gt; ~H(x)) /\\ " ^
      "(forall x. (G(x) ==&gt; ~U(x)) ==&gt; P(x) /\\ H(x)) " ^
      "==&gt; (forall x. U(x))")

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p31 *)

auto ("~(exists x. P(x) /\\ (G(x) \\/ H(x))) /\\ " ^
      "(exists x. Q(x) /\\ P(x)) /\\ " ^
      "(forall x. ~H(x) ==&gt; J(x)) " ^
      "==&gt; (exists x. Q(x) /\\ J(x))")

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p32 *)

auto ("(forall x. P(x) /\\ (G(x) \\/ H(x)) ==&gt; Q(x)) /\\ " ^
      "(forall x. Q(x) /\\ H(x) ==&gt; J(x)) /\\ " ^
      "(forall x. R(x) ==&gt; H(x)) " ^
      "==&gt; (forall x. P(x) /\\ R(x) ==&gt; J(x))")

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p33 *)

auto ("(forall x. P(a) /\\ (P(x) ==&gt; P(b)) ==&gt; P(c)) " ^
      "&lt;=&gt; (forall x. P(a) ==&gt; P(x) \\/ P(c)) /\\ (P(a) ==&gt; P(b) ==&gt; P(c))")

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p34 *)

prove
(&lt;!("((exists x. forall y. P(x) &lt;=&gt; P(y)) &lt;=&gt; ((exists x. Q(x)) &lt;=&gt; (forall y. Q(y)))) &lt;=&gt;"
^   "((exists x. forall y. Q(x) &lt;=&gt; Q(y)) &lt;=&gt; ((exists x. P(x)) &lt;=&gt; (forall y. P(y))))")!&gt;)
[

  note ("directions",
  &lt;!("(((exists x. forall y. P(x) &lt;=&gt; P(y)) &lt;=&gt; ((exists x. Q(x)) &lt;=&gt; (forall y. Q(y)))) ==&gt;"
^    "((exists x. forall y. Q(x) &lt;=&gt; Q(y)) &lt;=&gt; ((exists x. P(x)) &lt;=&gt; (forall y. P(y))))) /\\"
^    "(((exists x. forall y. Q(x) &lt;=&gt; Q(y)) &lt;=&gt; ((exists x. P(x)) &lt;=&gt; (forall y. P(y)))) ==&gt;"
^    "((exists x. forall y. P(x) &lt;=&gt; P(y)) &lt;=&gt; ((exists x. Q(x)) &lt;=&gt; (forall y. Q(y)))))")!&gt;)
  proof
  [
    conclude
    (&lt;!("((exists x. forall y. P(x) &lt;=&gt; P(y)) &lt;=&gt; ((exists x. Q(x)) &lt;=&gt; (forall y. Q(y)))) ==&gt;"
^       "((exists x. forall y. Q(x) &lt;=&gt; Q(y)) &lt;=&gt; ((exists x. P(x)) &lt;=&gt; (forall y. P(y))))")!&gt;)
    proof
    [
      assume [("A",
      &lt;!"(exists x. forall y. P(x) &lt;=&gt; P(y)) &lt;=&gt; ((exists x. Q(x)) &lt;=&gt; (forall y. Q(y)))"!&gt;)],

      note ("ant",
      &lt;!("((exists x. forall y. Q(x) &lt;=&gt; Q(y)) ==&gt; ((exists x. P(x)) &lt;=&gt; (forall y. P(y)))) /\\"
^        "(((exists x. P(x)) &lt;=&gt; (forall y. P(y))) ==&gt; ((exists x. forall y. Q(x) &lt;=&gt; Q(y))))")!&gt;)
      proof
      [

        conclude
        (&lt;!"(exists x. forall y. Q(x) &lt;=&gt; Q(y)) ==&gt; ((exists x. P(x)) &lt;=&gt; (forall y. P(y)))"!&gt;)
        proof
        [
          assume [("", &lt;!"exists x. forall y. Q(x) &lt;=&gt; Q(y)"!&gt;)],
          so have (&lt;!"(exists x. Q(x)) &lt;=&gt; (forall y. Q(y))"!&gt;) at once,
          so have (&lt;!"exists x. forall y. P(x) &lt;=&gt; P(y)"!&gt;) by ["A"],
          so our thesis at once,
          qed
        ],

        conclude
        (&lt;!"((exists x. P(x)) &lt;=&gt; (forall y. P(y))) ==&gt; (exists x. forall y. Q(x) &lt;=&gt; Q(y))"!&gt;)
        proof
        [
          note ("imp",
          &lt;!("((exists x. forall y. P(x) &lt;=&gt; P(y)) &lt;=&gt; ((exists x. Q(x)) &lt;=&gt; (forall y. Q(y)))) ==&gt;"
^            "((exists x. forall y. P(x) &lt;=&gt; P(y)) ==&gt; ((exists x. Q(x)) &lt;=&gt; (forall y. Q(y))))")!&gt;)
          using [axiom_iffimp1
            (&lt;!"exists x. forall y. P(x) &lt;=&gt; P(y)"!&gt;)
            (&lt;!"(exists x. Q(x)) &lt;=&gt; (forall y. Q(y))"!&gt;)],
          note ("A1",
           &lt;!"(exists x. forall y. P(x) &lt;=&gt; P(y)) ==&gt; ((exists x. Q(x)) &lt;=&gt; (forall y. Q(y)))"!&gt;)
          by_mp ("imp", "A"),

          assume [("", &lt;!"((exists x. P(x)) &lt;=&gt; (forall y. P(y)))"!&gt;)],
          so have (&lt;!"(exists x. forall y. P(x) &lt;=&gt; P(y))"!&gt;) at once,
          so have (&lt;!"((exists x. Q(x)) &lt;=&gt; (forall y. Q(y)))"!&gt;) by ["A1"],
          so our thesis at once,
          qed
        ],
        qed
      ],

      note ("imp",
      &lt;!("((exists x. forall y. Q(x) &lt;=&gt; Q(y)) ==&gt; ((exists x. P(x)) &lt;=&gt; (forall y. P(y)))) /\\"
^        "(((exists x. P(x)) &lt;=&gt; (forall y. P(y))) ==&gt; ((exists x. forall y. Q(x) &lt;=&gt; Q(y)))) ==&gt;"
^        "((exists x. forall y. Q(x) &lt;=&gt; Q(y)) &lt;=&gt; ((exists x. P(x)) &lt;=&gt; (forall y. P(y))))")!&gt;)
      using [unshunt (axiom_impiff
        (&lt;!"exists x. forall y. Q(x) &lt;=&gt; Q(y)"!&gt;)
        (&lt;!"(exists x. P(x)) &lt;=&gt; (forall y. P(y))"!&gt;))],

      our thesis by_mp ("imp", "ant"),
      qed
    ],

    conclude
    (&lt;!("((exists x. forall y. Q(x) &lt;=&gt; Q(y)) &lt;=&gt; ((exists x. P(x)) &lt;=&gt; (forall y. P(y)))) ==&gt;"
^       "((exists x. forall y. P(x) &lt;=&gt; P(y)) &lt;=&gt; ((exists x. Q(x)) &lt;=&gt; (forall y. Q(y))))")!&gt;)
    proof
    [
      assume [("A",
       &lt;!"(exists x. forall y. Q(x) &lt;=&gt; Q(y)) &lt;=&gt; ((exists x. P(x)) &lt;=&gt; (forall y. P(y)))"!&gt;)],

      note ("ant",
      &lt;!("((exists x. forall y. P(x) &lt;=&gt; P(y)) ==&gt; ((exists x. Q(x)) &lt;=&gt; (forall y. Q(y)))) /\\"
^        "(((exists x. Q(x)) &lt;=&gt; (forall y. Q(y))) ==&gt; (exists x. forall y. P(x) &lt;=&gt; P(y)))")!&gt;)
      proof
      [

        conclude
        (&lt;!"(exists x. forall y. P(x) &lt;=&gt; P(y)) ==&gt; ((exists x. Q(x)) &lt;=&gt; (forall y. Q(y)))"!&gt;)
        proof
        [
          assume [("", &lt;!"exists x. forall y. P(x) &lt;=&gt; P(y)"!&gt;)],
          so have (&lt;!"(exists x. P(x)) &lt;=&gt; (forall y. P(y))"!&gt;) at once,
          so have (&lt;!"exists x. forall y. Q(x) &lt;=&gt; Q(y)"!&gt;) by ["A"],
          so our thesis at once,
          qed
        ],

        conclude
        (&lt;!"((exists x. Q(x)) &lt;=&gt; (forall y. Q(y))) ==&gt; (exists x. forall y. P(x) &lt;=&gt; P(y))"!&gt;)
        proof
        [
          note ("imp",
          &lt;!("((exists x. forall y. Q(x) &lt;=&gt; Q(y)) &lt;=&gt; ((exists x. P(x)) &lt;=&gt; (forall y. P(y)))) ==&gt;"
^            "((exists x. forall y. Q(x) &lt;=&gt; Q(y)) ==&gt; ((exists x. P(x)) &lt;=&gt; (forall y. P(y))))")!&gt;)
          using [axiom_iffimp1
            (&lt;!"exists x. forall y. Q(x) &lt;=&gt; Q(y)"!&gt;)
            (&lt;!"(exists x. P(x)) &lt;=&gt; (forall y. P(y))"!&gt;)],
          note ("A1",
          &lt;!"(exists x. forall y. Q(x) &lt;=&gt; Q(y)) ==&gt; ((exists x. P(x)) &lt;=&gt; (forall y. P(y)))"!&gt;)
          by_mp ("imp", "A"),

          assume [("", &lt;!"(exists x. Q(x)) &lt;=&gt; (forall y. Q(y))"!&gt;)],
          so have (&lt;!"(exists x. forall y. Q(x) &lt;=&gt; Q(y))"!&gt;) at once,
          so have (&lt;!"((exists x. P(x)) &lt;=&gt; (forall y. P(y)))"!&gt;) by ["A1"],
          so our thesis at once,
          qed
        ],
        qed
      ],

      note ("imp",
      &lt;!("((exists x. forall y. P(x) &lt;=&gt; P(y)) ==&gt; ((exists x. Q(x)) &lt;=&gt; (forall y. Q(y)))) /\\"
^        "(((exists x. Q(x)) &lt;=&gt; (forall y. Q(y))) ==&gt; (exists x. forall y. P(x) &lt;=&gt; P(y))) ==&gt;"
^        "((exists x. forall y. P(x) &lt;=&gt; P(y)) &lt;=&gt; ((exists x. Q(x)) &lt;=&gt; (forall y. Q(y))))")!&gt;)
      using [unshunt (axiom_impiff
        (&lt;!"exists x. forall y. P(x) &lt;=&gt; P(y)"!&gt;)
        (&lt;!"(exists x. Q(x)) &lt;=&gt; (forall y. Q(y))"!&gt;))],

      our thesis by_mp ("imp", "ant"),
      qed
    ],
    qed
  ],

  note ("impiff",
  &lt;!(("(((exists x. forall y. P(x) &lt;=&gt; P(y)) &lt;=&gt; ((exists x. Q(x)) &lt;=&gt; (forall y. Q(y)))) ==&gt;"
^     "((exists x. forall y. Q(x) &lt;=&gt; Q(y)) &lt;=&gt; ((exists x. P(x)) &lt;=&gt; (forall y. P(y))))) /\\"
^     "(((exists x. forall y. Q(x) &lt;=&gt; Q(y)) &lt;=&gt; ((exists x. P(x)) &lt;=&gt; (forall y. P(y)))) ==&gt;"
^     "((exists x. forall y. P(x) &lt;=&gt; P(y)) &lt;=&gt; ((exists x. Q(x)) &lt;=&gt; (forall y. Q(y))))) ==&gt;"
^     "(((exists x. forall y. P(x) &lt;=&gt; P(y)) &lt;=&gt; ((exists x. Q(x)) &lt;=&gt; (forall y. Q(y)))) &lt;=&gt;"
^     "((exists x. forall y. Q(x) &lt;=&gt; Q(y)) &lt;=&gt; ((exists x. P(x)) &lt;=&gt; (forall y. P(y)))))"))!&gt;)
  using [unshunt (axiom_impiff
    (&lt;!("(exists x. forall y. P(x) &lt;=&gt; P(y)) &lt;=&gt; ((exists x. Q(x)) &lt;=&gt; (forall y. Q(y)))")!&gt;)
    (&lt;!("(exists x. forall y. Q(x) &lt;=&gt; Q(y)) &lt;=&gt; ((exists x. P(x)) &lt;=&gt; (forall y. P(y)))")!&gt;))],

  our thesis by_mp ("impiff", "directions"),
  qed
]

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p35 *)

auto "exists x y. P(x,y) ==&gt; (forall x y. P(x,y))"

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p36 *)

auto ("(forall x. exists y. P(x,y)) /\\ " ^
      "(forall x. exists y. G(x,y)) /\\ " ^
      "(forall x y. P(x,y) \\/ G(x,y) ==&gt; (forall z. P(y,z) \\/ G(y,z) ==&gt; H(x,z))) " ^
      "==&gt; (forall x. exists y. H(x,y))")

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p37 *)

auto ("(forall z. " ^
        "exists w. forall x. exists y. (P(x,z) ==&gt; P(y,w)) /\\ P(y,z) /\\ " ^
        "(P(y,w) ==&gt; (exists u. Q(u,w)))) /\\ " ^
      "(forall x z. ~P(x,z) ==&gt; (exists y. Q(y,z))) /\\ " ^
      "((exists x y. Q(x,y)) ==&gt; (forall x. R(x,x))) " ^
      "==&gt; (forall x. exists y. R(x,y))")

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p38 *)

auto ("(forall x. " ^
        "P(a) /\\ (P(x) ==&gt; (exists y. P(y) /\\ R(x,y))) ==&gt; " ^
        "(exists z w. P(z) /\\ R(x,w) /\\ R(w,z))) &lt;=&gt; " ^
      "(forall x. " ^
        "(~P(a) \\/ P(x) \\/ (exists z w. P(z) /\\ R(x,w) /\\ R(w,z))) /\\ " ^
        "(~P(a) \\/ ~(exists y. P(y) /\\ R(x,y)) \\/ " ^
        "(exists z w. P(z) /\\ R(x,w) /\\ R(w,z))))")

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p39 *)

auto "~(exists x. forall y. P(y,x) &lt;=&gt; ~P(y,y))"

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p40 *)

auto ("(exists y. forall x. P(x,y) &lt;=&gt; P(x,x)) " ^
      "==&gt; ~(forall x. exists y. forall z. P(z,y) &lt;=&gt; ~P(z,x))")

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p41 *)

auto ("(forall z. exists y. forall x. P(x,y) &lt;=&gt; P(x,z) /\\ ~P(x,x)) " ^
      "==&gt; ~(exists z. forall x. P(x,z))")

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p42 *)

auto "~(exists y. forall x. P(x,y) &lt;=&gt; ~(exists z. P(x,z) /\\ P(z,x)))"

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p44 *)

auto ("(forall x. P(x) ==&gt; (exists y. G(y) /\\ H(x,y)) /\\ " ^
      "(exists y. G(y) /\\ ~H(x,y))) /\\ " ^
      "(exists x. J(x) /\\ (forall y. G(y) ==&gt; H(x,y))) ==&gt; " ^
      "(exists x. J(x) /\\ ~P(x))")

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p45 *)

auto ("(forall x. " ^
        "P(x) /\\ (forall y. G(y) /\\ H(x,y) ==&gt; J(x,y)) ==&gt; " ^
             "(forall y. G(y) /\\ H(x,y) ==&gt; R(y))) /\\ " ^
      "~(exists y. L(y) /\\ R(y)) /\\ " ^
      "(exists x. P(x) /\\ (forall y. H(x,y) ==&gt; " ^
        "L(y)) /\\ (forall y. G(y) /\\ H(x,y) ==&gt; J(x,y))) ==&gt; " ^
      "(exists x. P(x) /\\ ~(exists y. G(y) /\\ H(x,y)))")

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p55 *)

auto ("lives(agatha) /\\ lives(butler) /\\ lives(charles) /\\ " ^
      "(killed(agatha,agatha) \\/ killed(butler,agatha) \\/ " ^
       "killed(charles,agatha)) /\\ " ^
      "(forall x y. killed(x,y) ==&gt; hates(x,y) /\\ ~richer(x,y)) /\\ " ^
      "(forall x. hates(agatha,x) ==&gt; ~hates(charles,x)) /\\ " ^
      "(hates(agatha,agatha) /\\ hates(agatha,charles)) /\\ " ^
      "(forall x. lives(x) /\\ ~richer(x,agatha) ==&gt; hates(butler,x)) /\\ " ^
      "(forall x. hates(agatha,x) ==&gt; hates(butler,x)) /\\ " ^
      "(forall x. ~hates(x,agatha) \\/ ~hates(x,butler) \\/ ~hates(x,charles)) " ^
      "==&gt; killed(agatha,agatha) /\\ " ^
             "~killed(butler,agatha) /\\ " ^
             "~killed(charles,agatha)")

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p57 *)

auto ("P(f(a,b),f(b,c)) /\\ " ^
      "P(f(b,c),f(a,c)) /\\ " ^
      "(forall x y z. P(x,y) /\\ P(y,z) ==&gt; P(x,z)) " ^
      "==&gt; P(f(a,b),f(a,c))")

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p59 *)

auto "(forall x. P(x) &lt;=&gt; ~P(f(x))) ==&gt; (exists x. P(x) /\\ ~P(f(x)))"

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* Pelletier p60 *)

auto "forall x. P(x,f(x)) &lt;=&gt; exists y. (forall z. P(z,y) ==&gt; P(z,f(x))) /\\ P(x,y)"

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* gilmore_3 *)

auto ("exists x. forall y z. " ^
              "((F(y,z) ==&gt; (G(y) ==&gt; H(x))) ==&gt; F(x,x)) /\\ " ^
              "((F(z,x) ==&gt; G(x)) ==&gt; H(z)) /\\ " ^
              "F(x,y) " ^
              "==&gt; F(z,z)")

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* gilmore_4 *)

auto ("exists x y. forall z. " ^
              "(F(x,y) ==&gt; F(y,z) /\\ F(z,z)) /\\ " ^
              "(F(x,y) /\\ G(x,y) ==&gt; G(x,z) /\\ G(z,z))")

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* gilmore_5 *)

auto ("(forall x. exists y. F(x,y) \\/ F(y,x)) /\\ " ^
      "(forall x y. F(y,x) ==&gt; F(y,y)) " ^
      "==&gt; exists z. F(z,z)")

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* gilmore_6 *)

auto ("forall x. exists y. " ^
              "(exists u. forall v. F(u,x) ==&gt; G(v,u) /\\ G(u,x)) " ^
              "==&gt; (exists u. forall v. F(u,y) ==&gt; G(v,u) /\\ G(u,y)) \\/ " ^
                        "(forall u v. exists w. G(v,u) \\/ H(w,y,u) ==&gt; G(u,w))")

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* gilmore_7 *)

auto ("(forall x. K(x) ==&gt; exists y. L(y) /\\ (F(x,y) ==&gt; G(x,y))) /\\ " ^
      "(exists z. K(z) /\\ forall u. L(u) ==&gt; F(z,u)) " ^
      "==&gt; exists v w. K(v) /\\ L(w) /\\ G(v,w)")

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* gilmore_8 *)

auto ("exists x. forall y z. " ^
              "((F(y,z) ==&gt; (G(y) ==&gt; (forall u. exists v. H(u,v,x)))) ==&gt; F(x,x)) /\\ " ^
              "((F(z,x) ==&gt; G(x)) ==&gt; (forall u. exists v. H(u,v,z))) /\\ " ^
              "F(x,y) " ^
              "==&gt; F(z,z)")

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* gilmore_9 *)

auto ("forall x. exists y. forall z. " ^
              "((forall u. exists v. F(y,u,v) /\\ G(y,u) /\\ ~H(y,x)) " ^
                   "==&gt; (forall u. exists v. F(x,u,v) /\\ G(z,u) /\\ ~H(x,z)) " ^
                   "==&gt; (forall u. exists v. F(x,u,v) /\\ G(y,u) /\\ ~H(x,y))) /\\ " ^
              "((forall u. exists v. F(x,u,v) /\\ G(y,u) /\\ ~H(x,y)) " ^
                  "==&gt; ~(forall u. exists v. F(x,u,v) /\\ G(z,u) /\\ ~H(x,z)) " ^
                  "==&gt; (forall u. exists v. F(y,u,v) /\\ G(y,u) /\\ ~H(y,x)) /\\ " ^
                         "(forall u. exists v. F(z,u,v) /\\ G(y,u) /\\ ~H(z,y)))")

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* davis_putnam_example *)

auto ("exists x. exists y. forall z. " ^
      "(F(x,y) ==&gt; (F(y,z) /\\ F(z,z))) /\\ " ^
      "((F(x,y) /\\ G(x,y)) ==&gt; (G(x,z) /\\ G(z,z)))")

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* ewd1062_1 *)

auto ("(forall x. x &lt;= x) /\\ " ^
      "(forall x y z. x &lt;= y /\\ y &lt;= z ==&gt; x &lt;= z) /\\ " ^
      "(forall x y. f(x) &lt;= y &lt;=&gt; x &lt;= g(y)) " ^
      "==&gt; (forall x y. x &lt;= y ==&gt; f(x) &lt;= f(y))")

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(* ewd1062_2 *)

auto ("(forall x. x &lt;= x) /\\ " ^
      "(forall x y z. x &lt;= y /\\ y &lt;= z ==&gt; x &lt;= z) /\\ " ^
      "(forall x y. f(x) &lt;= y &lt;=&gt; x &lt;= g(y)) " ^
      "==&gt; (forall x y. x &lt;= y ==&gt; g(x) &lt;= g(y))")

›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*

Non-terminating examples

ML_val {* (* ewd1062 *)

auto ("(forall x. x &lt;= x) /\\ " ^
      "(forall x y z. x &lt;= y /\\ y &lt;= z ==&gt; x &lt;= z) /\\ " ^
      "(forall x y. f(x) &lt;= y &lt;=&gt; x &lt;= g(y)) " ^
      "==&gt; (forall x y. x &lt;= y ==&gt; f(x) &lt;= f(y)) /\\ " ^
          "(forall x y. x &lt;= y ==&gt; g(x) &lt;= g(y))")

*}

ML_val {* (* Pelletier p34 / page 178 Andrews's challenge *)

auto ("((exists x. forall y. P(x) &lt;=&gt; P(y)) &lt;=&gt; " ^
    "((exists x. Q(x)) &lt;=&gt; (forall y. Q(y)))) &lt;=&gt; " ^
   "((exists x. forall y. Q(x) &lt;=&gt; Q(y)) &lt;=&gt; " ^
    "((exists x. P(x)) &lt;=&gt; (forall y. P(y))))")

*}

ML_val {* (* Pelletier p43 *)

auto "(forall x y. Q(x,y) &lt;=&gt; forall z. P(z,x) &lt;=&gt; P(z,y)) ==&gt; forall x y. Q(x,y) &lt;=&gt; Q(y,x)"

*}

ML_val {* (* Pelletier p46 *)

auto ("(forall x. P(x) /\\ (forall y. P(y) /\\ H(y,x) ==&gt; G(y)) ==&gt; G(x)) /\\ " ^
        "((exists x. P(x) /\\ ~G(x)) ==&gt; " ^
          "(exists x. P(x) /\\ ~G(x) /\\ (forall y. P(y) /\\ ~G(y) ==&gt; J(x,y)))) /\\ " ^
        "(forall x y. P(x) /\\ P(y) /\\ H(x,y) ==&gt; ~J(y,x)) ==&gt; " ^
        "(forall x. P(x) ==&gt; G(x))")

*}

ML_val {* (* Pelletier p56 *)

auto ("(forall x. (exists y. P(y) /\\ x = f(y)) ==&gt; P(x)) &lt;=&gt; (forall x. P(x) ==&gt; P(f(x)))")

*}

ML_val {* (* Correct Pelletier p58 *)

auto "(forall x y. f(x) = g(y)) ==&gt; (forall x y. f(f(x)) = f(g(y)))"

*}

ML_val {* (* gilmore_1 *)

auto ("exists x. forall y z. " ^
        "((F(y) ==&gt; G(y)) &lt;=&gt; F(x)) /\\ " ^
        "((F(y) ==&gt; H(y)) &lt;=&gt; G(x)) /\\ " ^
        "(((F(y) ==&gt; G(y)) ==&gt; H(y)) &lt;=&gt; H(x)) " ^
          "==&gt; F(z) /\\ G(z) /\\ H(z)")

*}

ML_val {* (* gilmore_2 has a counterexample *)

auto ("exists x y. forall z. (F(x,z) &lt;=&gt; F(z,y)) /\\ (F(z,y) &lt;=&gt; F(z,z)) /\\ (F(x,y) &lt;=&gt; F(y,x)) " ^
      "==&gt; (F(x,y) &lt;=&gt; F(x,z))")

*}

*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div>