<div id="More_Jordan_Normal_Forms">
<div class="head"><h1>Theory More_Jordan_Normal_Forms</h1>
<span class="command">theory</span> <span class="name">More_Jordan_Normal_Forms</span><br/>
<span class="keyword">imports</span> <a href="../Jordan_Normal_Form/Matrix_Impl.html"><span class="name">Matrix_Impl</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>More_Jordan_Normal_Forms</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>    </span><span>Jordan_Normal_Form.Matrix_Impl</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_comprehension_list_comprehension</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"set [f i . i &lt;- [x..&lt;a]] = {f i |i. i ∈ {x..&lt;a}}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>fastforce</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_second_append_list</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i≥ length a ⟹ i &lt; length (a@b) ⟹ (a@b)!i ∈ set b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>diff_add_inverse</span><span> </span><span>diff_less_mono</span><span> </span><span>in_set_conv_nth</span><span> </span><span>leD</span><span> </span><span>length_append</span><span> </span><span>nth_append</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ General Theorems used later, that could be moved ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>split_four_block_dual_fst_lst</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"split_block (four_block_mat A B C D) (dim_row A) (dim_col A) = (U, X, Y, V)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"U = A"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V = D"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>nr</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>nr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nr = dim_row (four_block_mat A B C D)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>nc</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>nc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nc = dim_col (four_block_mat A B C D)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>nr2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>nr2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nr2 = nr - dim_row A"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>nc2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>nc2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nc2 = nc - dim_col A"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>A1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>A1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A1 = mat (dim_row A) (dim_col A) (($$) (four_block_mat A B C D))"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>A2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>A2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A2 = mat (dim_row A) nc2 (λ(i, j). (four_block_mat A B C D) $$ (i, j + dim_col A))"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>A3</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>A3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A3 = mat nr2 (dim_col A) (λ(i, j). (four_block_mat A B C D) $$ (i + dim_row A, j))"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>A4</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>A4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A4 = mat nr2 nc2 (λ(i, j). (four_block_mat A B C D) $$ (i + dim_row A, j + dim_col A))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>g</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"split_block (four_block_mat A B C D) (dim_row A) (dim_col A) = (A1, A2, A3, A4)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split_block_def</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(four_block_mat A B C D)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(dim_row A)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(dim_col A)"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>A1</span><span> </span><span>A2</span><span> </span><span>A3</span><span> </span><span>A4</span><span> </span><span>nc</span><span> </span><span>nc2</span><span> </span><span>nr</span><span> </span><span>nr2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>D</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"D = A4"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A4</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>standard</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>  </span><span>nr</span><span> </span><span>nr2</span><span> </span><span>nc</span><span> </span><span>nc2</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A = A1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"split_block (four_block_mat A B C D) (dim_row A) (dim_col A) = (A, A2, A3, D)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D</span><span> </span><span>g</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"U = A"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>calculation</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V = D"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>append_split_vec_distrib_scalar_prod</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec (u @<span class="hidden">⇩</span><sub>v</sub> w) = dim_vec x"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u @<span class="hidden">⇩</span><sub>v</sub> w) ∙ x = u ∙ (vec_first x (dim_vec u)) + w ∙ (vec_last x (dim_vec w))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u @<span class="hidden">⇩</span><sub>v</sub> w) ∙ (vec_first x (dim_vec u) @<span class="hidden">⇩</span><sub>v</sub> vec_last x (dim_vec w)) = 
              u ∙ vec_first x (dim_vec u) + w ∙ vec_last x (dim_vec w)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>carrier_vec_dim_vec</span><span> </span><span>scalar_prod_append</span><span> </span><span>vec_first_carrier</span><span> </span><span>vec_last_carrier</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>carrier_vec_dim_vec</span><span> </span><span>index_append_vec</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>vec_first_last_append</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>append_dot_product_split</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec (u @<span class="hidden">⇩</span><sub>v</sub> w) = dim_vec x"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u @<span class="hidden">⇩</span><sub>v</sub> w) ∙ x = (∑i∈{0..&lt; dim_vec u}. u$i * x$i) + (∑i∈{0..&lt; dim_vec w}. w$i * x$(i + dim_vec u))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>ix</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ix = vec_first x (dim_vec u)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>lx</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>lx</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lx = vec_last x (dim_vec w)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(u @<span class="hidden">⇩</span><sub>v</sub> w) ∙ x = u ∙ ix + w ∙ lx"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>append_split_vec_distrib_scalar_prod</span><span> </span><span>ix_def</span><span> </span><span>lx</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u @<span class="hidden">⇩</span><sub>v</sub> w) ∙ x = (∑ i ∈ {0 ..&lt; dim_vec x}. (u @<span class="hidden">⇩</span><sub>v</sub> w) $ i * x $ i)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>scalar_prod_def</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(u @<span class="hidden">⇩</span><sub>v</sub> w)"</span></span></span><span> </span><span>x</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑ i ∈ {0 ..&lt; dim_vec u}. (u @<span class="hidden">⇩</span><sub>v</sub> w) $ i * x $ i) + 
                   (∑ i ∈ {dim_vec u ..&lt; dim_vec (u @<span class="hidden">⇩</span><sub>v</sub> w)}. (u @<span class="hidden">⇩</span><sub>v</sub> w) $ i * x $ i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>sum.atLeastLessThan_concat</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec u"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec (u @<span class="hidden">⇩</span><sub>v</sub> w)"</span></span></span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"(λi. (u @<span class="hidden">⇩</span><sub>v</sub> w) $ i * x $ i)"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>le0</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec u"</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span> 
</span><span>      </span><span>le_add1</span><span class="delimiter">[</span><span>of</span><span>  </span><span class="string"><span class="delete"><span class="delete">"dim_vec u"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec w"</span></span></span><span class="delimiter">]</span><span> </span><span>index_append_vec</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>u</span><span> </span><span>w</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"... =(∑i∈{0..&lt;dim_vec u}. u$i * x$i) + w ∙ lx"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>*</span><span> </span><span>calculation</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ix_def</span><span> </span><span>scalar_prod_def</span><span> </span><span>vec_first_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"w ∙ lx = (∑i∈{0..&lt; dim_vec w}. w$i * x$(i + dim_vec u))"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lx</span><span> </span><span>vec_last_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>scalar_prod_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>add_diff_cancel_right'</span><span> </span><span>index_append_vec</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>u</span><span> </span><span>w</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹dim_vec (u @<span class="hidden">⇩</span><sub>v</sub> w) = dim_vec u + dim_vec w›</span></span></span><span> </span><span>add.commute</span><span> </span><span>add_diff_cancel_right'</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>*</span><span> </span><span>calculation</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>assoc_scalar_prod_mult_mat_vec</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>A</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::comm_semiring_1 mat"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ carrier_vec n"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ carrier_vec m"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A ∈ carrier_mat n m"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(A *<span class="hidden">⇩</span><sub>v</sub> x) ∙ y = (A<span class="hidden">⇧</span><sup>T</sup> *<span class="hidden">⇩</span><sub>v</sub> y) ∙ x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(A *<span class="hidden">⇩</span><sub>v</sub> x) ∙ y = (∑ i ∈ {0 ..&lt; n}. (A *<span class="hidden">⇩</span><sub>v</sub> x) $ i * y $ i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>scalar_prod_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>carrier_vecD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑ i ∈ {0 ..&lt; n}. (vec (dim_row A) (λ i. row A i ∙ x)) $ i * y $ i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mult_mat_vec_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑ i ∈ {0 ..&lt; n}. (λ i. row A i ∙ x)  i * y $ i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑ i ∈ {0 ..&lt; n}. (∑ j ∈ {0 ..&lt; m}. (row A i) $ j * x $ j) * y $ i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>scalar_prod_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>carrier_vecD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑ j ∈ {0 ..&lt; n}. (∑ i ∈ {0 ..&lt; m}. (row A j) $ i * x $ i * y $ j))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sum_distrib_right</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑ j ∈ {0 ..&lt; n}. (∑ i ∈ {0 ..&lt; m}.  A $$ (j,i) * x $ i * y $ j))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>row_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑ j ∈ {0 ..&lt; n}. (∑ i ∈ {0 ..&lt; m}.  A $$ (j,i) * y $ j * x $ i))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>semiring_normalization_rules</span><span class="delimiter">(</span><span>16</span><span class="delimiter">)</span><span> </span><span>sum.cong</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑ j ∈ {0 ..&lt; n}. (∑ i ∈ {0 ..&lt; m}. (col A i) $ j * y $ j * x $ i))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑ i ∈ {0 ..&lt; m}. (∑ j ∈ {0 ..&lt; n}. (col A i) $ j * y $ j * x $ i))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Groups_Big.comm_monoid_add_class.sum.swap</span><span class="delimiter">[</span><span>of</span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"(λi j. (col A i) $ j * y $ j * x $ i)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{0..&lt;n}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{0 ..&lt; m}"</span></span></span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑ i ∈ {0 ..&lt; m}. (∑ j ∈ {0 ..&lt; n}. (col A i) $ j * y $ j) * x $ i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sum_distrib_right</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑ i ∈ {0 ..&lt; m}. (λ i. col A i ∙ y) i * x $ i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>scalar_prod_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>carrier_vecD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑ i ∈ {0 ..&lt; m}. (λ i. row A<span class="hidden">⇧</span><sup>T</sup> i ∙ y) i * x $ i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑ i ∈ {0 ..&lt; m}. (vec (dim_row A<span class="hidden">⇧</span><sup>T</sup>) (λ i. row A<span class="hidden">⇧</span><sup>T</sup> i ∙ y)) $ i * x $ i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑ i ∈ {0 ..&lt; m}. (A<span class="hidden">⇧</span><sup>T</sup> *<span class="hidden">⇩</span><sub>v</sub> y) $ i * x $ i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (A<span class="hidden">⇧</span><sup>T</sup> *<span class="hidden">⇩</span><sub>v</sub> y) ∙ x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>scalar_prod_def</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(A<span class="hidden">⇧</span><sup>T</sup> *<span class="hidden">⇩</span><sub>v</sub> y)"</span></span></span><span> </span><span>x</span><span class="delimiter">,</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>carrier_vecD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Vectors ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>singletonV</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"[_]<span class="hidden">⇩</span><sub>v</sub>"</span></span></span><span> </span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"singletonV e ≡ (vec 1 (λi. e))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>elem_in_singleton</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"[a]<span class="hidden">⇩</span><sub>v</sub> $ 0 = a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>elem_in_singleton_append</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x @<span class="hidden">⇩</span><sub>v</sub> [a]<span class="hidden">⇩</span><sub>v</sub>) $ dim_vec x = a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vector_cases_append</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a vec"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = vNil ∨ (∃v a. x = v @<span class="hidden">⇩</span><sub>v</sub> [a]<span class="hidden">⇩</span><sub>v</sub>)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≠ vNil ⟹ (∃v a. x = v @<span class="hidden">⇩</span><sub>v</sub> [a]<span class="hidden">⇩</span><sub>v</sub>)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≠ vNil"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>na</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ (∃v a. x = v @<span class="hidden">⇩</span><sub>v</sub> [a]<span class="hidden">⇩</span><sub>v</sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec x ≥ 1"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>eq_vecI</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>v</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>v</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v = vec (dim_vec x - 1) (λi. x $ i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>v'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i &lt; dim_vec v. v $ i = x $ i"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>v</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>a</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a = x $ (dim_vec x - 1)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"[a]<span class="hidden">⇩</span><sub>v</sub> $ 0 = a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ff1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"1 + dim_vec v = dim_vec x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹1 ≤ dim_vec x›</span></span></span><span> </span><span>add_diff_cancel_left'</span><span> </span><span>dim_vec</span><span> </span><span>le_Suc_ex</span><span> </span><span>v</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i &lt; dim_vec x. x$i = (v @<span class="hidden">⇩</span><sub>v</sub> [a]<span class="hidden">⇩</span><sub>v</sub>)$i"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>standard</span><span class="delimiter">,</span><span>standard</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>as</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; dim_vec x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x $ dim_vec v = a"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a</span><span> </span><span>v</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x $ i = (v @<span class="hidden">⇩</span><sub>v</sub> [a]<span class="hidden">⇩</span><sub>v</sub>) $ i"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ff1</span><span> </span><span>as</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>One_nat_def</span><span> </span><span>a'</span><span> </span><span>add.left_neutral</span><span> 
</span><span>            </span><span>add_Suc_right</span><span> </span><span>add_diff_cancel_left'</span><span> </span><span>add_diff_cancel_right'</span><span> 
</span><span>            </span><span>dim_vec</span><span> </span><span>index_append_vec</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>less_Suc_eq</span><span> </span><span>v'</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x$i = (v @<span class="hidden">⇩</span><sub>v</sub> [a]<span class="hidden">⇩</span><sub>v</sub>)$i"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = v @<span class="hidden">⇩</span><sub>v</sub> [a]<span class="hidden">⇩</span><sub>v</sub>"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>a'</span><span> </span><span>v</span><span> </span><span>v'</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>dim_vec</span><span> </span><span>eq_vecI</span><span> </span><span>ff1</span><span> </span><span>index_append_vec</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>semiring_normalization_rules</span><span class="delimiter">(</span><span>24</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>na</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vec_rev_induct</span><span> </span><span class="delimiter">[</span><span>case_names</span><span> </span><span>vNil</span><span> </span><span>append</span><span class="delimiter">,</span><span> </span><span>induct</span><span> </span><span>type</span><span class="delimiter">:</span><span> </span><span>vec</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P vNil"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀a v. P v ⟹ P (v @<span class="hidden">⇩</span><sub>v</sub> [a]<span class="hidden">⇩</span><sub>v</sub>)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P v"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec v"</span></span></span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>v</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v = vNil"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>l</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs</span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>xs_x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v = xs @<span class="hidden">⇩</span><sub>v</sub> [x]<span class="hidden">⇩</span><sub>v</sub>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vector_cases_append</span><span class="delimiter">[</span><span>of</span><span> </span><span>v</span><span class="delimiter">]</span><span> </span><span>Suc.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>dim_vec</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"l = dim_vec xs"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>xs_x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P xs"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc.hyps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>xs</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P (xs @<span class="hidden">⇩</span><sub>v</sub> [x]<span class="hidden">⇩</span><sub>v</sub>)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>xs</span><span> </span><span>x</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>xs_x</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>singleton_append_dotP</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec z = dim_vec y + 1"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(y @<span class="hidden">⇩</span><sub>v</sub> [x]<span class="hidden">⇩</span><sub>v</sub>) ∙ z = (∑i∈{0..&lt;dim_vec y}. y $ i * z $ i) + x * z $ dim_vec y"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(y @<span class="hidden">⇩</span><sub>v</sub> [x]<span class="hidden">⇩</span><sub>v</sub>) ∙ z = (∑i∈{0..&lt;dim_vec z}. (y @<span class="hidden">⇩</span><sub>v</sub> [x]<span class="hidden">⇩</span><sub>v</sub>) $ i * z $ i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>scalar_prod_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑i∈{0..&lt;dim_vec z-1}. (y @<span class="hidden">⇩</span><sub>v</sub> [x]<span class="hidden">⇩</span><sub>v</sub>) $ i * z $ i) + 
                   (y @<span class="hidden">⇩</span><sub>v</sub> [x]<span class="hidden">⇩</span><sub>v</sub>)$(dim_vec z-1) * z$(dim_vec z-1)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑i∈{0..&lt;dim_vec y}. (y @<span class="hidden">⇩</span><sub>v</sub> [x]<span class="hidden">⇩</span><sub>v</sub>) $ i * z $ i) + 
                   (y @<span class="hidden">⇩</span><sub>v</sub> [x]<span class="hidden">⇩</span><sub>v</sub>)$(dim_vec y)* z$(dim_vec y)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑i∈{0..&lt;dim_vec y}. y $ i * z $ i) + 
                   x * z$(dim_vec y)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_vec_append</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"map_vec f (a @<span class="hidden">⇩</span><sub>v</sub> b) = map_vec f a @<span class="hidden">⇩</span><sub>v</sub> map_vec f b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>a</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>b</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_mat_map_vec</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; dim_row P"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"row (map_mat f P) i = map_vec f (row P i)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>append_rows_access1</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; dim_row A"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_col A = dim_col B"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"row (A @<span class="hidden">⇩</span><sub>r</sub> B) i = row A i"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec (Matrix.row (A @<span class="hidden">⇩</span><sub>r</sub> B) i) = dim_vec (Matrix.row A i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>append_rows_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>ia</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ia &lt; dim_vec (row A i)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"row (A @<span class="hidden">⇩</span><sub>r</sub> B) i = (row A i @<span class="hidden">⇩</span><sub>v</sub> row (0<span class="hidden">⇩</span><sub>m</sub> (dim_row A) 0) i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>append_rows_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> 
</span><span>      </span><span>carrier_mat_triv</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span class="delimiter">]</span><span> </span><span>row_four_block_mat</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_row A"</span></span></span><span> 
</span><span>        </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"0<span class="hidden">⇩</span><sub>m</sub> (dim_row A) 0"</span></span></span><span> </span><span>0</span><span> </span><span>B</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_row B"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0<span class="hidden">⇩</span><sub>m</sub> (dim_row B) 0"</span></span></span><span> </span><span>i</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>carrier_mat_triv</span><span> </span><span>zero_carrier_mat</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = row A i @<span class="hidden">⇩</span><sub>v</sub> vNil"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = row A i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"row (A @<span class="hidden">⇩</span><sub>r</sub> B) i $ ia = row A i $ ia"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>append_rows_access2</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ≥ dim_row A"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; dim_row A + dim_row B"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_col A = dim_col B"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"row (A @<span class="hidden">⇩</span><sub>r</sub> B) i = row B (i - dim_row A)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec (row (A @<span class="hidden">⇩</span><sub>r</sub> B) i) = dim_vec (row B (i - dim_row A))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>append_rows_def</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>ia</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ia &lt; dim_vec (row B (i - dim_row A))"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"row (A @<span class="hidden">⇩</span><sub>r</sub> B) i = (row B (i - dim_row A) @<span class="hidden">⇩</span><sub>v</sub> row (0<span class="hidden">⇩</span><sub>m</sub> (dim_row B) 0) (i - dim_row A))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>append_rows_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>carrier_mat_triv</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span class="delimiter">]</span><span> </span><span>row_four_block_mat</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_row A"</span></span></span><span> 
</span><span>        </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"0<span class="hidden">⇩</span><sub>m</sub> (dim_row A) 0"</span></span></span><span> </span><span>0</span><span> </span><span>B</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_row B"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0<span class="hidden">⇩</span><sub>m</sub> (dim_row B) 0"</span></span></span><span> </span><span>i</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>carrier_mat_triv</span><span> </span><span>le_antisym</span><span> </span><span>less_imp_le_nat</span><span> </span><span>nat_less_le</span><span> </span><span>zero_carrier_mat</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = row B (i - dim_row A) @<span class="hidden">⇩</span><sub>v</sub> vNil"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = row B (i - dim_row A)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"row (A @<span class="hidden">⇩</span><sub>r</sub> B) i $ ia = row B (i - dim_row A) $ ia"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>append_singleton_access</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Matrix.vec n f @<span class="hidden">⇩</span><sub>v</sub> [r]<span class="hidden">⇩</span><sub>v</sub>) $ n = r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Move to right place ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>mat_append_col</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mat_append_col A b = mat_of_cols (dim_row A) (cols A @ [b])"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>mat_append_row</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mat_append_row A c = mat_of_rows (dim_col A) (rows A @ [c])"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mat_append_col_dims</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mat_append_col A b ∈ carrier_mat (dim_row A) (dim_col A + 1)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mat_append_row_dims</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mat_append_row A c ∈ carrier_mat (dim_row A + 1) (dim_col A)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mat_append_col_col</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_row A = dim_vec b"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"col (mat_append_col A b) (dim_col A) = b"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>standard</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?nA</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(mat_of_cols (dim_row A) (cols A @ [b]))"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec (col (mat_append_col A b) (dim_col A)) = dim_vec b"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; dim_vec b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"col (mat_append_col A b) (dim_col A) $ i = vec_index (vec (dim_row ?nA) (λ i. ?nA $$ (i, (dim_col A)))) i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>col_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = vec_index (vec (dim_row A) (λ i. ?nA $$ (i, (dim_col A)))) i"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = vec_index ((cols A @ [b]) ! dim_col A) i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹i &lt; dim_vec b›</span></span></span><span> </span><span>assms</span><span> </span><span>mat_of_cols_index</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = vec_index b i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>cols_length</span><span> </span><span>nth_append_length</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"col (mat_append_col A b) (dim_col A) $ i = b $ i"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mat_append_col_vec_index</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; dim_row A"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_row A = dim_vec b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(row (mat_append_col A b) i) $ (dim_col A) = b $ i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mat_append_col_col</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>One_nat_def</span><span> </span><span>add_Suc_right</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>carrier_matD</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> 
</span><span>      </span><span>col_def</span><span> </span><span>dim_row_mat</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>index_row</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>index_vec</span><span> </span><span>lessI</span><span> </span><span>mat_append_col.simps</span><span> 
</span><span>      </span><span>mat_append_col_dims</span><span> </span><span>mat_of_cols_def</span><span> </span><span>semiring_norm</span><span class="delimiter">(</span><span>51</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mat_append_row_row</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_col A = dim_vec c"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"row (mat_append_row A c) (dim_row A) = c"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?nA</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(mat_of_rows (dim_col A) (Matrix.rows A @ [c]))"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec (Matrix.row (mat_append_row A c) (dim_row A)) = dim_vec c"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; dim_vec c"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>mat_append_row.simps</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span> </span><span>c</span><span class="delimiter">]</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"row (mat_append_row A c) (dim_row A) $ i = vec_index (row ?nA (dim_row A)) i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = vec_index (vec (dim_col ?nA) (λ j. ?nA $$ (dim_row A,j))) i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Matrix.row_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... =  vec_index ((rows A @ [c]) ! dim_row A) i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹mat_append_row A c = mat_of_rows (dim_col A) (Matrix.rows A @ [c])›</span></span></span><span> 
</span><span>        </span><span>add_Suc_right</span><span> </span><span>append_Nil2</span><span> </span><span>assms</span><span> </span><span>calculation</span><span> </span><span>carrier_matD</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>col_transpose</span><span> </span><span>cols_transpose</span><span> 
</span><span>        </span><span>index_transpose_mat</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>index_transpose_mat</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>length_append</span><span> </span><span>length_rows</span><span> </span><span>lessI</span><span> </span><span>list.size</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> 
</span><span>        </span><span>mat_append_col.elims</span><span> </span><span>mat_append_col_col</span><span> </span><span>mat_append_row_dims</span><span> </span><span>nth_append_length</span><span> 
</span><span>        </span><span>transpose_mat_of_rows</span><span> </span><span>One_nat_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = vec_index c i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>length_rows</span><span> </span><span>nth_append_length</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Matrix.row (mat_append_row A c) (dim_row A) $ i = c $ i"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mat_append_row_in_mat</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; dim_row A"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"row (mat_append_row A r) i = row A i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>le_imp_less_Suc</span><span> </span><span>length_append_singleton</span><span> 
</span><span>      </span><span>length_rows</span><span> </span><span>mat_of_rows_row</span><span> </span><span>nat_less_le</span><span> </span><span>nth_append</span><span> </span><span>nth_rows</span><span> </span><span>row_carrier</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mat_append_row_vec_index</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; dim_col A"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_col A = dim_vec b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vec_index (col (mat_append_row A b) i) (dim_row A) = vec_index b i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>add.right_neutral</span><span> </span><span>add_Suc_right</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>carrier_matD</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> 
</span><span>      </span><span>carrier_matD</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>index_col</span><span> </span><span>index_row</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>lessI</span><span> </span><span>mat_append_row_dims</span><span> </span><span>mat_append_row_row</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mat_append_col_access_in_mat</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_row A = dim_vec b"</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; dim_row A"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j &lt; dim_col A"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(row (mat_append_col A b) i) $ j = (row A i) $ j"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Matrix.row_transpose</span><span class="delimiter">[</span><span>of</span><span> </span><span>j</span><span> </span><span>A</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span>Matrix.transpose_transpose</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(mat_append_col A b)"</span></span></span><span class="delimiter">]</span><span> </span><span>assms</span><span> </span><span>carrier_matD</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> 
</span><span>    </span><span>carrier_matD</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>cols_length</span><span> </span><span>cols_transpose</span><span> </span><span>index_col</span><span> </span><span>index_row</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span> </span><span class="string"><span class="delete"><span class="delete">"mat_append_col A b"</span></span></span><span> </span><span>j</span><span class="delimiter">]</span><span> </span><span>index_transpose_mat</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>    </span><span>mat_append_col.simps</span><span> </span><span>mat_append_col_dims</span><span>
</span><span>    </span><span>mat_of_cols_carrier</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>mat_of_rows_row</span><span>
</span><span>    </span><span>nth_append</span><span> </span><span>nth_rows</span><span> </span><span>row_carrier</span><span> </span><span>trans_less_add1</span><span> </span><span>transpose_mat_of_cols</span><span>
</span><span>    </span><span>mat_of_cols_index</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>cols_nth</span><span> </span><span>index_row</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>constructing_append_col_row</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; dim_row A"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_row A = dim_vec b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"row (mat_append_col A b) i = row A i @<span class="hidden">⇩</span><sub>v</sub> [vec_index b i]<span class="hidden">⇩</span><sub>v</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec (Matrix.row (mat_append_col A b) i) = dim_vec (Matrix.row A i @<span class="hidden">⇩</span><sub>v</sub> [b $ i]<span class="hidden">⇩</span><sub>v</sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>ia</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ia &lt; dim_vec (Matrix.row A i @<span class="hidden">⇩</span><sub>v</sub> [b $ i]<span class="hidden">⇩</span><sub>v</sub>)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">consider</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ia = dim_col A"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ia &lt; dim_col A"</span></span></span><span>     
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>less_SucE</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"row (mat_append_col A b) i $ ia = (Matrix.row A i @<span class="hidden">⇩</span><sub>v</sub> [b $ i]<span class="hidden">⇩</span><sub>v</sub>) $ ia "</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mat_append_col_vec_index</span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span> </span><span>A</span><span> </span><span>b</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>2</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"row (mat_append_col A b) i $ ia = (mat_append_col A b) $$ (i, ia)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mat_append_col_access_in_mat</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span> </span><span>b</span><span> </span><span>i</span><span> </span><span>ia</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>2</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>one_element_vec</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"one_element_vec n e = vec n (λi. e)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>one_element_vec_carrier</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"one_element_vec n e ∈ carrier_vec n"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>one_element_vec_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>one_element_vec_dim</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec (one_element_vec n (r::rat)) = n"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>one_element_vec_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>one_element_vec_access</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. i &lt; n ⟹ vec_index (one_element_vec n e) i = e"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>one_element_vec_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>single_nz_val</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"single_nz_val n i v = vec n (λj. (if i = j then v else 0))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>single_nz_val_carrier</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"single_nz_val n i v ∈ carrier_vec n"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>single_nz_val_access1</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; n ⟹ single_nz_val n i v $ i = v"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>single_nz_val_access2</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; n ⟹ j &lt; n ⟹ i ≠ j⟹ single_nz_val n i v $ j = 0"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; n ⟹ (v ⋅<span class="hidden">⇩</span><sub>v</sub> unit_vec n i) $ i = (v::'a::{monoid_mult,times,zero_neq_one})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>single_nz_val_unit_vec</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>v</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'a::{monoid_mult,times,zero_neq_one,mult_zero}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⋅<span class="hidden">⇩</span><sub>v</sub> (unit_vec n i) = single_nz_val n i v"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec (v ⋅<span class="hidden">⇩</span><sub>v</sub> unit_vec n i) = dim_vec (single_nz_val n i v)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>ia</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ia &lt; dim_vec (single_nz_val n i v)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(v ⋅<span class="hidden">⇩</span><sub>v</sub> unit_vec n i) $ ia = single_nz_val n i v $ ia"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>*</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>unit_vec_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>single_nz_valI</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>v</span><span> </span><span>i</span><span> </span><span>val</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀j. j &lt; dim_vec v ⟹ j ≠ i ⟹ v$j = 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v$i = val"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v = single_nz_val (dim_vec v) i val"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>single_nz_val_dotP</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; n"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec x = n"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"single_nz_val n i v ∙ x = v * x $ i"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?y</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"single_nz_val n i v"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"single_nz_val n i v ∙ x = (∑i∈{0 ..&lt; dim_vec x}. ?y $ i * x $ i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>scalar_prod_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑i∈{0 ..&lt; dim_vec x}-{i}. ?y $ i * x $ i) + ?y $ i * x $ i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>add.commute</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>atLeast0LessThan</span><span> 
</span><span>        </span><span>finite_atLeastLessThan</span><span> </span><span>lessThan_iff</span><span> </span><span>sum.remove</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑i∈{0 ..&lt; dim_vec x}-{i}. ?y $ i * x $ i) + v * x $ i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = v * x $ i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀j. j ∈ {0 ..&lt; dim_vec x}-{i} ⟹ ?y $ j * x $ j = 0"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑i∈{0 ..&lt; dim_vec x}-{i}. ?y $ i * x $ i) = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>single_nz_zero_singleton</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"single_nz_val 1 0 v = [v]<span class="hidden">⇩</span><sub>v</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>append_one_elem_zero_dotP</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec u = m"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec x = n"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(one_element_vec n e @<span class="hidden">⇩</span><sub>v</sub> (0<span class="hidden">⇩</span><sub>v</sub> m)) ∙ (x @<span class="hidden">⇩</span><sub>v</sub> u) = (∑i∈{0 ..&lt; dim_vec x}. e * x $ i)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?OEV</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"one_element_vec n e"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec (?OEV @<span class="hidden">⇩</span><sub>v</sub> (0<span class="hidden">⇩</span><sub>v</sub> m)) = dim_vec (x @<span class="hidden">⇩</span><sub>v</sub> u)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>one_element_vec_carrier</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(one_element_vec n e @<span class="hidden">⇩</span><sub>v</sub> 0<span class="hidden">⇩</span><sub>v</sub> m) ∙ (x @<span class="hidden">⇩</span><sub>v</sub> u) = one_element_vec n e ∙ x + 0<span class="hidden">⇩</span><sub>v</sub> m ∙ u"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>scalar_prod_append</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?OEV</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"0<span class="hidden">⇩</span><sub>v</sub> m"</span></span></span><span> </span><span>_</span><span> </span><span>x</span><span> </span><span>u</span><span class="delimiter">]</span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>carrier_vec_dim_vec</span><span> </span><span>one_element_vec_carrier</span><span> </span><span>zero_carrier_vec</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑i∈{0..&lt;dim_vec x}. ?OEV $ i * x $ i) + (∑i∈{0..&lt;dim_vec u}. (0<span class="hidden">⇩</span><sub>v</sub> m)$i * u$i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>scalar_prod_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑i∈{0..&lt;dim_vec x}. ?OEV $ i * x $ i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑i∈{0..&lt;dim_vec x}. e * x $ i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>one_element_vec_dotP</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec x = n"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(one_element_vec n e) ∙ x = (∑i∈{0 ..&lt; dim_vec x}. e * x $ i)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>assms</span><span> </span><span>one_element_vec_access</span><span> </span><span>scalar_prod_def</span><span> </span><span>sum.ivl_cong</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>singleton_dotP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec x = 1 ⟹ [v]<span class="hidden">⇩</span><sub>v</sub> ∙ x = v * x$0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>dim_vec</span><span> </span><span>index_vec</span><span> </span><span>less_one</span><span> </span><span>single_nz_valI</span><span> </span><span>single_nz_val_dotP</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>singletons_dotP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"[v]<span class="hidden">⇩</span><sub>v</sub> ∙ [w]<span class="hidden">⇩</span><sub>v</sub> = v * w"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>dim_vec</span><span> </span><span>index_vec</span><span> </span><span>less_one</span><span> </span><span>singleton_dotP</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>singleton_appends_dotP</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec x = dim_vec y ⟹ (x @<span class="hidden">⇩</span><sub>v</sub> [v]<span class="hidden">⇩</span><sub>v</sub>) ∙ (y @<span class="hidden">⇩</span><sub>v</sub> [w]<span class="hidden">⇩</span><sub>v</sub>) = x ∙ y + v * w"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>scalar_prod_append</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec x"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[v]<span class="hidden">⇩</span><sub>v</sub>"</span></span></span><span> </span><span>1</span><span> </span><span>y</span><span> </span><span class="string"><span class="delete"><span class="delete">"[w]<span class="hidden">⇩</span><sub>v</sub>"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>carrier_dim_vec</span><span> </span><span>singletons_dotP</span><span> </span><span>vec_carrier</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div><div id="Matrix_LinPoly">
<div class="head"><h1>Theory Matrix_LinPoly</h1>
<span class="command">theory</span> <span class="name">Matrix_LinPoly</span><br/>
<span class="keyword">imports</span> <a href="../Jordan_Normal_Form/Matrix_Impl.html"><span class="name">Matrix_Impl</span></a> <a href="Simplex_for_Reals.html"><span class="name">Simplex_for_Reals</span></a> <a href="Matrix_Farkas.html"><span class="name">Matrix_Farkas</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Matrix_LinPoly</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> 
</span><span>    </span><span>Jordan_Normal_Form.Matrix_Impl</span><span>
</span><span>    </span><span>Farkas.Simplex_for_Reals</span><span>
</span><span>    </span><span>Farkas.Matrix_Farkas</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Add this to linear polynomials in Simplex ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eval_poly_with_sum</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(v ⦃ X ⦄) = (∑x∈ vars v. coeff v x * X x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>linear_poly_sum</span><span> </span><span>sum.cong</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eval_poly_with_sum_superset</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite S"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S ⊇ vars v"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(v ⦃X⦄) = (∑x∈S. coeff v x * X x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>D</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>D</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"D = S - vars v"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>zeros</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x ∈ D. coeff v x = 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D</span><span> </span><span>coeff_zero</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fnt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (vars v)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finite_vars</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(v ⦃X⦄) = (∑x∈ vars v. coeff v x * X x)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>linear_poly_sum</span><span> </span><span>sum.cong</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑x∈ vars v. coeff v x * X x) + (∑x∈D. coeff v x * X x)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>zeros</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑x∈ vars v ∪ D. coeff v x * X x)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>fnt</span><span> </span><span>Diff_partition</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars v"</span></span></span><span> </span><span>S</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> 
</span><span>      </span><span>sum.subset_diff</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars v"</span></span></span><span> </span><span>S</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀g. sum g S = sum g (S - vars v) + sum g (vars v)›</span></span></span><span> </span><span>D</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑x∈S. coeff v x * X x)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D</span><span> </span><span>Diff_partition</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Get rid of these synonyms ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Translations of Jordan Normal Forms Matrix Library to Simplex polynomials ›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Vectors ›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Translate rat list to linear polynomial with same coefficients *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>list_to_lpoly</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"list_to_lpoly cs = sum_list (map2 (λ i c. lp_monom c i) [0..&lt;length cs] cs)"</span></span></span><span> 
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>empty_list_0poly</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"list_to_lpoly [] = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>list_to_lpoly_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sum_list_map_upto_coeff_limit</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ≥ length L"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"coeff (list_to_lpoly L) i = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>L</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>list_to_lpoly_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rl_lpoly_coeff_nth_non_empty</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length cs"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cs ≠ []"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"coeff (list_to_lpoly cs) i = cs!i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>cs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_nonempty_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span>rat</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length [x]"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(list_to_lpoly [x]) = lp_monom x 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>list_to_lpoly_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"coeff (list_to_lpoly [x]) i = [x] ! i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹i &lt; length [x]›</span></span></span><span> </span><span>list_to_lpoly_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span>rat</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>xs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"rat list"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs ≠ []"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length xs ⟹ coeff (list_to_lpoly xs) i = xs ! i"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length (xs @ [x])"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">consider</span></span><span> </span><span class="delimiter">(</span><span>le</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length xs"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="delimiter">(</span><span>eq</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"i = length xs"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹i &lt; length (xs @ [x])›</span></span></span><span> </span><span>less_Suc_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"coeff (list_to_lpoly (xs @ [x])) i = (xs @ [x]) ! i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>le</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"coeff (lp_monom x (length xs)) i = 0"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"coeff (sum_list (map2 (λx y. lp_monom y x) 
          [0..&lt;length (xs @ [x])] (xs @ [x]))) i = (xs @ [x]) ! i"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>IH</span><span> </span><span>le</span><span> </span><span>nth_append</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span> </span><span>le</span><span> </span><span>list_to_lpoly_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>list_to_lpoly_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>eq</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"coeff (sum_list (map2 (λx y. lp_monom y x) [0..&lt;length xs] xs)) i = 0"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sum_list_map_upto_coeff_limit</span><span class="delimiter">[</span><span>of</span><span> </span><span>xs</span><span> </span><span>i</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>list_to_lpoly_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>**</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(sum_list (map2 (λ x y. lp_monom y x) [0..&lt;length (xs @ [x])] (xs @ [x]))) = 
          sum_list (map (λ(x,y). lp_monom y x) (zip [0..&lt;length xs] xs)) + lp_monom x (length xs)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"coeff ((list_to_lpoly xs) + lp_monom x (length xs)) i = x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>list_to_lpoly_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>*</span><span> </span><span>**</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eq</span><span> </span><span>list_to_lpoly_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_to_lpoly_coeff_nth</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length cs "</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"coeff (list_to_lpoly cs) i = cs ! i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gr_implies_not0</span><span> </span><span>rl_lpoly_coeff_nth_non_empty</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rat_list_outside_zero</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length cs ≤ i"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"coeff (list_to_lpoly cs) i = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sum_list_map_upto_coeff_limit</span><span class="delimiter">[</span><span>of</span><span> </span><span>cs</span><span> </span><span>i</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Transform linear polynomials to rational vectors ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>dim_poly</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"dim_poly p = (if (vars p) = {} then 0 else Max (vars p)+1)"</span></span></span><span> 
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* 0, 0, 0, 3, 0, 0, … has dimension 4 , consistent with  dim vec  *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>max_dim_poly_list</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"max_dim_poly_list lst = Max {Max (vars p) |p. p ∈ set lst}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>lpoly_to_vec</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"lpoly_to_vec p = vec (dim_poly p) (coeff p)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>all_greater_dim_poly_zero</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≥ dim_poly p"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"coeff p x = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Max_ge</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars p"</span></span></span><span> </span><span>x</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>finite_vars</span><span class="delimiter">[</span><span>of</span><span> </span><span>p</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>coeff_zero</span><span class="delimiter">[</span><span>of</span><span> </span><span>p</span><span> </span><span>x</span><span class="delimiter">]</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_cancel_left_right</span><span> </span><span>assms</span><span> </span><span>dim_poly.elims</span><span> </span><span>empty_iff</span><span> </span><span>leD</span><span> </span><span>le_eq_less_or_eq</span><span> 
</span><span>      </span><span>trans_less_add1</span><span> </span><span>zero_neq_one_class.zero_neq_one</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lpoly_to_vec_0_iff_zero_poly</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(lpoly_to_vec p) = 0<span class="hidden">⇩</span><sub>v</sub> 0 ⟷ p = 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>standard</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lpoly_to_vec p = 0<span class="hidden">⇩</span><sub>v</sub> 0 ⟹ p = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>contrapos_pp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ≠ 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vars p ≠ {}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>vars_empty_zero</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_poly p &gt; 0"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lpoly_to_vec p ≠ 0<span class="hidden">⇩</span><sub>v</sub> 0"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vec_of_dim_0</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"lpoly_to_vec p"</span></span></span><span class="delimiter">]</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>vars_empty_zero</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dim_poly_dim_vec_equiv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"dim_vec (lpoly_to_vec p) = dim_poly p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lpoly_to_vec.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dim_poly_greater_ex_coeff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_poly x &gt; d ⟹ ∃i≥d. coeff x i ≠ 0"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>Max_in</span><span> </span><span>coeff_zero</span><span> </span><span>finite_vars</span><span> </span><span>less_Suc_eq_le</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dimpoly_all_zero_limit</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. i ≥ d ⟹ coeff x i = 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_poly x ≤ d"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀i≥ d. coeff x i = 0) ⟹ dim_poly x ≤ d "</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>contrapos_pp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ dim_poly x ≤ d"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_poly x &gt; d"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃i ≥ d. coeff x i ≠ 0"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dim_poly_greater_ex_coeff</span><span class="delimiter">[</span><span>of</span><span> </span><span>d</span><span> </span><span>x</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ (∀i≥d. coeff x i = 0)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>construct_poly_from_lower_dim_poly</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_poly x = d+1"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>p</span><span> </span><span>c</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_poly p ≤ d"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = p + lp_monom c d"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>c'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>c'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c' = coeff x d"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i&gt;d. coeff x i = 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x = x - (lp_monom c' d) + (lp_monom c' d)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"coeff (x - (lp_monom c' d)) d = 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i≥d. coeff (x - (lp_monom c' d)) i = 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>**</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_poly (x - (lp_monom c' d)) ≤ d"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dimpoly_all_zero_limit</span><span class="delimiter">[</span><span>of</span><span> </span><span>d</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x - (lp_monom c' d))"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>p'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>p'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p' = x - (lp_monom c' d)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃p c. dim_poly p ≤ d ∧ x = p + lp_monom c d"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"*"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"**"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>*</span><span> </span><span>p'</span><span> </span><span>c'</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vars_subset_0_dim_poly</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"vars z ⊆ {0..&lt;dim_poly z}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>finite_vars</span><span> </span><span>less_Suc_eq_le</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_dim_and_not_var_zero</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ {0..&lt;dim_poly z} - vars z ⟹ coeff z x = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>coeff_zero</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valuate_with_dim_poly</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z ⦃ X ⦄ = (∑i∈{0..&lt;dim_poly z}. coeff z i * X i)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eval_poly_with_sum_superset</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"{0..&lt;dim_poly z}"</span></span></span><span> </span><span>z</span><span> </span><span>X</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vars_subset_0_dim_poly</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lin_poly_to_vec_coeff_access</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x &lt; dim_poly y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(lpoly_to_vec y) $ x = coeff y x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x &lt; dim_vec (lpoly_to_vec y)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dim_poly_dim_vec_equiv</span><span class="delimiter">[</span><span>of</span><span> </span><span>y</span><span class="delimiter">]</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>coeff_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>addition_over_lin_poly_to_vec</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a &lt; dim_poly x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_poly x = dim_poly y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"(lpoly_to_vec x + lpoly_to_vec y) $ a = coeff (x + y) a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>lin_poly_to_vec_coeff_access</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>dim_poly_dim_vec_equiv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_to_lpoly_dim_less</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length cs ≥ dim_poly (list_to_lpoly cs)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dimpoly_all_zero_limit</span><span> </span><span>sum_list_map_upto_coeff_limit</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Transform rational vectors to linear polynomials ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>vec_to_lpoly</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"vec_to_lpoly rv = list_to_lpoly (list_of_vec rv)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vec_to_lin_poly_coeff_access</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x &lt; dim_vec y"</span></span></span><span>           
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y $ x = coeff (vec_to_lpoly y) x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>list_to_lpoly_coeff_nth</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>addition_over_vec_to_lin_poly</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a &lt; dim_vec x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec x = dim_vec y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"(x + y) $ a = coeff (vec_to_lpoly x + vec_to_lpoly y) a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>coeff_plus</span><span> </span><span>index_add_vec</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>vec_to_lin_poly_coeff_access</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>outside_list_coeff0</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ≥ dim_vec xs"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"coeff (vec_to_lpoly xs) i = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>sum_list_map_upto_coeff_limit</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vec_to_poly_dim_less</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"dim_poly (vec_to_lpoly x) ≤ dim_vec x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>list_to_lpoly_dim_less</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"list_of_vec x"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vec_to_lpoly_from_lpoly_coeff_dual1</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"coeff (vec_to_lpoly (lpoly_to_vec p)) i = coeff p i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>all_greater_dim_poly_zero</span><span> </span><span>dim_poly_dim_vec_equiv</span><span> </span><span>lin_poly_to_vec_coeff_access</span><span>
</span><span>      </span><span>not_less</span><span> </span><span>outside_list_coeff0</span><span> </span><span>vec_to_lin_poly_coeff_access</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vec_to_lpoly_from_lpoly_coeff_dual2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; dim_vec (lpoly_to_vec (vec_to_lpoly v))"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(lpoly_to_vec (vec_to_lpoly v)) $ i = v $ i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>dim_poly_dim_vec_equiv</span><span> </span><span>less_le_trans</span><span> </span><span>lin_poly_to_vec_coeff_access</span><span> 
</span><span>      </span><span>vec_to_lin_poly_coeff_access</span><span> </span><span>vec_to_poly_dim_less</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vars_subset_dim_vec_to_lpoly_dim</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars (vec_to_lpoly v) ⊆ {0..&lt;dim_vec v}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>ivl_subset</span><span> </span><span>le_numeral_extra</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>order.trans</span><span> </span><span>vec_to_poly_dim_less</span><span>
</span><span>      </span><span>vars_subset_0_dim_poly</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sum_dim_vec_equals_sum_dim_poly</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑a = 0..&lt;dim_vec A. coeff (vec_to_lpoly  A) a * X a) = 
         (∑a = 0..&lt;dim_poly (vec_to_lpoly A). coeff (vec_to_lpoly  A) a * X a)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">consider</span></span><span> </span><span class="delimiter">(</span><span>eq</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec A = dim_poly (vec_to_lpoly A)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>           </span><span class="delimiter">(</span><span>le</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec A &gt; dim_poly (vec_to_lpoly A)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vec_to_poly_dim_less</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"A"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>le</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>dp</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>dp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dp = dim_poly (vec_to_lpoly A)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑a = 0..&lt;dim_vec A. coeff (vec_to_lpoly A) a * X a) = 
          (∑a = 0..&lt;dp. coeff (vec_to_lpoly A) a * X a) +
          (∑a = dp..&lt;dim_vec A. coeff (vec_to_lpoly A) a * X a)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>dp</span><span> </span><span>vec_to_poly_dim_less</span><span> </span><span>sum.atLeastLessThan_concat</span><span> </span><span>zero_le</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑a = 0..&lt;dp. coeff (vec_to_lpoly A) a * X a)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_greater_dim_poly_zero</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>dp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑a = 0..&lt;dim_poly (vec_to_lpoly A).coeff (vec_to_lpoly A) a * X a)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vec_to_lpoly_vNil</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vec_to_lpoly vNil = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>empty_list_0poly</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>zero_vector_is_zero_poly</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"coeff (vec_to_lpoly (0<span class="hidden">⇩</span><sub>v</sub> n)) i = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>index_zero_vec</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>index_zero_vec</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>not_less</span><span> 
</span><span>      </span><span>outside_list_coeff0</span><span> </span><span>vec_to_lin_poly_coeff_access</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>coeff_nonzero_dim_vec_non_zero</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"coeff (vec_to_lpoly v) i ≠ 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v $ i ≠ 0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; dim_vec v"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>leI</span><span> </span><span>outside_list_coeff0</span><span> </span><span>vec_to_lin_poly_coeff_access</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>leI</span><span> </span><span>outside_list_coeff0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lpoly_of_v_equals_v_append0</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"vec_to_lpoly v = vec_to_lpoly (v @<span class="hidden">⇩</span><sub>v</sub> 0<span class="hidden">⇩</span><sub>v</sub> a)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs = ?rhs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i. coeff ?lhs i = coeff ?rhs i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> 
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">consider</span></span><span> </span><span class="delimiter">(</span><span>le</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; dim_vec v"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="delimiter">(</span><span>ge</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ≥ dim_vec v"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>leI</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"coeff (vec_to_lpoly v) i = coeff (vec_to_lpoly (v @<span class="hidden">⇩</span><sub>v</sub> 0<span class="hidden">⇩</span><sub>v</sub> a)) i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>le</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vec_to_lin_poly_coeff_access</span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span> </span><span>v</span><span class="delimiter">]</span><span> </span><span>index_append_vec</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span>  </span><span>index_append_vec</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>vec_to_lin_poly_coeff_access</span><span> </span><span>trans_less_add1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>ge</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"coeff (vec_to_lpoly v) i = 0"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>outside_list_coeff0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"coeff (vec_to_lpoly (v @<span class="hidden">⇩</span><sub>v</sub> 0<span class="hidden">⇩</span><sub>v</sub> a)) i = 0"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>na</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ coeff (vec_to_lpoly (v @<span class="hidden">⇩</span><sub>v</sub> 0<span class="hidden">⇩</span><sub>v</sub> a)) i = 0"</span></span></span><span> 
</span><span>        </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>va</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>v</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"va = coeff (vec_to_lpoly (v @<span class="hidden">⇩</span><sub>v</sub> 0<span class="hidden">⇩</span><sub>v</sub> a)) i"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; dim_vec (v @<span class="hidden">⇩</span><sub>v</sub> 0<span class="hidden">⇩</span><sub>v</sub> a)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>coeff_nonzero_dim_vec_non_zero</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(v @<span class="hidden">⇩</span><sub>v</sub> 0<span class="hidden">⇩</span><sub>v</sub> a)"</span></span></span><span> </span><span>i</span><span class="delimiter">]</span><span> </span><span>na</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(0<span class="hidden">⇩</span><sub>v</sub> a) $ (i - dim_vec v) = va"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ge</span><span> </span><span>diff_is_0_eq'</span><span> </span><span>index_append_vec</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>index_append_vec</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> 
</span><span>              </span><span>not_less_zero</span><span> </span><span>vec_to_lin_poly_coeff_access</span><span> </span><span>v</span><span> </span><span>zero_less_diff</span><span> </span><span>calculation</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"va ≠ 0"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>v</span><span> </span><span>na</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ge</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"coeff (vec_to_lpoly v) i = coeff (vec_to_lpoly (v @<span class="hidden">⇩</span><sub>v</sub> 0<span class="hidden">⇩</span><sub>v</sub> a)) i"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>not_less</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>calculation</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Abstract_Linear_Poly.poly_eqI</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vec_to_lpoly_eval_dot_prod</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"(vec_to_lpoly v) ⦃ x ⦄ = v ∙ (vec (dim_vec v) x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(vec_to_lpoly v) ⦃ x ⦄ = (∑i∈{0..&lt;dim_vec v}. coeff (vec_to_lpoly v) i * x i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eval_poly_with_sum_superset</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"{0..&lt;dim_vec v}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vec_to_lpoly v"</span></span></span><span> </span><span>x</span><span class="delimiter">]</span><span>
</span><span>      </span><span>vars_subset_dim_vec_to_lpoly_dim</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑i∈{0..&lt;dim_vec v}. v$i * x i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>list_to_lpoly_coeff_nth</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... =  v ∙ (vec (dim_vec v) x)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>scalar_prod_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dim_poly_of_append_vec</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"dim_poly (vec_to_lpoly (a@<span class="hidden">⇩</span><sub>v</sub>b)) ≤ dim_vec a + dim_vec b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vec_to_poly_dim_less</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"a@<span class="hidden">⇩</span><sub>v</sub>b"</span></span></span><span class="delimiter">]</span><span> </span><span>index_append_vec</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>a</span><span> </span><span>b</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vec_coeff_append1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ {0..&lt;dim_vec a} ⟹ coeff (vec_to_lpoly (a@<span class="hidden">⇩</span><sub>v</sub>b)) i = a$i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>atLeastLessThan_iff</span><span> </span><span>index_append_vec</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>index_append_vec</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>vec_to_lin_poly_coeff_access</span><span> </span><span>trans_less_add1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vec_coeff_append2</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"i ∈ {dim_vec a..&lt;dim_vec (a@<span class="hidden">⇩</span><sub>v</sub>b)} ⟹ coeff (vec_to_lpoly (a@<span class="hidden">⇩</span><sub>v</sub>b)) i = b$(i-dim_vec a)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>atLeastLessThan_iff</span><span> </span><span>index_append_vec</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>index_append_vec</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>leD</span><span> </span><span>vec_to_lin_poly_coeff_access</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Maybe Code Equation ›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vec_to_lpoly_poly_of_vec_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vec_to_lpoly v = poly_of_vec v"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. i &lt; dim_vec v ⟹ coeff (poly_of_vec v) i = v $ i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>coeff.rep_eq</span><span> </span><span>poly_of_vec.rep_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. i &lt; dim_vec v ⟹ coeff (vec_to_lpoly v) i = v $ i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>vec_to_lin_poly_coeff_access</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. i ≥ dim_vec v ⟹ coeff (poly_of_vec v) i = 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>coeff.rep_eq</span><span> </span><span>poly_of_vec.rep_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. i ≥ dim_vec v ⟹ coeff (vec_to_lpoly v) i = 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>outside_list_coeff0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Abstract_Linear_Poly.poly_eq_iff</span><span> </span><span>le_less_linear</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vars_vec_append_subset</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars (vec_to_lpoly (0<span class="hidden">⇩</span><sub>v</sub> n @<span class="hidden">⇩</span><sub>v</sub> v)) ⊆ {n..&lt;n+dim_vec v}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?p</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(vec_to_lpoly (0<span class="hidden">⇩</span><sub>v</sub> n @<span class="hidden">⇩</span><sub>v</sub> v))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_poly ?p ≤ n+dim_vec v"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dim_poly_of_append_vec</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"0<span class="hidden">⇩</span><sub>v</sub> n"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vars (vec_to_lpoly (0<span class="hidden">⇩</span><sub>v</sub> n @<span class="hidden">⇩</span><sub>v</sub> v)) ⊆ {0..&lt;n+dim_vec v}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vars_subset_dim_vec_to_lpoly_dim</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(0<span class="hidden">⇩</span><sub>v</sub> n @<span class="hidden">⇩</span><sub>v</sub> v)"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i &lt; n. coeff ?p i = 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vec_coeff_append1</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"0<span class="hidden">⇩</span><sub>v</sub> n"</span></span></span><span> </span><span>v</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vars (vec_to_lpoly (0<span class="hidden">⇩</span><sub>v</sub> n @<span class="hidden">⇩</span><sub>v</sub> v)) ⊆ {n..&lt;n+dim_vec v}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>atLeastLessThan_iff</span><span> </span><span>coeff_zero</span><span> </span><span>not_le</span><span> </span><span>subsetCE</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Matrices ›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* ‹ From ‹ mat › to ‹ linear_poly list ›  *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>matrix_to_lpolies</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"matrix_to_lpolies A = map vec_to_lpoly (rows A)"</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>matrix_to_lpolies_vec_of_row</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"i &lt;dim_row A ⟹ matrix_to_lpolies A ! i = vec_to_lpoly (row A i)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>matrix_to_lpolies.simps</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>outside_of_col_range_is_0</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; dim_row A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j ≥ dim_col A"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"coeff ((matrix_to_lpolies A)!i) j = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>outside_list_coeff0</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"col A i"</span></span></span><span> </span><span>j</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>index_row</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>length_rows</span><span> </span><span>matrix_to_lpolies.simps</span><span> </span><span>nth_map</span><span> </span><span>nth_rows</span><span> </span><span>outside_list_coeff0</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>polys_greater_col_zero</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ set (matrix_to_lpolies A)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j ≥ dim_col A"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"coeff x j = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>outside_of_col_range_is_0</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>A</span><span> </span><span>j</span><span class="delimiter">]</span><span> 
</span><span>    </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>matrix_to_lpolies.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>in_set_conv_nth</span><span> </span><span>length_map</span><span> </span><span>length_rows</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>matrix_to_lp_vec_to_lpoly_row</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; dim_row A"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(matrix_to_lpolies A)!i = vec_to_lpoly (row A i)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>matrix_to_lpolies_coeff_access</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; dim_row A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j &lt; dim_col A"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"coeff (matrix_to_lpolies A ! i) j = A $$ (i,j)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>matrix_to_lp_vec_to_lpoly_row</span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span> </span><span>A</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>index_row</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>index_row</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>vec_to_lin_poly_coeff_access</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ From linear polynomial list to matrix ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>lin_polies_to_mat</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"lin_polies_to_mat lst = mat (length lst) (max_dim_poly_list lst) (λ(x,y).coeff (lst!x) y)"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lin_polies_to_rat_mat_coeff_index</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length L"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j &lt;  (max_dim_poly_list L)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"coeff (L ! i) j = (lin_polies_to_mat L) $$ (i,j)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lin_polies_to_mat_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vec_to_lpoly_valuate_equiv_dot_prod</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec y = dim_vec x"</span></span></span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Can be ≥ *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(vec_to_lpoly y) ⦃ ($)x ⦄ = y ∙ x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?p</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"vec_to_lpoly y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?p⦃ ($)x ⦄ = (∑j∈vars?p. coeff ?p j * x$j)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eval_poly_with_sum</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?p</span><span> </span><span class="string"><span class="delete"><span class="delete">"($)x"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vars ?p ⊆ {0..&lt;dim_vec y}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vars_subset_dim_vec_to_lpoly_dim</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?p⦃ ($)x ⦄ = (∑j∈vars?p. coeff ?p j * x$j)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eval_poly_with_sum</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?p</span><span> </span><span class="string"><span class="delete"><span class="delete">"($)x"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑i∈{0..&lt;dim_poly ?p}. coeff ?p i * x$i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valuate_with_dim_poly</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>calculation</span><span> </span><span>sum.cong</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = y ∙ x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀j. j &lt; dim_vec x ⟹ coeff (vec_to_lpoly y) j = y $ j"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>vec_to_lin_poly_coeff_access</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vec_to_lpoly_eval_dot_prod</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"($)x"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>calculation</span><span> </span><span>dim_vec</span><span> </span><span>index_vec</span><span> </span><span>vec_eq_iff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>scalar_prod_def</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>matrix_to_lpolies_valuate_scalarP</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; dim_row A"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_col A = dim_vec x"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(matrix_to_lpolies A!i) ⦃ ($)x ⦄ = (row A i) ∙ x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vec_to_lpoly_valuate_equiv_dot_prod</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"row A i"</span></span></span><span> </span><span>x</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>matrix_to_lpolies_lambda_valuate_scalarP</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; dim_row A"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_col A = dim_vec x"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(matrix_to_lpolies A!i) ⦃ (λi. (if i &lt; dim_vec x then x$i else 0)) ⦄ = (row A i) ∙ x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀j. j &lt; dim_vec x ⟹ x$j = (λi. (if i &lt; dim_vec x then x$i else 0)) j"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?p</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(matrix_to_lpolies A!i)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀j. coeff (matrix_to_lpolies A!i) j ≠ 0 ⟹ j &lt; dim_vec x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>outside_of_col_range_is_0</span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span> </span><span>A</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>leI</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>subs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars ?p ⊆ {0..&lt;dim_vec x}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀j. Abstract_Linear_Poly.coeff (matrix_to_lpolies A ! i) j ≠ 0 ⟹ j &lt; dim_vec x›</span></span></span><span> </span><span>atLeastLessThan_iff</span><span> </span><span>coeff_zero</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀j. j ∈ vars ?p ⟹ x$j = (λi. (if i &lt; dim_vec x then x$i else 0)) j"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀j. Abstract_Linear_Poly.coeff (matrix_to_lpolies A ! i) j ≠ 0 ⟹ j &lt; dim_vec x›</span></span></span><span> </span><span>coeff_zero</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"row A i ∙ x = (?p ⦃ ($) x ⦄)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>matrix_to_lpolies_valuate_scalarP</span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span> </span><span>A</span><span> </span><span>x</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑j∈ vars ?p. coeff ?p j * x$j)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eval_poly_with_sum</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑j∈ vars ?p. coeff ?p j * (λi. (if i &lt; dim_vec x then x$i else 0)) j)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">,</span><span> </span><span>hide_lams</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀j. Abstract_Linear_Poly.coeff (matrix_to_lpolies A ! i) j ≠ 0 ⟹ j &lt; dim_vec x›</span></span></span><span> </span><span>mult.commute</span><span> </span><span>mult_zero_right</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (?p ⦃ (λi. (if i &lt; dim_vec x then x$i else 0)) ⦄)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eval_poly_with_sum</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div><div id="LP_Preliminaries">
<div class="head"><h1>Theory LP_Preliminaries</h1>
<span class="command">theory</span> <span class="name">LP_Preliminaries</span><br/>
<span class="keyword">imports</span> <a href="More_Jordan_Normal_Forms.html"><span class="name">More_Jordan_Normal_Forms</span></a> <a href="Matrix_LinPoly.html"><span class="name">Matrix_LinPoly</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>LP_Preliminaries</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span> 
</span><span>    </span><span>More_Jordan_Normal_Forms</span><span>
</span><span>    </span><span>Matrix_LinPoly</span><span>
</span><span>    </span><span>Jordan_Normal_Form.Matrix_Impl</span><span>
</span><span>    </span><span>Farkas.Simplex_for_Reals</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Mapping"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
        Component wise greater equal constraints for vector b starting at index 
            ‹ [x<span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>n</sub><span class="hidden">⇩</span><sub>d</sub><span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>x</sub>, x<span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>n</sub><span class="hidden">⇩</span><sub>d</sub><span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>x</sub><span class="hidden">⇩</span><sub>+</sub><span class="hidden">⇩</span><sub>1</sub>,…,x<span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>n</sub><span class="hidden">⇩</span><sub>d</sub><span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>x</sub><span class="hidden">⇩</span><sub>+</sub><span class="hidden">⇩</span><sub>n</sub>] ≥ [b<span class="hidden">⇩</span><sub>0</sub>, b<span class="hidden">⇩</span><sub>1</sub>,…,b<span class="hidden">⇩</span><sub>n</sub>] › 
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>vars_from_index_geq_vec</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"vars_from_index_geq_vec index b = [GEQ (lp_monom 1 (i+index)) (b$i). i ← [0..&lt;dim_vec b]]"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>constraints_set_vars_geq_vec_def</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"set (vars_from_index_geq_vec start b) = 
   {GEQ (lp_monom 1 (i+start)) (b$i) |i. i ∈ {0..&lt;dim_vec b}}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>set_comprehension_list_comprehension</span><span class="delimiter">[</span><span>of</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"(λi. GEQ (lp_monom 1 (i+start)) (b$i))"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec b"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vars_from_index_geq_sat</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨x⟩ ⊨<span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> set (vars_from_index_geq_vec start b)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; dim_vec b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨x⟩ (i+start) ≥ b$i"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>e_e</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"GEQ (lp_monom 1 (i+start)) (b$i) ∈ set (vars_from_index_geq_vec start b)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>constraints_set_vars_geq_vec_def</span><span class="delimiter">[</span><span>of</span><span> </span><span>start</span><span> </span><span>b</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨x⟩ ⊨<span class="hidden">⇩</span><sub>c</sub> GEQ (lp_monom 1 (i+start)) (b$i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(lp_monom 1 (i+start)) ⦃⟨x⟩⦄ ≥ (b$i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>satisfies_constraint.simps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨x⟩"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lp_monom 1 (i + start)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b$i"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Matrix A less equal vector b (A ≤ b):
           a1 b1 c1 d1 ∙ X ≤ b_1,
           a2 b2 c2 d2 ∙ X ≤ b_2,
           ...
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>mat_x_leq_vec</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"mat_x_leq_vec A b = [LEQ (matrix_to_lpolies A!i) (b$i) . i &lt;- [0..&lt;dim_vec b]]"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mat_x_leq_vec_sol</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨x⟩ ⊨<span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> set (mat_x_leq_vec A b)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; dim_vec b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"((matrix_to_lpolies A)!i) ⦃⟨x⟩⦄ ≤ b$i"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>e_e</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"LEQ ((matrix_to_lpolies A)!i) (b$i) ∈ set (mat_x_leq_vec A b)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨x⟩ ⊨<span class="hidden">⇩</span><sub>c</sub> LEQ ((matrix_to_lpolies A)!i) (b$i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>satisfies_constraint.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Matrix A less equal vector b (A = b):
           a1 b1 c1 d1 ∙ X = b_1,
           a2 b2 c2 d2 ∙ X = b_2,
           ... 
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>x_mat_eq_vec</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"x_mat_eq_vec b A = [EQ (matrix_to_lpolies A!i) (b$i) . i &lt;- [0..&lt;dim_vec b]]"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>x_mat_eq_vec_sol</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊨<span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> set (x_mat_eq_vec b A)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; dim_vec b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"((matrix_to_lpolies A)!i) ⦃ x ⦄ = b$i"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>e_e</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"EQ ((matrix_to_lpolies A)!i) (b$i) ∈ set (x_mat_eq_vec b A)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊨<span class="hidden">⇩</span><sub>c</sub> EQ ((matrix_to_lpolies A)!i) (b$i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>satisfies_constraint.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Get different matrices into same space, without interference ›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Given matrix A and B create: 
               A 0
               0 B  
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>two_block_non_interfering</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"two_block_non_interfering A B = (let z1 = 0<span class="hidden">⇩</span><sub>m</sub> (dim_row A) (dim_col B);
                                        z2 = 0<span class="hidden">⇩</span><sub>m</sub> (dim_row B) (dim_col A) in
                                    four_block_mat A z1 z2 B)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>split_two_block_non_interfering</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"split_block (two_block_non_interfering A B) (dim_row A) (dim_col A) = (Q1, Q2, Q3, Q4)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Q1 = A"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Q4 = B"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split_four_block_dual_fst_lst</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>B</span><span> </span><span>Q1</span><span> </span><span>Q2</span><span> </span><span>Q3</span><span> </span><span>Q4</span><span class="delimiter">]</span><span> 
</span><span>    </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>two_block_non_interfering_dims</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"dim_row (two_block_non_interfering A B) = dim_row A + dim_row B"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"dim_col (two_block_non_interfering A B) = dim_col A + dim_col B"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>two_block_non_interfering_zeros_are_0</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; dim_row A"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j ≥ dim_col A"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j &lt; dim_col (two_block_non_interfering A B)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(two_block_non_interfering A B)$$(i,j) = 0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(two_block_non_interfering A B)$$(i,j) = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>four_block_mat_def</span><span> </span><span>assms</span><span> </span><span>two_block_non_interfering_dims</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span> </span><span>B</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>two_block_non_interfering_row_comp1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt;dim_row A"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"row (two_block_non_interfering A B) i = row A i @<span class="hidden">⇩</span><sub>v</sub> (0<span class="hidden">⇩</span><sub>v</sub> (dim_col B))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>two_block_non_interfering_row_comp2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt;dim_row (two_block_non_interfering A B)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ≥ dim_row A"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"row (two_block_non_interfering A B) i = (0<span class="hidden">⇩</span><sub>v</sub> (dim_col A)) @<span class="hidden">⇩</span><sub>v</sub> row B (i - dim_row A)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>first_vec_two_block_non_inter_is_first_vec</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_col A + dim_col B = dim_vec v"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_row A = n"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vec_first (two_block_non_interfering A B *<span class="hidden">⇩</span><sub>v</sub> v) n = A *<span class="hidden">⇩</span><sub>v</sub> (vec_first v (dim_col A))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; dim_vec (A *<span class="hidden">⇩</span><sub>v</sub> vec_first v (dim_col A))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?tb</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"two_block_non_interfering A B"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>i_n</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; n"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vec_first (?tb *<span class="hidden">⇩</span><sub>v</sub> v) n $ i = vec_first (vec (dim_row ?tb) (λ i. row ?tb i ∙ v)) n $ i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mult_mat_vec_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (vec n  (λ i. row ?tb i ∙ v)) $ i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vec_first_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>trans_less_add1</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>dim_mult_mat_vec</span><span> </span><span>index_vec</span><span>  </span><span>two_block_non_interfering_dims</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = row ?tb i ∙ v"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>i_n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (row A i @<span class="hidden">⇩</span><sub>v</sub> 0<span class="hidden">⇩</span><sub>v</sub> (dim_col B)) ∙ v"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>i_n</span><span> </span><span>two_block_non_interfering_row_comp1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = row A i ∙ vec_first v (dim_vec (row A i)) + 
                   0<span class="hidden">⇩</span><sub>v</sub> (dim_col B) ∙ vec_last v (dim_vec (0<span class="hidden">⇩</span><sub>v</sub> (dim_col B)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>append_split_vec_distrib_scalar_prod</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"row A i"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0<span class="hidden">⇩</span><sub>v</sub> (dim_col B)"</span></span></span><span> </span><span>v</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vec_first (two_block_non_interfering A B *<span class="hidden">⇩</span><sub>v</sub> v) n $ i = 
             row A i ∙ vec_first v (dim_vec (row A i))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>calculation</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vec_first (two_block_non_interfering A B *<span class="hidden">⇩</span><sub>v</sub> v) n $ i = 
             (A *<span class="hidden">⇩</span><sub>v</sub> vec_first v (dim_col A)) $ i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>i_n</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec (A *<span class="hidden">⇩</span><sub>v</sub> v) = dim_row A"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dim_vec_def</span><span> </span><span>dim_mult_mat_vec</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span> </span><span>v</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec (vec_first (two_block_non_interfering A B *<span class="hidden">⇩</span><sub>v</sub> v) n) = n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec (vec_first (two_block_non_interfering A B *<span class="hidden">⇩</span><sub>v</sub> v) n) = 
             dim_vec (A *<span class="hidden">⇩</span><sub>v</sub> vec_first v (dim_col A))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>last_vec_two_block_non_inter_is_last_vec</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_col A + dim_col B = dim_vec v"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_row B = n"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vec_last ((two_block_non_interfering A B) *<span class="hidden">⇩</span><sub>v</sub> v) n = B *<span class="hidden">⇩</span><sub>v</sub> (vec_last v (dim_col B))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; dim_vec (B *<span class="hidden">⇩</span><sub>v</sub> vec_last v (dim_col B))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?tb</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"two_block_non_interfering A B"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?vl</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(vec (dim_row ?tb) (λ i. row ?tb i ∙ v))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>i_n</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; n"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>in3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(dim_row ?tb) - n + i ≥ dim_row A"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>in3'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(dim_row ?tb) - n + i &lt; dim_row ?tb"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>i_n</span><span> </span><span>two_block_non_interfering_dims</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_row A + n = dim_row (two_block_non_interfering A B)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>two_block_non_interfering_dims</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dim_a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_row A = dim_row (two_block_non_interfering A B) - n"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>diff_add_inverse2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vec_last (?tb *<span class="hidden">⇩</span><sub>v</sub> v) n $ i = vec_last (vec (dim_row ?tb) (λ i. row ?tb i ∙ v)) n $ i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mult_mat_vec_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = ?vl $ (dim_vec ?vl - n + i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vec_last_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i_n</span><span> </span><span>index_vec</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = row ?tb ((dim_row ?tb) - n + i) ∙ v"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>index_vec</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>i_n</span><span> </span><span>two_block_non_interfering_dims</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = row B i ∙ vec_last v (dim_vec (row B i))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec (0<span class="hidden">⇩</span><sub>v</sub> (dim_col A) @<span class="hidden">⇩</span><sub>v</sub> row B i) = dim_vec v"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹dim_col A + dim_col B = dim_vec v›</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dim_a</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>in3'</span><span> </span><span>two_block_non_interfering_row_comp2</span><span>
</span><span>        </span><span>append_split_vec_distrib_scalar_prod</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"0<span class="hidden">⇩</span><sub>v</sub> (dim_col A)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"row B i"</span></span></span><span> </span><span>v</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add.commute</span><span> </span><span>add.right_neutral</span><span> </span><span>diff_add_inverse</span><span>
</span><span>          </span><span>in3</span><span> </span><span>index_zero_vec</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>scalar_prod_left_zero</span><span>  </span><span>vec_first_carrier</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = row B i ∙ vec_last v (dim_col B)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vec_last (two_block_non_interfering A B *<span class="hidden">⇩</span><sub>v</sub> v) n $ i = (B *<span class="hidden">⇩</span><sub>v</sub> vec_last v (dim_col B)) $ i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>calculation</span><span> </span><span>i_n</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>two_block_non_interfering_mult_decomposition</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_col A + dim_col B = dim_vec v"</span></span></span><span>      
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"two_block_non_interfering A B *<span class="hidden">⇩</span><sub>v</sub> v =
         A *<span class="hidden">⇩</span><sub>v</sub> vec_first v (dim_col A) @<span class="hidden">⇩</span><sub>v</sub> B *<span class="hidden">⇩</span><sub>v</sub> vec_last v (dim_col B)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?tb</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"two_block_non_interfering A B"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>first_vec_two_block_non_inter_is_first_vec</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span> </span><span>B</span><span> </span><span>v</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_row A"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vec_first (?tb *<span class="hidden">⇩</span><sub>v</sub> v) (dim_row A) = A *<span class="hidden">⇩</span><sub>v</sub> vec_first v (dim_col A)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>last_vec_two_block_non_inter_is_last_vec</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span> </span><span>B</span><span> </span><span>v</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_row B"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vec_last (?tb *<span class="hidden">⇩</span><sub>v</sub> v) (dim_row B) = B *<span class="hidden">⇩</span><sub>v</sub> vec_last v (dim_col B)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vec_first_last_append</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"?tb *<span class="hidden">⇩</span><sub>v</sub> v"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(dim_row A)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(dim_row B)"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span>dim_mult_mat_vec</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"?tb"</span></span></span><span> </span><span>v</span><span class="delimiter">]</span><span> </span><span>two_block_non_interfering_dims</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span> </span><span>B</span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>carrier_vec_dim_vec</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* A ≤ b   
   A = c *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>mat_leqb_eqc</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"mat_leqb_eqc A b c = (let lst = matrix_to_lpolies (two_block_non_interfering A A<span class="hidden">⇧</span><sup>T</sup>) in
                         [LEQ (lst!i) (b$i) . i &lt;- [0..&lt;dim_vec b]] @
                         [EQ  (lst!i) ((b@<span class="hidden">⇩</span><sub>v</sub>c)$i) . i &lt;- [dim_vec b ..&lt; dim_vec (b@<span class="hidden">⇩</span><sub>v</sub>c)]])"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mat_leqb_eqc_for_LEQ</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; dim_vec b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; dim_row A"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(mat_leqb_eqc A b c)!i = LEQ ((matrix_to_lpolies A)!i) (b$i)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>lst</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>lst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lst = (mat_leqb_eqc A b c)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>l</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"l = matrix_to_lpolies (two_block_non_interfering A A<span class="hidden">⇧</span><sup>T</sup>)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ileqA</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; dim_row A"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"l!i = vec_to_lpoly ((row A i)@<span class="hidden">⇩</span><sub>v</sub> 0<span class="hidden">⇩</span><sub>v</sub> (dim_row A))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>l</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>two_block_non_interfering_row_comp1</span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span> </span><span>A</span><span> </span><span class="string"><span class="delete"><span class="delete">"A<span class="hidden">⇧</span><sup>T</sup>"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>ileqA</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ileqA</span><span> </span><span>lpoly_of_v_equals_v_append0</span><span> </span><span>matrix_to_lp_vec_to_lpoly_row</span><span> 
</span><span>        </span><span>trans_less_add1</span><span> </span><span>two_block_non_interfering_dims</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>leq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"l!i = (matrix_to_lpolies A)!i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lpoly_of_v_equals_v_append0</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"row A i"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(dim_row A)"</span></span></span><span class="delimiter">]</span><span> </span><span>l</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ileqA</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lst = [LEQ (l!i) (b$i) . i &lt;- [0..&lt;dim_vec b]] @
                         [EQ  (l!i) ((b@<span class="hidden">⇩</span><sub>v</sub>c)$i) . i &lt;- [dim_vec b ..&lt; dim_vec (b@<span class="hidden">⇩</span><sub>v</sub>c)] ]"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>l</span><span> </span><span>lst</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mat_leqb_eqc.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"([LEQ (l!i) (b$i). i &lt;- [0..&lt;dim_vec b]] @ 
         [EQ (l!i) ((b@<span class="hidden">⇩</span><sub>v</sub>c)$i). i &lt;- [dim_vec b ..&lt; dim_vec (b@<span class="hidden">⇩</span><sub>v</sub>c)]]) ! i = 
         [LEQ (l!i) (b$i). i &lt;- [0..&lt;dim_vec b]]!i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>lst</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>nth_append</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = LEQ (l!i) (b$i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l</span><span> </span><span>lst</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"*"</span></span></span><span> </span><span>leq</span><span> </span><span>lst</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mat_leqb_eqc.simps</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span> </span><span>b</span><span> </span><span>c</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mat_leqb_eqc_for_EQ</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec b ≤ i"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; dim_vec (b@<span class="hidden">⇩</span><sub>v</sub>c)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_row A = dim_vec b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_col A ≥ dim_vec c"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(mat_leqb_eqc A b c)!i = 
    EQ (vec_to_lpoly (0<span class="hidden">⇩</span><sub>v</sub> (dim_col A) @<span class="hidden">⇩</span><sub>v</sub> row A<span class="hidden">⇧</span><sup>T</sup> (i-dim_vec b))) (c$(i-dim_vec b))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>lst</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>lst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lst = (mat_leqb_eqc A b c)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>l</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"l = matrix_to_lpolies (two_block_non_interfering A A<span class="hidden">⇧</span><sup>T</sup>)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>i_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; dim_row (two_block_non_interfering A A<span class="hidden">⇧</span><sup>T</sup>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>two_block_non_interfering_dims</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>l'</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"l!i = vec_to_lpoly ((0<span class="hidden">⇩</span><sub>v</sub> (dim_col A)) @<span class="hidden">⇩</span><sub>v</sub> (row A<span class="hidden">⇧</span><sup>T</sup> (i - dim_vec b)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l</span><span> </span><span>two_block_non_interfering_row_comp2</span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span> </span><span>A</span><span> </span><span class="string"><span class="delete"><span class="delete">"A<span class="hidden">⇧</span><sup>T</sup>"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>i_s</span><span class="delimiter">]</span><span>
</span><span>      </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>i_s</span><span> </span><span>matrix_to_lp_vec_to_lpoly_row</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"([LEQ (l!i) (b$i) . i &lt;- [0..&lt;dim_vec b]] @
                         [EQ  (l!i) ((b@<span class="hidden">⇩</span><sub>v</sub>c)$i) . i &lt;- [dim_vec b ..&lt; dim_vec (b@<span class="hidden">⇩</span><sub>v</sub>c)]])!i =
        [EQ  (l!i) ((b@<span class="hidden">⇩</span><sub>v</sub>c)$i) . i &lt;- [dim_vec b..&lt; dim_vec (b@<span class="hidden">⇩</span><sub>v</sub>c)]] ! (i - dim_vec b)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>leD</span><span> </span><span>nth_append</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = EQ (l!i) ((b@<span class="hidden">⇩</span><sub>v</sub>c)$i)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = EQ (l!i) (c$(i-dim_vec b))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mat_leqb_eqc.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>calculation</span><span> </span><span>l</span><span> </span><span>l'</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mat_leqb_eqc_satisfies1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊨<span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> set (mat_leqb_eqc A b c)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; dim_vec b"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; dim_row A"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(matrix_to_lpolies A!i) ⦃x⦄ ≤ b$i"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>e_e</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"LEQ (matrix_to_lpolies A ! i) (b$i) ∈ set (mat_leqb_eqc A b c)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mat_leqb_eqc_for_LEQ</span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span> </span><span>b</span><span> </span><span>A</span><span> </span><span>c</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span> 
</span><span>      </span><span>nth_mem</span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span> </span><span class="string"><span class="delete"><span class="delete">"matrix_to_lpolies A"</span></span></span><span class="delimiter">]</span><span> </span><span>mat_leqb_eqc.simps</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>diff_zero</span><span> </span><span>in_set_conv_nth</span><span> </span><span>length_append</span><span> </span><span>length_map</span><span> 
</span><span>        </span><span>length_upt</span><span> </span><span>trans_less_add1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊨<span class="hidden">⇩</span><sub>c</sub> LEQ ((matrix_to_lpolies A)!i) (b$i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>satisfies_constraint.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mat_leqb_eqc_satisfies2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊨<span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> set (mat_leqb_eqc A b c)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec b ≤ i"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; dim_vec (b@<span class="hidden">⇩</span><sub>v</sub>c)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_row A = dim_vec b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec c ≤ dim_col A"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(matrix_to_lpolies (two_block_non_interfering A A<span class="hidden">⇧</span><sup>T</sup>) ! i) ⦃x⦄ = (b @<span class="hidden">⇩</span><sub>v</sub> c) $ i"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>e_e</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"EQ (vec_to_lpoly (0<span class="hidden">⇩</span><sub>v</sub> (dim_col A) @<span class="hidden">⇩</span><sub>v</sub> row A<span class="hidden">⇧</span><sup>T</sup> (i - dim_vec b))) (c $ (i - dim_vec b))
              ∈ set (mat_leqb_eqc A b c)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>mat_leqb_eqc.simps</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span> </span><span>b</span><span> </span><span>c</span><span class="delimiter">]</span><span> 
</span><span>      </span><span>nth_mem</span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span> </span><span class="string"><span class="delete"><span class="delete">"(mat_leqb_eqc A b c)"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>mat_leqb_eqc_for_EQ</span><span class="delimiter">[</span><span>of</span><span> </span><span>b</span><span> </span><span>i</span><span> </span><span>c</span><span> </span><span>A</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>add_diff_cancel_left'</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>diff_zero</span><span> </span><span>index_append_vec</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> 
</span><span>        </span><span>length_append</span><span> </span><span>length_map</span><span> </span><span>length_upt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>sateq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊨<span class="hidden">⇩</span><sub>c</sub> EQ (vec_to_lpoly (0<span class="hidden">⇩</span><sub>v</sub> (dim_col A) @<span class="hidden">⇩</span><sub>v</sub> 
                row A<span class="hidden">⇧</span><sup>T</sup> (i - dim_vec b))) (c $ (i - dim_vec b))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; dim_row (two_block_non_interfering A A<span class="hidden">⇧</span><sup>T</sup>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>dual_order.order_iff_strict</span><span> </span><span>dual_order.strict_trans</span><span> 
</span><span>        </span><span>index_append_vec</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>index_transpose_mat</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>nat_add_left_cancel_less</span><span> 
</span><span>        </span><span>two_block_non_interfering_dims</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>**</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_row A ≤ i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊨<span class="hidden">⇩</span><sub>c</sub> EQ ((matrix_to_lpolies (two_block_non_interfering A A<span class="hidden">⇧</span><sup>T</sup>))!i) ((b@<span class="hidden">⇩</span><sub>v</sub>c)$i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>two_block_non_interfering_row_comp2</span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span> </span><span>A</span><span> </span><span class="string"><span class="delete"><span class="delete">"A<span class="hidden">⇧</span><sup>T</sup>"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>*</span><span> </span><span>**</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="string"><span class="delete"><span class="delete">"*"</span></span></span><span> </span><span>sateq</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>index_append_vec</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>index_append_vec</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>leD</span><span>
</span><span>        </span><span>matrix_to_lp_vec_to_lpoly_row</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>satisfies_constraint.simps</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mat_leqb_eqc_simplex_satisfies2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"simplex (mat_leqb_eqc A b c) = Sat x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec b ≤ i"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; dim_vec (b@<span class="hidden">⇩</span><sub>v</sub>c)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_row A = dim_vec b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec c ≤ dim_col A"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(matrix_to_lpolies (two_block_non_interfering A A<span class="hidden">⇧</span><sup>T</sup>) ! i) ⦃⟨x⟩⦄ = (b @<span class="hidden">⇩</span><sub>v</sub> c) $ i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mat_leqb_eqc_satisfies2</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>simplex</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>index_geq_n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"index_geq_n i n = GEQ (lp_monom 1 i) n"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>index_geq_n_simplex</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨x⟩  ⊨<span class="hidden">⇩</span><sub>c</sub> (index_geq_n i n)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨x⟩ i ≥ n"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* In the variables x_i to x_i+(length v) we synthesise a vector that is pointwise
       greater than v *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>from_index_geq0_vector</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"from_index_geq0_vector i v = [GEQ (lp_monom 1 (i+j)) (v$j) . j &lt;-[0..&lt;dim_vec v]]"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>from_index_geq_vector_simplex</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊨<span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> set (from_index_geq0_vector i v)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"j &lt; dim_vec v"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x (i + j) ≥ v$j"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"GEQ (lp_monom 1 (i+j)) (v$j)∈ set (from_index_geq0_vector i v)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊨<span class="hidden">⇩</span><sub>c</sub> GEQ (lp_monom 1 (i+j)) (v$j)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>calculation</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>from_index_geq0_vector_simplex2</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨x⟩ ⊨<span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> set (from_index_geq0_vector i v)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ≤ j"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j &lt; (dim_vec v) + i"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨x⟩ j ≥ v$(j - i)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>from_index_geq_vector_simplex</span><span> 
</span><span>      </span><span>le_add_diff_inverse</span><span> </span><span>less_diff_conv2</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* [c1, ... cm, 01, ... 0n] * X ≥ [01, ... 0m, b1,...,bn] * X *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>x_times_c_geq_y_times_b</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"x_times_c_geq_y_times_b c b = GEQPP (vec_to_lpoly (c @<span class="hidden">⇩</span><sub>v</sub> 0<span class="hidden">⇩</span><sub>v</sub> (dim_vec b)))
                                       (vec_to_lpoly (0<span class="hidden">⇩</span><sub>v</sub> (dim_vec c) @<span class="hidden">⇩</span><sub>v</sub> b))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>x_times_c_geq_y_times_b_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"simplex [x_times_c_geq_y_times_b c b] = Sat x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"((vec_to_lpoly (c @<span class="hidden">⇩</span><sub>v</sub> 0<span class="hidden">⇩</span><sub>v</sub> (dim_vec b))) ⦃ ⟨x⟩ ⦄) ≥
         ((vec_to_lpoly (0<span class="hidden">⇩</span><sub>v</sub> (dim_vec c) @<span class="hidden">⇩</span><sub>v</sub> b)) ⦃ ⟨x⟩ ⦄)"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>simplex</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Splitting an assignment into two vectors *)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* The first [0...(i-1)] elements and [i...j] elements *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>split_i_j_x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"split_i_j_x i j x = (vec i ⟨x⟩, vec (j - i) (λy. ⟨x⟩ (y+i)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>split_n_m_x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"split_n_m_x n m x ≡ split_i_j_x n (n+m) x"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>split_vec_dims</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"split_i_j_x i j x = (a ,b)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec a = i"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec b = (j - i)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>split_i_j_x_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>split_n_m_x_abbrev_dims</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"split_n_m_x n m x = (a, b)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec a = n"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec b = m"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split_vec_dims</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>split_vec_dims</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>split_access_fst_1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k &lt; i"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"split_i_j_x i j x = (a, b)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a $ k = ⟨x⟩ k"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Pair_inject</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>index_vec</span><span> </span><span>split_i_j_x_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>split_access_snd_1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ≤ k"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k &lt; j"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"split_i_j_x i j x = (a, b)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b $ (k - i) = ⟨x⟩ k"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vec (j - i) (λn. ⟨x⟩ (n + i)) = b"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>prod.sel</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>split_i_j_x_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>split_access_fst_2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) = split_i_j_x i j Z"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k &lt; dim_vec x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x$k = ⟨Z⟩ k"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>split_access_fst_1</span><span> </span><span>split_vec_dims</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>split_access_snd_2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) = split_i_j_x i j Z"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k &lt; dim_vec y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y$k = ⟨Z⟩ (k+dim_vec x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>split_i_j_x_def</span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span> </span><span>j</span><span> </span><span>Z</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>from_index_geq0_vector_split_snd</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨X⟩ ⊨<span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> set (from_index_geq0_vector d v)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) = split_n_m_x d m X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. i &lt; dim_vec v ⟹ i &lt; m ⟹ y$i ≥ v$i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>split_i_j_x_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>from_index_geq_vector_simplex</span><span class="delimiter">[</span><span>of</span><span> </span><span>d</span><span> </span><span>v</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨X⟩"</span></span></span><span> </span><span>_</span><span class="delimiter">]</span><span> </span><span>index_vec</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add.commute</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>split_coeff_vec_index_sum</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x,y) = split_i_j_x (dim_vec (lpoly_to_vec v)) l X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑i = 0..&lt;dim_vec x. Abstract_Linear_Poly.coeff v i * ⟨X⟩ i) = 
         (∑i = 0..&lt;dim_vec x. lpoly_to_vec v $ i * x $ i)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>valuate_with_dim_poly</span><span class="delimiter">[</span><span>of</span><span> </span><span>v</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨X⟩"</span></span></span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑i = 0..&lt;dim_vec x. (lpoly_to_vec v) $ i * ⟨X⟩ i) = 
        (∑i = 0..&lt;dim_vec x. (lpoly_to_vec v) $ i * x $ i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>assms</span><span> </span><span>split_access_fst_1</span><span> </span><span>split_vec_dims</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>sum.ivl_cong</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>assms</span><span> </span><span>dim_poly_dim_vec_equiv</span><span> 
</span><span>        </span><span>lin_poly_to_vec_coeff_access</span><span> </span><span>split_vec_dims</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>sum.ivl_cong</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>scalar_prod_valuation_after_split_equiv1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x,y) = split_i_j_x (dim_vec (lpoly_to_vec v)) l X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(lpoly_to_vec v) ∙ x = (v ⦃⟨X⟩⦄)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>valuate_with_dim_poly</span><span class="delimiter">[</span><span>of</span><span> </span><span>v</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨X⟩"</span></span></span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(v ⦃⟨X⟩⦄) = (∑i = 0..&lt;dim_poly v. Abstract_Linear_Poly.coeff v i * ⟨X⟩ i)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑i = 0..&lt;dim_vec x. (lpoly_to_vec v) $ i * ⟨X⟩ i) = 
    (∑i = 0..&lt;dim_vec x. (lpoly_to_vec v) $ i * x $ i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>assms</span><span> </span><span>split_access_fst_1</span><span> </span><span>split_vec_dims</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>sum.ivl_cong</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... =  (lpoly_to_vec v) ∙ x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>scalar_prod_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"1"</span></span></span><span> </span><span>dim_poly_dim_vec_equiv</span><span> </span><span>lin_poly_to_vec_coeff_access</span><span> 
</span><span>        </span><span>split_vec_dims</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>sum.ivl_cong</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>mat_times_vec_leq</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"[_*<span class="hidden">⇩</span><sub>v</sub>_]≤_"</span></span></span><span> </span><span class="delimiter">[</span><span>1000</span><span class="delimiter">,</span><span>1000</span><span class="delimiter">,</span><span>100</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"[A *<span class="hidden">⇩</span><sub>v</sub> x]≤b ⟷ (∀i &lt; dim_vec b. (A *<span class="hidden">⇩</span><sub>v</sub> x)$i ≤ b$i) ∧
                    (dim_row A = dim_vec b) ∧
                    (dim_col A = dim_vec x)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>vec_times_mat_eq</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"[_<span class="hidden">⇩</span><sub>v</sub>*_]=_"</span></span></span><span> </span><span class="delimiter">[</span><span>1000</span><span class="delimiter">,</span><span>1000</span><span class="delimiter">,</span><span>100</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"[y <span class="hidden">⇩</span><sub>v</sub>* A]=c ⟷ (∀i &lt; dim_vec c. (A<span class="hidden">⇧</span><sup>T</sup> *<span class="hidden">⇩</span><sub>v</sub> y)$i = c$i) ∧
                    (dim_col A<span class="hidden">⇧</span><sup>T</sup> = dim_vec y) ∧
                    (dim_row A<span class="hidden">⇧</span><sup>T</sup> = dim_vec c)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>vec_times_mat_leq</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"[_<span class="hidden">⇩</span><sub>v</sub>*_]≤_"</span></span></span><span> </span><span class="delimiter">[</span><span>1000</span><span class="delimiter">,</span><span>1000</span><span class="delimiter">,</span><span>100</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"[y <span class="hidden">⇩</span><sub>v</sub>* A]≤c ⟷ (∀i &lt; dim_vec c. (A<span class="hidden">⇧</span><sup>T</sup> *<span class="hidden">⇩</span><sub>v</sub> y)$i ≤ c$i) ∧
                    (dim_col A<span class="hidden">⇧</span><sup>T</sup> = dim_vec y) ∧
                    (dim_row A<span class="hidden">⇧</span><sup>T</sup> = dim_vec c)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mat_times_vec_leqI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_row A = dim_vec b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_col A = dim_vec x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. i &lt; dim_vec b ⟹ (A *<span class="hidden">⇩</span><sub>v</sub> x)$i ≤ b$i"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[A *<span class="hidden">⇩</span><sub>v</sub> x]≤b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mat_times_vec_leq_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mat_times_vec_leqD</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[A *<span class="hidden">⇩</span><sub>v</sub> x]≤b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_row A = dim_vec b"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_col A = dim_vec x"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. i &lt; dim_vec b ⟹ (A *<span class="hidden">⇩</span><sub>v</sub> x)$i ≤ b$i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>mat_times_vec_leq_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vec_times_mat_eqD</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[y <span class="hidden">⇩</span><sub>v</sub>* A]=c"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀i &lt; dim_vec c. (A<span class="hidden">⇧</span><sup>T</sup> *<span class="hidden">⇩</span><sub>v</sub> y)$i = c$i)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(dim_col A<span class="hidden">⇧</span><sup>T</sup> = dim_vec y)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(dim_row A<span class="hidden">⇧</span><sup>T</sup> = dim_vec c)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>vec_times_mat_eq_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vec_times_mat_leqD</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[y <span class="hidden">⇩</span><sub>v</sub>* A]≤c"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀i &lt; dim_vec c. (A<span class="hidden">⇧</span><sup>T</sup> *<span class="hidden">⇩</span><sub>v</sub> y)$i ≤ c$i)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(dim_col A<span class="hidden">⇧</span><sup>T</sup> = dim_vec y)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(dim_row A<span class="hidden">⇧</span><sup>T</sup> = dim_vec c)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>vec_times_mat_leq_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mat_times_vec_eqI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_col A<span class="hidden">⇧</span><sup>T</sup> = dim_vec x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_row A<span class="hidden">⇧</span><sup>T</sup> = dim_vec c"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. i &lt; dim_vec c ⟹ (A<span class="hidden">⇧</span><sup>T</sup> *<span class="hidden">⇩</span><sub>v</sub> x)$i = c$i"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[x <span class="hidden">⇩</span><sub>v</sub>* A]=c"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vec_times_mat_eq_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mat_leqb_eqc_split_correct1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec b = dim_row A"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨X⟩ ⊨<span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> set (mat_leqb_eqc A b c)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x,y) = split_i_j_x (dim_col A) l X"</span></span></span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[A *<span class="hidden">⇩</span><sub>v</sub> x]≤b"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>standard</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>2</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>split_i_j_x_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split_vec_dims</span><span class="delimiter">[</span><span>of</span><span>  </span><span>0</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_col A"</span></span></span><span> </span><span>X</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>3</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>mat_leqb_eqc_satisfies1</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨X⟩"</span></span></span><span> </span><span>i</span><span class="delimiter">]</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>m</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(matrix_to_lpolies A ! i) ⦃ ⟨X⟩ ⦄ ≤ b $ i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>leq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_poly (vec_to_lpoly (row A i)) ≤ dim_col A"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vec_to_poly_dim_less</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"row A i"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; dim_row A"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"3"</span></span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>two_block_non_interfering_row_comp1</span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span> </span><span>A</span><span> </span><span class="string"><span class="delete"><span class="delete">"A<span class="hidden">⇧</span><sup>T</sup>"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"row (two_block_non_interfering A A<span class="hidden">⇧</span><sup>T</sup>) i = row A i @<span class="hidden">⇩</span><sub>v</sub> 0<span class="hidden">⇩</span><sub>v</sub> (dim_col A<span class="hidden">⇧</span><sup>T</sup>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"3"</span></span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(vec_to_lpoly (row A i @<span class="hidden">⇩</span><sub>v</sub> 0<span class="hidden">⇩</span><sub>v</sub> (dim_col A<span class="hidden">⇧</span><sup>T</sup>))) ⦃⟨X⟩⦄ = ((vec_to_lpoly (row A i)) ⦃⟨X⟩⦄)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lpoly_of_v_equals_v_append0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑a = 0..&lt;dim_poly (vec_to_lpoly (row A i)). 
                      Abstract_Linear_Poly.coeff (vec_to_lpoly (row A i)) a * ⟨X⟩ a)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valuate_with_dim_poly</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"vec_to_lpoly (row A i)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨X⟩"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑a = 0..&lt;dim_col A. Abstract_Linear_Poly.coeff (vec_to_lpoly (row A i)) a * ⟨X⟩ a)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split_coeff_vec_index_sum</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">]</span><span>
</span><span>      </span><span>sum_dim_vec_equals_sum_dim_poly</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"row A i"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨X⟩"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = row A i ∙ x"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>scalar_prod_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹dim_col A = dim_vec x›</span></span></span><span> </span><span>i</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>matrix_to_lpolies_coeff_access</span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span> </span><span>A</span><span class="delimiter">]</span><span> </span><span>matrix_to_lp_vec_to_lpoly_row</span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span> </span><span>A</span><span class="delimiter">]</span><span> 
</span><span>      </span><span>split_access_fst_1</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"(dim_col A)"</span></span></span><span> </span><span>l</span><span> </span><span>X</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>m</span><span> </span><span>i</span><span> </span><span>lpoly_of_v_equals_v_append0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mat_leqb_eqc_split_simplex_correct1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec b = dim_row A"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"simplex (mat_leqb_eqc A b c) = Sat X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x,y) = split_i_j_x (dim_col A) l X"</span></span></span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[A *<span class="hidden">⇩</span><sub>v</sub> x]≤b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mat_leqb_eqc_split_correct1</span><span class="delimiter">[</span><span>of</span><span> </span><span>b</span><span> </span><span>A</span><span> </span><span>c</span><span> </span><span>X</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>simplex</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sat_mono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set A ⊆ set B"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨X⟩ ⊨<span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> set B ⟹ ⟨X⟩ ⊨<span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> set A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mat_leqb_eqc_split_subset_correct1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec b = dim_row A"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set (mat_leqb_eqc A b c) ⊆ set S"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"simplex S = Sat X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x,y) = split_i_j_x (dim_col A) l X"</span></span></span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[A *<span class="hidden">⇩</span><sub>v</sub> x]≤b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sat_mono</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> 
</span><span>    </span><span>mat_leqb_eqc_split_correct1</span><span> </span><span>simplex</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mat_leqb_eqc_split_correct2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec c = dim_row A<span class="hidden">⇧</span><sup>T</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec b = dim_col A<span class="hidden">⇧</span><sup>T</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨X⟩ ⊨<span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> set (mat_leqb_eqc A b c)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) = split_n_m_x (dim_row A<span class="hidden">⇧</span><sup>T</sup>) (dim_col A<span class="hidden">⇧</span><sup>T</sup>) X"</span></span></span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[y <span class="hidden">⇩</span><sub>v</sub>* A]=c"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>standard</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>split_n_m_x_abbrev_dims</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>2</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>3</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>lst</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>lst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lst = matrix_to_lpolies (two_block_non_interfering A A<span class="hidden">⇧</span><sup>T</sup>)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>db</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>db</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"db = dim_vec b"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>dc</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>dc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dc = dim_vec c"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>cA</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec c ≤ dim_col A"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dbi_dim</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"db+i &lt; dim_vec (b @<span class="hidden">⇩</span><sub>v</sub> c)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"3"</span></span></span><span> </span><span>db</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec b ≤ db+i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>db</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"([LEQ (lst!i) (b$i) . i &lt;- [0..&lt;dim_vec b]] @
        [EQ  (lst!i) ((b@<span class="hidden">⇩</span><sub>v</sub>c)$i) . i &lt;- [dim_vec b ..&lt; dim_vec (b@<span class="hidden">⇩</span><sub>v</sub>c)]]) ! (db + i) =
         EQ (lst!(db+i)) ((b@<span class="hidden">⇩</span><sub>v</sub>c)$(db+i))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mat_leqb_eqc_for_EQ</span><span class="delimiter">[</span><span>of</span><span> </span><span>b</span><span> </span><span class="string"><span class="delete"><span class="delete">"db+i"</span></span></span><span> </span><span>c</span><span> </span><span>A</span><span class="delimiter">]</span><span>
</span><span>    </span><span>nth_append</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"[LEQ (lst!i) (b$i) . i &lt;- [0..&lt;dim_vec b]]"</span></span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"[EQ  (lst!i) ((b@<span class="hidden">⇩</span><sub>v</sub>c)$i) . i &lt;- [dim_vec b ..&lt; dim_vec (b@<span class="hidden">⇩</span><sub>v</sub>c)]]"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"3"</span></span></span><span> </span><span>db</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>rowA</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec b = dim_row A"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>index_transpose_mat</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨X⟩ ⊨<span class="hidden">⇩</span><sub>c</sub> EQ (lst!(db+i)) (c$i)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"db + i - dim_vec b = i"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>db</span><span> </span><span>diff_add_inverse</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(lst ! (db + i)) ⦃ ⟨X⟩ ⦄ = c $ i"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>dbi_dim</span><span> </span><span>rowA</span><span> </span><span>*</span><span> </span><span>cA</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>index_append_vec</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>          </span><span>index_append_vec</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>leD</span><span> </span><span>lst</span><span> </span><span>mat_leqb_eqc_satisfies2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>satisfies_constraint.simps</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨X⟩"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(lst ! (db + i))"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(c $ i)"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(lst!(db+i)) ⦃⟨X⟩⦄ = c$i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>V</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>V</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"V = vec (db+dc) (λi. ⟨X⟩ i)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>vdim</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec V = dim_vec (b@<span class="hidden">⇩</span><sub>v</sub>c)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>V</span><span> </span><span>db</span><span> </span><span>dc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"db + i &lt; dim_row (two_block_non_interfering A A<span class="hidden">⇧</span><sup>T</sup>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>dbi_dim</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>index_append_vec</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>rowA</span><span> </span><span>two_block_non_interfering_dims</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>**</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_row A ≤ db + i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>db</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>two_block_non_interfering_row_comp2</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"db+i"</span></span></span><span> </span><span>A</span><span> </span><span class="string"><span class="delete"><span class="delete">"A<span class="hidden">⇧</span><sup>T</sup>"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>*</span><span> </span><span>**</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>eql</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"row (two_block_non_interfering A A<span class="hidden">⇧</span><sup>T</sup>) (db + i) = 0<span class="hidden">⇩</span><sub>v</sub> (dim_col A) @<span class="hidden">⇩</span><sub>v</sub> row A<span class="hidden">⇧</span><sup>T</sup> i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>db</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>matrix_to_lp_vec_to_lpoly_row</span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span> </span><span class="string"><span class="delete"><span class="delete">"A<span class="hidden">⇧</span><sup>T</sup>"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>eqv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lst!(db+i) = vec_to_lpoly (0<span class="hidden">⇩</span><sub>v</sub> (dim_col A) @<span class="hidden">⇩</span><sub>v</sub> row A<span class="hidden">⇧</span><sup>T</sup> i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"*"</span></span></span><span> </span><span>lst</span><span> </span><span>matrix_to_lp_vec_to_lpoly_row</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀j&lt;dim_col A. Abstract_Linear_Poly.coeff (lst!(db+i)) j = 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>index_append_vec</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>index_append_vec</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>index_zero_vec</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>index_zero_vec</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> 
</span><span>        </span><span>vec_to_lin_poly_coeff_access</span><span> </span><span>trans_less_add1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀j≥db+dc. Abstract_Linear_Poly.coeff (lst!(db+i)) j = 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>eqv</span><span> </span><span>index_transpose_mat</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>index_zero_vec</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>leD</span><span>
</span><span>        </span><span>add.commute</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>coeff_nonzero_dim_vec_non_zero</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>index_append_vec</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> 
</span><span>        </span><span>index_row</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>index_transpose_mat</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>db</span><span> </span><span>dc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vars (lst!(db+i)) ⊆ {dim_col A..&lt;db+dc}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>atLeastLessThan_iff</span><span> </span><span>calculation</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>calculation</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>coeff_zero</span><span> </span><span>not_le</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(lst!(db+i))⦃⟨X⟩⦄ = (∑j∈{dim_col A..&lt;db+dc}. Abstract_Linear_Poly.coeff (lst!(db+i)) j * ⟨X⟩ j)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eval_poly_with_sum_superset</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"{dim_col A..&lt;db+dc}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lst!(db+i)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨X⟩"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑j∈{dim_col A..&lt;db+dc}. Abstract_Linear_Poly.coeff (lst!(db+i)) j * V$j)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>V</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑j∈{dim_col A..&lt;db+dc}. (0<span class="hidden">⇩</span><sub>v</sub> (dim_col A) @<span class="hidden">⇩</span><sub>v</sub> row A<span class="hidden">⇧</span><sup>T</sup> i)$j * V$j)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀j∈{dim_col A..&lt;db+dc}. Abstract_Linear_Poly.coeff (lst!(db+i)) j = (0<span class="hidden">⇩</span><sub>v</sub> (dim_col A) @<span class="hidden">⇩</span><sub>v</sub> row A<span class="hidden">⇧</span><sup>T</sup> i)$j"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹V ≡ vec (db + dc) ⟨X⟩›</span></span></span><span> </span><span>vdim</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>index_transpose_mat</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>          </span><span>atLeastLessThan_iff</span><span> </span><span>dim_vec</span><span> </span><span>eql</span><span> </span><span>eqv</span><span> </span><span>index_append_vec</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>index_row</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> 
</span><span>          </span><span>vec_to_lin_poly_coeff_access</span><span> </span><span>semiring_normalization_rules</span><span class="delimiter">(</span><span>24</span><span class="delimiter">)</span><span> 
</span><span>          </span><span>two_block_non_interfering_dims</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>sum.cong</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑j∈{0..&lt;dim_col A}. (0<span class="hidden">⇩</span><sub>v</sub> (dim_col A) @<span class="hidden">⇩</span><sub>v</sub> row A<span class="hidden">⇧</span><sup>T</sup> i)$j * V$j) + 
                   (∑j∈{dim_col A..&lt;db+dc}. (0<span class="hidden">⇩</span><sub>v</sub> (dim_col A) @<span class="hidden">⇩</span><sub>v</sub> row A<span class="hidden">⇧</span><sup>T</sup> i)$j * V$j)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>add_cancel_left_left</span><span> </span><span>atLeastLessThan_iff</span><span> </span><span>mult_eq_0_iff</span><span>
</span><span>        </span><span>class_semiring.add.finprod_all1</span><span> </span><span>index_append_vec</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>index_zero_vec</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>        </span><span>index_zero_vec</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>trans_less_add1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑j∈{0..&lt;db+dc}. (0<span class="hidden">⇩</span><sub>v</sub> (dim_col A) @<span class="hidden">⇩</span><sub>v</sub> row A<span class="hidden">⇧</span><sup>T</sup> i)$j * V$j)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>add.commute</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>dc</span><span> </span><span>index_transpose_mat</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> 
</span><span>        </span><span>le_add1</span><span> </span><span>le_add_same_cancel1</span><span> </span><span>sum.atLeastLessThan_concat</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (0<span class="hidden">⇩</span><sub>v</sub> (dim_col A) @<span class="hidden">⇩</span><sub>v</sub> row A<span class="hidden">⇧</span><sup>T</sup> i) ∙ V"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>scalar_prod_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>V</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = 0<span class="hidden">⇩</span><sub>v</sub> (dim_col A) ∙ vec_first V (dim_vec (0<span class="hidden">⇩</span><sub>v</sub> (dim_col A))) + 
                   row A<span class="hidden">⇧</span><sup>T</sup> i ∙ vec_last V (dim_vec (row A<span class="hidden">⇧</span><sup>T</sup> i))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>append_split_vec_distrib_scalar_prod</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"0<span class="hidden">⇩</span><sub>v</sub> (dim_col A)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"row A<span class="hidden">⇧</span><sup>T</sup> i"</span></span></span><span> </span><span>V</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹dim_vec V = dim_vec (b @<span class="hidden">⇩</span><sub>v</sub> c)›</span></span></span><span> </span><span>add.commute</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> 
</span><span>        </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>index_append_vec</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>index_row</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>index_transpose_mat</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> 
</span><span>        </span><span>index_transpose_mat</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>index_zero_vec</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"0<span class="hidden">⇩</span><sub>v</sub> (dim_col A) ∙ vec_first V (dim_vec (0<span class="hidden">⇩</span><sub>v</sub> (dim_col A))) + 
                   row A<span class="hidden">⇧</span><sup>T</sup> i ∙ vec_last V (dim_vec (row A<span class="hidden">⇧</span><sup>T</sup> i)) = (row A<span class="hidden">⇧</span><sup>T</sup> i) ∙ y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vec_last V (dim_vec (row A<span class="hidden">⇧</span><sup>T</sup> i)) = y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>standard</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_col A<span class="hidden">⇧</span><sup>T</sup> = db"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>db</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀v va. vec db (λn. ⟨X⟩ (n + dc)) = v ∨ (x, y) ≠ (va, v)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Pair_inject</span><span> </span><span>add_diff_cancel_left'</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>dc</span><span> </span><span>split_i_j_x_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>V</span><span> </span><span>vec_last_def</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split_access_fst_1</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(dim_row A<span class="hidden">⇧</span><sup>T</sup>)"</span></span></span><span>  </span><span>i</span><span> </span><span class="string"><span class="delete"><span class="delete">"(dim_col A<span class="hidden">⇧</span><sup>T</sup>)"</span></span></span><span> </span><span>X</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="string"><span class="delete"><span class="delete">"1"</span></span></span><span> </span><span>add.commute</span><span> </span><span>add_diff_cancel_left'</span><span> </span><span>add_less_cancel_left</span><span> 
</span><span>              </span><span>dim_vec</span><span> </span><span>f1</span><span> </span><span>index_row</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>index_vec</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>2</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹dim_col A<span class="hidden">⇧</span><sup>T</sup> = dim_vec y›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mult_mat_vec_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="string"><span class="delete"><span class="delete">"3"</span></span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>calculation</span><span> </span><span>index_vec</span><span> </span><span>sat</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mat_leqb_eqc_split_simplex_correct2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec c = dim_row A<span class="hidden">⇧</span><sup>T</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec b = dim_col A<span class="hidden">⇧</span><sup>T</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"simplex (mat_leqb_eqc A b c) = Sat X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) = split_n_m_x (dim_row A<span class="hidden">⇧</span><sup>T</sup>) (dim_col A<span class="hidden">⇧</span><sup>T</sup>) X"</span></span></span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[y <span class="hidden">⇩</span><sub>v</sub>* A]=c"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>mat_leqb_eqc_split_correct2</span><span> </span><span>simplex</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mat_leqb_eqc_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec c = dim_row A<span class="hidden">⇧</span><sup>T</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec b = dim_col A<span class="hidden">⇧</span><sup>T</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"simplex (mat_leqb_eqc A b c) = Sat X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) = split_n_m_x (dim_row A<span class="hidden">⇧</span><sup>T</sup>) (dim_col A<span class="hidden">⇧</span><sup>T</sup>) X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[y <span class="hidden">⇩</span><sub>v</sub>* A]=c"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[A *<span class="hidden">⇩</span><sub>v</sub> x]≤b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mat_leqb_eqc_split_simplex_correct1</span><span class="delimiter">[</span><span>of</span><span> </span><span>b</span><span> </span><span>A</span><span> </span><span>c</span><span> </span><span>X</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>mat_leqb_eqc_split_simplex_correct2</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mat_leqb_eqc_split_correct2</span><span class="delimiter">[</span><span>of</span><span> </span><span>b</span><span> </span><span>A</span><span> </span><span>c</span><span> </span><span>X</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>Matrix.transpose_transpose</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>index_transpose_mat</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>      </span><span>mat_leqb_eqc_split_simplex_correct1</span><span class="delimiter">[</span><span>of</span><span> </span><span>b</span><span> </span><span>A</span><span> </span><span>c</span><span> </span><span>X</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eval_lpoly_eq_dot_prod_split1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) = split_n_m_x (dim_vec c) (dim_vec b) X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span class="string"><span class="delete"><span class="delete">"(vec_to_lpoly c) ⦃⟨X⟩⦄ =  c ∙ x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(vec_to_lpoly c) ⦃⟨X⟩⦄ =
           (∑i∈vars (vec_to_lpoly c). Abstract_Linear_Poly.coeff (vec_to_lpoly c) i * ⟨X⟩ i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>linear_poly_sum</span><span> </span><span>sum.cong</span><span> </span><span>eval_poly_with_sum</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑i∈{0..&lt;dim_vec c}. Abstract_Linear_Poly.coeff (vec_to_lpoly c) i * ⟨X⟩ i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vars_subset_dim_vec_to_lpoly_dim</span><span class="delimiter">[</span><span>of</span><span> </span><span>c</span><span class="delimiter">]</span><span> </span><span>linear_poly_sum</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"vec_to_lpoly c"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨X⟩"</span></span></span><span class="delimiter">]</span><span> 
</span><span>      </span><span>eval_poly_with_sum_superset</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"{0..&lt;dim_vec c}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vec_to_lpoly c"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨X⟩"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑i∈{0..&lt;dim_vec c}. c$i * x$i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split_access_fst_1</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec c"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(dim_vec c) + (dim_vec b)"</span></span></span><span> </span><span>X</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">]</span><span>
</span><span>      </span><span>split_access_snd_1</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec c"</span></span></span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"((dim_vec c) + (dim_vec b))"</span></span></span><span> </span><span>X</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">]</span><span>
</span><span>      </span><span>vec_to_lin_poly_coeff_access</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>c</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = c ∙ x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>scalar_prod_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split_vec_dims</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec c"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(dim_vec c) + (dim_vec b)"</span></span></span><span> </span><span>X</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">]</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eval_lpoly_eq_dot_prod_split2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) = split_n_m_x (dim_vec b) (dim_vec c) X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span class="string"><span class="delete"><span class="delete">"(vec_to_lpoly (0<span class="hidden">⇩</span><sub>v</sub> (dim_vec b) @<span class="hidden">⇩</span><sub>v</sub> c)) ⦃⟨X⟩⦄ =  c ∙ y"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?p</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(vec_to_lpoly ((0<span class="hidden">⇩</span><sub>v</sub> (dim_vec b) @<span class="hidden">⇩</span><sub>v</sub> c)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?v0</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(0<span class="hidden">⇩</span><sub>v</sub> (dim_vec b) @<span class="hidden">⇩</span><sub>v</sub> c)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i&lt;dim_vec b. Abstract_Linear_Poly.coeff ?p i = 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>coeff_nonzero_dim_vec_non_zero</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>**</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec ?v0 = dim_vec b + dim_vec c"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?p ⦃⟨X⟩⦄ = (∑i∈vars ?p. Abstract_Linear_Poly.coeff ?p i * ⟨X⟩ i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eval_poly_with_sum</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑i∈{0..&lt;dim_vec ?v0}. Abstract_Linear_Poly.coeff ?p i * ⟨X⟩ i)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eval_poly_with_sum_superset</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"{0..&lt;dim_vec ?v0}"</span></span></span><span> </span><span class="var">?p</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨X⟩"</span></span></span><span class="delimiter">]</span><span> </span><span>calculation</span><span>
</span><span>      </span><span>vars_subset_dim_vec_to_lpoly_dim</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?v0</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑i∈{0..&lt;dim_vec b}. Abstract_Linear_Poly.coeff ?p i * ⟨X⟩ i) + 
                   (∑i∈{(dim_vec b)..&lt;dim_vec ?v0}. Abstract_Linear_Poly.coeff ?p i * ⟨X⟩ i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sum.atLeastLessThan_concat</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑i∈{(dim_vec b)..&lt;dim_vec ?v0}. Abstract_Linear_Poly.coeff ?p i * ⟨X⟩ i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>*</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑i∈{(dim_vec b)..&lt;dim_vec ?v0}. ?v0$i * ⟨X⟩ i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vec_to_lin_poly_coeff_access</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑i∈{0..&lt;dim_vec c}. ?v0$(i+dim_vec b) * ⟨X⟩ (i+dim_vec b))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>index_zero_vec</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec b"</span></span></span><span class="delimiter">]</span><span> </span><span>index_append_vec</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"0<span class="hidden">⇩</span><sub>v</sub> (dim_vec b)"</span></span></span><span> </span><span>c</span><span class="delimiter">]</span><span> </span><span>**</span><span> </span><span>*</span><span>
</span><span>       </span><span>sum.shift_bounds_nat_ivl</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(λi. ?v0$i * ⟨X⟩ i)"</span></span></span><span> </span><span>0</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec b"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec c"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add.commute</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑i∈{0..&lt;dim_vec c}. c$i * ⟨X⟩ (i+dim_vec b))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑i∈{0..&lt;dim_vec c}. c$i * y$i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split_access_snd_2</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="string"><span class="delete"><span class="delete">"(dim_vec b)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(dim_vec c)"</span></span></span><span> </span><span>X</span><span class="delimiter">]</span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>atLeastLessThan_iff</span><span> </span><span>split_access_snd_2</span><span> 
</span><span>        </span><span>split_n_m_x_abbrev_dims</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>split_vec_dims</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>sum.cong</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = c ∙ y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>scalar_prod_def</span><span> </span><span>split_n_m_x_abbrev_dims</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>x_times_c_geq_y_times_b_split_dotP</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨X⟩ ⊨<span class="hidden">⇩</span><sub>c</sub> x_times_c_geq_y_times_b c b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) = split_n_m_x (dim_vec c) (dim_vec b) X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ∙ x ≥ b ∙ y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>lpoly_of_v_equals_v_append0</span><span> </span><span>eval_lpoly_eq_dot_prod_split2</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>c</span><span> </span><span>b</span><span> </span><span>X</span><span class="delimiter">]</span><span>
</span><span>   </span><span>eval_lpoly_eq_dot_prod_split1</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>c</span><span> </span><span>b</span><span> </span><span>X</span><span class="delimiter">]</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mult_right_leq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>A</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::{comm_semiring_1,ordered_semiring}) mat"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec y = dim_vec b"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i &lt; dim_vec y. y$i ≥ 0"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[A *<span class="hidden">⇩</span><sub>v</sub> x]≤ b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(A *<span class="hidden">⇩</span><sub>v</sub> x) ∙ y ≤ b ∙ y"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑n&lt;dim_vec b. (A *<span class="hidden">⇩</span><sub>v</sub> x) $ n * y $ n) ≤ (∑n&lt;dim_vec b. b $ n * y $ n)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>lessThan_iff</span><span> 
</span><span>        </span><span>mat_times_vec_leq_def</span><span> </span><span>mult_right_mono</span><span> </span><span>sum_mono</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>atLeast0LessThan</span><span> </span><span>scalar_prod_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mult_right_eq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec x = dim_vec c"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[y <span class="hidden">⇩</span><sub>v</sub>* A]=c"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(A<span class="hidden">⇧</span><sup>T</sup> *<span class="hidden">⇩</span><sub>v</sub> y) ∙ x = c ∙ x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>scalar_prod_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>atLeastLessThan_iff</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>0</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec x"</span></span></span><span class="delimiter">]</span><span> </span><span>vec_times_mat_eq_def</span><span class="delimiter">[</span><span>of</span><span> </span><span>y</span><span> </span><span>A</span><span> </span><span>c</span><span class="delimiter">]</span><span> 
</span><span>    </span><span>sum.cong</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"λi. (A<span class="hidden">⇧</span><sup>T</sup> *<span class="hidden">⇩</span><sub>v</sub> y) $ i * x $ i"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λi. c $ i * x $ i"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>soundness_mat_x_leq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_row A = dim_vec b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"simplex (mat_x_leq_vec A b) = Sat X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃x. [A *<span class="hidden">⇩</span><sub>v</sub> x]≤b"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x = fst (split_n_m_x (dim_col A) (dim_row A) X)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec x = dim_col A"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>split_i_j_x_def</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i&lt;dim_vec b. (A *<span class="hidden">⇩</span><sub>v</sub> x) $ i ≤ b $ i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>standard</span><span class="delimiter">,</span><span> </span><span>standard</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; dim_vec b"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"row A i ∙ x ≤ b$i"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mat_x_leq_vec_sol</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span> </span><span>b</span><span> </span><span>X</span><span> </span><span>i</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹i &lt; dim_vec b›</span></span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>eval_lpoly_eq_dot_prod_split1</span><span> 
</span><span>          </span><span>fst_conv</span><span> </span><span>index_row</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>matrix_to_lp_vec_to_lpoly_row</span><span> </span><span>simplex</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>split_i_j_x_def</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(A *<span class="hidden">⇩</span><sub>v</sub> x) $ i ≤ b $ i"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹i &lt; dim_vec b›</span></span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[A *<span class="hidden">⇩</span><sub>v</sub> x]≤b"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mat_times_vec_leqI</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span> </span><span>b</span><span> </span><span>x</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>*</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>completeness_mat_x_leq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃x. [A *<span class="hidden">⇩</span><sub>v</sub> x]≤b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃X. simplex (mat_x_leq_vec A b) = Sat X"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∄X. simplex (mat_x_leq_vec A b) = Inr X"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∄v. v ⊨<span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> set (mat_x_leq_vec A b)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>simplex</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"mat_x_leq_vec A b"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1"</span></span></span><span> </span><span>sum.exhaust_sel</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec b = dim_row A"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>mat_times_vec_leqD</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span> </span><span>_</span><span> </span><span>b</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"[A *<span class="hidden">⇩</span><sub>v</sub> x]≤b"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x_A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec x = dim_col A"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>v</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>v</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v = (λi. (if i &lt; dim_vec x then x$i else 0))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>v_d</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i &lt; dim_vec x. x$i = v i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>v</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> set (mat_x_leq_vec A b)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> 
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>c</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ∈ set (mat_x_leq_vec A b)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c = LEQ (matrix_to_lpolies A!i) (b$i)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; dim_vec b"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?p</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"matrix_to_lpolies A!i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?p⦃ v ⦄ = (row A i) ∙ x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>matrix_to_lpolies_lambda_valuate_scalarP</span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span> </span><span>A</span><span> </span><span>x</span><span class="delimiter">]</span><span> </span><span>v</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹dim_vec b = dim_row A›</span></span></span><span> </span><span>i</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>x_A</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ b$i"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>i</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>index_mult_mat_vec</span><span> </span><span>mat_times_vec_leq_def</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>c</sub> c"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>satisfies_constraint.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>v</span><span> </span><span class="string"><span class="delete"><span class="delete">"(matrix_to_lpolies A ! i)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b $ i"</span></span></span><span class="delimiter">]</span><span> 
</span><span>        </span><span>2</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹row A i ∙ x ≤ b $ i›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>*</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>soundness_mat_x_eq_vec</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_row A<span class="hidden">⇧</span><sup>T</sup> = dim_vec c"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"simplex (x_mat_eq_vec c A<span class="hidden">⇧</span><sup>T</sup>) = Sat X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"∃x. [x <span class="hidden">⇩</span><sub>v</sub>* A]=c"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x = fst (split_n_m_x (dim_col A<span class="hidden">⇧</span><sup>T</sup>) (dim_row A<span class="hidden">⇧</span><sup>T</sup>) X)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec x = dim_col A<span class="hidden">⇧</span><sup>T</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>split_i_j_x_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split_vec_dims</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(dim_col A<span class="hidden">⇧</span><sup>T</sup>)"</span></span></span><span> </span><span>_</span><span> </span><span>X</span><span> </span><span>x</span><span class="delimiter">]</span><span> </span><span>fst_conv</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>split_i_j_x_def</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i &lt; dim_vec c. (A<span class="hidden">⇧</span><sup>T</sup> *<span class="hidden">⇩</span><sub>v</sub> x)$i = c$i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>standard</span><span class="delimiter">,</span><span> </span><span>standard</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; dim_vec c"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨X⟩ ⊨<span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> set (x_mat_eq_vec c A<span class="hidden">⇧</span><sup>T</sup>)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>simplex</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"row A<span class="hidden">⇧</span><sup>T</sup> i ∙ x = c$i"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x_mat_eq_vec_sol</span><span class="delimiter">[</span><span>of</span><span> </span><span>c</span><span> </span><span class="string"><span class="delete"><span class="delete">"A<span class="hidden">⇧</span><sup>T</sup>"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨X⟩"</span></span></span><span> </span><span>i</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>*</span><span> </span><span>a</span><span class="delimiter">]</span><span> </span><span>eval_lpoly_eq_dot_prod_split1</span><span> </span><span>fstI</span><span>       
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>index_row</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>matrix_to_lpolies_vec_of_row</span><span> </span><span>split_i_j_x_def</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(A<span class="hidden">⇧</span><sup>T</sup> *<span class="hidden">⇩</span><sub>v</sub> x) $ i = c $ i"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mult_mat_vec_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[x <span class="hidden">⇩</span><sub>v</sub>* A]=c"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mat_times_vec_eqI</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span> </span><span>x</span><span> </span><span>c</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹dim_vec x = dim_col A<span class="hidden">⇧</span><sup>T</sup>›</span></span></span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>completeness_mat_x_eq_vec</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃x. [x <span class="hidden">⇩</span><sub>v</sub>* A]=c"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃X. simplex (x_mat_eq_vec c A<span class="hidden">⇧</span><sup>T</sup>) = Sat X"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∄X. simplex (x_mat_eq_vec c A<span class="hidden">⇧</span><sup>T</sup>) = Inr X"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∄v. v ⊨<span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> set (x_mat_eq_vec c A<span class="hidden">⇧</span><sup>T</sup>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>simplex</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"x_mat_eq_vec c A<span class="hidden">⇧</span><sup>T</sup>"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sum.exhaust_sel</span><span> </span><span>1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec c = dim_col A"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>index_transpose_mat</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>vec_times_mat_eqD</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" [x <span class="hidden">⇩</span><sub>v</sub>* A]=c"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec x = dim_col A<span class="hidden">⇧</span><sup>T</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹[x <span class="hidden">⇩</span><sub>v</sub>* A]=c›</span></span></span><span> </span><span>vec_times_mat_eq_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>v</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>v</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v = (λi. (if i &lt; dim_vec x then x$i else 0))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>v_d</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i &lt; dim_vec x. x$i = v i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>v</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> set (x_mat_eq_vec c A<span class="hidden">⇧</span><sup>T</sup>)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> 
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ set (x_mat_eq_vec c A<span class="hidden">⇧</span><sup>T</sup>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a = EQ (matrix_to_lpolies A<span class="hidden">⇧</span><sup>T</sup>!i) (c$i)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; dim_vec c"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>add_cancel_right_left</span><span> </span><span>diff_zero</span><span> </span><span>in_set_conv_nth</span><span> </span><span>length_map</span><span> </span><span>length_upt</span><span> </span><span>nth_map_upt</span><span> </span><span>x_mat_eq_vec.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?p</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"matrix_to_lpolies A<span class="hidden">⇧</span><sup>T</sup>!i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?p⦃ v ⦄ = (row A<span class="hidden">⇧</span><sup>T</sup> i) ∙ x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>matrix_to_lpolies_lambda_valuate_scalarP</span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span> </span><span class="string"><span class="delete"><span class="delete">"A<span class="hidden">⇧</span><sup>T</sup>"</span></span></span><span> </span><span>x</span><span class="delimiter">]</span><span> </span><span>v</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹dim_vec c = dim_col A›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹dim_vec x = dim_col A<span class="hidden">⇧</span><sup>T</sup>›</span></span></span><span> </span><span>i</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>index_transpose_mat</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = c$i"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹[x <span class="hidden">⇩</span><sub>v</sub>* A]=c›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹dim_vec c = dim_col A›</span></span></span><span> </span><span>i</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>index_mult_mat_vec</span><span> </span><span>index_transpose_mat</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>vec_times_mat_eqD</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>c</sub> a"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>satisfies_constraint.simps</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>v</span><span> </span><span class="string"><span class="delete"><span class="delete">"(matrix_to_lpolies A<span class="hidden">⇧</span><sup>T</sup> ! i)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(c $ i)"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"*"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>soundness_mat_leqb_eqc1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_row A = dim_vec b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"simplex (mat_leqb_eqc A b c) = Sat X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃x. [A *<span class="hidden">⇩</span><sub>v</sub> x]≤b"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x = fst (split_n_m_x (dim_col A) (dim_row A) X)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec x = dim_col A"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>split_i_j_x_def</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i&lt;dim_vec b. (A *<span class="hidden">⇩</span><sub>v</sub> x) $ i ≤ b $ i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>standard</span><span class="delimiter">,</span><span> </span><span>standard</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; dim_vec b"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"row A i ∙ x ≤ b$i"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mat_x_leq_vec_sol</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span> </span><span>b</span><span> </span><span>X</span><span> </span><span>i</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹i &lt; dim_vec b›</span></span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>fst_conv</span><span> </span><span>split_i_j_x_def</span><span> </span><span>x</span><span>
</span><span>          </span><span>index_mult_mat_vec</span><span> </span><span>mat_leqb_eqc_split_simplex_correct1</span><span> </span><span>mat_times_vec_leqD</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(A *<span class="hidden">⇩</span><sub>v</sub> x) $ i ≤ b $ i"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹i &lt; dim_vec b›</span></span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[A *<span class="hidden">⇩</span><sub>v</sub> x]≤b"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mat_times_vec_leqI</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span> </span><span>b</span><span> </span><span>x</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>*</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>soundness_mat_leqb_eqc2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_row A<span class="hidden">⇧</span><sup>T</sup> = dim_vec c"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_col A<span class="hidden">⇧</span><sup>T</sup> = dim_vec b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"simplex (mat_leqb_eqc A b c) = Sat X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃y. [y <span class="hidden">⇩</span><sub>v</sub>* A]=c"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>standard</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>mat_times_vec_eqI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y = snd (split_n_m_x (dim_col A) (dim_row A) X)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec y = dim_row A"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>split_i_j_x_def</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_col A<span class="hidden">⇧</span><sup>T</sup> = dim_vec y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"*"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_row A<span class="hidden">⇧</span><sup>T</sup> = dim_vec c"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. i &lt; dim_vec c ⟹ (A<span class="hidden">⇧</span><sup>T</sup> *<span class="hidden">⇩</span><sub>v</sub> y) $ i = c $ i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; dim_vec c"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[y <span class="hidden">⇩</span><sub>v</sub>* A]=c"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mat_leqb_eqc_split_correct2</span><span class="delimiter">[</span><span>of</span><span> </span><span>c</span><span> </span><span>A</span><span> </span><span>b</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>y</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Matrix.transpose_transpose</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>index_transpose_mat</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> 
</span><span>          </span><span>simplex</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>snd_conv</span><span> </span><span>split_i_j_x_def</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(A<span class="hidden">⇧</span><sup>T</sup> *<span class="hidden">⇩</span><sub>v</sub> y) $ i = c $ i"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a</span><span> </span><span>vec_times_mat_eq_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>completeness_mat_leqb_eqc</span><span class="delimiter">:</span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃x. [A *<span class="hidden">⇩</span><sub>v</sub> x]≤b"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃y. [y <span class="hidden">⇩</span><sub>v</sub>* A]=c"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃X. simplex (mat_leqb_eqc A b c) = Sat X"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∄X. simplex (mat_leqb_eqc A b c) = Sat X"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∄v. v ⊨<span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> set (mat_leqb_eqc A b c)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>simplex</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"mat_leqb_eqc A b c"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1"</span></span></span><span> </span><span>sum.exhaust_sel</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec b = dim_row A"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>mat_times_vec_leqD</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span> </span><span>_</span><span> </span><span>b</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"[A *<span class="hidden">⇩</span><sub>v</sub> x]≤b"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[y <span class="hidden">⇩</span><sub>v</sub>* A]=c"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x_A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec x = dim_col A"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>yr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec y = dim_row A"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vec_times_mat_eq_def</span><span> </span><span>x</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>v</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>v</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v = (λi. (if i &lt; dim_vec (x@<span class="hidden">⇩</span><sub>v</sub>y) then (x@<span class="hidden">⇩</span><sub>v</sub>y)$i else 0))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>v_d</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i &lt; dim_vec (x@<span class="hidden">⇩</span><sub>v</sub>y). (x@<span class="hidden">⇩</span><sub>v</sub>y)$i = v i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>v</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>i_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i ∈ {0..&lt; dim_vec y}. y$i = v (i+dim_vec x)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>v</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> set (mat_leqb_eqc A b c)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>e</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"e ∈ set (mat_leqb_eqc A b c)"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>lst</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>lst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lst = matrix_to_lpolies (two_block_non_interfering A A<span class="hidden">⇧</span><sup>T</sup>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?L</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"[LEQ (lst!i) (b$i) . i &lt;- [0..&lt;dim_vec b]] @
              [EQ  (lst!i) ((b@<span class="hidden">⇩</span><sub>v</sub>c)$i) . i &lt;- [dim_vec b ..&lt; dim_vec (b@<span class="hidden">⇩</span><sub>v</sub>c)]]"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mat_leqb_eqc A b c = ?L"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>lst</span><span> </span><span>mat_leqb_eqc.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"e = ?L!i"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈{0..&lt;length ?L}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>asm</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>atLeastLessThan_iff</span><span> </span><span>in_set_conv_nth</span><span> </span><span>not_le</span><span> </span><span>not_less0</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ldimbc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length ?L = dim_vec (b@<span class="hidden">⇩</span><sub>v</sub>c)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">consider</span></span><span> </span><span class="delimiter">(</span><span>leqb</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ {0..&lt;dim_vec b}"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="delimiter">(</span><span>eqc</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ {dim_vec b..&lt;length ?L}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>leI</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>c</sub> e"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>leqb</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>il</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; dim_vec b"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>atLeastLessThan_iff</span><span> </span><span>leqb</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>iA</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; dim_row A"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹dim_vec b = dim_row A›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹i &lt; dim_vec b›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"e = LEQ (lst!i) (b$i)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>i</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>nth_append</span><span> </span><span>il</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = LEQ ((matrix_to_lpolies A)!i) (b$i)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mat_leqb_eqc_for_LEQ</span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span> </span><span>b</span><span> </span><span>A</span><span> </span><span>c</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>il</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹i &lt; dim_row A›</span></span></span><span class="delimiter">]</span><span> </span><span>L</span><span> </span><span>i</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>eqmp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lst!i = ((matrix_to_lpolies A)!i)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sset</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars (lst!i) ⊆ {0..&lt;dim_vec x}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>matrix_to_lpolies_vec_of_row</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹i &lt; dim_row A›</span></span></span><span> </span><span>eqmp</span><span> </span><span>index_row</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>  
</span><span>            </span><span>vars_subset_dim_vec_to_lpoly_dim</span><span> </span><span>x_A</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>**</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"((lst!i) ⦃ v ⦄) = ((vec_to_lpoly (row A i)) ⦃ v ⦄)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹i &lt; dim_row A›</span></span></span><span> </span><span>eqmp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑j∈vars(lst!i). Abstract_Linear_Poly.coeff (lst!i) j * v j)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>**</span><span> </span><span>eval_poly_with_sum</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑j∈{0..&lt;dim_vec x}. Abstract_Linear_Poly.coeff (lst!i) j * v j)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sset</span><span> </span><span>eval_poly_with_sum_superset</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"{0..&lt;dim_vec x}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lst!i"</span></span></span><span> </span><span>v</span><span class="delimiter">,</span><span> 
</span><span>            </span><span>OF</span><span> </span><span>finite_atLeastLessThan</span><span> </span><span>sset</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"**"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>calculation</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑j∈{0..&lt;dim_vec x}. Abstract_Linear_Poly.coeff (lst!i) j * x$j)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>v</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑j∈{0..&lt;dim_vec x}. (row A i)$j * x$j)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>matrix_to_lpolies_vec_of_row</span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span> </span><span>A</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>iA</span><span class="delimiter">]</span><span> 
</span><span>          </span><span>vec_to_lin_poly_coeff_access</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"row A i"</span></span></span><span class="delimiter">]</span><span> </span><span>index_row</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span> </span><span>i</span><span class="delimiter">]</span><span> 
</span><span>          </span><span>atLeastLessThan_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>eqmp</span><span> </span><span>sum.cong</span><span> </span><span>x_A</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"... = row A i ∙ x"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>scalar_prod_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ b$i"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹i &lt; dim_vec b›</span></span></span><span> </span><span>index_mult_mat_vec</span><span> </span><span>mat_times_vec_leq_def</span><span> </span><span>x</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"*"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>eqc</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>igeq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ≥ dim_vec b"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>atLeastLessThan_iff</span><span> </span><span>eqc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length ?L"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>atLeastLessThan_iff</span><span> </span><span>eqc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e =?L!i"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L</span><span> </span><span>i</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?L!i ∈ set [EQ  (lst!i) ((b@<span class="hidden">⇩</span><sub>v</sub>c)$i). i &lt;- [dim_vec b..&lt; dim_vec (b@<span class="hidden">⇩</span><sub>v</sub>c)]]"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>in_second_append_list</span><span> </span><span>length_map</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>igeq</span><span> </span><span>*</span><span>  </span><span>length_upt</span><span> </span><span>minus_nat.diff_0</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?L!i = [EQ  (lst!i) ((b@<span class="hidden">⇩</span><sub>v</sub>c)$i). i &lt;- [dim_vec b..&lt; dim_vec (b@<span class="hidden">⇩</span><sub>v</sub>c)]]!(i-dim_vec b)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹dim_vec b ≤ i›</span></span></span><span> </span><span>diff_zero</span><span> </span><span>leD</span><span> 
</span><span>            </span><span>length_map</span><span> </span><span>length_upt</span><span> </span><span>nth_append</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?L!i = EQ (lst!i) ((b@<span class="hidden">⇩</span><sub>v</sub>c)$i)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>add_diff_inverse_nat</span><span> </span><span>diff_less_mono</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹dim_vec b ≤ i›</span></span></span><span> </span><span>*</span><span> </span><span>ldimbc</span><span>  </span><span>leD</span><span> </span><span>nth_map_upt</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>e</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"e = EQ (lst!i) ((b@<span class="hidden">⇩</span><sub>v</sub>c)$i)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>mat_leqb_eqc_for_EQ</span><span class="delimiter">[</span><span>of</span><span> </span><span>b</span><span> </span><span>i</span><span> </span><span>c</span><span> </span><span>A</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>igeq</span><span class="delimiter">]</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lsta</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(lst!i) = (vec_to_lpoly (0<span class="hidden">⇩</span><sub>v</sub> (dim_col A) @<span class="hidden">⇩</span><sub>v</sub> row A<span class="hidden">⇧</span><sup>T</sup> (i - dim_vec b)))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹dim_vec b = dim_row A›</span></span></span><span> </span><span>*</span><span> </span><span>ldimbc</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>igeq</span><span> 
</span><span>            </span><span>index_append_vec</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>lst</span><span> </span><span>matrix_to_lpolies_vec_of_row</span><span> </span><span>vec_times_mat_eq_def</span><span>
</span><span>            </span><span>two_block_non_interfering_dims</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>two_block_non_interfering_row_comp2</span><span> </span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?p</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(vec_to_lpoly (0<span class="hidden">⇩</span><sub>v</sub> (dim_col A) @<span class="hidden">⇩</span><sub>v</sub> row A<span class="hidden">⇧</span><sup>T</sup> (i - dim_vec b)))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_poly ?p ≤ dim_col A + dim_row A"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dim_poly_of_append_vec</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"0<span class="hidden">⇩</span><sub>v</sub> (dim_col A)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"row A<span class="hidden">⇧</span><sup>T</sup> (i - dim_vec b)"</span></span></span><span class="delimiter">]</span><span>
</span><span>          </span><span>index_zero_vec</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_col A"</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹dim_vec (0<span class="hidden">⇩</span><sub>v</sub> (dim_col A)) = dim_col A›</span></span></span><span> </span><span>index_row</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>index_transpose_mat</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i &lt; dim_col A. Abstract_Linear_Poly.coeff ?p i = 0"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vec_coeff_append1</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"0<span class="hidden">⇩</span><sub>v</sub> (dim_col A)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"row A<span class="hidden">⇧</span><sup>T</sup> (i - dim_vec b)"</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>atLeastLessThan_iff</span><span> </span><span>index_zero_vec</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>index_zero_vec</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>zero_le</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec (0<span class="hidden">⇩</span><sub>v</sub> (dim_col A) @<span class="hidden">⇩</span><sub>v</sub> row A<span class="hidden">⇧</span><sup>T</sup> (i - dim_vec b)) = dim_col A + dim_row A"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>index_append_vec</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>index_row</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>index_transpose_mat</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>index_zero_vec</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>allcr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀j∈{0..&lt;dim_row A}. Abstract_Linear_Poly.coeff ?p (j+dim_col A) = (row A<span class="hidden">⇧</span><sup>T</sup> (i - dim_vec b))$j"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_diff_cancel_right'</span><span> </span><span>atLeastLessThan_iff</span><span> </span><span>diff_add_inverse</span><span> </span><span>index_zero_vec</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> 
</span><span>            </span><span>le_add_same_cancel2</span><span> </span><span>less_diff_conv</span><span> </span><span>vec_coeff_append2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>vs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars ?p ⊆ {dim_col A..&lt;dim_col A + dim_row A}"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vars_vec_append_subset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>index_row</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>index_transpose_mat</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?p ⦃ v ⦄ = (∑j∈vars ?p. Abstract_Linear_Poly.coeff ?p j * v j)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eval_poly_with_sum</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑j∈{dim_col A..&lt;dim_col A + dim_row A}. Abstract_Linear_Poly.coeff ?p j * v j)"</span></span></span><span>     
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>DiffD2</span><span> </span><span>vs</span><span> </span><span>coeff_zero</span><span> </span><span>finite_atLeastLessThan</span><span>
</span><span>            </span><span>mult_not_zero</span><span> </span><span>sum.mono_neutral_left</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑j∈{0..&lt;dim_row A}. Abstract_Linear_Poly.coeff ?p (j+dim_col A) * v (j+dim_col A))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sum.shift_bounds_nat_ivl</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"λj. Abstract_Linear_Poly.coeff ?p j * v j"</span></span></span><span> </span><span>0</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_col A"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_row A"</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>add.commute</span><span> </span><span>add_cancel_left_left</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑j∈{0..&lt;dim_row A}. Abstract_Linear_Poly.coeff ?p (j+dim_col A) * y$j)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>v</span><span> </span><span>i_in</span><span> </span><span>yr</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>sum.cong</span><span> </span><span>x_A</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑j∈{0..&lt;dim_row A}. (row A<span class="hidden">⇧</span><sup>T</sup> (i - dim_vec b))$j * y$j)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>allcr</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>sum.cong</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (row A<span class="hidden">⇧</span><sup>T</sup> (i - dim_vec b)) ∙ y"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹dim_vec y = dim_row A›</span></span></span><span> </span><span>scalar_prod_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (b@<span class="hidden">⇩</span><sub>v</sub>c)$i"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vec_times_mat_eqD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>x</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>*</span><span> </span><span>igeq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>e</span><span> </span><span>lsta</span><span> </span><span>satisfies_constraint.simps</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"(lst ! i)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"((b @<span class="hidden">⇩</span><sub>v</sub> c) $ i)"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>*</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sound_and_compltete_mat_leqb_eqc</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_row A<span class="hidden">⇧</span><sup>T</sup> = dim_vec c"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_col A<span class="hidden">⇧</span><sup>T</sup> = dim_vec b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃x. [A *<span class="hidden">⇩</span><sub>v</sub> x]≤b) ∧ (∃y. [y <span class="hidden">⇩</span><sub>v</sub>* A]=c) ⟷ (∃X. simplex (mat_leqb_eqc A b c) = Sat X)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>completeness_mat_leqb_eqc</span><span> </span><span>index_transpose_mat</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> 
</span><span>      </span><span>soundness_mat_leqb_eqc1</span><span> </span><span>soundness_mat_leqb_eqc2</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Translate Inequalities to Matrix Form ›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* We (obviously) cannot use strict inequalities hence we use the option type *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>nonstrict_constr</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nonstrict_constr (LEQ p r) = True"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nonstrict_constr (GEQ p r) = True"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nonstrict_constr (EQ p r) = True"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nonstrict_constr (LEQPP p q) = True"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nonstrict_constr (GEQPP p q) = True"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nonstrict_constr (EQPP p q) = True"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nonstrict_constr _ = False"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nonstrict_constrs cs ≡ (∀a ∈ set cs. nonstrict_constr a)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>transf_constraint</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"transf_constraint (LEQ p r) = [LEQ p r]"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"transf_constraint (GEQ p r) = [LEQ (-p) (-r)]"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"transf_constraint (EQ p r) = [LEQ p r, LEQ (-p) (-r)]"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"transf_constraint (LEQPP p q) = [LEQ (p - q) 0]"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"transf_constraint (GEQPP p q) = [LEQ (-(p - q)) 0]"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"transf_constraint (EQPP p q) = [LEQ (p - q) 0, LEQ (-(p - q)) 0]"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"transf_constraint _ = []"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>transf_constraints</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"transf_constraints [] = []"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"transf_constraints (x#xs) = transf_constraint x @ (transf_constraints xs)"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trans_constraint_creats_LEQ_only</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"transf_constraint x ≠ []"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀x ∈ set (transf_constraint x). ∃a b. x = LEQ a b)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trans_constraints_creats_LEQ_only</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"transf_constraints xs ≠ []"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ set (transf_constraints xs)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃p r. LEQ p r = x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>xs</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>trans_constraint_creats_LEQ_only</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fastforce</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>in_set_simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>trans_constraint_creats_LEQ_only</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>non_strict_constr_no_LT</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nonstrict_constrs cs"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x ∈ set cs. ¬(∃a b. LT a b = x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>nonstrict_constr.simps</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>non_strict_constr_no_GT</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nonstrict_constrs cs"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x ∈ set cs. ¬(∃a b. GT a b = x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>nonstrict_constr.simps</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>non_strict_constr_no_LTPP</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nonstrict_constrs cs"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x ∈ set cs. ¬(∃a b. LTPP a b = x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>nonstrict_constr.simps</span><span class="delimiter">(</span><span>9</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>non_strict_constr_no_GTPP</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nonstrict_constrs cs"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x ∈ set cs. ¬(∃a b. GTPP a b = x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>nonstrict_constr.simps</span><span class="delimiter">(</span><span>10</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>non_strict_consts_cond</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x. x ∈ set cs ⟹ ¬(∃a b. LT a b = x)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x. x ∈ set cs ⟹ ¬(∃a b. GT a b = x)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x. x ∈ set cs ⟹ ¬(∃a b. LTPP a b = x)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x. x ∈ set cs ⟹ ¬(∃a b. GTPP a b = x)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nonstrict_constrs cs"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>nonstrict_constr.elims</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sat_constr_sat_transf_constrs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>c</sub> cs"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> set (transf_constraint cs)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>cs</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>valuate_uminus</span><span> </span><span>valuate_minus</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sat_constrs_sat_transf_constrs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> set cs"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> set (transf_constraints cs)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>cs</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>UnE</span><span> </span><span>list.set_intros</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> 
</span><span>      </span><span>list.set_intros</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>sat_constr_sat_transf_constrs</span><span> </span><span>set_append</span><span> </span><span>transf_constraints.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sat_transf_constrs_sat_constr</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nonstrict_constr cs"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> set (transf_constraint cs)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>c</sub> cs"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>cs</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>valuate_uminus</span><span> </span><span>valuate_minus</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sat_transf_constrs_sat_constrs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nonstrict_constrs cs"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> set (transf_constraints cs)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> set cs"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>cs</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sat_transf_constrs_sat_constr</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div><div id="Linear_Programming">
<div class="head"><h1>Theory Linear_Programming</h1>
<span class="command">theory</span> <span class="name">Linear_Programming</span><br/>
<span class="keyword">imports</span> <a href="LP_Preliminaries.html"><span class="name">LP_Preliminaries</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Linear_Programming</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Code_Target_Int"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"LP_Preliminaries"</span></span></span><span>
</span><span>    </span><span>Farkas.Simplex_for_Reals</span><span> 
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Abstract LPs ›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* A b c, where A leq b are the constraints and c is the objective function *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Primal Problem ›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sat_primal A b = { x. [A *<span class="hidden">⇩</span><sub>v</sub> x]≤b }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Dual Problem ›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sat_dual A c  = {y. [y <span class="hidden">⇩</span><sub>v</sub>* A]=c ∧ (∀i&lt;dim_vec y. y $ i ≥ 0)}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"optimal_set f S = {x ∈ S. (∀y∈ S. f x y)}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>max_lp</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"max_lp A b c ≡ optimal_set (λx y. (y ∙ c) ≤ (x ∙ c)) (sat_primal A b)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>min_lp</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"min_lp A b c ≡ optimal_set (λx y. (y ∙ c) ≥ (x ∙ c)) (sat_dual A c)"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>optimal_setI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ S"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀y. y ∈ S ⟹ (λx y. (y ∙ c) ≥ (x ∙ c)) x y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ optimal_set (λx y. (y ∙ c) ≥ (x ∙ c)) S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>optimal_set_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>max_lpI</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[A *<span class="hidden">⇩</span><sub>v</sub> x]≤b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀y. [A *<span class="hidden">⇩</span><sub>v</sub> y]≤b ⟹ (λx y. (y ∙ c) ≥ (x ∙ c)) y x)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ max_lp A b c"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>optimal_setI</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span class="string"><span class="delete"><span class="delete">"{ x. [A *<span class="hidden">⇩</span><sub>v</sub> x]≤b }"</span></span></span><span> </span><span>c</span><span class="delimiter">]</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>optimal_set_def</span><span> </span><span>optimal_setI</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>sat_primal_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>min_lpI</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[y <span class="hidden">⇩</span><sub>v</sub>* A]=c"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀i. i&lt;dim_vec y ⟹ y $ i ≥ 0)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀x. x ∈ sat_dual A c ⟹ (λx y. (y ∙ c) ≥ (x ∙ c)) y x)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ min_lp A b c"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>optimal_setI</span><span class="delimiter">[</span><span>of</span><span> </span><span>y</span><span> </span><span class="string"><span class="delete"><span class="delete">"sat_dual A c"</span></span></span><span> </span><span>c</span><span class="delimiter">]</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>optimal_set_def</span><span> </span><span>optimal_setI</span><span> </span><span>sat_dual_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>sat_dual_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sat_primalD</span><span> </span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ sat_primal A b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[A *<span class="hidden">⇩</span><sub>v</sub> x]≤b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>sat_primal_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sat_primalI</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[A *<span class="hidden">⇩</span><sub>v</sub> x]≤b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ sat_primal A b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>sat_primal_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sat_dualD</span><span> </span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ sat_dual A c"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[y <span class="hidden">⇩</span><sub>v</sub>* A]=c"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀i&lt;dim_vec y. y $ i ≥ 0)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>sat_dual_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>sat_dual_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sat_dualI</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[y <span class="hidden">⇩</span><sub>v</sub>* A]=c"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀i&lt;dim_vec y. y $ i ≥ 0)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ sat_dual A c"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>sat_dual_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sol_dim_in_sat_primal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ sat_primal A b ⟹ dim_vec x = dim_col A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mat_times_vec_leq_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mat_times_vec_leq_def</span><span> </span><span>sat_primal_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sol_dim_in_max_lp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ max_lp A b c ⟹ dim_vec x = dim_col A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>optimal_set_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sol_dim_in_sat_primal</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span>A</span><span> </span><span>b</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sol_dim_in_sat_dual</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ sat_dual A c ⟹ dim_vec x = dim_row A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mat_times_vec_leq_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sat_dual_def</span><span> </span><span>vec_times_mat_eq_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sol_dim_in_min_lp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ min_lp A b c ⟹ dim_vec x = dim_row A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>optimal_set_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sol_dim_in_sat_dual</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span>A</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>min_lp_in_sat_dual</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ min_lp A b c ⟹ x ∈ sat_dual A c"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>optimal_set_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sol_dim_in_sat_dual</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span>A</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>max_lp_in_sat_primal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ max_lp A b c ⟹ x ∈ sat_primal A b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>optimal_set_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sol_dim_in_sat_dual</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span>A</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>abstract_LP</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>A</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::{comm_semiring_1,ordered_semiring,linorder}) mat"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>b</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a vec"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>c</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a vec"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>m</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>n</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∈ carrier_vec m"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ∈ carrier_vec n"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A ∈ carrier_mat m n"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dim_b_row_A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec b = dim_row A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>abstract_LP_axioms</span><span> </span><span>abstract_LP_def</span><span> </span><span>carrier_matD</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>carrier_vecD</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dim_b_col_A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec c = dim_col A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>abstract_LP_axioms</span><span> </span><span>abstract_LP_def</span><span> </span><span>carrier_matD</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>carrier_vecD</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>weak_duality_aux</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>i</span><span> </span><span>j</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ {c ∙ x |x. x ∈ sat_primal A b}"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j ∈ {b ∙ y |y. y ∈ sat_dual A c}"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ≤ j"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i = c ∙ x"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[A *<span class="hidden">⇩</span><sub>v</sub> x]≤b"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>y</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"j = b ∙ y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[y <span class="hidden">⇩</span><sub>v</sub>* A]=c"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀i&lt;dim_vec y. 0 ≤ y $ i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>d1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec x = n"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mat_times_vec_leq_def</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span> </span><span>x</span><span> </span><span>b</span><span class="delimiter">]</span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>abstract_LP_axioms</span><span> </span><span>abstract_LP_def</span><span> </span><span>carrier_matD</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>d2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec y = m"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>abstract_LP_axioms</span><span> </span><span>abstract_LP_def</span><span> </span><span>carrier_matD</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>index_transpose_mat</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>vec_times_mat_eq_def</span><span> </span><span>y</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i = c ∙ x"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (A<span class="hidden">⇧</span><sup>T</sup> *<span class="hidden">⇩</span><sub>v</sub> y) ∙ x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mult_right_eq</span><span> </span><span>carrier_vecD</span><span> </span><span>y</span><span> </span><span>abstract_LP_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>abstract_LP_axioms</span><span> </span><span>calculation</span><span> </span><span>d1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (A *<span class="hidden">⇩</span><sub>v</sub> x) ∙ y"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assoc_scalar_prod_mult_mat_vec</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>y</span><span> </span><span>m</span><span> </span><span>x</span><span> </span><span>n</span><span> </span><span>A</span><span class="delimiter">]</span><span> </span><span>abstract_LP_axioms</span><span> </span><span>abstract_LP_def</span><span> </span><span>d1</span><span> </span><span>d2</span><span> 
</span><span>      </span><span>carrier_vec_dim_vec</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ b ∙ y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mult_right_leq</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>index_transpose_mat</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>mat_times_vec_leq_def</span><span> </span><span>vec_times_mat_eq_def</span><span> </span><span>x</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>y</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>y</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = j"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>y</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ≤ j"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>weak_duality_theorem</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ max_lp A b c"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ min_lp A b c"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∙ c ≤ y ∙ b"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i = x ∙ c"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>j</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>j</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"j = y ∙ b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dx</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec x = n"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sol_dim_in_max_lp</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span>c</span><span> </span><span>A</span><span> </span><span>b</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>abstract_LP_axioms</span><span> </span><span>abstract_LP_def</span><span> 
</span><span>      </span><span>carrier_matD</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dy</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec y = m"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sol_dim_in_min_lp</span><span class="delimiter">[</span><span>of</span><span> </span><span>y</span><span> </span><span>c</span><span> </span><span>A</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>  </span><span>abstract_LP_axioms</span><span> </span><span>abstract_LP_def</span><span> 
</span><span>      </span><span>carrier_matD</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ {c ∙ x |x. [A *<span class="hidden">⇩</span><sub>v</sub> x]≤b}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>optimal_set_def</span><span> </span><span>dx</span><span> </span><span>sat_primal_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>abstract_LP_axioms</span><span> </span><span>abstract_LP_def</span><span> </span><span>carrier_vec_dim_vec</span><span> </span><span>comm_scalar_prod</span><span> </span><span>dx</span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>**</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"j ∈ {b ∙ y |y. [y <span class="hidden">⇩</span><sub>v</sub>* A]=c ∧ (∀i &lt; dim_vec y. y$i ≥ 0)}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>optimal_set_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>abstract_LP_axioms</span><span> </span><span>abstract_LP_def</span><span> 
</span><span>      </span><span>carrier_vec_dim_vec</span><span> </span><span>comm_scalar_prod</span><span> </span><span>dy</span><span> </span><span>j</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>weak_duality_aux</span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span> </span><span>j</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ≤ j"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sat_primal_def</span><span> </span><span>sat_dual_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"*"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"**"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i</span><span> </span><span>j</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>create_optimal_solutions</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"create_optimal_solutions A b c = 
        (case simplex (x_times_c_geq_y_times_b c b #
                                      mat_leqb_eqc A b c @
                                      from_index_geq0_vector (dim_vec c) (0<span class="hidden">⇩</span><sub>v</sub> (dim_vec b)))
                                    of
                                      Unsat X ⇒ Unsat X
                                      | Sat X ⇒ Sat X)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>optimize_no_cond</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"optimize_no_cond A b c = (case create_optimal_solutions A b c of 
                          Unsat X ⇒ Unsat X 
                        | Sat X ⇒  Sat (fst (split_n_m_x (dim_vec c) (dim_vec b) X)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>create_opt_sol_satisfies</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"create_optimal_solutions A b c = Sat X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨X⟩ ⊨<span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> set ((x_times_c_geq_y_times_b c b # mat_leqb_eqc A b c @
                      from_index_geq0_vector (dim_vec c) (0<span class="hidden">⇩</span><sub>v</sub> (dim_vec b))))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"simplex (x_times_c_geq_y_times_b c b # mat_leqb_eqc A b c @
        from_index_geq0_vector (dim_vec c) (0<span class="hidden">⇩</span><sub>v</sub> (dim_vec b))) = Sat X"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"simplex (x_times_c_geq_y_times_b c b # mat_leqb_eqc A b c @ from_index_geq0_vector (dim_vec c) (0<span class="hidden">⇩</span><sub>v</sub> (dim_vec b))) ≠ Inr X"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃e. simplex (x_times_c_geq_y_times_b c b # mat_leqb_eqc A b c @ from_index_geq0_vector (dim_vec c) (0<span class="hidden">⇩</span><sub>v</sub> (dim_vec b))) = Unsat e"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>create_optimal_solutions.simps</span><span> </span><span>sum.case</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>sumE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃e. create_optimal_solutions A b c = Unsat e"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>option.split</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>simplex</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>create_opt_sol_sat_leq_mat</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec b = dim_row A"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"create_optimal_solutions A b c = Sat X"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) = split_i_j_x (dim_col A) (dim_vec b) X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[A *<span class="hidden">⇩</span><sub>v</sub> x]≤b"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨X⟩ ⊨<span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> set (mat_leqb_eqc A b c)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>create_opt_sol_satisfies</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>X</span><span class="delimiter">]</span><span> </span><span>sat_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(mat_leqb_eqc A b c)"</span></span></span><span> </span><span>_</span><span> </span><span>X</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append_Cons</span><span> </span><span>append_assoc</span><span> </span><span>in_set_conv_decomp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mat_leqb_eqc_split_correct1</span><span class="delimiter">[</span><span>of</span><span> </span><span>b</span><span> </span><span>A</span><span> </span><span>c</span><span> </span><span>X</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>*</span><span class="delimiter">]</span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>create_opt_sol_sat_eq_mat</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec c = dim_row A<span class="hidden">⇧</span><sup>T</sup>"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec b = dim_col A<span class="hidden">⇧</span><sup>T</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"create_optimal_solutions A b c = Sat X"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) = split_i_j_x (dim_vec c) (dim_vec c + dim_vec b) X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[y <span class="hidden">⇩</span><sub>v</sub>* A]=c"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨X⟩ ⊨<span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> set (mat_leqb_eqc A b c)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>create_opt_sol_satisfies</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>X</span><span class="delimiter">]</span><span> </span><span>sat_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(mat_leqb_eqc A b c)"</span></span></span><span> </span><span>_</span><span> </span><span>X</span><span class="delimiter">]</span><span>
</span><span>      </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>UnCI</span><span> </span><span>list.set_intros</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>set_append</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_row A<span class="hidden">⇧</span><sup>T</sup> = dim_vec c"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_col A<span class="hidden">⇧</span><sup>T</sup> = dim_vec b"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mat_leqb_eqc_split_correct2</span><span class="delimiter">[</span><span>of</span><span> </span><span>c</span><span> </span><span>A</span><span> </span><span>b</span><span> </span><span>X</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>*</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹dim_vec b = dim_col A<span class="hidden">⇧</span><sup>T</sup>›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹dim_vec c = dim_row A<span class="hidden">⇧</span><sup>T</sup>›</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>create_opt_sol_satisfies_leq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"create_optimal_solutions A b c = Sat X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) = split_n_m_x (dim_vec c) (dim_vec b) X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∙ c ≥ y ∙ b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>create_opt_sol_satisfies</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>X</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>carrier_vec_dim_vec</span><span> </span><span>comm_scalar_prod</span><span> </span><span>list.set_intros</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> 
</span><span>      </span><span>split_n_m_x_abbrev_dims</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>split_vec_dims</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>x_times_c_geq_y_times_b_split_dotP</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>create_opt_sol_satisfies_geq0</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"create_optimal_solutions A b c = Sat X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) = split_n_m_x (dim_vec c) (dim_vec b) X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. i &lt; dim_vec y ⟹ y$i ≥ 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; dim_vec y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨X⟩ ⊨<span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> set (from_index_geq0_vector (dim_vec c) (0<span class="hidden">⇩</span><sub>v</sub> (dim_vec b)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>create_opt_sol_satisfies</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>UnCI</span><span> </span><span>append_Cons</span><span> </span><span>set_append</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>**</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; dim_vec b"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹i &lt; dim_vec y›</span></span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>split_n_m_x_abbrev_dims</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ y $ i"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>from_index_geq0_vector_split_snd</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec c"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0<span class="hidden">⇩</span><sub>v</sub> (dim_vec b)"</span></span></span><span> </span><span>X</span><span> </span><span>x</span><span> </span><span>y</span><span>  
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"dim_vec b"</span></span></span><span> </span><span>i</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>*</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>rat_LP</span><span> </span><span class="delimiter">=</span><span> </span><span>abstract_LP</span><span> </span><span>A</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>m</span><span> </span><span>n</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>A</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"rat mat"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"rat vec"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>c</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"rat vec"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>create_opt_sol_in_LP</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"create_optimal_solutions A b c = Sat X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) = split_n_m_x (dim_vec c) (dim_vec b) X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[A *<span class="hidden">⇩</span><sub>v</sub> x]≤b"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[y <span class="hidden">⇩</span><sub>v</sub>* A]=c"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∙ c ≥ y ∙ b"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. i &lt; dim_vec y ⟹ y$i ≥ 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Pair_inject</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>create_opt_sol_sat_leq_mat</span><span> </span><span>dim_b_col_A</span><span> </span><span>dim_b_row_A</span><span> </span><span>split_i_j_x_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>create_opt_sol_sat_eq_mat</span><span> </span><span>dim_b_col_A</span><span> </span><span>dim_b_row_A</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>index_transpose_mat</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>index_transpose_mat</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>create_opt_sol_satisfies_leq</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>create_opt_sol_satisfies_geq0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>create_optim_in_sols</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"create_optimal_solutions A b c = Sat X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) = split_n_m_x (dim_vec c) (dim_vec b) X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ∙ x ∈ {c ∙ x |x. [A *<span class="hidden">⇩</span><sub>v</sub> x]≤b}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"b ∙ y ∈ {b ∙ y |y. [y <span class="hidden">⇩</span><sub>v</sub>* A]=c ∧ (∀i &lt; dim_vec y. y$i ≥ 0)}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>create_opt_sol_in_LP</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>create_opt_sol_in_LP</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>create_opt_sol_in_LP</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cx_leq_bx_in_creating_opt</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"create_optimal_solutions A b c = Sat X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) = split_n_m_x (dim_vec c) (dim_vec b) X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ∙ x ≤ b ∙ y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>weak_duality_aux</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"c ∙ x"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∙ y"</span></span></span><span class="delimiter">]</span><span>  </span><span>create_optim_in_sols</span><span class="delimiter">[</span><span>of</span><span> </span><span>X</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>min_max_for_sol</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"create_optimal_solutions A b c = Sat X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) = split_n_m_x (dim_vec c) (dim_vec b) X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ∙ x = b ∙ y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>create_opt_sol_in_LP</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>X</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span>cx_leq_bx_in_creating_opt</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span>
</span><span>    </span><span>comm_scalar_prod</span><span class="delimiter">[</span><span>of</span><span> </span><span>c</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec c"</span></span></span><span> </span><span>x</span><span class="delimiter">]</span><span> </span><span>comm_scalar_prod</span><span class="delimiter">[</span><span>of</span><span> </span><span>b</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec b"</span></span></span><span> </span><span>y</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_diff_cancel_left'</span><span> </span><span>antisym</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>carrier_vec_dim_vec</span><span> </span><span>split_vec_dims</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>split_vec_dims</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>create_opt_solutions_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"create_optimal_solutions A b c = Sat X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) = split_n_m_x (dim_vec c) (dim_vec b) X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ max_lp A b c"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[A *<span class="hidden">⇩</span><sub>v</sub> x]≤b"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>create_opt_sol_in_LP</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>z</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"[A *<span class="hidden">⇩</span><sub>v</sub> z]≤b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c ∙ z ∈ {c ∙ x |x. x ∈ sat_primal A b}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sat_primalI</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span> </span><span>z</span><span> </span><span>b</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>a</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∙ y ∈ {b ∙ y |y. y ∈ sat_dual A c}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sat_dualI</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>create_opt_sol_in_LP</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>        </span><span>mem_Collect_eq</span><span> </span><span>rat_LP.create_opt_sol_in_LP</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>rat_LP_axioms</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ∙ z ≤ b ∙ y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>weak_duality_aux</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"c ∙ z"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∙ y"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>1</span><span> </span><span>2</span><span class="delimiter">]</span><span> </span><span>sat_primalI</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span> </span><span>z</span><span> </span><span>b</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>a</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>      
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = x ∙ c"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>carrier_vec_dim_vec</span><span> </span><span>comm_scalar_prod</span><span> 
</span><span>        </span><span>min_max_for_sol</span><span> </span><span>split_n_m_x_abbrev_dims</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ∙ c ≤ x ∙ c"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a</span><span> </span><span>carrier_vec_dim_vec</span><span> </span><span>comm_scalar_prod</span><span> </span><span>dim_b_col_A</span><span> </span><span>mat_times_vec_leqD</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>optimize_no_cond_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"optimize_no_cond A b c = Sat x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ max_lp A b c"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>X</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>X</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"create_optimal_solutions A b c = Sat X"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Inr_Inl_False</span><span> </span><span>assms</span><span> </span><span>old.sum.exhaust</span><span> </span><span>old.sum.simps</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>optimize_no_cond.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = (fst (split_n_m_x (dim_vec c) (dim_vec b) X))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>X</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>old.sum.inject</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>old.sum.simps</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>optimize_no_cond.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>create_opt_solutions_correct</span><span class="delimiter">[</span><span>of</span><span> </span><span>X</span><span> </span><span>x</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>X</span><span> </span><span>fst_conv</span><span> </span><span>old.prod.exhaust</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>optimize_no_cond_sol_sat</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"optimize_no_cond A b c = Sat x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ sat_primal A b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>max_lp_in_sat_primal</span><span class="delimiter">[</span><span>OF</span><span> </span><span>optimize_no_cond_correct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* end of ‹ rat_LP › *)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>maximize</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"maximize A b c = (if dim_vec b = dim_row A ∧ dim_vec c = dim_col A then
                      Some (optimize_no_cond A b c)
                    else None)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>optimize_sound</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"maximize A b c = Some (Sat x)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ max_lp A b c"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec b = dim_row A ∧ dim_vec c = dim_col A"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>maximize.simps</span><span> </span><span>option.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>rat</span><span class="delimiter">:</span><span> </span><span>rat_LP</span><span> </span><span>A</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec b"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec c"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>abstract_LP_def</span><span> </span><span>carrier_mat_triv</span><span> </span><span>carrier_vec_dim_vec</span><span> </span><span>rat_LP.intro</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Sat x = optimize_no_cond A b c"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>*</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rat.optimize_no_cond_correct</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>maximize_option_elim</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"maximize A b c = Some x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec b = dim_row A"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_vec c = dim_col A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>maximize.simps</span><span> </span><span>option.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>optimize_sol_dimension</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"maximize A b c = Some (Sat x)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ carrier_vec (dim_col A)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>carrier_dim_vec</span><span> </span><span>max_lp_in_sat_primal</span><span> </span><span>optimize_sound</span><span> </span><span>sol_dim_in_sat_primal</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>optimize_sat</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"maximize A b c = Some (Sat x)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[A *<span class="hidden">⇩</span><sub>v</sub> x]≤b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>maximize_option_elim</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span>
</span><span>    </span><span>max_lp_in_sat_primal</span><span class="delimiter">[</span><span>OF</span><span> </span><span>optimize_sound</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>x</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span class="delimiter">(</span><span>eq</span><span class="delimiter">)</span><span> </span><span>ceq</span><span> </span><span>rat</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span class="delimiter">(</span><span>linorder</span><span class="delimiter">)</span><span> </span><span>compare</span><span> </span><span>rat</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span class="delimiter">(</span><span>compare</span><span class="delimiter">)</span><span> </span><span>ccompare</span><span> </span><span>rat</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span class="delimiter">(</span><span>rbt</span><span class="delimiter">)</span><span> </span><span>set_impl</span><span> </span><span>rat</span><span>
</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span class="delimiter">(</span><span>eq</span><span class="delimiter">)</span><span> </span><span>ceq</span><span> </span><span>atom</span><span> </span><span>QDelta</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span class="delimiter">(</span><span>linorder</span><span class="delimiter">)</span><span> </span><span>compare_order</span><span> </span><span>QDelta</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span>compare_order</span><span> </span><span>atom</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span>ccompare</span><span> </span><span>atom</span><span> </span><span>QDelta</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span class="delimiter">(</span><span>rbt</span><span class="delimiter">)</span><span> </span><span>set_impl</span><span> </span><span>atom</span><span> </span><span>QDelta</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*export_code maximize mat_of_cols_list mat_of_rows_list mat_of_cols vec_of_list quotient_of Inr Inl Some None list_of_vec nat
Rat.Fract int_of_integer in Haskell module_name LP  file "/home/julian/coding/ForGET/LPBenchmarks/HaskellLP/src" 
*)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
export_code  maximize mat_of_cols_list mat_of_rows_list mat_of_cols vec_of_list quotient_of Inr Inl Some None list_of_vec nat
Rat.Fract int_of_integer in Scala
*)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
section ‹ Testing ›
lemma "(let A = mat_of_rows 3 (map vec_of_list [[1, 12, 2], [1, 5, 9], [-1,0,0], [0,-1,0],[0,0,-1]]) in
       (let b = vec_of_list [10000, 8539,0,0,0] in
       (let c = vec_of_list [100, 600, 400] in
       maximize A b c))) =  Some (Inr (vec_of_list [52468 / 7, 1461 / 7, 0]))"
  by eval

lemma "(let A = mat_of_cols 4 (map vec_of_list [[2::rat, -1, -1, 1/2], [1, 2, -1, -1/2]]) in
       (let b = vec_of_list [5, 2, -1, 1/2] in
       (let c = vec_of_list [7, 1::rat] in
       maximize A b c))) = Some (Inr (vec_of_list [2::rat, 1]))"
  by eval
*)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
value "(let A = mat_of_cols_list 4 [[-1::rat, -1, -0, 1], [1, -1, -1, -2]] in
       (let b = vec_of_list [1, -2, -0, 4] in
       (let c = vec_of_list [-2, 1::rat] in
       maximize A b c)))"

value "(let A = mat_of_cols 4 (map vec_of_list [[2::rat, 2, -1, 0], [3, 1, 0, -1]]) in
       (let b = vec_of_list [1500::rat,1000,0,0] in
       (let c = vec_of_list [50, 40::rat] in
       maximize A b c)))"
 (*  Sol should be 375, 250 *)

value "(let A = mat_of_cols 2 (map vec_of_list [[-1::rat, 1], [-1,-1]]) in
       (let b = vec_of_list [2::rat, 2] in
       (let c = vec_of_list [0, 1::rat] in
       maximize A b c)))"
  (* Sol should be 375, 250 *)

value "(let A = mat_of_rows 2 (map vec_of_list [[2::rat,3],[2, 1], [-1,0],[0,-1]]) in
       (let b = vec_of_list [1500::rat,1000,0,0] in
       (let c = vec_of_list [50, 40::rat] in
       maximize A b c)))"
  (* Sol should be 375, 250 *)
*)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>of_rat_val</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"simplex cs = (Sat v) ⟹ of_rat_val ⟨v⟩ ⊨<span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> set cs"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>of_rat_val_constraint</span><span> </span><span>simplex_real</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div>