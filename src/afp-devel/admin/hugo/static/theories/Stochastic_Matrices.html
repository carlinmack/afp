<div id="Stochastic_Matrix">
<div class="head">
<h1>Theory Stochastic_Matrix</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Stochastic Matrices›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We define a type for stochastic vectors and right-stochastic matrices,
 i.e., non-negative real vectors and matrices where the sum of each column is 1.
 For this type we define a matrix-vector multplication, i.e., we show that
 $A * v$ is a stochastic vector, if $A$ is a right-stochastic matrix and $v$ 
 a stochastic vector.
›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Stochastic_Matrix
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="../Perron_Frobenius/Perron_Frobenius_Aux.html">Perron_Frobenius.Perron_Frobenius_Aux</a> <span class="comment1">(* for non_neg_mat *)</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">non_neg_vec</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> linordered_idom <span class="main">^</span> <span class="tfree">'n</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">non_neg_vec</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">i</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">$</span> <span class="bound">i</span> <span class="main">≥</span> <span class="main">0</span><span class="main">)</span>"</span></span> 

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">stoch_vec</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> comm_ring_1 <span class="main">^</span> <span class="tfree">'n</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">stoch_vec</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span> <span class="main">(</span>sum <span class="main">(</span><span class="main">λ</span> <span class="bound">i</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">$</span> <span class="bound">i</span><span class="main">)</span> UNIV <span class="main">=</span> <span class="main">1</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">right_stoch_mat</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> comm_ring_1 <span class="main">^</span> <span class="tfree">'n</span> <span class="main">^</span> <span class="tfree">'m</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">right_stoch_mat</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">j</span><span class="main">.</span> stoch_vec <span class="main">(</span>column <span class="bound">j</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span> 

<span class="keyword1"><span class="command">typedef</span></span> <span class="tfree">'i</span> st_mat <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span> <span class="bound">a</span> <span class="main">::</span> real <span class="main">^</span> <span class="tfree">'i</span> <span class="main">^</span> <span class="tfree">'i</span><span class="main">.</span> non_neg_mat <span class="bound">a</span> <span class="main">∧</span> right_stoch_mat <span class="bound">a</span><span class="main">}</span>"</span></span> 
  <span class="keyword2"><span class="keyword">morphisms</span></span> st_mat Abs_st_mat
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> exI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">χ</span> <span class="bound">i</span> <span class="bound">j</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">i</span> <span class="main">=</span> undefined <span class="keyword1">then</span> <span class="main">1</span> <span class="keyword1">else</span> <span class="main">0</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> 
      <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> non_neg_mat_def elements_mat_h_def right_stoch_mat_def stoch_vec_def column_def<span class="main">)</span>

<span class="keyword1"><span class="command">setup_lifting</span></span> type_definition_st_mat

<span class="keyword1"><span class="command">typedef</span></span> <span class="tfree">'i</span> st_vec <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span> <span class="bound">v</span> <span class="main">::</span> real <span class="main">^</span> <span class="tfree">'i</span><span class="main">.</span> non_neg_vec <span class="bound">v</span> <span class="main">∧</span> stoch_vec <span class="bound">v</span><span class="main">}</span>"</span></span> 
  <span class="keyword2"><span class="keyword">morphisms</span></span> st_vec Abs_st_vec
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> exI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">χ</span> <span class="bound">i</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">i</span> <span class="main">=</span> undefined <span class="keyword1">then</span> <span class="main">1</span> <span class="keyword1">else</span> <span class="main">0</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> 
      <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> non_neg_vec_def stoch_vec_def<span class="main">)</span>

<span class="keyword1"><span class="command">setup_lifting</span></span> type_definition_st_vec

<span class="keyword1"><span class="command">lift_definition</span></span> transition_vec_of_st_mat <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'i</span> <span class="main">::</span> finite st_mat <span class="main">⇒</span> <span class="tfree">'i</span> <span class="main">⇒</span> <span class="tfree">'i</span> st_vec"</span></span> 
  <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">a</span> <span class="bound">i</span><span class="main">.</span> column <span class="bound">i</span> <span class="bound">a</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> right_stoch_mat_def non_neg_mat_def stoch_vec_def 
      elements_mat_h_def non_neg_vec_def column_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> non_neg_vec_st_vec<span class="main">:</span> <span class="quoted"><span class="quoted">"non_neg_vec <span class="main">(</span>st_vec <span class="free">v</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> non_neg_mat_mult_non_neg_vec<span class="main">:</span> <span class="quoted"><span class="quoted">"non_neg_mat <span class="free">a</span> <span class="main">⟹</span> non_neg_vec <span class="free">v</span> <span class="main">⟹</span> 
  non_neg_vec <span class="main">(</span><span class="free">a</span> <span class="keyword1">*v</span> <span class="free">v</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> non_neg_mat_def non_neg_vec_def  elements_mat_h_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> matrix_vector_mult_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> sum_nonneg<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> right_stoch_mat_mult_stoch_vec<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"right_stoch_mat <span class="free">a</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"stoch_vec <span class="free">v</span>"</span></span> 
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"stoch_vec <span class="main">(</span><span class="free">a</span> <span class="keyword1">*v</span> <span class="free">v</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">note</span></span> * <span class="main">=</span> assms<span class="main">[</span><span class="operator">unfolded</span> right_stoch_mat_def column_def stoch_vec_def<span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"stoch_vec <span class="main">(</span><span class="free">a</span> <span class="keyword1">*v</span> <span class="free">v</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="main">∑</span><span class="bound">i</span><span class="main">∈</span>UNIV<span class="main">.</span> <span class="main">∑</span><span class="bound">j</span><span class="main">∈</span>UNIV<span class="main">.</span> <span class="free">a</span> <span class="main">$</span> <span class="bound">i</span> <span class="main">$</span> <span class="bound">j</span> <span class="main">*</span> <span class="free">v</span> <span class="main">$</span> <span class="bound">j</span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span><span class="main">)</span>"</span></span> 
    <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">=</span> <span class="main">(</span><span class="var">?sum</span> <span class="main">=</span> <span class="main">1</span><span class="main">)</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> stoch_vec_def matrix_vector_mult_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?sum</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">j</span><span class="main">∈</span>UNIV<span class="main">.</span> <span class="main">∑</span><span class="bound">i</span><span class="main">∈</span>UNIV<span class="main">.</span> <span class="free">a</span> <span class="main">$</span> <span class="bound">i</span> <span class="main">$</span> <span class="bound">j</span> <span class="main">*</span> <span class="free">v</span> <span class="main">$</span> <span class="bound">j</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> sum.swap<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">j</span><span class="main">∈</span>UNIV<span class="main">.</span> <span class="free">v</span> <span class="main">$</span> <span class="bound">j</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> sum.cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> refl<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">insert</span> *<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sum_distrib_right<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> * <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> st_mat_times_st_vec <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'i</span> <span class="main">::</span> finite st_mat <span class="main">⇒</span> <span class="tfree">'i</span> st_vec <span class="main">⇒</span> <span class="tfree">'i</span> st_vec"</span></span> 
  <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">*st</span>"</span> 70<span class="main">)</span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">(*v)</span>"</span></span> 
  <span class="keyword1"><span class="command">using</span></span> right_stoch_mat_mult_stoch_vec non_neg_mat_mult_non_neg_vec <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lift_definition</span></span> to_st_vec <span class="main">::</span> <span class="quoted"><span class="quoted">"real <span class="main">^</span> <span class="tfree">'i</span> <span class="main">⇒</span> <span class="tfree">'i</span> st_vec"</span></span> <span class="keyword2"><span class="keyword">is</span></span> 
  <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> stoch_vec <span class="bound">x</span> <span class="main">∧</span> non_neg_vec <span class="bound">x</span> <span class="keyword1">then</span> <span class="bound">x</span> <span class="keyword1">else</span> <span class="main">(</span><span class="keyword1">χ</span> <span class="bound">i</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">i</span> <span class="main">=</span> undefined <span class="keyword1">then</span> <span class="main">1</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> non_neg_vec_def stoch_vec_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> right_stoch_mat_st_mat<span class="main">:</span> <span class="quoted"><span class="quoted">"right_stoch_mat <span class="main">(</span>st_mat <span class="free">A</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> non_neg_mat_st_mat<span class="main">:</span> <span class="quoted"><span class="quoted">"non_neg_mat <span class="main">(</span>st_mat <span class="free">A</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> non_neg_mat_def elements_mat_h_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> st_mat_mult_st_vec<span class="main">:</span> <span class="quoted"><span class="quoted">"st_mat <span class="free">A</span> <span class="keyword1">*v</span> st_vec <span class="free">X</span> <span class="main">=</span> st_vec <span class="main">(</span><span class="free">A</span> <span class="keyword1">*st</span> <span class="free">X</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> st_vec_nonneg<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"st_vec <span class="free">x</span> <span class="main">$</span> <span class="free">i</span> <span class="main">≥</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> non_neg_vec_st_vec<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">x</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> non_neg_vec_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> st_mat_nonneg<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"st_mat <span class="free">x</span> <span class="main">$</span> <span class="free">i</span> <span class="keyword1">$h</span> <span class="free">j</span> <span class="main">≥</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> non_neg_mat_st_mat<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">x</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> non_neg_mat_def elements_mat_h_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="Stochastic_Vector_PMF">
<div class="head">
<h1>Theory Stochastic_Vector_PMF</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Stochastic Vectors and Probability Mass Functions›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We prove that over a finite type, stochastic vectors and probability
  mass functions are essentially the same thing: one can convert between both
  representations.›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Stochastic_Vector_PMF
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="Stochastic_Matrix.html">Stochastic_Matrix</a>
  <span class="quoted">"<a href="../../HOL/HOL-Probability/Probability_Mass_Function.html">HOL-Probability.Probability_Mass_Function</a>"</span> 
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> sigma_algebra_UNIV_finite<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"sigma_algebra <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span> <span class="main">::</span> finite set<span class="main">)</span> UNIV"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">goal_cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>4 <span class="skolem">a</span> <span class="skolem">b</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> exI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="skolem">a</span><span class="main">-</span><span class="skolem">b</span><span class="main">}</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">measure_of_st_vec'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> st_vec <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">::</span> finite set <span class="main">⇒</span> ennreal"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">measure_of_st_vec'</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">I</span></span></span> <span class="main">=</span> sum <span class="main">(</span><span class="main">λ</span> <span class="bound">i</span><span class="main">.</span> st_vec <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">$</span> <span class="bound">i</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">I</span></span></span>"</span></span> 

<span class="keyword1"><span class="command">lemma</span></span> positive_measure_of_st_vec'<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"positive <span class="free">A</span> <span class="main">(</span>measure_of_st_vec' <span class="free">x</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> measure_of_st_vec'_def positive_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> measure_space_measure_of_st_vec'<span class="main">:</span> <span class="quoted"><span class="quoted">"measure_space UNIV UNIV <span class="main">(</span>measure_of_st_vec' <span class="free">x</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> measure_space_def 
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> countably_additive_def measure_of_st_vec'_def disjoint_family_on_def<span class="main"><span class="keyword3">,</span></span>
  <span class="operator">clarify</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">goal_cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">A</span><span class="main">)</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?x</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"st_vec <span class="free">x</span>"</span></span> 
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">N</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">N</span> <span class="main">=</span> <span class="main">{</span><span class="bound">i</span><span class="main">.</span> <span class="skolem">A</span> <span class="bound">i</span> <span class="main">≠</span> <span class="main">{}</span><span class="main">}</span>"</span></span> 
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?A</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">⋃</span><span class="main">(</span><span class="skolem">A</span> <span class="main">`</span> <span class="skolem">N</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="skolem">B</span> <span class="main">⟹</span> <span class="skolem">B</span> <span class="main">⊆</span> <span class="var">?A</span> <span class="main">⟹</span> <span class="main">∃</span> <span class="bound">K</span><span class="main">.</span> finite <span class="bound">K</span> <span class="main">∧</span> <span class="bound">K</span> <span class="main">⊆</span> <span class="skolem">N</span> <span class="main">∧</span> <span class="skolem">B</span> <span class="main">⊆</span> <span class="main">⋃</span><span class="main">(</span><span class="skolem">A</span> <span class="main">`</span> <span class="bound">K</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">B</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> finite_induct<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>insert <span class="skolem">b</span> <span class="skolem">B</span><span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> insert<span class="main">(</span>3-4<span class="main">)</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">K</span></span> <span class="keyword2"><span class="keyword">where</span></span> K<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="skolem">K</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">K</span> <span class="main">⊆</span> <span class="skolem">N</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">B</span> <span class="main">⊆</span> <span class="main">⋃</span><span class="main">(</span><span class="skolem">A</span> <span class="main">`</span> <span class="skolem">K</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> insert<span class="main">(</span>4<span class="main">)</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">a</span></span> <span class="keyword2"><span class="keyword">where</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> <span class="skolem">N</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> <span class="skolem">A</span> <span class="skolem">a</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> exI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted">"insert <span class="skolem">a</span> <span class="skolem">K</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">insert</span> a K<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">OF</span> _ subset_refl<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">K</span></span> <span class="keyword2"><span class="keyword">where</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="skolem">K</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">K</span> <span class="main">⊆</span> <span class="skolem">N</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋃</span><span class="main">(</span><span class="skolem">A</span> <span class="main">`</span> <span class="skolem">K</span><span class="main">)</span> <span class="main">=</span> <span class="var">?A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">K</span> <span class="main">⊂</span> <span class="skolem">N</span>"</span></span> 
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">n</span></span> <span class="keyword2"><span class="keyword">where</span></span> **<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">∈</span> <span class="skolem">N</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">∉</span> <span class="skolem">K</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">unfolded</span> N_def<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">a</span></span> <span class="keyword2"><span class="keyword">where</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> <span class="skolem">A</span> <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> ** * <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">k</span></span> <span class="keyword2"><span class="keyword">where</span></span> ***<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span> <span class="main">∈</span> <span class="skolem">K</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> <span class="skolem">A</span> <span class="skolem">k</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
    <span class="keyword1"><span class="command">from</span></span> ** *** <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">≠</span> <span class="skolem">k</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> 1<span class="main">[</span><span class="operator">rule_format</span><span class="main">,</span> <span class="operator">OF</span> this<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="skolem">n</span> <span class="main">∩</span> <span class="skolem">A</span> <span class="skolem">k</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> *** a <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">with</span></span> * <span class="keyword1"><span class="command">have</span></span> fin<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="skolem">N</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> id<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋃</span><span class="main">(</span><span class="skolem">A</span> <span class="main">`</span> UNIV<span class="main">)</span> <span class="main">=</span> <span class="var">?A</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> N_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">i</span><span class="main">.</span> ennreal <span class="main">(</span>sum <span class="main">(</span><span class="keyword1">($h)</span> <span class="var">?x</span><span class="main">)</span> <span class="main">(</span><span class="skolem">A</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
    ennreal <span class="main">(</span>sum <span class="main">(</span><span class="keyword1">($h)</span> <span class="var">?x</span><span class="main">)</span> <span class="main">(</span><span class="main">⋃</span><span class="main">(</span><span class="skolem">A</span> <span class="main">`</span> UNIV<span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> id
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> suminf_finite<span class="main"><span class="main">[</span></span><span class="operator">OF</span> fin<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> N_def<span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> sum_ennreal<span class="main"><span class="keyword3">,</span></span> <span class="main">(</span><span class="operator">insert</span> non_neg_vec_st_vec<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free">x</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> non_neg_vec_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> sum_nonneg<span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> arg_cong<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="quoted">ennreal</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> sum.UNION_disjoint<span class="main"><span class="main">[</span></span><span class="operator">OF</span> fin<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">insert</span> 1<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">setup_lifting</span></span> type_definition_measure

<span class="keyword1"><span class="command">lift_definition</span></span> measure_of_st_vec <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> st_vec <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">::</span> finite measure"</span></span> <span class="keyword2"><span class="keyword">is</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">x</span><span class="main">.</span> <span class="main">(</span>UNIV<span class="main">,</span> UNIV<span class="main">,</span> measure_of_st_vec' <span class="bound">x</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> measure_space_measure_of_st_vec'<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> sets_measure_of_st_vec<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"sets <span class="main">(</span>measure_of_st_vec <span class="free">x</span><span class="main">)</span> <span class="main">=</span> UNIV"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> sets_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> space_measure_of_st_vec<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"space <span class="main">(</span>measure_of_st_vec <span class="free">x</span><span class="main">)</span> <span class="main">=</span> UNIV"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> space_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> emeasure_measure_of_st_vec<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"emeasure <span class="main">(</span>measure_of_st_vec <span class="free">x</span><span class="main">)</span> <span class="free">I</span> <span class="main">=</span> 
  sum <span class="main">(</span><span class="main">λ</span> <span class="bound">i</span><span class="main">.</span> st_vec <span class="free">x</span> <span class="main">$</span> <span class="bound">i</span><span class="main">)</span> <span class="free">I</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> emeasure_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">transfer'</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> measure_of_st_vec'_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> prob_space_measure_of_st_vec<span class="main">:</span> <span class="quoted"><span class="quoted">"prob_space <span class="main">(</span>measure_of_st_vec <span class="free">x</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">intro</span> exI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted">UNIV</span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> stoch_vec_def<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> st_vec_of_pmf <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'i</span> <span class="main">::</span> finite pmf <span class="main">⇒</span> <span class="tfree">'i</span> st_vec"</span></span> <span class="keyword2"><span class="keyword">is</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">pmF</span><span class="main">.</span> vec_lambda <span class="main">(</span>pmf <span class="bound">pmF</span><span class="main">)</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> conjI<span class="main"><span class="keyword3">,</span></span> <span class="operator">goal_cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>2 <span class="skolem">pmF</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"stoch_vec <span class="main">(</span>vec_lambda <span class="main">(</span>pmf <span class="skolem">pmF</span><span class="main">)</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> stoch_vec_def 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> measure_pmf_UNIV<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="skolem">pmF</span></span><span class="main"><span class="main">,</span></span> <span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> measure_pmf_conv_infsetsum<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> non_neg_vec_def stoch_vec_def<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> pmf_as_measure
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> pmf_of_st_vec <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> finite st_vec <span class="main">⇒</span> <span class="tfree">'a</span> pmf"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">measure_of_st_vec</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">goal_cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">x</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> prob_space_measure_of_st_vec measure_def<span class="main">)</span>
      <span class="main">(</span><span class="operator">rule</span> AE_I<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> N <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">i</span><span class="main">.</span> st_vec <span class="skolem">x</span> <span class="main">$</span> <span class="bound">i</span> <span class="main">=</span> <span class="main">0</span><span class="main">}</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> st_vec_st_vec_of_pmf<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"st_vec <span class="main">(</span>st_vec_of_pmf <span class="free">x</span><span class="main">)</span> <span class="main">$</span> <span class="free">i</span> <span class="main">=</span> pmf <span class="free">x</span> <span class="free">i</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> st_vec_of_pmf.rep_eq<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> pmf_pmf_of_st_vec<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"pmf <span class="main">(</span>pmf_of_st_vec <span class="free">x</span><span class="main">)</span> <span class="free">i</span> <span class="main">=</span> st_vec <span class="free">x</span> <span class="main">$</span> <span class="free">i</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> measure_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> st_vec_of_pmf_pmf_of_st_vec<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"st_vec_of_pmf <span class="main">(</span>pmf_of_st_vec <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">x</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"st_vec <span class="main">(</span>st_vec_of_pmf <span class="main">(</span>pmf_of_st_vec <span class="free">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> st_vec <span class="free">x</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> vec_eq_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> st_vec_inject <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> pmf_of_st_vec_inj<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>pmf_of_st_vec <span class="free">x</span> <span class="main">=</span> pmf_of_st_vec <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span> <span class="main">=</span> <span class="free">y</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> st_vec_of_pmf_pmf_of_st_vec<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>  
<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="Stochastic_Matrix_Markov_Models">
<div class="head">
<h1>Theory Stochastic_Matrix_Markov_Models</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Stochastic Matrices and Markov Models›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We interpret stochastic matrices as Markov chain with
  discrete time and finite state and prove that the bind-operation
  on probability mass functions is precisely matrix-vector multiplication.
  As a consequence, the notion of stationary distribution is equivalent to
  being an eigenvector with eigenvalue 1.›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Stochastic_Matrix_Markov_Models
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="../Markov_Models/Classifying_Markov_Chain_States.html">Markov_Models.Classifying_Markov_Chain_States</a>
  <a href="Stochastic_Vector_PMF.html">Stochastic_Vector_PMF</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">transition_of_st_mat</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'i</span> st_mat <span class="main">⇒</span> <span class="tfree">'i</span> <span class="main">::</span> finite <span class="main">⇒</span> <span class="tfree">'i</span> pmf"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">transition_of_st_mat</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">=</span> pmf_as_measure.pmf_of_st_vec <span class="main">(</span>transition_vec_of_st_mat <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span>"</span></span> 

<span class="keyword1"><span class="command">lemma</span></span> st_vec_transition_vec_of_st_mat<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"st_vec <span class="main">(</span>transition_vec_of_st_mat <span class="free">A</span> <span class="free">a</span><span class="main">)</span> <span class="main">$</span> <span class="free">i</span> <span class="main">=</span> st_mat <span class="free">A</span> <span class="main">$</span> <span class="free">i</span> <span class="main">$</span> <span class="free">a</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> column_def<span class="main">)</span>

<span class="keyword1"><span class="command">locale</span></span> transition_matrix <span class="main">=</span> pmf_as_measure <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">A</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'i</span> <span class="main">::</span> finite st_mat"</span></span> 
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">sublocale</span></span> MC_syntax <span class="quoted"><span class="quoted">"transition_of_st_mat <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lemma</span></span> measure_pmf_of_st_vec<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"measure_pmf <span class="main">(</span>pmf_of_st_vec <span class="free">x</span><span class="main">)</span> <span class="main">=</span> measure_of_st_vec <span class="free">x</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> pmf_as_measure.pmf_of_st_vec.rep_eq<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> pmf_transition_of_st_mat<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"pmf <span class="main">(</span>transition_of_st_mat <span class="free">A</span> <span class="free">a</span><span class="main">)</span> <span class="free">i</span> <span class="main">=</span> st_mat <span class="free">A</span> <span class="main">$</span> <span class="free">i</span> <span class="main">$</span> <span class="free">a</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> transition_of_st_mat_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> measure_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> bind_is_matrix_vector_mult<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>bind_pmf <span class="free">x</span> <span class="main">(</span>transition_of_st_mat <span class="free">A</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
  pmf_as_measure.pmf_of_st_vec <span class="main">(</span><span class="free">A</span> <span class="keyword1">*st</span> st_vec_of_pmf <span class="free">x</span><span class="main">)</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> pmf_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">goal_cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">i</span><span class="main">)</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">X</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">X</span> <span class="main">=</span> st_vec_of_pmf <span class="free">x</span>"</span></span> 
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"pmf <span class="main">(</span>bind_pmf <span class="free">x</span> <span class="main">(</span>transition_of_st_mat <span class="free">A</span><span class="main">)</span><span class="main">)</span> <span class="skolem">i</span> <span class="main">=</span> 
    <span class="main">(</span><span class="main">∑</span><span class="bound">a</span><span class="main">∈</span>UNIV<span class="main">.</span> pmf <span class="free">x</span> <span class="bound">a</span> <span class="keyword1">*<span class="hidden">⇩</span><sub>R</sub></span> pmf <span class="main">(</span>transition_of_st_mat <span class="free">A</span> <span class="bound">a</span><span class="main">)</span> <span class="skolem">i</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> pmf_bind <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> integral_measure_pmf<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted">UNIV</span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">a</span><span class="main">∈</span>UNIV<span class="main">.</span> st_mat <span class="free">A</span> <span class="main">$</span> <span class="skolem">i</span> <span class="main">$</span> <span class="bound">a</span> <span class="main">*</span> st_vec <span class="skolem">X</span> <span class="main">$</span> <span class="bound">a</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> sum.cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> refl<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> X_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span>st_mat <span class="free">A</span> <span class="keyword1">*v</span> st_vec <span class="skolem">X</span><span class="main">)</span> <span class="main">$</span> <span class="skolem">i</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> matrix_vector_mult_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> st_vec <span class="main">(</span><span class="free">A</span> <span class="keyword1">*st</span> <span class="skolem">X</span><span class="main">)</span> <span class="main">$</span> <span class="skolem">i</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> st_mat_mult_st_vec <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> pmf <span class="main">(</span>pmf_of_st_vec <span class="main">(</span><span class="free">A</span> <span class="keyword1">*st</span> <span class="skolem">X</span><span class="main">)</span><span class="main">)</span> <span class="skolem">i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> X_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> stationary_distribution_alt_def <span class="main">=</span> 
  stationary_distribution_def<span class="main">[</span><span class="operator">unfolded</span> bind_is_matrix_vector_mult<span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> stationary_distribution_implies_pmf_of_st_vec<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"stationary_distribution <span class="free">N</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">x</span><span class="main">.</span> <span class="free">N</span> <span class="main">=</span> pmf_of_st_vec <span class="bound">x</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms<span class="main">[</span><span class="operator">unfolded</span> stationary_distribution_alt_def<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> stationary_distribution_pmf_of_st_vec<span class="main">:</span>
  <span class="quoted"><span class="quoted">"stationary_distribution <span class="main">(</span>pmf_of_st_vec <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">A</span> <span class="keyword1">*st</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> stationary_distribution_alt_def pmf_of_st_vec_inj <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="Eigenspace">
<div class="head">
<h1>Theory Eigenspace</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Eigenspaces›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Using results on Jordan-Normal forms, we prove that the geometric
  multiplicity of an eigenvalue (i.e., the dimension of the eigenspace)
  is bounded by the algebraic multiplicity of an eigenvalue (i.e., the
  multiplicity as root of the characteristic polynomial.).
  As a consequence we derive that any two eigenvectors of some
  eigenvalue with multiplicity 1 must be scalar multiples of each other.›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Eigenspace
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="../Jordan_Normal_Form/Jordan_Normal_Form_Uniqueness.html">Jordan_Normal_Form.Jordan_Normal_Form_Uniqueness</a>
  <a href="../Perron_Frobenius/Perron_Frobenius_Aux.html">Perron_Frobenius.Perron_Frobenius_Aux</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">hide_const</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> Coset.order

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The dimension of every generalized eigenspace is bounded by the
  algebraic multiplicity of an eigenvalue. Hence, in particular the
  geometric multiplicity is smaller than the algebraic multiplicity.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> dim_gen_eigenspace_order_char_poly<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> jnf<span class="main">:</span> <span class="quoted"><span class="quoted">"jordan_nf <span class="free">A</span> <span class="free">n_as</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"dim_gen_eigenspace <span class="free">A</span> <span class="free">lam</span> <span class="free">k</span> <span class="main">≤</span> order <span class="free">lam</span> <span class="main">(</span>char_poly <span class="free">A</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> jordan_nf_order<span class="main">[</span><span class="operator">OF</span> jnf<span class="main">]</span>  dim_gen_eigenspace<span class="main">[</span><span class="operator">OF</span> jnf<span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n_as</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Every eigenvector is contained in the eigenspace.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> eigenvector_mat_kernel_char_matrix<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">∈</span> carrier_mat <span class="free">n</span> <span class="free">n</span>"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> ev<span class="main">:</span> <span class="quoted"><span class="quoted">"eigenvector <span class="free">A</span> <span class="free">v</span> <span class="free">lam</span>"</span></span> 
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> mat_kernel <span class="main">(</span>char_matrix <span class="free">A</span> <span class="free">lam</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">using</span></span> ev<span class="main">[</span><span class="operator">unfolded</span> eigenvector_char_matrix<span class="main"><span class="main">[</span></span><span class="operator">OF</span> A<span class="main"><span class="main">]</span></span><span class="main">]</span> A
  <span class="keyword1"><span class="command">unfolding</span></span> mat_kernel_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> char_matrix_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹If the algebraic multiplicity is one, then every two eigenvectors are
  scalar multiples of each other.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> unique_eigenvector_jnf<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> jnf<span class="main">:</span> <span class="quoted"><span class="quoted">"jordan_nf <span class="main">(</span><span class="free">A</span> <span class="main">::</span> <span class="tfree">'a</span> <span class="main">::</span> field mat<span class="main">)</span> <span class="free">n_as</span>"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> ord<span class="main">:</span> <span class="quoted"><span class="quoted">"order <span class="free">lam</span> <span class="main">(</span>char_poly <span class="free">A</span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span>"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> ev<span class="main">:</span> <span class="quoted"><span class="quoted">"eigenvector <span class="free">A</span> <span class="free">v</span> <span class="free">lam</span>"</span></span> <span class="quoted"><span class="quoted">"eigenvector <span class="free">A</span> <span class="free">w</span> <span class="free">lam</span>"</span></span> 
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">a</span><span class="main">.</span> <span class="free">v</span> <span class="main">=</span> <span class="bound">a</span> <span class="keyword1">⋅<span class="hidden">⇩</span><sub>v</sub></span> <span class="free">w</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?cA</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"char_matrix <span class="free">A</span> <span class="free">lam</span>"</span></span> 
  <span class="keyword1"><span class="command">from</span></span> similar_matD jnf<span class="main">[</span><span class="operator">unfolded</span> jordan_nf_def<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">n</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">∈</span> carrier_mat <span class="skolem">n</span> <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> dim_gen_eigenspace_order_char_poly<span class="main">[</span><span class="operator">OF</span> jnf<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">lam</span></span> <span class="quoted"><span class="main">1</span></span><span class="main">,</span> <span class="operator">unfolded</span> ord<span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> dim<span class="main">:</span> <span class="quoted"><span class="quoted">"kernel_dim <span class="var">?cA</span> <span class="main">≤</span> <span class="main">1</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> dim_gen_eigenspace_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> eigenvector_mat_kernel_char_matrix<span class="main">[</span><span class="operator">OF</span> A ev<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> vk<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> mat_kernel <span class="var">?cA</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">from</span></span> eigenvector_mat_kernel_char_matrix<span class="main">[</span><span class="operator">OF</span> A ev<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> wk<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">∈</span> mat_kernel <span class="var">?cA</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">from</span></span> ev<span class="main">[</span><span class="operator">unfolded</span> eigenvector_def<span class="main">]</span> A <span class="keyword1"><span class="command">have</span></span> 
    v<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> carrier_vec <span class="skolem">n</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">≠</span> <span class="keyword1">0<span class="hidden">⇩</span><sub>v</sub></span> <span class="skolem">n</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    w<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">∈</span> carrier_vec <span class="skolem">n</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">≠</span> <span class="keyword1">0<span class="hidden">⇩</span><sub>v</sub></span> <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> cA<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?cA</span> <span class="main">∈</span> carrier_mat <span class="skolem">n</span> <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> A
    <span class="keyword1"><span class="command">unfolding</span></span> char_matrix_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">interpret</span></span> kernel <span class="quoted"><span class="skolem">n</span></span> <span class="quoted"><span class="skolem">n</span></span> <span class="var"><span class="quoted"><span class="var">?cA</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> cA<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> kernel_basis_exists<span class="main">[</span><span class="operator">OF</span> A<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">B</span></span> <span class="keyword2"><span class="keyword">where</span></span> B<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="skolem">B</span>"</span></span> <span class="quoted"><span class="quoted">"basis <span class="skolem">B</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">unfolded</span> Ker.basis_def<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> basis<span class="main">:</span> <span class="quoted"><span class="quoted">"mat_kernel <span class="var">?cA</span> <span class="main">=</span> span <span class="skolem">B</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"card <span class="skolem">B</span> <span class="main">=</span> <span class="main">0</span>"</span></span> 
    <span class="keyword1"><span class="command">with</span></span> B basis <span class="keyword1"><span class="command">have</span></span> bas<span class="main">:</span> <span class="quoted"><span class="quoted">"mat_kernel <span class="var">?cA</span> <span class="main">=</span> local.span <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">{</span><span class="keyword1">0<span class="hidden">⇩</span><sub>v</sub></span> <span class="skolem">n</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> Ker.span_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> v vk <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">with</span></span> Ker.dim_basis<span class="main">[</span><span class="operator">OF</span> B<span class="main">]</span> dim <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="skolem">B</span> <span class="main">=</span> Suc <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"card <span class="skolem">B</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">b</span><span class="main">.</span> <span class="skolem">B</span> <span class="main">=</span> <span class="main">{</span><span class="bound">b</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> card_eq_SucD <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">b</span></span> <span class="keyword2"><span class="keyword">where</span></span> Bb<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">B</span> <span class="main">=</span> <span class="main">{</span><span class="skolem">b</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">from</span></span> B<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">unfolded</span> Bb Ker.basis_def<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> bk<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> mat_kernel <span class="var">?cA</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> b<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> carrier_vec <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> cA mat_kernelD<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">from</span></span> Bb basis <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"mat_kernel <span class="var">?cA</span> <span class="main">=</span> span <span class="main">{</span><span class="skolem">b</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> NC.span <span class="main">{</span><span class="skolem">b</span><span class="main">}</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> span_same<span class="main"><span class="keyword3">,</span></span> <span class="operator">insert</span> bk<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">⊆</span> <span class="main">{</span> <span class="bound">a</span> <span class="keyword1">⋅<span class="hidden">⇩</span><sub>v</sub></span> <span class="skolem">b</span> <span class="main">|</span> <span class="bound">a</span><span class="main">.</span> True<span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> NC.span <span class="main">{</span><span class="skolem">b</span><span class="main">}</span>"</span></span> 
      <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">unfolded</span> NC.span_def<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">a</span></span> <span class="skolem"><span class="skolem">A</span></span> 
        <span class="keyword2"><span class="keyword">where</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> NC.lincomb <span class="skolem">a</span> <span class="skolem">A</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">⊆</span> <span class="main">{</span><span class="skolem">b</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">∨</span> <span class="skolem">A</span> <span class="main">=</span> <span class="main">{</span><span class="skolem">b</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">a</span><span class="main">.</span> <span class="skolem">x</span> <span class="main">=</span> <span class="bound">a</span> <span class="keyword1">⋅<span class="hidden">⇩</span><sub>v</sub></span> <span class="skolem">b</span>"</span></span> 
      <span class="keyword1"><span class="command">proof</span></span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> x <span class="keyword1"><span class="command">using</span></span> b <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> exI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="main">0</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">=</span> <span class="main">{</span><span class="skolem">b</span><span class="main">}</span>"</span></span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> x <span class="keyword1"><span class="command">using</span></span> b 
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> exI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="skolem">b</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> NC.lincomb_def<span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">vv</span></span> <span class="skolem"><span class="skolem">ww</span></span> <span class="keyword2"><span class="keyword">where</span></span> vb<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">=</span> <span class="skolem">vv</span> <span class="keyword1">⋅<span class="hidden">⇩</span><sub>v</sub></span> <span class="skolem">b</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> wb<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">=</span> <span class="skolem">ww</span> <span class="keyword1">⋅<span class="hidden">⇩</span><sub>v</sub></span> <span class="skolem">b</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> vk wk <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">from</span></span> wb w b <span class="keyword1"><span class="command">have</span></span> ww<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">ww</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> arg_cong<span class="main">[</span><span class="operator">OF</span> wb<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">x</span><span class="main">.</span> inverse <span class="skolem">ww</span> <span class="keyword1">⋅<span class="hidden">⇩</span><sub>v</sub></span> <span class="bound">x</span>"</span></span><span class="main">]</span> w ww b <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">=</span> inverse <span class="skolem">ww</span> <span class="keyword1">⋅<span class="hidden">⇩</span><sub>v</sub></span> <span class="free">w</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> smult_smult_assoc<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> vb<span class="main">[</span><span class="operator">unfolded</span> this smult_smult_assoc<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>  

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Getting rid of the JNF-assumption for complex matrices.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> unique_eigenvector_complex<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">∈</span> carrier_mat <span class="free">n</span> <span class="free">n</span>"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> ord<span class="main">:</span> <span class="quoted"><span class="quoted">"order <span class="free">lam</span> <span class="main">(</span>char_poly <span class="free">A</span> <span class="main">::</span> complex poly<span class="main">)</span> <span class="main">=</span> <span class="main">1</span>"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> ev<span class="main">:</span> <span class="quoted"><span class="quoted">"eigenvector <span class="free">A</span> <span class="free">v</span> <span class="free">lam</span>"</span></span> <span class="quoted"><span class="quoted">"eigenvector <span class="free">A</span> <span class="free">w</span> <span class="free">lam</span>"</span></span> 
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">a</span><span class="main">.</span> <span class="free">v</span> <span class="main">=</span> <span class="bound">a</span> <span class="keyword1">⋅<span class="hidden">⇩</span><sub>v</sub></span> <span class="free">w</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> jordan_nf_exists<span class="main">[</span><span class="operator">OF</span> A<span class="main">]</span> char_poly_factorized<span class="main">[</span><span class="operator">OF</span> A<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">n_as</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"jordan_nf <span class="free">A</span> <span class="skolem">n_as</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> unique_eigenvector_jnf<span class="main">[</span><span class="operator">OF</span> this ord ev<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Convert the result to real matrices via homomorphisms.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> unique_eigenvector_real<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">∈</span> carrier_mat <span class="free">n</span> <span class="free">n</span>"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> ord<span class="main">:</span> <span class="quoted"><span class="quoted">"order <span class="free">lam</span> <span class="main">(</span>char_poly <span class="free">A</span> <span class="main">::</span> real poly<span class="main">)</span> <span class="main">=</span> <span class="main">1</span>"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> ev<span class="main">:</span> <span class="quoted"><span class="quoted">"eigenvector <span class="free">A</span> <span class="free">v</span> <span class="free">lam</span>"</span></span> <span class="quoted"><span class="quoted">"eigenvector <span class="free">A</span> <span class="free">w</span> <span class="free">lam</span>"</span></span> 
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">a</span><span class="main">.</span> <span class="free">v</span> <span class="main">=</span> <span class="bound">a</span> <span class="keyword1">⋅<span class="hidden">⇩</span><sub>v</sub></span> <span class="free">w</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?c</span></span></span> <span class="main">=</span> <span class="quoted">complex_of_real</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?A</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"map_mat <span class="var">?c</span> <span class="free">A</span>"</span></span> 
  <span class="keyword1"><span class="command">from</span></span> A <span class="keyword1"><span class="command">have</span></span> cA<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?A</span> <span class="main">∈</span> carrier_mat <span class="free">n</span> <span class="free">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> ord<span class="main">:</span> <span class="quoted"><span class="quoted">"order <span class="main">(</span><span class="var">?c</span> <span class="free">lam</span><span class="main">)</span> <span class="main">(</span>char_poly <span class="var">?A</span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> of_real_hom.char_poly_hom<span class="main">[</span><span class="operator">OF</span> A<span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> map_poly_inj_idom_divide_hom.order_hom<span class="main"><span class="keyword3">,</span></span> <span class="operator">unfold_locales</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> ord<span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> evc <span class="main">=</span> of_real_hom.eigenvector_hom<span class="main">[</span><span class="operator">OF</span> A<span class="main">]</span>
  <span class="keyword1"><span class="command">from</span></span> unique_eigenvector_complex<span class="main">[</span><span class="operator">OF</span> cA ord evc evc<span class="main">,</span> <span class="operator">OF</span> ev<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">a</span></span> <span class="main">::</span> <span class="quoted">complex</span> 
    <span class="keyword2"><span class="keyword">where</span></span> id<span class="main">:</span> <span class="quoted"><span class="quoted">"map_vec <span class="var">?c</span> <span class="free">v</span> <span class="main">=</span> <span class="skolem">a</span> <span class="keyword1">⋅<span class="hidden">⇩</span><sub>v</sub></span> map_vec <span class="var">?c</span> <span class="free">w</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="comment1">(* now prove that a is real *)</span>
  <span class="keyword1"><span class="command">from</span></span> ev<span class="main">[</span><span class="operator">unfolded</span> eigenvector_def<span class="main">]</span> A <span class="keyword1"><span class="command">have</span></span> carr<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> carrier_vec <span class="free">n</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">∈</span> carrier_vec <span class="free">n</span>"</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">≠</span> <span class="keyword1">0<span class="hidden">⇩</span><sub>v</sub></span> <span class="free">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">i</span></span> <span class="keyword2"><span class="keyword">where</span></span> i<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> <span class="free">n</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">$</span> <span class="skolem">i</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> Matrix.vec_eq_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> arg_cong<span class="main">[</span><span class="operator">OF</span> id<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">$</span> <span class="skolem">i</span>"</span></span><span class="main">]</span> carr i 
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?c</span> <span class="main">(</span><span class="free">v</span> <span class="main">$</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">a</span> <span class="main">*</span> <span class="var">?c</span> <span class="main">(</span><span class="free">w</span> <span class="main">$</span> <span class="skolem">i</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> i<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> Reals"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Reals_cnj_iff complex_cnj_complex_of_real complex_cnj_mult mult_cancel_right
        mult_eq_0_iff of_real_hom.hom_zero of_real_hom.injectivity<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">b</span></span> <span class="keyword2"><span class="keyword">where</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">=</span> <span class="var">?c</span> <span class="skolem">b</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Reals_cases<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> id<span class="main">[</span><span class="operator">unfolded</span> a<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_vec <span class="var">?c</span> <span class="free">v</span> <span class="main">=</span> map_vec <span class="var">?c</span> <span class="main">(</span><span class="skolem">b</span> <span class="keyword1">⋅<span class="hidden">⇩</span><sub>v</sub></span> <span class="free">w</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">=</span> <span class="skolem">b</span> <span class="keyword1">⋅<span class="hidden">⇩</span><sub>v</sub></span> <span class="free">w</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> of_real_hom.vec_hom_inj<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Finally, the statement converted to HMA-world.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> unique_eigen_vector_real<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> ord<span class="main">:</span> <span class="quoted"><span class="quoted">"order <span class="free">lam</span> <span class="main">(</span>charpoly <span class="free">A</span> <span class="main">::</span> real poly<span class="main">)</span> <span class="main">=</span> <span class="main">1</span>"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> ev<span class="main">:</span> <span class="quoted"><span class="quoted">"eigen_vector <span class="free">A</span> <span class="free">v</span> <span class="free">lam</span>"</span></span> <span class="quoted"><span class="quoted">"eigen_vector <span class="free">A</span> <span class="free">w</span> <span class="free">lam</span>"</span></span> 
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">a</span><span class="main">.</span> <span class="free">v</span> <span class="main">=</span> <span class="bound">a</span> <span class="keyword1">*s</span> <span class="free">w</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">goal_cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">lam</span> <span class="skolem">A</span> <span class="skolem">v</span> <span class="skolem">w</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> unique_eigenvector_real<span class="main"><span class="main">[</span></span><span class="operator">OF</span> 1<span class="main"><span class="main"><span class="main">(</span></span></span>1-2<span class="main"><span class="main"><span class="main">,</span></span></span>4<span class="main"><span class="main"><span class="main">,</span></span></span>6<span class="main"><span class="main"><span class="main">)</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

</pre>
</div><div id="Stochastic_Matrix_Perron_Frobenius">
<div class="head">
<h1>Theory Stochastic_Matrix_Perron_Frobenius</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Stochastic Matrices and the Perron--Frobenius Theorem›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Since a stationary distribution corresponds to a non-negative real
  eigenvector of the stochastic matrix, we can apply the Perron--Frobenius
  theorem. In this way we easily derive that every stochastic matrix has 
  a stationary distribution, and moreover that this distribution is unique, if the 
  matrix is irreducible, i.e., if the graph of the matrix is strongly connected.›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Stochastic_Matrix_Perron_Frobenius
<span class="keyword2"><span class="keyword">imports</span></span>   
  <a href="../Perron_Frobenius/Perron_Frobenius_Irreducible.html">Perron_Frobenius.Perron_Frobenius_Irreducible</a>
  <a href="Stochastic_Matrix_Markov_Models.html">Stochastic_Matrix_Markov_Models</a>
  <a href="Eigenspace.html">Eigenspace</a>
<span class="keyword2"><span class="keyword">begin</span></span>    

<span class="keyword1"><span class="command">hide_const</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> Coset.order

<span class="keyword1"><span class="command">lemma</span></span> pf_nonneg_mat_st_mat<span class="main">:</span> <span class="quoted"><span class="quoted">"pf_nonneg_mat <span class="main">(</span>st_mat <span class="free">A</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> non_neg_mat_st_mat<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> stoch_non_neg_vec_norm1<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"stoch_vec <span class="main">(</span><span class="free">v</span> <span class="main">::</span> real <span class="main">^</span> <span class="tfree">'n</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"non_neg_vec <span class="free">v</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"norm1 <span class="free">v</span> <span class="main">=</span> <span class="main">1</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> assms<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">unfolded</span> stoch_vec_def<span class="main">,</span> <span class="operator">symmetric</span><span class="main">]</span> norm1_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> sum.cong<span class="main"><span class="keyword3">,</span></span> <span class="operator">insert</span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> non_neg_vec_def<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> stationary_distribution_exists<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">v</span><span class="main">.</span> <span class="free">A</span> <span class="keyword1">*st</span> <span class="bound">v</span> <span class="main">=</span> <span class="bound">v</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?A</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"st_mat <span class="free">A</span>"</span></span> 
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?c</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"complex_of_real"</span></span> 
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?B</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="keyword1">χ</span> <span class="bound">i</span> <span class="bound">j</span><span class="main">.</span> <span class="var">?c</span> <span class="main">(</span><span class="var">?A</span> <span class="main">$</span> <span class="bound">i</span> <span class="main">$</span> <span class="bound">j</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"real_non_neg_mat <span class="var">?B</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> non_neg_mat_st_mat<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">A</span></span><span class="main">]</span> 
    <span class="keyword1"><span class="command">unfolding</span></span> real_non_neg_mat_def elements_mat_h_def non_neg_mat_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> Perron_Frobenius.perron_frobenius_both<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v</span></span> <span class="skolem"><span class="skolem">a</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    ev<span class="main">:</span> <span class="quoted"><span class="quoted">"eigen_vector <span class="var">?B</span> <span class="skolem">v</span> <span class="main">(</span><span class="var">?c</span> <span class="skolem">a</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> nn<span class="main">:</span> <span class="quoted"><span class="quoted">"real_non_neg_vec <span class="skolem">v</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">=</span> HMA_Connect.spectral_radius <span class="var">?B</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> spectral_radius_ev<span class="main">[</span><span class="operator">of</span> <span class="var"><span class="quoted"><span class="var">?B</span></span></span><span class="main">,</span> <span class="operator">folded</span> a<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> a0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">≥</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">w</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">χ</span> <span class="bound">i</span><span class="main">.</span> Re <span class="main">(</span><span class="skolem">v</span> <span class="main">$</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">from</span></span> nn <span class="keyword1"><span class="command">have</span></span> vw<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">χ</span> <span class="bound">i</span><span class="main">.</span> <span class="var">?c</span> <span class="main">(</span><span class="skolem">w</span> <span class="main">$</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> real_non_neg_vec_def w_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> vec_elements_h_def<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> ev<span class="main">[</span><span class="operator">unfolded</span> eigen_vector_def<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> v0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> ev<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?B</span> <span class="keyword1">*v</span> <span class="skolem">v</span> <span class="main">=</span> <span class="var">?c</span> <span class="skolem">a</span> <span class="keyword1">*s</span> <span class="skolem">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> v0 <span class="keyword1"><span class="command">have</span></span> w0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> vw <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Finite_Cartesian_Product.vec_eq_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span>
    <span class="keyword1"><span class="command">from</span></span> ev <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Re <span class="main">(</span><span class="main">(</span><span class="var">?B</span> <span class="keyword1">*v</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">$</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">=</span> Re <span class="main">(</span><span class="main">(</span><span class="var">?c</span> <span class="skolem">a</span> <span class="keyword1">*s</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">$</span> <span class="skolem">i</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Re <span class="main">(</span><span class="main">(</span><span class="var">?c</span> <span class="skolem">a</span> <span class="keyword1">*s</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">$</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">a</span> <span class="keyword1">*s</span> <span class="skolem">w</span><span class="main">)</span> <span class="main">$</span> <span class="skolem">i</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> vw <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Re <span class="main">(</span><span class="main">(</span><span class="var">?B</span> <span class="keyword1">*v</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">$</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="var">?A</span> <span class="keyword1">*v</span> <span class="skolem">w</span><span class="main">)</span> <span class="main">$</span> <span class="skolem">i</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> vw 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> matrix_vector_mult_def<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> calculation
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">hence</span></span> ev<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?A</span> <span class="keyword1">*v</span> <span class="skolem">w</span> <span class="main">=</span> <span class="skolem">a</span> <span class="keyword1">*s</span> <span class="skolem">w</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Finite_Cartesian_Product.vec_eq_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> nn <span class="keyword1"><span class="command">have</span></span> nn<span class="main">:</span> <span class="quoted"><span class="quoted">"non_neg_vec <span class="skolem">w</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> vw <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> real_non_neg_vec_def non_neg_vec_def vec_elements_h_def<span class="main">)</span>
  <span class="comment1">(* we now mainly have to prove that a = 1 *)</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?n</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"norm1 <span class="skolem">w</span>"</span></span> 
  <span class="keyword1"><span class="command">from</span></span> w0 <span class="keyword1"><span class="command">have</span></span> n0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?n</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> n_pos<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?n</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> norm1_ge_0<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">w</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">linarith</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">u</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">=</span> inverse <span class="var">?n</span> <span class="keyword1">*s</span> <span class="skolem">w</span>"</span></span> 
  <span class="keyword1"><span class="command">have</span></span> nn<span class="main">:</span> <span class="quoted"><span class="quoted">"non_neg_vec <span class="skolem">u</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> nn n_pos <span class="keyword1"><span class="command">unfolding</span></span> u_def non_neg_vec_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> nu<span class="main">:</span> <span class="quoted"><span class="quoted">"norm1 <span class="skolem">u</span> <span class="main">=</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> u_def scalar_mult_eq_scaleR norm1_scaleR <span class="keyword1"><span class="command">using</span></span> n_pos
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">field_simps</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"stoch_vec <span class="skolem">u</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> stoch_vec_def nu<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> norm1_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> sum.cong<span class="main"><span class="keyword3">,</span></span> <span class="operator">insert</span> nn<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> non_neg_vec_def<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> arg_cong<span class="main">[</span><span class="operator">OF</span> ev<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">x</span><span class="main">.</span> inverse <span class="var">?n</span> <span class="keyword1">*s</span> <span class="bound">x</span>"</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> ev<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?A</span> <span class="keyword1">*v</span> <span class="skolem">u</span> <span class="main">=</span> <span class="skolem">a</span> <span class="keyword1">*s</span> <span class="skolem">u</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> u_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">ac_simps</span></span> vector_smult_distrib matrix_vect_scaleR<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> right_stoch_mat_mult_stoch_vec<span class="main">[</span><span class="operator">OF</span> right_stoch_mat_st_mat<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free">A</span></span><span class="main"><span class="main">]</span></span> 1<span class="main">,</span> <span class="operator">unfolded</span> ev<span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> st<span class="main">:</span> <span class="quoted"><span class="quoted">"stoch_vec <span class="main">(</span><span class="skolem">a</span> <span class="keyword1">*s</span> <span class="skolem">u</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">from</span></span> non_neg_mat_mult_non_neg_vec<span class="main">[</span><span class="operator">OF</span> non_neg_mat_st_mat<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free">A</span></span><span class="main"><span class="main">]</span></span> nn<span class="main">,</span> <span class="operator">unfolded</span> ev<span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> nn'<span class="main">:</span> <span class="quoted"><span class="quoted">"non_neg_vec <span class="main">(</span><span class="skolem">a</span> <span class="keyword1">*s</span> <span class="skolem">u</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">from</span></span> stoch_non_neg_vec_norm1<span class="main">[</span><span class="operator">OF</span> st nn'<span class="main">,</span> <span class="operator">unfolded</span> scalar_mult_eq_scaleR norm1_scaleR nu<span class="main">]</span> a0
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">=</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> ev st <span class="keyword1"><span class="command">have</span></span> ev<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?A</span> <span class="keyword1">*v</span> <span class="skolem">u</span> <span class="main">=</span> <span class="skolem">u</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> st<span class="main">:</span> <span class="quoted"><span class="quoted">"stoch_vec <span class="skolem">u</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> ev st nn
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> exI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted">"to_st_vec <span class="skolem">u</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> stationary_distribution_unique<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"fixed_mat.irreducible <span class="main">(</span>st_mat <span class="free">A</span><span class="main">)</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃!</span> <span class="bound">v</span><span class="main">.</span> <span class="free">A</span> <span class="keyword1">*st</span> <span class="bound">v</span> <span class="main">=</span> <span class="bound">v</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> stationary_distribution_exists <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v</span></span> <span class="keyword2"><span class="keyword">where</span></span> ev<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="keyword1">*st</span> <span class="skolem">v</span> <span class="main">=</span> <span class="skolem">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> ex1I<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> ev<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">w</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="keyword1">*st</span> <span class="skolem">w</span> <span class="main">=</span> <span class="skolem">w</span>"</span></span> 
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">=</span> <span class="skolem">v</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> ev assms
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">goal_cases</span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">A</span> <span class="skolem">w</span> <span class="skolem">v</span><span class="main">)</span>
      <span class="keyword1"><span class="command">interpret</span></span> perron_frobenius <span class="quoted"><span class="skolem">A</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">insert</span> 1<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> 1 <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"eigen_vector <span class="skolem">A</span> <span class="skolem">v</span> <span class="main">1</span>"</span></span> <span class="quoted"><span class="quoted">"le_vec <span class="main">0</span> <span class="skolem">v</span>"</span></span> <span class="quoted"><span class="quoted">"eigen_vector <span class="skolem">A</span> <span class="skolem">w</span> <span class="main">1</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> eigen_vector_def stoch_vec_def non_neg_vec_def<span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> nonnegative_eigenvector_has_ev_sr<span class="main">[</span><span class="operator">OF</span> *<span class="main"><span class="main">(</span></span>1-2<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> sr1<span class="main">:</span> <span class="quoted"><span class="quoted">"sr <span class="main">=</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  
      <span class="keyword1"><span class="command">from</span></span> multiplicity_sr_1<span class="main">[</span><span class="operator">unfolded</span> sr1<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"order <span class="main">1</span> <span class="main">(</span>charpoly <span class="skolem">A</span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
      <span class="keyword1"><span class="command">from</span></span> unique_eigen_vector_real<span class="main">[</span><span class="operator">OF</span> this *<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span>3<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">a</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
        vw<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">=</span> <span class="skolem">a</span> <span class="keyword1">*s</span> <span class="skolem">w</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">from</span></span> 1<span class="main">(</span>2<span class="main">,</span>4<span class="main">)</span><span class="main">[</span><span class="operator">unfolded</span> stoch_vec_def<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"sum <span class="main">(</span><span class="keyword1">($h)</span> <span class="skolem">v</span><span class="main">)</span> UNIV <span class="main">=</span> sum <span class="main">(</span><span class="keyword1">($h)</span> <span class="skolem">w</span><span class="main">)</span> UNIV"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"sum <span class="main">(</span><span class="keyword1">($h)</span> <span class="skolem">v</span><span class="main">)</span> UNIV <span class="main">=</span> <span class="skolem">a</span> <span class="main">*</span> sum <span class="main">(</span><span class="keyword1">($h)</span> <span class="skolem">w</span><span class="main">)</span> UNIV"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> vw 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sum_distrib_left<span class="main">)</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">=</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> 1<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">unfolded</span> stoch_vec_def<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> vw <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">=</span> <span class="skolem">w</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Let us now convert the stationary distribution results from matrices to Markov chains.›</span></span>

<span class="keyword1"><span class="command">context</span></span> transition_matrix
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> stationary_distribution_exists<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">x</span><span class="main">.</span> stationary_distribution <span class="main">(</span>pmf_of_st_vec <span class="bound">x</span><span class="main">)</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> stationary_distribution_exists <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> ev<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="keyword1">*st</span> <span class="skolem">x</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> exI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="skolem">x</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">unfold</span> stationary_distribution_pmf_of_st_vec<span class="main"><span class="keyword3">,</span></span>
    <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ev<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> stationary_distribution_unique<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"fixed_mat.irreducible <span class="main">(</span>st_mat <span class="free">A</span><span class="main">)</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃!</span> <span class="bound">N</span><span class="main">.</span> stationary_distribution <span class="bound">N</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> stationary_distribution_exists <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    st<span class="main">:</span> <span class="quoted"><span class="quoted">"stationary_distribution <span class="main">(</span>pmf_of_st_vec <span class="skolem">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ex1I<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> st<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">N</span>
    <span class="keyword3"><span class="command">assume</span></span> st'<span class="main">:</span> <span class="quoted"><span class="quoted">"stationary_distribution <span class="skolem">N</span>"</span></span> 
    <span class="keyword1"><span class="command">from</span></span> stationary_distribution_implies_pmf_of_st_vec<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
      N<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">N</span> <span class="main">=</span> pmf_of_st_vec <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> st'<span class="main">[</span><span class="operator">unfolded</span> N<span class="main">]</span> st 
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="keyword1">*st</span> <span class="skolem">x</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="keyword1">*st</span> <span class="skolem">y</span> <span class="main">=</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> stationary_distribution_pmf_of_st_vec <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> stationary_distribution_unique<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> this <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> N <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">N</span> <span class="main">=</span> pmf_of_st_vec <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>
<span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div>