<div id="BinomialHeap">
<div class="head"><h1>Theory BinomialHeap</h1>
<span class="command">theory</span> <span class="name">BinomialHeap</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL-Library/Multiset.html"><span class="name">Multiset</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Binomial Heaps"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>BinomialHeap</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span> </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Multiset"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>BinomialHeapStruc_loc</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Datatype Definition›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Binomial heaps are lists of binomial trees.›</span></span></span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'e</span><span class="delimiter">,</span><span> </span><span class="tfree">'a</span><span class="delimiter">)</span><span> </span><span>BinomialTree</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span>Node</span><span> </span><span class="delimiter">(</span><span>val</span><span class="delimiter">:</span><span> </span><span class="tfree">'e</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>prio</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::linorder"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>rank</span><span class="delimiter">:</span><span> </span><span>nat</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>children</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e , 'a) BinomialTree list"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'e</span><span class="delimiter">,</span><span> </span><span class="tfree">'a</span><span class="delimiter">)</span><span> </span><span>BinomialQueue_inv</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'a::linorder) BinomialTree list"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Combine two binomial trees (of rank $r$) to one (of rank $r+1$).›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span>  </span><span>link</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'a::linorder) BinomialTree ⇒ ('e, 'a) BinomialTree ⇒ 
  ('e, 'a) BinomialTree"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"link (Node e1 a1 r1 ts1) (Node e2 a2 r2 ts2) = 
   (if  a1≤a2 
     then (Node e1 a1 (Suc r1) ((Node e2 a2 r2 ts2)#ts1))
     else (Node e2 a2 (Suc r2) ((Node e1 a1 r1 ts1)#ts2)))"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Abstraction to Multiset"</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Return a multiset with all (element, priority) pairs from a queue.›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>tree_to_multiset</span><span> 
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'a::linorder) BinomialTree ⇒ ('e × 'a) multiset"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>queue_to_multiset</span><span> 
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'a::linorder) BinomialQueue_inv ⇒ ('e × 'a) multiset"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_to_multiset (Node e a r ts) = {#(e,a)#} + queue_to_multiset ts"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"queue_to_multiset [] = {#}"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"queue_to_multiset (t#q) = tree_to_multiset t + queue_to_multiset q"</span></span></span><span> 
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>qtmset_append_union</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_to_multiset (q @ q') = 
  queue_to_multiset q + queue_to_multiset q'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>q</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>union_ac</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>qtmset_rev</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_to_multiset (rev q) = queue_to_multiset q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>q</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>union_ac</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Invariant"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We first formulate the invariant for single binomial trees,
  and then extend the invariant to binomial heaps (lists of binomial trees).
  The invariant for trees claims that a tree labeled rank $0$ has no children,
  and a tree labeled rank $r+1$ is the result of a link operation of
  two rank $r$ trees.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">function</span></span><span> </span><span>tree_invar</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'a::linorder) BinomialTree ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_invar (Node e a 0 ts) = (ts = [])"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_invar (Node e a (Suc r) ts) = 
  (∃ e1 a1 ts1 e2 a2 ts2. 
    tree_invar (Node e1 a1 r ts1) ∧ 
    tree_invar (Node e2 a2 r ts2) ∧ 
    (Node e a (Suc r) ts) = link (Node e1 a1 r ts1) (Node e2 a2 r ts2))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>pat_completeness</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">termination</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>relation</span><span> </span><span class="string"><span class="delete"><span class="delete">"measure (λt. rank t)"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A queue satisfies the invariant, iff all trees inside the queue satisfy 
  the invariant, and the queue contains only trees of distinct rank and 
  is ordered by rank›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹First part: All trees of the queue satisfy the tree invariant:›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>queue_invar</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'a::linorder) BinomialQueue_inv ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"queue_invar q ≡ (∀t ∈ set q. tree_invar t)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Second part: Trees have distinct rank, and are ordered by 
  ascending rank:›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>rank_invar</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'a::linorder) BinomialQueue_inv ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rank_invar [] = True"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rank_invar [t] = True"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rank_invar (t # t' # bq) = (rank t &lt; rank t' ∧ rank_invar (t' # bq))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>queue_invar_simps</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"queue_invar []"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"queue_invar (t#q) ⟷ tree_invar t ∧ queue_invar q"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"queue_invar (q@q') ⟷ queue_invar q ∧ queue_invar q'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>queue_invar_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Invariant for binomial queues:›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invar q == queue_invar q ∧ rank_invar q"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mset_link</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(tree_to_multiset (link t1 t2)) 
  = (tree_to_multiset t1) + (tree_to_multiset t2)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>t1</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span>t2</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>union_ac</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>link_tree_invar</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦tree_invar t1; tree_invar t2; rank t1 = rank t2⟧ ⟹ tree_invar (link t1 t2)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t1</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span>t2</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>invar_children</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar ((Node e a r ts)::(('e, 'a::linorder) BinomialTree))"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_invar ts"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>queue_invar_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>r</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>e</span><span> </span><span>a</span><span> </span><span>ts</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>r</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Suc</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>e1</span><span> </span><span>a1</span><span> </span><span>ts1</span><span> </span><span>e2</span><span> </span><span>a2</span><span> </span><span>ts2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span>O</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar (Node e1 a1 r ts1)"</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_invar (Node e2 a2 r ts2)"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(Node e a (Suc r) ts) = link (Node e1 a1 r ts1) (Node e2 a2 r ts2)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>tree_invar.simps</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Suc</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>O</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>O</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>case1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_invar ((Node e2 a2 r ts2) # ts1)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>queue_invar_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Suc</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>O</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>O</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>case2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_invar ((Node e1 a1 r ts1) # ts2)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>queue_invar_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>O</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ts = (if a1≤a2 
    then (Node e2 a2 r ts2) # ts1 
    else (Node e1 a1 r ts1) # ts2)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>case1</span><span> </span><span>case2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>queue_invar_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>invar_children'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar t ⟹ queue_invar (children t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>invar_children</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rank_link</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank t = rank t' ⟹ rank (link t t') = rank t + 1"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t'</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rank_invar_not_empty_hd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦rank_invar (t # bq); bq ≠ []⟧ ⟹ 
  rank t &lt; rank (hd bq)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>bq</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rank_invar_to_set</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank_invar (t # bq) ⟹ 
  ∀ t' ∈ set bq. rank t &lt; rank t'"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>bq</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>nat_less_le</span><span> </span><span>rank_invar.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>set_ConsD</span><span> </span><span>xt1</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_to_rank_invar</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦∀ t' ∈ set bq. rank t &lt; rank t'; rank_invar bq⟧ 
  ⟹  rank_invar (t # bq)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>bq</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>hd_in_set</span><span> </span><span>list.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>rank_invar.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rank_invar_hd_cons</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦rank_invar bq; rank t &lt; rank (hd bq)⟧ ⟹ rank_invar (t # bq)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>bq</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rank_invar_cons</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank_invar (t # bq) ⟹ rank_invar bq"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>bq</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>invar_cons_up</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦invar (t # bq); rank t' &lt; rank t; tree_invar t'⟧ ⟹ invar (t' # t # bq)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>invar_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>bq</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>invar_cons_down</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar (t # bq) ⟹ invar bq"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>invar_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>bq</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>invar_app_single</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦invar bq; ∀t ∈ set bq. rank t &lt; rank t'; tree_invar t'⟧ 
   ⟹ invar (bq @ [t'])"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>bq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>invar_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>bq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹invar (a # bq)›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invar bq"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>invar_cons_down</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invar (bq @ [t'])"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>bq</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>invar_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Heap Ordering"</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>heap_ordered</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'a::linorder) BinomialTree ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"heap_ordered (Node e a r ts) = (∀x ∈ set_mset(queue_to_multiset ts). a ≤ snd x)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The invariant for trees implies heap order.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tree_invar_heap_ordered</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"heap_ordered t"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Node</span><span> </span><span>e</span><span> </span><span>a</span><span> </span><span>nat</span><span> </span><span>list</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>nat</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span> </span><span>e</span><span> </span><span>a</span><span> </span><span>list</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>nat</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t1</span><span> </span><span>e1</span><span> </span><span>a1</span><span> </span><span>ts1</span><span> </span><span>t2</span><span> </span><span>e2</span><span> </span><span>a2</span><span> </span><span>ts2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>      </span><span>O</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar t1"</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_invar t2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t = link t1 t2"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t1</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t1 = (Node e1 a1 nat ts1)"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t2</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t2 = (Node e2 a2 nat ts2)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>tree_invar.simps</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>O</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t = (if  a1≤a2 
      then (Node e1 a1 (Suc nat) (t2 # ts1))
      else (Node e2 a2 (Suc nat) (t1 # ts2)))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Suc</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>O</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>t1</span><span class="delimiter">]</span><span> </span><span>Suc</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>O</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>t2</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"a1 ≤ a2"</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Height and Length"</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Although complexity of HOL-functions cannot be expressed within 
  HOL, we can express the height and length of a binomial heap.
  By showing that both, height and length, are logarithmic in the number 
  of contained elements, we give strong evidence that our functions have
  logarithmic complexity in the number of elements.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Height of a tree and queue›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>height_tree</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, ('a::linorder)) BinomialTree ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>height_queue</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, ('a::linorder)) BinomialQueue_inv ⇒ nat"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"height_tree (Node e a r ts) = height_queue ts"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"height_queue [] = 0"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"height_queue (t # ts) = max (Suc (height_tree t)) (height_queue ts)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>link_length</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"size (tree_to_multiset (link t1 t2)) = 
  size (tree_to_multiset t1) + size (tree_to_multiset t2)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>t1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>t2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tree_rank_estimate</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_invar (Node e a r ts) ⟹ 
    size (tree_to_multiset (Node e a r ts)) = (2::nat)^r"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>r</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>e</span><span> </span><span>a</span><span> </span><span>ts</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>r</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Suc</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>e1</span><span> </span><span>a1</span><span> </span><span>ts1</span><span> </span><span>e2</span><span> </span><span>a2</span><span> </span><span>ts2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>link</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(Node e a (Suc r) ts) = link (Node e1 a1 r ts1) (Node e2 a2 r ts2)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar (Node e1 a1 r ts1) "</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar (Node e2 a2 r ts2)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>link_length</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Node e1 a1 r ts1)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(Node e2 a2 r ts2)"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span>Suc</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv1</span><span class="delimiter">]</span><span> </span><span>Suc</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv2</span><span class="delimiter">]</span><span> </span><span>link</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tree_rank_height</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_invar (Node e a r ts) ⟹ height_tree (Node e a r ts) = r"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>r</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>e</span><span> </span><span>a</span><span> </span><span>ts</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>r</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Suc</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>e1</span><span> </span><span>a1</span><span> </span><span>ts1</span><span> </span><span>e2</span><span> </span><span>a2</span><span> </span><span>ts2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>link</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(Node e a (Suc r) ts) = link (Node e1 a1 r ts1) (Node e2 a2 r ts2)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar (Node e1 a1 r ts1) "</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar (Node e2 a2 r ts2)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>link</span><span> </span><span>Suc</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv1</span><span class="delimiter">]</span><span> </span><span>Suc</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv2</span><span class="delimiter">]</span><span> </span><span>Suc</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"a1 ≤ a2"</span></span></span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A binomial tree of height $h$ contains exactly $2^{h}$ elements›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>tree_height_estimate</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_invar t ⟹ size (tree_to_multiset t) = (2::nat)^(height_tree t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>tree_rank_estimate</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>tree_rank_height</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*lemma size_mset_tree_Node: "tree_invar (Node e a r ts) ⟹ 
  size (tree_to_multiset (Node e a r ts)) = (2::nat)^r"
  apply(induct r arbitrary: e a ts, simp)
proof -
  case goal1
  from goal1(2) obtain e1 a1 ts1 e2 a2 ts2 where link:
    "(Node e a (Suc r) ts) = link (Node e1 a1 r ts1) (Node e2 a2 r ts2)"
    and inv1: "tree_invar (Node e1 a1 r ts1) "
    and inv2: "tree_invar (Node e2 a2 r ts2)" by simp blast
  from link_length[of "(Node e1 a1 r ts1)" "(Node e2 a2 r ts2)"]
    goal1(1)[OF inv1] goal1(1)[OF inv2] link
  show ?case by simp
qed*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>size_mset_tree</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar t ⟹ 
  size (tree_to_multiset t) = (2::nat)^(rank t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>tree_rank_estimate</span><span> </span><span>BinomialTree.sel</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span> 
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>invar_butlast</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar (bq @ [t]) ⟹ invar bq"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>invar_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>bq</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>bq</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>invar_last_max</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar (bq @ [m]) ⟹ ∀ t ∈ set bq. rank t &lt; rank m"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>invar_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>bq</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>bq</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>invar_length</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar bq ⟹ length bq ≤ Suc (rank (last bq))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>bq</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>snoc</span><span> </span><span>x</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>xxs</span><span> </span><span>xx</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>snoc.hyps</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invar_butlast</span><span class="delimiter">[</span><span>OF</span><span> </span><span>snoc.prems</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>      </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length xs ≤ Suc (rank (last xs))"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>invar_last_max</span><span class="delimiter">[</span><span>OF</span><span> </span><span>snoc.prems</span><span class="delimiter">]</span><span> </span><span>last_in_set</span><span class="delimiter">[</span><span>of</span><span> </span><span>xs</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"Suc (rank (last xs)) ≤ rank (last (xs @ [x]))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>size_queue_sum_list</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"size (queue_to_multiset bq) = sum_list (map (size ∘ tree_to_multiset) bq)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>bq</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  A binomial heap of length $l$ contains at least $2^l - 1$ elements. 
›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>queue_length_estimate_lower</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"invar bq ⟹ (size (queue_to_multiset bq)) ≥ 2^(length bq) - 1"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>bq</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>snoc</span><span> </span><span>x</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>snoc.hyps</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invar_butlast</span><span class="delimiter">[</span><span>OF</span><span> </span><span>snoc.prems</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"2 ^ length xs ≤ Suc (size (queue_to_multiset xs))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>size_q</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"size (queue_to_multiset (xs @ [x])) = 
    size (queue_to_multiset xs) + size (tree_to_multiset x)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>size_queue_sum_list</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>snoc.prems</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inv_x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>invar_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"size (tree_to_multiset x) = 2 ^ rank x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>size_mset_tree</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>    </span><span>eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"size (queue_to_multiset (xs @ [x])) = 
         size (queue_to_multiset xs) + (2::nat)^(rank x)"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>invar_length</span><span class="delimiter">[</span><span>OF</span><span> </span><span>snoc.prems</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length xs ≤ rank x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>snd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(2::nat) ^ length xs ≤ (2::nat) ^ rank x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(2::nat) ^ length (xs @ [x]) = (2::nat) ^ (length xs) + (2::nat) ^ (length xs)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>IH</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"2 ^ length (xs @ [x]) ≤ Suc (size (queue_to_multiset xs)) + 2 ^ length xs"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>snd</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 ^ length (xs @ [x]) ≤ 
    Suc (size (queue_to_multiset xs)) + 2 ^ rank x"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>arith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>eq</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Operations›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Empty"</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>empty_correct</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"invar Nil"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"queue_to_multiset Nil = {#}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>invar_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The empty multiset is represented by exactly the empty queue›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>empty_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t=Nil ⟷ queue_to_multiset t = {#}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Insert"</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Inserts a binomial tree into a binomial queue, such that the queue 
  does not contain two trees of same rank.›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span>  </span><span>ins</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'a::linorder) BinomialTree ⇒ ('e, 'a) BinomialQueue_inv ⇒ 
  ('e, 'a) BinomialQueue_inv"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ins t [] = [t]"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ins t' (t # bq) = (if (rank t') &lt; (rank t) 
    then t' # t # bq 
    else (if (rank t) &lt; (rank t') 
            then t # (ins t' bq)       
            else ins (link t' t) bq))"</span></span></span><span> 
</span><span>  
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Inserts an element with priority into the queue.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>insert</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'e ⇒ 'a::linorder ⇒ ('e, 'a) BinomialQueue_inv ⇒ 
  ('e, 'a) BinomialQueue_inv"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"insert e a bq = ins (Node e a 0 []) bq"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ins_mset</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦tree_invar t; queue_invar q⟧ ⟹ queue_to_multiset (ins t q) 
   = tree_to_multiset t + queue_to_multiset q"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>q</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>union_ac</span><span> </span><span>link_tree_invar</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>insert_mset</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_invar q ⟹
  queue_to_multiset (insert e a q) = queue_to_multiset q + {# (e,a) #}"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ins_mset</span><span> </span><span>union_ac</span><span> </span><span>insert_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ins_queue_invar</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦tree_invar t; queue_invar q⟧ ⟹ queue_invar (ins t q)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>q</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>q</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>iv</span><span> </span><span class="delimiter">=</span><span> </span><span>Cons.hyps</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank t = rank a"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons.prems</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>      </span><span>inv_a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv_q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_invar q"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>inv_link</span><span> </span><span class="delimiter">=</span><span> </span><span>link_tree_invar</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹tree_invar t›</span></span></span><span> </span><span>inv_a</span><span> </span><span>True</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>iv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv_link</span><span> </span><span>inv_q</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>insert_queue_invar</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_invar q"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_invar (insert e a q)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar (Node e a 0 [])"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ins_queue_invar</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>insert_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>  </span><span>rank_ins</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(rank_invar (t # bq) ⟹ 
  (rank (hd (ins t' (t # bq))) ≥ rank t) ∨ 
  (rank (hd (ins t' (t # bq))) ≥ rank t'))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>bq</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span> </span><span>t'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rank_link</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>goal_cases</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>prems</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>a</span><span> </span><span>bq</span><span> </span><span>t</span><span> </span><span>t'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank (link t' t) = rank a"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rank_link</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>goal_cases</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>*</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀t' t. ⟦rank_invar (t # bq); rank t' = rank t⟧
      ⟹ rank t ≤ rank (hd (ins (link t' t) bq))›</span></span></span><span class="delimiter">[</span><span>of</span><span> </span><span>a</span><span> </span><span class="string"><span class="delete"><span class="delete">"(link t' t)"</span></span></span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank (hd (ins (link (link t' t) a) bq)) = rank a"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>*</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>*</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rank a ≤ rank (hd (ins (link (link t' t) a) bq))"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rank_link</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>*</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rank_ins2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank_invar bq ⟹ 
  rank t ≤ rank (hd (ins t bq)) ∨ 
  (rank (hd (ins t bq)) = rank (hd bq) ∧ bq ≠ [])"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>bq</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>goal_cases</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>prems</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>a</span><span> </span><span>bq</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank (link t a) = rank a + 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rank_link</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>prems</span><span> </span><span>r</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(link t a)"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>bq</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rank_invar_ins</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank_invar bq ⟹ rank_invar (ins t bq)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>bq</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>goal_cases</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>prems</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>a</span><span> </span><span>bq</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank_invar (ins t bq)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>bq</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>prems</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>hd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bq ≠ [] ⟹ rank a &lt; rank (hd bq)"</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>bq</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>prems</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rank t ≤ rank (hd (ins t bq)) ∨
    (rank (hd (ins t bq)) = rank (hd bq) ∧ bq ≠ [])"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rank_ins2</span><span> </span><span>rank_invar_cons</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>prems</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rank a &lt; rank (hd (ins t bq)) ∨
    (rank (hd (ins t bq)) = rank (hd bq) ∧ bq ≠ [])"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>prems</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hd</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rank_invar_hd_cons</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>prems</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>a</span><span> </span><span>bq</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank_invar bq"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>bq</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>prems</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(link t a)"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rank_invar_insert</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank_invar bq ⟹ rank_invar (insert e a bq)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rank_invar_ins</span><span> </span><span>insert_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>insert_correct</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>I</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"invar (insert e a q)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"queue_to_multiset (insert e a q) = queue_to_multiset q + {# (e,a) #}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>insert_queue_invar</span><span class="delimiter">[</span><span>of</span><span> </span><span>q</span><span class="delimiter">]</span><span> </span><span>rank_invar_insert</span><span class="delimiter">[</span><span>of</span><span> </span><span>q</span><span class="delimiter">]</span><span> </span><span>insert_mset</span><span class="delimiter">[</span><span>of</span><span> </span><span>q</span><span class="delimiter">]</span><span> </span><span>I</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>invar_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Meld"</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Melds two queues.›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>meld</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'a::linorder) BinomialQueue_inv ⇒ ('e, 'a) BinomialQueue_inv
  ⇒ ('e, 'a) BinomialQueue_inv"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"meld [] bq = bq"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"meld bq [] = bq"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"meld (t1#bq1) (t2#bq2) =
   (if (rank t1) &lt; (rank t2) 
       then t1 # (meld bq1 (t2 # bq2))
       else (
         if (rank t2 &lt; rank t1)
            then t2 # (meld (t1 # bq1) bq2)
            else ins (link t1 t2) (meld bq1 bq2)
       )
    )"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>meld_queue_invar</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦queue_invar q; queue_invar q'⟧ ⟹ queue_invar (meld q q')"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>q</span><span> </span><span>q'</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>meld.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>2</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>3</span><span> </span><span>t1</span><span> </span><span>bq1</span><span> </span><span>t2</span><span> </span><span>bq2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">consider</span></span><span> </span><span class="delimiter">(</span><span>lt</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank t1 &lt; rank t2"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="delimiter">(</span><span>gt</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank t1 &gt; rank t2"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="delimiter">(</span><span>eq</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank t1 = rank t2"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>atomize_elim</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>lt</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>3</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inv_bq1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_invar bq1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>3</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inv_t1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar t1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>3</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>lt</span><span> </span><span>inv_bq1</span><span> </span><span>3</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>inv_t1</span><span> </span><span>lt</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>gt</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>3</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inv_bq2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_invar bq2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>3</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inv_t2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar t2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>gt</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ rank t1 &lt; rank t2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>3</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span> </span><span>gt</span><span> </span><span>3</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>inv_bq2</span><span class="delimiter">]</span><span> </span><span>inv_t2</span><span> </span><span>gt</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>eq</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>3</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inv_bq1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_invar bq1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>3</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inv_t1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar t1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>3</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inv_bq2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_invar bq2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>3</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inv_t2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar t2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>inv_link</span><span> </span><span class="delimiter">=</span><span> </span><span>link_tree_invar</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv_t1</span><span> </span><span>inv_t2</span><span> </span><span>eq</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>eq</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ rank t1 &lt; rank t2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ rank t2 &lt; rank t1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>inv_meld</span><span> </span><span class="delimiter">=</span><span> </span><span>3</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>*</span><span> </span><span>inv_bq1</span><span> </span><span>inv_bq2</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ins_queue_invar</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv_link</span><span> </span><span>inv_meld</span><span class="delimiter">]</span><span> </span><span>*</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rank_ins_min</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank_invar bq ⟹ 
  rank (hd (ins t bq)) ≥ min (rank t) (rank (hd bq))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>bq</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>goal_cases</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>prems</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>a</span><span> </span><span>bq</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank_invar bq"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>bq</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>prems</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank (link t a) = rank a + 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rank_link</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>prems</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(link t a)"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>bq</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rank_invar_meld_strong</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦rank_invar bq1; rank_invar bq2⟧ ⟹ rank_invar (meld bq1 bq2) ∧ 
  rank (hd (meld bq1 bq2)) ≥ min (rank (hd bq1)) (rank (hd bq2))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>bq1</span><span> </span><span>bq2</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>meld.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>2</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>3</span><span> </span><span>t1</span><span> </span><span>bq1</span><span> </span><span>t2</span><span> </span><span>bq2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>3</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inv1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank_invar bq1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>bq1</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>3</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inv2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank_invar bq2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>bq2</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv2</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>3</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?t</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"t2"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?bq</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"bq2"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?meld</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank t2 &lt; rank (hd (meld (t1 # bq1) bq2))"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>prems</span><span class="delimiter">:</span><span> </span><span>1</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bq ≠ [] ⟹ rank ?t &lt; rank (hd ?bq)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rank_invar_not_empty_hd</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>prems</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ne</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?bq ≠ [] ⟹ ?meld"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>prems</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bq = [] ⟹ ?meld"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ne</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?meld"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"?bq = []"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>prems</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rank_invar_hd_cons</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span> </span><span class="comment">― ‹analog›</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?t</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"t1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?bq</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"bq1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?meld</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank t1 &lt; rank (hd (meld bq1 (t2 # bq2)))"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>prems</span><span class="delimiter">:</span><span> </span><span>2</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bq ≠ [] ⟹ rank ?t &lt; rank (hd ?bq)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rank_invar_not_empty_hd</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>prems</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ne</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?bq ≠ [] ⟹ ?meld"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>prems</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bq = [] ⟹ ?meld"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ne</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?meld"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"?bq = []"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>prems</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rank_invar_hd_cons</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>3</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rank_invar_ins</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>prems</span><span class="delimiter">:</span><span> </span><span>4</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Ab hier wirds hässlich *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank (link t1 t2) = rank t2 + 1"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rank_link</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>m</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"meld bq1 [] = bq1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>bq1</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv2</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prems</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>mm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"min (rank (hd bq1)) (rank (hd bq2)) ≤ rank (hd (meld bq1 bq2))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹rank_invar (t1 # bq1)›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bq1 ≠ [] ⟹ rank t1 &lt; rank (hd bq1)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rank_invar_not_empty_hd</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>prems</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>r1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bq1 ≠ [] ⟹ rank t2 &lt; rank (hd bq1)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹rank_invar (t2 # bq2)›</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>r2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bq2 ≠ [] ⟹ rank t2 &lt; rank (hd bq2)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rank_invar_not_empty_hd</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv1</span><span> </span><span>r</span><span> </span><span>r1</span><span> </span><span>rank_ins_min</span><span class="delimiter">[</span><span>of</span><span> </span><span>bq1</span><span> </span><span class="string"><span class="delete"><span class="delete">"(link t1 t2)"</span></span></span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>abc1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bq1 ≠ [] ⟹ rank t2 ≤ rank (hd (ins (link t1 t2) bq1))"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv2</span><span> </span><span>r</span><span> </span><span>r2</span><span> </span><span>rank_ins_min</span><span class="delimiter">[</span><span>of</span><span> </span><span>bq2</span><span> </span><span class="string"><span class="delete"><span class="delete">"(link t1 t2)"</span></span></span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>abc2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bq2 ≠ [] ⟹ rank t2 ≤ rank (hd (ins (link t1 t2) bq2))"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>r1</span><span> </span><span>r2</span><span> </span><span>mm</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"⟦bq1 ≠ []; bq2 ≠ []⟧ ⟹ rank t2 &lt; rank (hd (meld bq1 bq2))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹rank_invar (meld bq1 bq2)›</span></span></span><span> 
</span><span>      </span><span>r</span><span> </span><span>rank_ins_min</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"meld bq1 bq2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"link t1 t2"</span></span></span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦bq1 ≠ []; bq2 ≠ []⟧ ⟹ 
      rank t2 &lt; rank (hd (ins (link t1 t2) (meld bq1 bq2)))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>rank_ins_min</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"meld bq1 bq2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"link t1 t2"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>inv1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv2</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>r</span><span> </span><span>m</span><span> </span><span>r1</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"bq2 = []"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"bq1 = []"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>abc1</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"bq1 = []"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>abc2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rank_invar_meld</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦rank_invar bq1; rank_invar bq2⟧ ⟹ rank_invar (meld bq1 bq2)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>rank_invar_meld_strong</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>meld_mset</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦queue_invar q; queue_invar q'⟧ ⟹ 
  queue_to_multiset (meld q q') = 
  queue_to_multiset q + queue_to_multiset q'"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>q</span><span> </span><span>q'</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>meld.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>link_tree_invar</span><span> </span><span>meld_queue_invar</span><span> </span><span>ins_mset</span><span> </span><span>union_ac</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>meld_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invar q"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invar q'"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"invar (meld q q')"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"queue_to_multiset (meld q q') = queue_to_multiset q + queue_to_multiset q'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>invar_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>meld_queue_invar</span><span> </span><span>rank_invar_meld</span><span> </span><span>meld_mset</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Find Minimal Element"</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Finds the tree containing the minimal element.›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>getMinTree</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'a::linorder) BinomialQueue_inv ⇒ 
  ('e, 'a) BinomialTree"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"getMinTree [t] = t"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"getMinTree (t#bq) = (if prio t ≤ prio (getMinTree bq) 
     then t else (getMinTree bq))"</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mintree_exists</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(bq ≠ []) = (getMinTree bq ∈ set bq)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>bq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>_</span><span> </span><span>bq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>bq</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>treehead_in_multiset</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"t ∈ set bq ⟹ (val t, prio t) ∈# queue_to_multiset bq"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>bq</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span>t</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>heap_ordered_single</span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">"heap_ordered t = (∀x ∈ set_mset (tree_to_multiset t). prio t ≤ snd x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>getMinTree_cons</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"prio (getMinTree (y # x # xs)) ≤ prio (getMinTree (x # xs))"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>getMinTree.induct</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>getMinTree_min_tree</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"t ∈ set bq  ⟹ prio (getMinTree bq) ≤ prio t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>bq</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>getMinTree.induct</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>   
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>goal_cases</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>prems</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>t</span><span> </span><span>v</span><span> </span><span>va</span><span> </span><span>ta</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"ta = t"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>getMinTree_cons</span><span> </span><span>prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>prems</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>set_ConsD</span><span> </span><span>xt1</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>getMinTree_min_prio</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_invar bq"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ set_mset (queue_to_multiset bq)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prio (getMinTree bq) ≤ snd y"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bq ≠ []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>bq</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ t ∈ set bq. (y ∈ set_mset ((tree_to_multiset t)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>bq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>bq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ set_mset (tree_to_multiset a)"</span></span></span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>bq</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>O</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"t ∈ set bq"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"y ∈ set_mset (tree_to_multiset t)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>e</span><span> </span><span>a</span><span> </span><span>r</span><span> </span><span>ts</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t = (Node e a r ts)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>O</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>queue_invar_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>tree_invar_heap_ordered</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv</span><span class="delimiter">]</span><span> </span><span>heap_ordered.simps</span><span class="delimiter">[</span><span>of</span><span> </span><span>e</span><span> </span><span>a</span><span> </span><span>r</span><span> </span><span>ts</span><span class="delimiter">]</span><span> </span><span>O</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prio t ≤ snd y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>getMinTree_min_tree</span><span class="delimiter">[</span><span>OF</span><span> </span><span>O</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Finds the minimal Element in the queue.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>findMin</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'a::linorder) BinomialQueue_inv ⇒ ('e × 'a)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"findMin bq = (let min = getMinTree bq in (val min, prio min))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>findMin_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>I</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>NE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"q ≠ Nil"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"findMin q ∈# queue_to_multiset q"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∀y∈set_mset (queue_to_multiset q). snd (findMin q) ≤ snd y"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>NE</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"getMinTree q ∈ set q"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>mintree_exists</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"findMin q ∈# queue_to_multiset q"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>treehead_in_multiset</span><span> </span><span>Let_def</span><span> </span><span>findMin_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀y∈set_mset (queue_to_multiset q). snd (findMin q) ≤ snd y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>I</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>invar_def</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>getMinTree_min_prio</span><span> </span><span>Let_def</span><span> </span><span>findMin_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Delete Minimal Element"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Removes the first tree, which has the priority $a$ within his root.›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>remove1Prio</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ ('e, 'a::linorder) BinomialQueue_inv ⇒
  ('e, 'a) BinomialQueue_inv"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"remove1Prio a [] = []"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"remove1Prio a (t#bq) = 
  (if (prio t) = a then bq else t # (remove1Prio a bq))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Returns the queue without the minimal element.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>deleteMin</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'a::linorder) BinomialQueue_inv ⇒ 
  ('e, 'a) BinomialQueue_inv"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"deleteMin bq ≡ (let min = getMinTree bq in 
                    meld (rev (children min)) 
                         (remove1Prio (prio min) bq))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>queue_invar_rev</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_invar q ⟹ queue_invar (rev q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>queue_invar_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>queue_invar_remove1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_invar q ⟹ queue_invar (remove1 t q)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>queue_invar_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>qtm_in_set_subset</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ set q ⟹ 
  tree_to_multiset t ⊆# queue_to_multiset q"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>q</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>q</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"t = a"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>t_in_q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ set q"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_to_multiset q ⊆# queue_to_multiset (a # q)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>subset_mset.order_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t_in_q</span><span class="delimiter">]</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>remove1_mset</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ set q ⟹ 
  queue_to_multiset (remove1 t q) = 
  queue_to_multiset q - tree_to_multiset t"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>q</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>qtm_in_set_subset</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>remove1Prio_remove1</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"remove1Prio (prio (getMinTree bq)) bq = remove1 (getMinTree bq) bq"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>bq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>t</span><span> </span><span>bq</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>iv</span><span> </span><span class="delimiter">=</span><span> </span><span>Cons</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"t = getMinTree (t # bq)"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>iv</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>ne</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bq ≠ []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>down</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"getMinTree (t # bq) = getMinTree bq"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>bq</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>getMinTree.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ne</span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prio t ≠ prio (getMinTree bq)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>bq</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>getMinTree.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>down</span><span> </span><span>iv</span><span> </span><span>False</span><span> </span><span>ne</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>deleteMin_queue_invar</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>INV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_invar q"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>NE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"q ≠ Nil"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_invar (deleteMin q)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>q</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Cons</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>NE</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>mintree_exists</span><span class="delimiter">[</span><span>of</span><span> </span><span>q</span><span class="delimiter">]</span><span> </span><span>INV</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inv_min</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar (getMinTree q)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>queue_invar_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>inv_children</span><span> </span><span class="delimiter">=</span><span> </span><span>invar_children'</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv_min</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>inv_rev</span><span> </span><span class="delimiter">=</span><span> </span><span>queue_invar_rev</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv_children</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>inv_rem</span><span> </span><span class="delimiter">=</span><span> </span><span>queue_invar_remove1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>INV</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"getMinTree q"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>meld_queue_invar</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv_rev</span><span> </span><span>inv_rem</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deleteMin_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>children_rank_less</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀t' ∈ set (children t). rank t' &lt; rank t"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Node</span><span> </span><span>e</span><span> </span><span>a</span><span> </span><span>nat</span><span> </span><span>list</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>nat</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span> </span><span>e</span><span> </span><span>a</span><span> </span><span>list</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>nat</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>e1</span><span> </span><span>a1</span><span> </span><span>ts1</span><span> </span><span>e2</span><span> </span><span>a2</span><span> </span><span>ts2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>      </span><span>O</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar (Node e1 a1 nat ts1)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar (Node e2 a2 nat ts2)"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>tree_invar.simps</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>ch_id</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"children t = 
      (if a1 ≤ a2 then (Node e2 a2 nat ts2)#ts1 
       else (Node e1 a1 nat ts1)#ts2)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>O</span><span> </span><span>Suc</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Node e1 a1 nat ts1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ts1"</span></span></span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span>p1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀t'∈set ((Node e2 a2 nat ts2) # ts1). rank t' &lt; Suc nat"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>O</span><span> </span><span>Suc</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Node e2 a2 nat ts2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ts2"</span></span></span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>p2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀t'∈set ((Node e1 a1 nat ts1) # ts2). rank t' &lt; Suc nat"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Suc</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>p1</span><span> </span><span>p2</span><span> </span><span>ch_id</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strong_rev_children</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invar (rev (children t))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>invar_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Node</span><span> </span><span>e</span><span> </span><span>a</span><span> </span><span>nat</span><span> </span><span>list</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_invar (rev (children t)) ∧ rank_invar (rev (children t))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat"</span></span></span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span> </span><span>e</span><span> </span><span>a</span><span> </span><span>list</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>nat</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>e1</span><span> </span><span>a1</span><span> </span><span>ts1</span><span> </span><span>e2</span><span> </span><span>a2</span><span> </span><span>ts2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>      </span><span>O</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar (Node e1 a1 nat ts1)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar (Node e2 a2 nat ts2)"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>tree_invar.simps</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>ch_id</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"children t = 
      (if a1 ≤ a2 then (Node e2 a2 nat ts2)#ts1 
       else (Node e1 a1 nat ts1)#ts2)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>O</span><span> </span><span>Suc</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Node e1 a1 nat ts1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ts1"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>rev_ts1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar (rev ts1)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>invar_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>O</span><span> </span><span>children_rank_less</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Node e1 a1 nat ts1"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"∀t∈set (rev ts1). rank t &lt; rank (Node e2 a2 nat ts2)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>O</span><span> </span><span>rev_ts1</span><span> </span><span>invar_app_single</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"rev ts1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Node e2 a2 nat ts2"</span></span></span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>p1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar (rev ((Node e2 a2 nat ts2) # ts1))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>O</span><span> </span><span>Suc</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Node e2 a2 nat ts2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ts2"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>rev_ts2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar (rev ts2)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>invar_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>O</span><span> </span><span>children_rank_less</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Node e2 a2 nat ts2"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀t∈set (rev ts2). rank t &lt; rank (Node e1 a1 nat ts1)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>O</span><span> </span><span>rev_ts2</span><span> </span><span>invar_app_single</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"rev ts2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Node e1 a1 nat ts1"</span></span></span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>p2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar (rev ((Node e1 a1 nat ts1) # ts2))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>p1</span><span> </span><span>p2</span><span> </span><span>ch_id</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>invar_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>first_less</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank_invar (t # bq) ⟹ ∀t' ∈ set bq. rank t &lt; rank t'"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>bq</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>order_le_less</span><span> </span><span>rank_invar.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>set_ConsD</span><span> </span><span>xt1</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strong_remove1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar bq ⟹ invar (remove1 t bq)"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>bq</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>bq</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"t=a"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invar bq"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>invar_cons_down</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>True</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invar bq"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>invar_cons_down</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"t"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>si1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar (remove1 t bq)"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invar (remove1 t (a # bq)) = invar (a # (remove1 t bq))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"remove1 t bq"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>si1</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>False</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>invar_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Cons'</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>aa</span><span> </span><span>list</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>invar_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons</span><span> </span><span>first_less</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"a"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bq"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀t ∈ set (remove1 t bq). rank a &lt; rank t"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>notin_set_remove1</span><span> </span><span>invar_def</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons'</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rank a &lt; rank aa"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>si1</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>False</span><span> </span><span>Cons'</span><span> </span><span>invar_cons_up</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"aa"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"list"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>invar_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>deleteMin_invar</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invar bq"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bq ≠ []"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invar (deleteMin bq)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar (deleteMin bq) = 
    invar (meld (rev (children (getMinTree bq))) (remove1 (getMinTree bq) bq))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deleteMin_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span>mintree_exists</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"bq"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ti</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar (getMinTree bq)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>invar_def</span><span> </span><span>Let_def</span><span> </span><span>queue_invar_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>strong_rev_children</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"getMinTree bq"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>m1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar (rev (children (getMinTree bq)))"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>strong_remove1</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"bq"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"getMinTree bq"</span></span></span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>m2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar (remove1 (getMinTree bq) bq)"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>meld_correct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"rev (children (getMinTree bq))"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"remove1 (getMinTree bq) bq"</span></span></span><span class="delimiter">]</span><span> </span><span>m1</span><span> </span><span>m2</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invar (meld (rev (children (getMinTree bq))) (remove1 (getMinTree bq) bq))"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>eq</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>children_mset</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_to_multiset (children t) = 
  tree_to_multiset t - {# (val t, prio t) #}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Node</span><span> </span><span>e</span><span> </span><span>a</span><span> </span><span>nat</span><span> </span><span>list</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>list</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>deleteMin_mset</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_invar q"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q ≠ Nil"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_to_multiset (deleteMin q) = queue_to_multiset q - {# (findMin q) #}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span>mintree_exists</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"q"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>min_in_q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"getMinTree q ∈ set q"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inv_min</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar (getMinTree q)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>queue_invar_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>q_ne</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"q ≠ []"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>inv_children</span><span> </span><span class="delimiter">=</span><span> </span><span>invar_children'</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv_min</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>inv_rev</span><span> </span><span class="delimiter">=</span><span> </span><span>queue_invar_rev</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv_children</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>inv_rem</span><span> </span><span class="delimiter">=</span><span> </span><span>queue_invar_remove1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"getMinTree q"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>m_meld</span><span> </span><span class="delimiter">=</span><span> </span><span>meld_mset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv_rev</span><span> </span><span>inv_rem</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>m_rem</span><span> </span><span class="delimiter">=</span><span> </span><span>remove1_mset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>min_in_q</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>m_rev</span><span> </span><span class="delimiter">=</span><span> </span><span>qtmset_rev</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"children (getMinTree q)"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>m_children</span><span> </span><span class="delimiter">=</span><span> </span><span>children_mset</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"getMinTree q"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>min_subset_q</span><span> </span><span class="delimiter">=</span><span> </span><span>qtm_in_set_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>min_in_q</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?Q</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_to_multiset q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?MT</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_to_multiset (getMinTree q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>q_ne</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>head_subset_min</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"{# (val (getMinTree q), prio (getMinTree q)) #} ⊆# ?MT"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"getMinTree q"</span></span></span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?Q</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_to_multiset q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?MT</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_to_multiset (getMinTree q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>m_meld</span><span> </span><span>m_rem</span><span> </span><span>m_rev</span><span> </span><span>m_children</span><span> 
</span><span>    </span><span>multiset_diff_union_assoc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>head_subset_min</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"?Q - ?MT"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span>mset_subset_eq_multiset_union_diff_commute</span><span class="delimiter">[</span><span>OF</span><span> </span><span>min_subset_q</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"?MT"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deleteMin_def</span><span> </span><span>union_ac</span><span> </span><span>Let_def</span><span> </span><span>findMin_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>deleteMin_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>INV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar q"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>NE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"q ≠ Nil"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"invar (deleteMin q)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"queue_to_multiset (deleteMin q) = queue_to_multiset q - {# (findMin q) #}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>deleteMin_invar</span><span> </span><span>deleteMin_mset</span><span> </span><span>INV</span><span> </span><span>NE</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>invar_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>BinomialHeapStruc</span><span class="delimiter">:</span><span> </span><span>BinomialHeapStruc_loc</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Hiding the Invariant"</span></span></span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Datatype"</span></span></span><span>
</span><span class="keyword1"><span class="command">typedef</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">overloaded</span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span class="tfree">'e</span><span class="delimiter">,</span><span> </span><span class="tfree">'a</span><span class="delimiter">)</span><span> </span><span>BinomialHeap</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"{q :: ('e,'a::linorder) BinomialHeapStruc.BinomialQueue_inv. BinomialHeapStruc.invar q }"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"Nil"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Rep_BinomialHeap_invar</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"BinomialHeapStruc.invar (Rep_BinomialHeap x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Rep_BinomialHeap</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"BinomialHeapStruc.invar q ⟹ Rep_BinomialHeap (Abs_BinomialHeap q) = q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Abs_BinomialHeap_inverse</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>code</span><span> </span><span>abstype</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Abs_BinomialHeap (Rep_BinomialHeap q) = q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Rep_BinomialHeap_inverse</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>BinomialHeap_loc</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Operations"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"to_mset t == BinomialHeapStruc.queue_to_multiset (Rep_BinomialHeap t)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>empty</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"empty == Abs_BinomialHeap Nil"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>code</span><span> </span><span>abstract</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Rep_BinomialHeap empty = []"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>empty_def</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isEmpty q == Rep_BinomialHeap q = Nil"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>empty_rep</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"q=empty ⟷ Rep_BinomialHeap q = Nil"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>empty_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Rep_BinomialHeap_inverse</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isEmpty_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isEmpty q ⟷ q=empty"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>empty_rep</span><span> </span><span>isEmpty_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> 
</span><span>    </span><span>insert</span><span> 
</span><span>    </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'e  ⇒ ('a::linorder) ⇒ ('e,'a) BinomialHeap ⇒ ('e,'a) BinomialHeap"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"insert e a q == 
            Abs_BinomialHeap (BinomialHeapStruc.insert e a (Rep_BinomialHeap q))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>code</span><span> </span><span>abstract</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"Rep_BinomialHeap (insert e a q) 
    = BinomialHeapStruc.insert e a (Rep_BinomialHeap q)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>insert_def</span><span> </span><span>BinomialHeapStruc.insert_correct</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"findMin q == BinomialHeapStruc.findMin (Rep_BinomialHeap q)"</span></span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"deleteMin q == 
    if q=empty then empty 
    else Abs_BinomialHeap (BinomialHeapStruc.deleteMin (Rep_BinomialHeap q))"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
    In this lemma, we do not use equality, but case-distinction for checking 
    non-emptyness. That prevents the code generator from introducing
    an equality-class parameter for the entry type ‹'a›.
›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>code</span><span> </span><span>abstract</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Rep_BinomialHeap (deleteMin q) =
    (case (Rep_BinomialHeap q) of [] ⇒ [] |
     _ ⇒ BinomialHeapStruc.deleteMin (Rep_BinomialHeap q))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"Rep_BinomialHeap q"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> 
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Nil</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deleteMin_def</span><span> </span><span>BinomialHeapStruc.deleteMin_correct</span><span> 
</span><span>      </span><span>BinomialHeapStruc.empty_iff</span><span> </span><span>empty_rep</span><span> </span><span>Nil</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>NE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Rep_BinomialHeap q ≠ []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cons</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fold</span><span> </span><span>Cons</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NE</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deleteMin_def</span><span> </span><span>BinomialHeapStruc.deleteMin_correct</span><span> 
</span><span>        </span><span>BinomialHeapStruc.empty_iff</span><span> </span><span>empty_rep</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  lemma [code abstract]: "Rep_BinomialHeap (deleteMin q) =
    (if (Rep_BinomialHeap q = []) then [] 
     else BinomialHeapStruc.deleteMin (Rep_BinomialHeap q))"
    by (auto simp add: deleteMin_def BinomialHeapStruc.deleteMin_correct 
      BinomialHeapStruc.empty_iff empty_rep)
      *)</span></span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"meld q1 q2 == 
    Abs_BinomialHeap (BinomialHeapStruc.meld (Rep_BinomialHeap q1) 
                                             (Rep_BinomialHeap q2))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>code</span><span> </span><span>abstract</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"Rep_BinomialHeap (meld q1 q2) 
    = BinomialHeapStruc.meld (Rep_BinomialHeap q1) (Rep_BinomialHeap q2)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>meld_def</span><span> </span><span>BinomialHeapStruc.meld_correct</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Correctness"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>empty_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"to_mset q = {#} ⟷ q=empty"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>to_mset_def</span><span> </span><span>BinomialHeapStruc.empty_iff</span><span> </span><span>empty_rep</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>to_mset_of_empty</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"to_mset empty = {#}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>empty_correct</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>insert_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"to_mset (insert e a q) = to_mset q + {#(e,a)#}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>insert_def</span><span> </span><span>to_mset_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>BinomialHeapStruc.insert_correct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>findMin_correct</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q≠empty"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"findMin q ∈# to_mset q"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"∀y∈set_mset (to_mset q). snd (findMin q) ≤ snd y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>findMin_def</span><span> </span><span>to_mset_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>empty_rep</span><span> </span><span>BinomialHeapStruc.findMin_correct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>deleteMin_correct</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q≠empty"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"to_mset (deleteMin q) = to_mset q - {# findMin q #}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>findMin_def</span><span> </span><span>deleteMin_def</span><span> </span><span>to_mset_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>empty_rep</span><span> </span><span>BinomialHeapStruc.deleteMin_correct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>meld_correct</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"to_mset (meld q q') = to_mset q + to_mset q'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>to_mset_def</span><span> </span><span>meld_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>BinomialHeapStruc.meld_correct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Correctness lemmas to be used with simplifier›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>correct</span><span> </span><span class="delimiter">=</span><span> </span><span>empty_correct</span><span> </span><span>deleteMin_correct</span><span> </span><span>meld_correct</span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>BinomialHeap</span><span class="delimiter">:</span><span> </span><span>BinomialHeap_loc</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  
</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Documentation"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*#DOC
  fun [no_spec] BinomialHeap.to_mset
    Abstraction to multiset.

  fun BinomialHeap.empty
    The empty heap. ($O(1)$)

  fun BinomialHeap.isEmpty
    Checks whether heap is empty. Mainly used to work around 
    code-generation issues. ($O(1)$)

  fun BinomialHeap.insert
    Inserts element ($O(\log(n))$)

  fun BinomialHeap.findMin
    Returns a minimal element ($O(\log(n))$)

  fun BinomialHeap.deleteMin
    Deletes {\em the} element that is returned by {\em find\_min}

  fun [long_type] BinomialHeap.meld
    Melds two heaps ($O(\log(n+m))$)

*)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
    \underline{@{term_type "BinomialHeap.to_mset"}}\\
        Abstraction to multiset.\\


    \underline{@{term_type "BinomialHeap.empty"}}\\
        The empty heap. ($O(1)$)\\
    {\bf Spec} ‹BinomialHeap.empty_correct›:
    @{thm [display] BinomialHeap.empty_correct[no_vars]}


    \underline{@{term_type "BinomialHeap.isEmpty"}}\\
        Checks whether heap is empty. Mainly used to work around
    code-generation issues. ($O(1)$)\\
    {\bf Spec} ‹BinomialHeap.isEmpty_correct›:
    @{thm [display] BinomialHeap.isEmpty_correct[no_vars]}


    \underline{@{term_type "BinomialHeap.insert"}}\\
        Inserts element ($O(\log(n))$)\\
    {\bf Spec} ‹BinomialHeap.insert_correct›:
    @{thm [display] BinomialHeap.insert_correct[no_vars]}


    \underline{@{term_type "BinomialHeap.findMin"}}\\
        Returns a minimal element ($O(\log(n))$)\\
    {\bf Spec} ‹BinomialHeap.findMin_correct›:
    @{thm [display] BinomialHeap.findMin_correct[no_vars]}


    \underline{@{term_type "BinomialHeap.deleteMin"}}\\
        Deletes {\em the} element that is returned by {\em find\_min}\\
    {\bf Spec} ‹BinomialHeap.deleteMin_correct›:
    @{thm [display] BinomialHeap.deleteMin_correct[no_vars]}


    \underline{@{term "BinomialHeap.meld"}}
    @{term_type [display] "BinomialHeap.meld"}
        Melds two heaps ($O(\log(n+m))$)\\
    {\bf Spec} ‹BinomialHeap.meld_correct›:
    @{thm [display] BinomialHeap.meld_correct[no_vars]}

›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="SkewBinomialHeap">
<div class="head"><h1>Theory SkewBinomialHeap</h1>
<span class="command">theory</span> <span class="name">SkewBinomialHeap</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL-Library/Multiset.html"><span class="name">Multiset</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Skew Binomial Heaps"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>SkewBinomialHeap</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span> </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Multiset"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Skew Binomial Queues as specified by Brodal and Okasaki \cite{BrOk96}
  are a data structure for priority queues with worst case O(1) {\em findMin}, 
  {\em insert}, and {\em meld} operations, and worst-case logarithmic 
  {\em deleteMin} operation.
  They are derived from priority queues in three steps:
    \begin{enumerate}
      \item Skew binomial trees are used to eliminate the possibility of 
            cascading links during insert operations. This reduces the complexity
            of an insert operation to $O(1)$.
      \item The current minimal element is cached. This approach, known as 
            {\em global root}, reduces the cost of a {\em findMin}-operation to
            O(1).
      \item By allowing skew binomial queues to contain skew binomial queues,
            the cost for meld-operations is reduced to $O(1)$. This approach
            is known as {\em data-structural bootstrapping}.
    \end{enumerate}

  In this theory, we combine Steps~2 and 3, i.e. we first implement skew binomial
  queues, and then bootstrap them. The bootstrapping implicitly introduces a 
  global root, such that we also get a constant time findMin operation.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>SkewBinomialHeapStruc_loc</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Datatype"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'e</span><span class="delimiter">,</span><span> </span><span class="tfree">'a</span><span class="delimiter">)</span><span> </span><span>SkewBinomialTree</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span>Node</span><span> </span><span class="delimiter">(</span><span>val</span><span class="delimiter">:</span><span> </span><span class="tfree">'e</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>prio</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::linorder"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>rank</span><span class="delimiter">:</span><span> </span><span>nat</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>children</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e , 'a) SkewBinomialTree list"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'e</span><span class="delimiter">,</span><span> </span><span class="tfree">'a</span><span class="delimiter">)</span><span> </span><span>SkewBinomialQueue</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'a::linorder) SkewBinomialTree list"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Abstraction to Multisets"</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Returns a multiset with all (element, priority) pairs from a queue›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>tree_to_multiset</span><span> 
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'a::linorder) SkewBinomialTree ⇒ ('e × 'a) multiset"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>queue_to_multiset</span><span> 
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'a::linorder) SkewBinomialQueue ⇒ ('e × 'a) multiset"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_to_multiset (Node e a r ts) = {#(e,a)#} + queue_to_multiset ts"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"queue_to_multiset [] = {#}"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"queue_to_multiset (t#q) = tree_to_multiset t + queue_to_multiset q"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ttm_children</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_to_multiset t = 
  {#(val t,prio t)#} + queue_to_multiset (children t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*lemma qtm_cons[simp]: "queue_to_multiset (t#q)
  = queue_to_multiset q + tree_to_multiset t"
  apply(induct q arbitrary: t)
  apply simp
  apply(auto simp add: union_ac)
done*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>qtm_conc</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_to_multiset (q@q') 
  = queue_to_multiset q + queue_to_multiset q'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>q</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>union_ac</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Invariant"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Link two trees of rank $r$ to a new tree of rank $r+1$›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span>  </span><span>link</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'a::linorder) SkewBinomialTree ⇒ ('e, 'a) SkewBinomialTree ⇒ 
  ('e, 'a) SkewBinomialTree"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"link (Node e1 a1 r1 ts1) (Node e2 a2 r2 ts2) = 
   (if  a1≤a2 
     then (Node e1 a1 (Suc r1) ((Node e2 a2 r2 ts2)#ts1))
     else (Node e2 a2 (Suc r2) ((Node e1 a1 r1 ts1)#ts2)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Link two trees of rank $r$ and a new element to a new tree of 
  rank $r+1$›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>skewlink</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'e ⇒ 'a::linorder ⇒ ('e, 'a) SkewBinomialTree ⇒ 
  ('e, 'a) SkewBinomialTree ⇒ ('e, 'a) SkewBinomialTree"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"skewlink e a t t' = (if a ≤ (prio t) ∧ a ≤ (prio t')
  then (Node e a (Suc (rank t)) [t,t'])
  else (if (prio t) ≤ (prio t') 
   then 
    Node (val t)  (prio t)  (Suc (rank t))  (Node e a 0 [] # t' # children t)
   else 
    Node (val t') (prio t') (Suc (rank t')) (Node e a 0 [] # t # children t')))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  The invariant for trees claims that a tree labeled rank $0$ has no children, 
  and a tree labeled rank $r + 1$ is the result of an ordinary link or 
  a skew link of two trees with rank $r$.›</span></span></span><span>
</span><span class="keyword1"><span class="command">function</span></span><span> </span><span>tree_invar</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'a::linorder) SkewBinomialTree ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_invar (Node e a 0 ts) = (ts = [])"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_invar (Node e a (Suc r) ts) = (∃ e1 a1 ts1 e2 a2 ts2 e' a'. 
  tree_invar (Node e1 a1 r ts1) ∧ tree_invar (Node e2 a2 r ts2) ∧ 
  ((Node e a (Suc r) ts) = link (Node e1 a1 r ts1) (Node e2 a2 r ts2) ∨ 
   (Node e a (Suc r) ts) = skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>pat_completeness</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">termination</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>relation</span><span> </span><span class="string"><span class="delete"><span class="delete">"measure rank"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A heap satisfies the invariant, if all contained trees satisfy the 
  invariant, the ranks of the trees in the heap are distinct, except that the
  first two trees may have same rank, and the ranks are ordered in ascending 
  order.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹First part: All trees inside the queue satisfy the invariant.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>queue_invar</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'a::linorder) SkewBinomialQueue ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"queue_invar q ≡ (∀t ∈ set q. tree_invar t)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>queue_invar_simps</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"queue_invar []"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"queue_invar (t#q) ⟷ tree_invar t ∧ queue_invar q"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"queue_invar (q@q') ⟷ queue_invar q ∧ queue_invar q'"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"queue_invar q ⟹ t∈set q ⟹ tree_invar t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>queue_invar_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Second part: The ranks of the trees in the heap are distinct, 
  except that the first two trees may have same rank, and the ranks are 
  ordered in ascending order.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹For tail of queue›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>rank_invar</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'a::linorder) SkewBinomialQueue ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rank_invar [] = True"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rank_invar [t] = True"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rank_invar (t # t' # bq) = (rank t &lt; rank t' ∧ rank_invar (t' # bq))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹For whole queue: First two elements may have same rank›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>rank_skew_invar</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'a::linorder) SkewBinomialQueue ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rank_skew_invar [] = True"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rank_skew_invar [t] = True"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rank_skew_invar (t # t' # bq) = ((rank t ≤ rank t') ∧ rank_invar (t' # bq))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>tail_invar</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'a::linorder) SkewBinomialQueue ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tail_invar bq = (queue_invar bq ∧ rank_invar bq)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>invar</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'a::linorder) SkewBinomialQueue ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"invar bq = (queue_invar bq ∧ rank_skew_invar bq)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>invar_empty</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"invar []"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tail_invar []"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>invar_def</span><span> </span><span>tail_invar_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>invar_tail_invar</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"invar (t # bq) ⟹ tail_invar bq"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>invar_def</span><span> </span><span>tail_invar_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>bq</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>link_mset</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_to_multiset (link t1 t2) 
                  = tree_to_multiset t1 +tree_to_multiset t2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t1</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span>t2</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>union_ac</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>link_tree_invar</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦tree_invar t1; tree_invar t2; rank t1 = rank t2⟧ ⟹
  tree_invar (link t1 t2)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t1</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span>t2</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>skewlink_mset</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_to_multiset (skewlink e a t1 t2) 
  = {# (e,a) #} +  tree_to_multiset t1 + tree_to_multiset t2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t1</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span>t2</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>union_ac</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>skewlink_tree_invar</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦tree_invar t1; tree_invar t2; rank t1 = rank t2⟧ ⟹ 
  tree_invar (skewlink e a t1 t2)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t1</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span>t2</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rank_link</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank t = rank t' ⟹ rank (link t t') = rank t + 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rank_skew_rank_invar</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank_skew_invar (t # bq) ⟹ rank_invar bq"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>bq</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rank_invar_rank_skew</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rank_invar q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rank_skew_invar q"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>q</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>_</span><span> </span><span>list</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>list</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rank_invar_cons_up</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦rank_invar (t # bq); rank t' &lt; rank t⟧ ⟹ rank_invar (t' # t # bq)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rank_skew_cons_up</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦rank_invar (t # bq); rank t' ≤ rank t⟧ ⟹ rank_skew_invar (t' # t # bq)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rank_invar_cons_down</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank_invar (t # bq) ⟹ rank_invar bq"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>bq</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rank_invar_hd_cons</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦rank_invar bq; rank t &lt; rank (hd bq)⟧ ⟹ rank_invar (t # bq)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>bq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tail_invar_cons_up</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦tail_invar (t # bq); rank t' &lt; rank t; tree_invar t'⟧ 
  ⟹ tail_invar (t' # t # bq)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tail_invar_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>bq</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tail_invar_cons_up_invar</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦tail_invar (t # bq); rank t' ≤ rank t; tree_invar t'⟧ ⟹ invar (t' # t # bq)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>bq</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>invar_def</span><span> </span><span>tail_invar_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tail_invar_cons_down</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tail_invar (t # bq) ⟹ tail_invar bq"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tail_invar_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>bq</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tail_invar_app_single</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦tail_invar bq; ∀t ∈ set bq. rank t &lt; rank t'; tree_invar t'⟧ 
    ⟹ tail_invar (bq @ [t'])"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>bq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>tail_invar_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>bq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹tail_invar (a # bq)›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tail_invar bq"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>tail_invar_cons_down</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tail_invar (bq @ [t'])"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>bq</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>tail_invar_cons_up</span><span> </span><span>tail_invar_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>invar_app_single</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦invar bq; ∀t ∈ set bq. rank t &lt; rank t'; tree_invar t'⟧ 
   ⟹ invar (bq @ [t'])"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>bq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>invar_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>bq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>bq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>invar_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Cons'</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>ta</span><span> </span><span>qa</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tail_invar bq"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>invar_tail_invar</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀t∈set bq. rank t &lt; rank t'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>tail_invar_app_single</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"bq"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t'"</span></span></span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tail_invar (bq @ [t'])"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons</span><span> </span><span>Cons'</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>tail_invar_cons_up_invar</span><span> </span><span>invar_def</span><span> </span><span>tail_invar_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>invar_children</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar ((Node e a r ts)::(('e, 'a::linorder) SkewBinomialTree))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_invar ts"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>r</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>e</span><span> </span><span>a</span><span> </span><span>ts</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>r</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Suc</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>e1</span><span> </span><span>a1</span><span> </span><span>ts1</span><span> </span><span>e2</span><span> </span><span>a2</span><span> </span><span>ts2</span><span> </span><span>e'</span><span> </span><span>a'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>  
</span><span>    </span><span>inv_t1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar (Node e1 a1 r ts1)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>inv_t2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar (Node e2 a2 r ts2)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>link_or_skew</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"((Node e a (Suc r) ts) = link (Node e1 a1 r ts1) (Node e2 a2 r ts2)
    ∨ (Node e a (Suc r) ts) 
       = skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>tree_invar.simps</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Suc</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv_t1</span><span class="delimiter">]</span><span> </span><span>inv_t2</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>case1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_invar ((Node e2 a2 r ts2) # ts1)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Suc</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv_t2</span><span class="delimiter">]</span><span> </span><span>inv_t1</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>case2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_invar ((Node e1 a1 r ts1) # ts2)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Node e a (Suc r) ts) = link (Node e1 a1 r ts1) (Node e2 a2 r ts2)"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ts =
     (if a1 ≤ a2 
      then (Node e2 a2 r ts2) # ts1 
      else (Node e1 a1 r ts1) # ts2)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>case1</span><span> </span><span>case2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>link_or_skew</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Node e a (Suc r) ts = 
      skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ts =
     (if a' ≤ a1 ∧ a' ≤ a2
      then [(Node e1 a1 r ts1),(Node e2 a2 r ts2)]
      else (if a1 ≤ a2 
        then (Node e' a' 0 []) # (Node e2 a2 r ts2) # ts1
        else (Node e' a' 0 []) # (Node e1 a1 r ts1) # ts2))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>case1</span><span> </span><span>case2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Heap Order"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>heap_ordered</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'a::linorder) SkewBinomialTree ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"heap_ordered (Node e a r ts) 
   = (∀x ∈ set_mset (queue_to_multiset ts). a ≤ snd x)"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The invariant for trees implies heap order.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tree_invar_heap_ordered</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>t</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'a::linorder) SkewBinomialTree"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"heap_ordered t"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Node</span><span> </span><span>e</span><span> </span><span>a</span><span> </span><span>nat</span><span> </span><span>list</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>nat</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span> </span><span>e</span><span> </span><span>a</span><span> </span><span>list</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>nat</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Suc</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t1</span><span> </span><span>e1</span><span> </span><span>a1</span><span> </span><span>ts1</span><span> </span><span>t2</span><span> </span><span>e2</span><span> </span><span>a2</span><span> </span><span>ts2</span><span> </span><span>e'</span><span> </span><span>a'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>      </span><span>inv_t1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar t1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>inv_t2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar t2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>      </span><span>link_or_skew</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t = link t1 t2 ∨ t = skewlink e' a' t1 t2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>      </span><span>eq_t1</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t1 = (Node e1 a1 nat ts1)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>      </span><span>eq_t2</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t2 = (Node e2 a2 nat ts2)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>tree_invar.simps</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>heap_t1</span><span> </span><span class="delimiter">=</span><span> </span><span>Suc</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv_t1</span><span> </span><span>eq_t1</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>heap_t2</span><span> </span><span class="delimiter">=</span><span> </span><span>Suc</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv_t2</span><span> </span><span>eq_t2</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>link_or_skew</span><span> </span><span>heap_t1</span><span> </span><span>heap_t2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"t = link t1 t2"</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(***********************************************************)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(***********************************************************)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Height and Length"</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Although complexity of HOL-functions cannot be expressed within 
  HOL, we can express the height and length of a binomial heap.
  By showing that both, height and length, are logarithmic in the number 
  of contained elements, we give strong evidence that our functions have
  logarithmic complexity in the number of elements.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Height of a tree and queue›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>height_tree</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, ('a::linorder)) SkewBinomialTree ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>height_queue</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, ('a::linorder)) SkewBinomialQueue ⇒ nat"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"height_tree (Node e a r ts) = height_queue ts"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"height_queue [] = 0"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"height_queue (t # ts) = max (Suc (height_tree t)) (height_queue ts)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>link_length</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"size (tree_to_multiset (link t1 t2)) = 
  size (tree_to_multiset t1) + size (tree_to_multiset t2)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>t1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>t2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tree_rank_estimate_upper</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_invar (Node e a r ts) ⟹ 
   size (tree_to_multiset (Node e a r ts)) ≤ (2::nat)^(Suc r) - 1"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>r</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>e</span><span> </span><span>a</span><span> </span><span>ts</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>r</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Suc</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>e1</span><span> </span><span>a1</span><span> </span><span>ts1</span><span> </span><span>e2</span><span> </span><span>a2</span><span> </span><span>ts2</span><span> </span><span>e'</span><span> </span><span>a'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>link</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"(Node e a (Suc r) ts) = link (Node e1 a1 r ts1) (Node e2 a2 r ts2) ∨
       (Node e a (Suc r) ts) = skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar (Node e1 a1 r ts1)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar (Node e2 a2 r ts2)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>iv1</span><span> </span><span class="delimiter">=</span><span> </span><span>Suc</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>iv2</span><span> </span><span class="delimiter">=</span><span> </span><span>Suc</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv2</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(2::nat)^r - 1 + (2::nat)^r - 1 ≤ (2::nat)^(Suc r) - 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>link</span><span> </span><span>Suc</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2)"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>iv1</span><span> </span><span>iv2</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>link.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>iv1</span><span> </span><span>iv2</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>skewlink.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tree_rank_estimate_lower</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_invar (Node e a r ts) ⟹ 
   size (tree_to_multiset (Node e a r ts)) ≥ (2::nat)^r"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>r</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>e</span><span> </span><span>a</span><span> </span><span>ts</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>r</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Suc</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>e1</span><span> </span><span>a1</span><span> </span><span>ts1</span><span> </span><span>e2</span><span> </span><span>a2</span><span> </span><span>ts2</span><span> </span><span>e'</span><span> </span><span>a'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>link</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"(Node e a (Suc r) ts) = link (Node e1 a1 r ts1) (Node e2 a2 r ts2) ∨
       (Node e a (Suc r) ts) = skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar (Node e1 a1 r ts1)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar (Node e2 a2 r ts2)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>iv1</span><span> </span><span class="delimiter">=</span><span> </span><span>Suc</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>iv2</span><span> </span><span class="delimiter">=</span><span> </span><span>Suc</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv2</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(2::nat)^r - 1 + (2::nat)^r - 1 ≤ (2::nat)^(Suc r) - 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>link</span><span> </span><span>Suc</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2)"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>iv1</span><span> </span><span>iv2</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>link.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>iv1</span><span> </span><span>iv2</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>skewlink.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tree_rank_height</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_invar (Node e a r ts) ⟹ height_tree (Node e a r ts) = r"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>r</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>e</span><span> </span><span>a</span><span> </span><span>ts</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>r</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Suc</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>e1</span><span> </span><span>a1</span><span> </span><span>ts1</span><span> </span><span>e2</span><span> </span><span>a2</span><span> </span><span>ts2</span><span> </span><span>e'</span><span> </span><span>a'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>link</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"(Node e a (Suc r) ts) = link (Node e1 a1 r ts1) (Node e2 a2 r ts2) ∨
       (Node e a (Suc r) ts) = skewlink e' a' (Node e1 a1 r ts1) (Node e2 a2 r ts2)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar (Node e1 a1 r ts1)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar (Node e2 a2 r ts2)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>iv1</span><span> </span><span class="delimiter">=</span><span> </span><span>Suc</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>iv2</span><span> </span><span class="delimiter">=</span><span> </span><span>Suc</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv2</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Suc</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>link</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"Node e a (Suc r) ts = link (Node e1 a1 r ts1) (Node e2 a2 r ts2)"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"a1 ≤ a2"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>iv1</span><span> </span><span>iv2</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>iv1</span><span> </span><span>iv2</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"a' ≤ a1 ∧ a' ≤ a2"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>height_tree.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>iv1</span><span> </span><span>iv2</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"a1 ≤ a2"</span></span></span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>iv1</span><span> </span><span>iv2</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>tree_invar.simps</span><span> </span><span>link.simps</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>iv1</span><span> </span><span>iv2</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>tree_invar.simps</span><span> </span><span>link.simps</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A skew binomial tree of height $h$ contains at most  $2^{h+1} - 1$
  elements›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>tree_height_estimate_upper</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_invar t ⟹ 
  size (tree_to_multiset t) ≤ (2::nat)^(Suc (height_tree t)) - 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>tree_rank_estimate_upper</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>tree_rank_height</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A skew binomial tree of height $h$ contains at least  $2^{h}$ elements›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>tree_height_estimate_lower</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_invar t ⟹ size (tree_to_multiset t) ≥ (2::nat)^(height_tree t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>tree_rank_estimate_lower</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>tree_rank_height</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>size_mset_tree_upper</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar t ⟹ 
  size (tree_to_multiset t) ≤ (2::nat)^(Suc (rank t)) - (1::nat)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>tree_rank_estimate_upper</span><span> </span><span>SkewBinomialTree.sel</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>size_mset_tree_lower</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar t ⟹ 
  size (tree_to_multiset t) ≥ (2::nat)^(rank t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>tree_rank_estimate_lower</span><span> </span><span>SkewBinomialTree.sel</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span> 
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>invar_butlast</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar (bq @ [t]) ⟹ invar bq"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>invar_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>bq</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>bq</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>list</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>invar_last_max</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"invar ((b#b'#bq) @ [m]) ⟹ ∀ t ∈ set (b'#bq). rank t &lt; rank m"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>invar_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>bq</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>bq</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>invar_last_max'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar ((b#b'#bq) @ [m]) ⟹ rank b ≤ rank b'"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>invar_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>invar_length</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar bq ⟹ length bq ≤ Suc (Suc (rank (last bq)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>bq</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>snoc</span><span> </span><span>x</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>xxs</span><span> </span><span>xx</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>Cons'</span><span> </span><span class="delimiter">=</span><span> </span><span>Cons</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xx</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>snoc.prems</span><span> </span><span>Cons</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>xxxs</span><span> </span><span>xxx</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>snoc.hyps</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invar_butlast</span><span class="delimiter">[</span><span>OF</span><span> </span><span>snoc.prems</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>        </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length xs ≤ Suc (Suc (rank (last xs)))"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>invar_last_max</span><span class="delimiter">[</span><span>OF</span><span> </span><span>snoc.prems</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>Cons'</span><span> </span><span>Cons</span><span class="delimiter">]</span><span class="delimiter">]</span><span> 
</span><span>                </span><span>invar_last_max'</span><span class="delimiter">[</span><span>OF</span><span> </span><span>snoc.prems</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>Cons'</span><span> </span><span>Cons</span><span class="delimiter">]</span><span class="delimiter">]</span><span> 
</span><span>                </span><span>last_in_set</span><span class="delimiter">[</span><span>of</span><span> </span><span>xs</span><span class="delimiter">]</span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"Suc (rank (last xs)) ≤ rank (last (xs @ [x]))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>size_queue_sum_list</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"size (queue_to_multiset bq) = sum_list (map (size ∘ tree_to_multiset) bq)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>bq</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  A skew binomial heap of length $l$ contains at least $2^{l-1} - 1$ elements. 
›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>queue_length_estimate_lower</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"invar bq ⟹ (size (queue_to_multiset bq)) ≥ 2^(length bq - 1) - 1"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>bq</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>snoc</span><span> </span><span>x</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>xx</span><span> </span><span>xxs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>snoc.hyps</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invar_butlast</span><span class="delimiter">[</span><span>OF</span><span> </span><span>snoc.prems</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"2 ^ (length xs - 1) ≤ Suc (size (queue_to_multiset xs))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>size_q</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"size (queue_to_multiset (xs @ [x])) = 
      size (queue_to_multiset xs) + size (tree_to_multiset x)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>size_queue_sum_list</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>snoc.prems</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inv_x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>invar_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>size_mset_tree_lower</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 ^ (rank x) ≤ size (tree_to_multiset x)"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>      </span><span>eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"size (queue_to_multiset xs) + (2::nat)^(rank x) ≤ 
      size (queue_to_multiset (xs @ [x]))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>invar_length</span><span class="delimiter">[</span><span>OF</span><span> </span><span>snoc.prems</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length xs ≤ (rank x + 1)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>snd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(2::nat) ^ (length xs - 1) ≤ (2::nat) ^ ((rank x))"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>power.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"(2::nat) ^ (length (xs @ [x]) - 1) = 
      (2::nat) ^ (length xs - 1) + (2::nat) ^ (length xs - 1)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>IH</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"2 ^ (length (xs @ [x]) - 1) ≤ 
      Suc (size (queue_to_multiset xs)) + 2 ^ (length xs - 1)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>snd</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 ^ (length (xs @ [x]) - 1) ≤ 
      Suc (size (queue_to_multiset xs)) + 2 ^ rank x"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>arith</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>eq</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Operations"</span></span></span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Empty Tree"</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>empty_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"q=Nil ⟷ queue_to_multiset q = {#}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>q</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Insert"</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Inserts a tree into the queue, such that two trees of same rank get 
  linked and are recursively inserted. This is the same definition as for 
  binomial queues and is used for melding.›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>ins</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'a::linorder) SkewBinomialTree ⇒ ('e, 'a) SkewBinomialQueue ⇒ 
  ('e, 'a) SkewBinomialQueue"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ins t [] = [t]"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ins t' (t # bq) =
    (if (rank t') &lt; (rank t) 
      then t' # t # bq 
      else (if (rank t) &lt; (rank t')
        then t # (ins t' bq) 
        else ins (link t' t) bq))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Insert an element with priority into a queue using skewlinks.›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>insert</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'e ⇒ 'a::linorder ⇒ ('e, 'a) SkewBinomialQueue ⇒ 
  ('e, 'a) SkewBinomialQueue"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"insert e a [] = [Node e a 0 []]"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"insert e a [t] = [Node e a 0 [],t]"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"insert e a (t # t' # bq) =
    (if rank t ≠ rank t' 
      then (Node e a 0 []) # t # t' # bq
      else (skewlink e a t t') # bq)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ins_mset</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦tree_invar t; queue_invar q⟧ ⟹
   queue_to_multiset (ins t q) = tree_to_multiset t + queue_to_multiset q"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>q</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>union_ac</span><span> </span><span>link_tree_invar</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>insert_mset</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_invar q ⟹ 
  queue_to_multiset (insert e a q) = 
  queue_to_multiset q + {# (e,a) #}"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>q</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>insert.induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>union_ac</span><span> </span><span>ttm_children</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ins_queue_invar</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦tree_invar t; queue_invar q⟧ ⟹ queue_invar (ins t q)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>q</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>q</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>iv</span><span> </span><span class="delimiter">=</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank t &lt; rank a"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank t = rank a"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>iv</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"t"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>goal_cases</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>prems</span><span class="delimiter">:</span><span> </span><span>1</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inv_a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inv_q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_invar q"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>inv_link</span><span> </span><span class="delimiter">=</span><span> </span><span>link_tree_invar</span><span class="delimiter">[</span><span>OF</span><span> </span><span>prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>inv_a</span><span> </span><span>prems</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>iv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv_link</span><span> </span><span>inv_q</span><span class="delimiter">]</span><span> </span><span>prems</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>insert_queue_invar</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_invar q ⟹ queue_invar (insert e a q)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>q</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>insert.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>2</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>3</span><span> </span><span>e</span><span> </span><span>a</span><span> </span><span>t</span><span> </span><span>t'</span><span> </span><span>bq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank t = rank t'"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>3</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>3</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inv_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>3</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inv_t'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar t'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>3</span><span> </span><span>skewlink_tree_invar</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv_t</span><span> </span><span>inv_t'</span><span> </span><span>True</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>e</span><span> </span><span>a</span><span class="delimiter">]</span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rank_ins2</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rank_invar bq ⟹ 
    rank t ≤ rank (hd (ins t bq)) 
    ∨ (rank (hd (ins t bq)) = rank (hd bq) ∧ bq ≠ [])"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>bq</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>goal_cases</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>prems</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>a</span><span> </span><span>bq</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank (link t a) = rank a + 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rank_link</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>prems</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(link t a)"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>bq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>insert_rank_invar</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank_skew_invar q ⟹ rank_skew_invar (insert e a q)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>q</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span> </span><span>q'</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rank_skew_invar q"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q = t # q'"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rank_skew_invar (insert e a q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"q'"</span></span></span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>gr0I</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t'</span><span> </span><span>q''</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rank_skew_invar q"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q = t # q'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q' = t' # q''"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rank_skew_invar (insert e a q)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank t = rank t'"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>gr0I</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>skewlink.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>goal_cases</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>prems</span><span class="delimiter">:</span><span> </span><span>1</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>rank_invar_cons_down</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"t'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q'"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rank_invar q'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>q''</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>t''</span><span> </span><span>q'''</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>prems</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rank t' &lt; rank t''"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>prems</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rank (skewlink e a t t') ≤ rank t''"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>prems</span><span> </span><span>Cons</span><span> </span><span>rank_skew_cons_up</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"t''"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q'''"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"skewlink e a t t'"</span></span></span><span class="delimiter">]</span><span> 
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>insert_invar</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar q ⟹ invar (insert e a q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>invar_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>insert_queue_invar</span><span class="delimiter">[</span><span>of</span><span> </span><span>q</span><span class="delimiter">]</span><span> </span><span>insert_rank_invar</span><span class="delimiter">[</span><span>of</span><span> </span><span>q</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>insert_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>I</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"invar (insert e a q)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"queue_to_multiset (insert e a q) = queue_to_multiset q + {# (e,a) #}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>insert_mset</span><span class="delimiter">[</span><span>of</span><span> </span><span>q</span><span class="delimiter">]</span><span> </span><span>insert_invar</span><span class="delimiter">[</span><span>of</span><span> </span><span>q</span><span class="delimiter">]</span><span> </span><span>I</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>invar_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"meld"</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Remove duplicate tree ranks by inserting the first tree of the 
  queue into the rest of the queue.›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>uniqify</span><span> 
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'a::linorder) SkewBinomialQueue ⇒ ('e, 'a) SkewBinomialQueue"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"uniqify [] = []"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"uniqify (t#bq) = ins t bq"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Meld two uniquified queues using the same definition as for 
  binomial queues.›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>meldUniq</span><span> 
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'a::linorder) SkewBinomialQueue ⇒ ('e,'a) SkewBinomialQueue ⇒
  ('e, 'a) SkewBinomialQueue"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"meldUniq [] bq = bq"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"meldUniq bq [] = bq"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"meldUniq (t1#bq1) (t2#bq2) = (if rank t1 &lt; rank t2 
       then t1 # (meldUniq bq1 (t2#bq2))
       else (if rank t2 &lt; rank t1
              then t2 # (meldUniq (t1#bq1) bq2)
              else ins (link t1 t2) (meldUniq bq1 bq2)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Meld two queues using above functions.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>meld</span><span> 
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'a::linorder) SkewBinomialQueue ⇒ ('e, 'a) SkewBinomialQueue ⇒ 
      ('e, 'a) SkewBinomialQueue"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"meld bq1 bq2 = meldUniq (uniqify bq1) (uniqify bq2)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>invar_uniqify</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_invar q ⟹ queue_invar (uniqify q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>q</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ins_queue_invar</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>invar_meldUniq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦queue_invar q; queue_invar q'⟧ ⟹ queue_invar (meldUniq q q')"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>q</span><span> </span><span>q'</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>meldUniq.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>2</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>3</span><span> </span><span>t1</span><span> </span><span>bq1</span><span> </span><span>t2</span><span> </span><span>bq2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">consider</span></span><span> </span><span class="delimiter">(</span><span>lt</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank t1 &lt; rank t2"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="delimiter">(</span><span>gt</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank t1 &gt; rank t2"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="delimiter">(</span><span>eq</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank t1 = rank t2"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>atomize_elim</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>t1t2</span><span class="delimiter">:</span><span> </span><span>lt</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>3</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inv_bq1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_invar bq1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>3</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inv_t1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar t1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>3</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t1t2</span><span> </span><span>inv_bq1</span><span> </span><span>3</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>inv_t1</span><span> </span><span>t1t2</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>t1t2</span><span class="delimiter">:</span><span> </span><span>gt</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>3</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inv_bq2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_invar bq2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>3</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inv_t2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar t2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>t1t2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ rank t1 &lt; rank t2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>3</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span> </span><span>t1t2</span><span> </span><span>3</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>inv_bq2</span><span class="delimiter">]</span><span> </span><span>inv_t2</span><span> </span><span>t1t2</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>t1t2</span><span class="delimiter">:</span><span> </span><span>eq</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>3</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inv_bq1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_invar bq1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>3</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inv_t1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar t1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>3</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inv_bq2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_invar bq2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>3</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inv_t2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar t2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>inv_link</span><span> </span><span class="delimiter">=</span><span> </span><span>link_tree_invar</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv_t1</span><span> </span><span>inv_t2</span><span> </span><span>t1t2</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>t1t2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ rank t1 &lt; rank t2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ rank t2 &lt; rank t1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>inv_meld</span><span> </span><span class="delimiter">=</span><span> </span><span>3</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span> </span><span>inv_bq1</span><span> </span><span>inv_bq2</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ins_queue_invar</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv_link</span><span> </span><span>inv_meld</span><span class="delimiter">]</span><span> </span><span>t1t2</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>meld_queue_invar</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_invar q"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_invar q'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_invar (meld q q')"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>inv_uniq_q</span><span> </span><span class="delimiter">=</span><span> </span><span>invar_uniqify</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>inv_uniq_q'</span><span> </span><span class="delimiter">=</span><span> </span><span>invar_uniqify</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>inv_meldUniq</span><span> </span><span class="delimiter">=</span><span> </span><span>invar_meldUniq</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv_uniq_q</span><span> </span><span>inv_uniq_q'</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>meld_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uniqify_mset</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_invar q ⟹ queue_to_multiset q = queue_to_multiset (uniqify q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>q</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ins_mset</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>meldUniq_mset</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦queue_invar q; queue_invar q'⟧ ⟹ 
  queue_to_multiset (meldUniq q q') = 
  queue_to_multiset q + queue_to_multiset q'"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>q</span><span> </span><span>q'</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>meldUniq.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ins_mset</span><span> </span><span>link_tree_invar</span><span> </span><span>invar_meldUniq</span><span> </span><span>union_ac</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>meld_mset</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ queue_invar q; queue_invar q' ⟧ ⟹
  queue_to_multiset (meld q q') = queue_to_multiset q + queue_to_multiset q'"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>meld_def</span><span> </span><span>meldUniq_mset</span><span> </span><span>invar_uniqify</span><span> </span><span>uniqify_mset</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ins operation satisfies rank invariant, see binomial queues›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rank_ins</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank_invar bq ⟹ rank_invar (ins t bq)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>bq</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>bq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>goal_cases</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>prems</span><span class="delimiter">:</span><span> </span><span>1</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank_invar (ins t bq)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>bq</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>prems</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>hd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bq ≠ [] ⟹ rank a &lt; rank (hd bq)"</span></span></span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>bq</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>prems</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rank t ≤ rank (hd (ins t bq)) 
                     ∨ (rank (hd (ins t bq)) = rank (hd bq) ∧ bq ≠ [])"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>rank_ins2</span><span> </span><span>rank_invar_cons_down</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>prems</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rank a &lt; rank (hd (ins t bq)) 
      ∨ (rank (hd (ins t bq)) = rank (hd bq) ∧ bq ≠ [])"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>prems</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hd</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rank_invar_hd_cons</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>prems</span><span class="delimiter">:</span><span> </span><span>2</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank_invar bq"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>bq</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>prems</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(link t a)"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>     
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rank_uniqify</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rank_skew_invar q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rank_invar (uniqify q)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>q</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>list</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>rank_skew_rank_invar</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"a"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"list"</span></span></span><span class="delimiter">]</span><span> </span><span>rank_ins</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"list"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a"</span></span></span><span class="delimiter">]</span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rank_ins_min</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank_invar bq ⟹ rank (hd (ins t bq)) ≥ min (rank t) (rank (hd bq))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>bq</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>bq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>goal_cases</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>prems</span><span class="delimiter">:</span><span> </span><span>1</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank_invar bq"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>bq</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>prems</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank (link t a) = rank a + 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rank_link</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>prems</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(link t a)"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>bq</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rank_invar_not_empty_hd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦rank_invar (t # bq); bq ≠ []⟧ ⟹ rank t &lt; rank (hd bq)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>bq</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rank_invar_meldUniq_strong</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦rank_invar bq1; rank_invar bq2⟧ ⟹ 
    rank_invar (meldUniq bq1 bq2) 
    ∧ rank (hd (meldUniq bq1 bq2)) ≥ min (rank (hd bq1)) (rank (hd bq2))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>bq1</span><span> </span><span>bq2</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>meldUniq.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>2</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>3</span><span> </span><span>t1</span><span> </span><span>bq1</span><span> </span><span>t2</span><span> </span><span>bq2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>3</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inv1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank_invar bq1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>bq1</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>3</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inv2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank_invar bq2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>bq2</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv2</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>3</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>goal_cases</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?t</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"t2"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?bq</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"bq2"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?meldUniq</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank t2 &lt; rank (hd (meldUniq (t1 # bq1) bq2))"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>prems</span><span class="delimiter">:</span><span> </span><span>1</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bq ≠ [] ⟹ rank ?t &lt; rank (hd ?bq)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rank_invar_not_empty_hd</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>prems</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ne</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?bq ≠ [] ⟹ ?meldUniq"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>prems</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bq = [] ⟹ ?meldUniq"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ne</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?meldUniq"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"?bq = []"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>prems</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rank_invar_hd_cons</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span> </span><span class="comment">― ‹analog›</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?t</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"t1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?bq</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"bq1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?meldUniq</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank t1 &lt; rank (hd (meldUniq bq1 (t2 # bq2)))"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>prems</span><span class="delimiter">:</span><span> </span><span>2</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bq ≠ [] ⟹ rank ?t &lt; rank (hd ?bq)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rank_invar_not_empty_hd</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>prems</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ne</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?bq ≠ [] ⟹ ?meldUniq"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>prems</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bq = [] ⟹ ?meldUniq"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ne</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?meldUniq"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"?bq = []"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>prems</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rank_invar_hd_cons</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>3</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rank_ins</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>prems</span><span class="delimiter">:</span><span> </span><span>4</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Ab hier wirds hässlich *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank (link t1 t2) = rank t2 + 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rank_link</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>m</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"meldUniq bq1 [] = bq1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>bq1</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv2</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prems</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>      </span><span>mm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"min (rank (hd bq1)) (rank (hd bq2)) ≤ rank (hd (meldUniq bq1 bq2))"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹rank_invar (t1 # bq1)›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bq1 ≠ [] ⟹ rank t1 &lt; rank (hd bq1)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rank_invar_not_empty_hd</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>prems</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>r1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bq1 ≠ [] ⟹ rank t2 &lt; rank (hd bq1)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹rank_invar (t2 # bq2)›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>r2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bq2 ≠ [] ⟹ rank t2 &lt; rank (hd bq2)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rank_invar_not_empty_hd</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv1</span><span> </span><span>r</span><span> </span><span>r1</span><span> </span><span>rank_ins_min</span><span class="delimiter">[</span><span>of</span><span> </span><span>bq1</span><span> </span><span class="string"><span class="delete"><span class="delete">"(link t1 t2)"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>      </span><span>abc1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bq1 ≠ [] ⟹ rank t2 ≤ rank (hd (ins (link t1 t2) bq1))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inv2</span><span> </span><span>r</span><span> </span><span>r2</span><span> </span><span>rank_ins_min</span><span class="delimiter">[</span><span>of</span><span> </span><span>bq2</span><span> </span><span class="string"><span class="delete"><span class="delete">"(link t1 t2)"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>      </span><span>abc2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bq2 ≠ [] ⟹ rank t2 ≤ rank (hd (ins (link t1 t2) bq2))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>r1</span><span> </span><span>r2</span><span> </span><span>mm</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"⟦bq1 ≠ []; bq2 ≠ []⟧ ⟹ rank t2 &lt; rank (hd (meldUniq bq1 bq2))"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹rank_invar (meldUniq bq1 bq2)›</span></span></span><span> </span><span>r</span><span> 
</span><span>      </span><span>rank_ins_min</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"meldUniq bq1 bq2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"link t1 t2"</span></span></span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦bq1 ≠ []; bq2 ≠ []⟧ ⟹ 
      rank t2 &lt; rank (hd (ins (link t1 t2) (meldUniq bq1 bq2)))"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>inv1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv2</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>r</span><span> </span><span>m</span><span> </span><span>r1</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"bq2 = []"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"bq1 = []"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>abc1</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"bq1 = []"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>abc2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rank_meldUniq</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦rank_invar bq1; rank_invar bq2⟧ ⟹ rank_invar (meldUniq bq1 bq2)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>rank_invar_meldUniq_strong</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rank_meld</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦rank_skew_invar q1; rank_skew_invar q2⟧ ⟹ rank_skew_invar (meld q1 q2)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>meld_def</span><span> </span><span>rank_meldUniq</span><span> </span><span>rank_uniqify</span><span> </span><span>rank_invar_rank_skew</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>meld_invar</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦invar bq1; invar bq2⟧ 
  ⟹ invar (meld bq1 bq2)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>meld_queue_invar</span><span> </span><span>rank_meld</span><span> </span><span>invar_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>meld_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>I</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar q"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invar q'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"invar (meld q q')"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"queue_to_multiset (meld q q') = queue_to_multiset q + queue_to_multiset q'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>meld_invar</span><span class="delimiter">[</span><span>of</span><span> </span><span>q</span><span> </span><span>q'</span><span class="delimiter">]</span><span> </span><span>meld_mset</span><span class="delimiter">[</span><span>of</span><span> </span><span>q</span><span> </span><span>q'</span><span class="delimiter">]</span><span> </span><span>I</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>invar_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Find Minimal Element"</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Find the tree containing the minimal element.›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>getMinTree</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'a::linorder) SkewBinomialQueue ⇒ 
  ('e, 'a) SkewBinomialTree"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"getMinTree [t] = t"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"getMinTree (t#bq) =
    (if prio t ≤ prio (getMinTree bq)
      then t
      else (getMinTree bq))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Find the minimal Element in the queue.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>findMin</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'a::linorder) SkewBinomialQueue ⇒ ('e × 'a)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"findMin bq = (let min = getMinTree bq in (val min, prio min))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mintree_exists</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(bq ≠ []) = (getMinTree bq ∈ set bq)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>bq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>_</span><span> </span><span>bq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>bq</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>treehead_in_multiset</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"t ∈ set bq ⟹ (val t, prio t) ∈# (queue_to_multiset bq)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>bq</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span>t</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>heap_ordered_single</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"heap_ordered t = (∀x ∈ set_mset (tree_to_multiset t). prio t ≤ snd x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>getMinTree_cons</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"prio (getMinTree (y # x # xs)) ≤ prio (getMinTree (x # xs))"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>getMinTree.induct</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>getMinTree_min_tree</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ set bq  ⟹ prio (getMinTree bq) ≤ prio t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>bq</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>getMinTree.induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">,</span><span> </span><span>fastforce</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>getMinTree_min_prio</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_invar bq"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ set_mset (queue_to_multiset bq)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prio (getMinTree bq) ≤ snd y"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bq ≠ []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>bq</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃t ∈ set bq. (y ∈ set_mset (tree_to_multiset t))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>bq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>bq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ set_mset (tree_to_multiset a)"</span></span></span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>bq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>O</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"t ∈ set bq"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"y ∈ set_mset ((tree_to_multiset t))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>e</span><span> </span><span>a</span><span> </span><span>r</span><span> </span><span>ts</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t = (Node e a r ts)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>O</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>tree_invar_heap_ordered</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv</span><span class="delimiter">]</span><span> </span><span>heap_ordered.simps</span><span class="delimiter">[</span><span>of</span><span> </span><span>e</span><span> </span><span>a</span><span> </span><span>r</span><span> </span><span>ts</span><span class="delimiter">]</span><span> </span><span>O</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prio t ≤ snd y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>getMinTree_min_tree</span><span class="delimiter">[</span><span>OF</span><span> </span><span>O</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>findMin_mset</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>I</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_invar q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>NE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"q≠Nil"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"findMin q ∈# queue_to_multiset q"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∀y∈set_mset (queue_to_multiset q). snd (findMin q) ≤ snd y"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>NE</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"getMinTree q ∈ set q"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>mintree_exists</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"findMin q ∈# queue_to_multiset q"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>treehead_in_multiset</span><span> </span><span>findMin_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀y∈set_mset (queue_to_multiset q). snd (findMin q) ≤ snd y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>getMinTree_min_prio</span><span> </span><span>findMin_def</span><span> </span><span>Let_def</span><span> </span><span>NE</span><span> </span><span>I</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>findMin_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>I</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>NE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"q≠Nil"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"findMin q ∈# queue_to_multiset q"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∀y∈set_mset (queue_to_multiset q). snd (findMin q) ≤ snd y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>I</span><span> </span><span>NE</span><span> </span><span>findMin_mset</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>invar_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Delete Minimal Element"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Insert the roots of a given queue into an other queue.›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>insertList</span><span> </span><span class="delimiter">::</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"('e, 'a::linorder) SkewBinomialQueue ⇒ ('e, 'a) SkewBinomialQueue ⇒ 
   ('e, 'a) SkewBinomialQueue"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"insertList [] tbq = tbq"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"insertList (t#bq) tbq = insertList bq (insert (val t) (prio t) tbq)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Remove the first tree, which has the priority $a$ within his root.›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>remove1Prio</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ ('e, 'a::linorder) SkewBinomialQueue ⇒
  ('e, 'a) SkewBinomialQueue"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"remove1Prio a [] = []"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"remove1Prio a (t#bq) = 
  (if (prio t) = a then bq else t # (remove1Prio a bq))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>remove1Prio_remove1</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"remove1Prio (prio (getMinTree bq)) bq = remove1 (getMinTree bq) bq"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>bq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>t</span><span> </span><span>bq</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>iv</span><span> </span><span class="delimiter">=</span><span> </span><span>Cons</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"t = getMinTree (t # bq)"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>iv</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>ne</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bq ≠ []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>down</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"getMinTree (t # bq) = getMinTree bq"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>bq</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>getMinTree.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ne</span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prio t ≠ prio (getMinTree bq)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>bq</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>getMinTree.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>down</span><span> </span><span>iv</span><span> </span><span>False</span><span> </span><span>ne</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Return the queue without the minimal element found by findMin›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>deleteMin</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'a::linorder) SkewBinomialQueue ⇒ 
  ('e, 'a) SkewBinomialQueue"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"deleteMin bq = (let min = getMinTree bq in insertList
    (filter (λ t. rank t = 0) (children min))
    (meld (rev (filter (λ t. rank t &gt; 0) (children min))) 
     (remove1Prio (prio min) bq)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>invar_rev</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_invar (rev q) ⟷ queue_invar q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>queue_invar_def</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>invar_remove1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_invar q ⟹ queue_invar (remove1 t q)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>queue_invar_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mset_rev</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_to_multiset (rev q) = queue_to_multiset q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>q</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>union_ac</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_set_subset</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ set q ⟹ tree_to_multiset t ⊆# queue_to_multiset q"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>q</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>q</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"t = a"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>t_in_q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ set q"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_to_multiset q ⊆# queue_to_multiset (a # q)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>subset_mset.order_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t_in_q</span><span class="delimiter">]</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mset_remove1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ set q ⟹ 
  queue_to_multiset (remove1 t q) = 
  queue_to_multiset q - tree_to_multiset t"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>q</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_set_subset</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>invar_children'</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_invar (children t)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Node</span><span> </span><span>e</span><span> </span><span>a</span><span> </span><span>nat</span><span> </span><span>list</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar (Node e a nat list)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Node</span><span> </span><span>invar_children</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>invar_filter</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_invar q ⟹ queue_invar (filter f q)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>queue_invar_def</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>insertList_queue_invar</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_invar q ⟹ queue_invar (insertList ts q)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ts</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>q</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>q</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>inv_insert</span><span> </span><span class="delimiter">=</span><span> </span><span>insert_queue_invar</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"val a"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prio a"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv_insert</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>deleteMin_queue_invar</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦queue_invar q; queue_to_multiset q ≠ {#}⟧ ⟹ 
  queue_invar (deleteMin q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>deleteMin_def</span><span> </span><span>Let_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>goal_cases</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>prems</span><span class="delimiter">:</span><span> </span><span>1</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>q_ne</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"q ≠ []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>mintree_exists</span><span class="delimiter">[</span><span>of</span><span> </span><span>q</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inv_min</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar (getMinTree q)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>inv_rem</span><span> </span><span class="delimiter">=</span><span> </span><span>invar_remove1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"getMinTree q"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>inv_children</span><span> </span><span class="delimiter">=</span><span> </span><span>invar_children'</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv_min</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>inv_filter</span><span> </span><span class="delimiter">=</span><span> </span><span>invar_filter</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv_children</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"λt. 0 &lt; rank t"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>inv_rev</span><span> </span><span class="delimiter">=</span><span> </span><span>iffD2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invar_rev</span><span> </span><span>inv_filter</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>inv_meld</span><span> </span><span class="delimiter">=</span><span> </span><span>meld_queue_invar</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv_rev</span><span> </span><span>inv_rem</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>inv_ins</span><span> </span><span class="delimiter">=</span><span> 
</span><span>    </span><span>insertList_queue_invar</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv_meld</span><span class="delimiter">,</span><span> 
</span><span>      </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"[t←children (getMinTree q). rank t = 0]"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mset_children</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_to_multiset (children t) = 
  tree_to_multiset t - {# (val t, prio t) #}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mset_insertList</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦∀t ∈ set ts. rank t = 0 ∧ children t = [] ; queue_invar q⟧ ⟹ 
  queue_to_multiset (insertList ts q) = 
  queue_to_multiset ts + queue_to_multiset q"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ts</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>q</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>ts</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ball_ts</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀t∈set ts. rank t = 0 ∧ children t = []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>inv_insert</span><span> </span><span class="delimiter">=</span><span> </span><span>insert_queue_invar</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"val a"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prio a"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>iv</span><span> </span><span class="delimiter">=</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ball_ts</span><span> </span><span>inv_insert</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>mset_a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_to_multiset a = {# (val a, prio a)#}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>insert_mset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"val a"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prio a"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>mset_a</span><span> </span><span>iv</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>union_ac</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mset_filter</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(queue_to_multiset [t←q . rank t = 0]) +
  queue_to_multiset [t←q . 0 &lt; rank t] =
  queue_to_multiset q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>q</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>union_ac</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>deleteMin_mset</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_invar q"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_to_multiset q ≠ {#}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_to_multiset (deleteMin q) = queue_to_multiset q - {# (findMin q) #}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>q_ne</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"q ≠ []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>mintree_exists</span><span class="delimiter">[</span><span>of</span><span> </span><span>q</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>min_in_q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"getMinTree q ∈ set q"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inv_min</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar (getMinTree q)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>inv_rem</span><span> </span><span class="delimiter">=</span><span> </span><span>invar_remove1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"getMinTree q"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>inv_children</span><span> </span><span class="delimiter">=</span><span> </span><span>invar_children'</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv_min</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>inv_filter</span><span> </span><span class="delimiter">=</span><span> </span><span>invar_filter</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv_children</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"λt. 0 &lt; rank t"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>inv_rev</span><span> </span><span class="delimiter">=</span><span> </span><span>iffD2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invar_rev</span><span> </span><span>inv_filter</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>inv_meld</span><span> </span><span class="delimiter">=</span><span> </span><span>meld_queue_invar</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv_rev</span><span> </span><span>inv_rem</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>mset_rem</span><span> </span><span class="delimiter">=</span><span> </span><span>mset_remove1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>min_in_q</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>mset_rev</span><span> </span><span class="delimiter">=</span><span> </span><span>mset_rev</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"[t←children (getMinTree q). 0 &lt; rank t]"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>mset_meld</span><span> </span><span class="delimiter">=</span><span> </span><span>meld_mset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv_rev</span><span> </span><span>inv_rem</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>mset_children</span><span> </span><span class="delimiter">=</span><span> </span><span>mset_children</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"getMinTree q"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>mset_insertList</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"[t←children (getMinTree q) .
             rank t = 0]"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦tree_invar t; rank t = 0⟧ ⟹ children t = []"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>t</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>inv_children</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ball_min</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀t∈set [t←children (getMinTree q). rank t = 0]. 
    rank t = 0 ∧ children t = []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>queue_invar_def</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>mset_insertList</span><span> </span><span class="delimiter">=</span><span> </span><span>mset_insertList</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ball_min</span><span> </span><span>inv_meld</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>mset_filter</span><span> </span><span class="delimiter">=</span><span> </span><span>mset_filter</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"children (getMinTree q)"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?Q</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_to_multiset q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?MT</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_to_multiset (getMinTree q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>q_ne</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>head_subset_min</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"{# (val (getMinTree q), prio (getMinTree q)) #} ⊆# ?MT"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"getMinTree q"</span></span></span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>min_subset_q</span><span> </span><span class="delimiter">=</span><span> </span><span>in_set_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>min_in_q</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>mset_insertList</span><span> </span><span>mset_meld</span><span> </span><span>mset_rev</span><span> </span><span>mset_rem</span><span> </span><span>mset_filter</span><span> </span><span>mset_children</span><span>
</span><span>    </span><span>multiset_diff_union_assoc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>head_subset_min</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"?Q - ?MT"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span>mset_subset_eq_multiset_union_diff_commute</span><span class="delimiter">[</span><span>OF</span><span> </span><span>min_subset_q</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"?MT"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deleteMin_def</span><span> </span><span>Let_def</span><span> </span><span>union_ac</span><span> </span><span>findMin_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rank_insertList</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank_skew_invar q ⟹ rank_skew_invar (insertList ts q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ts</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>q</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>insert_rank_invar</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>insertList_invar</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar q ⟹ invar (insertList ts q)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ts</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>q</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>q</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>insertList.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>goal_cases</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>insert_rank_invar</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"q"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"val a"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prio a"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank_skew_invar (insert (val a) (prio a) q)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>invar_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>insert_queue_invar</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"q"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"val a"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prio a"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_invar (insert (val a) (prio a) q)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>invar_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invar (insert (val a) (prio a) q)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>invar_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(insert (val a) (prio a) q)"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>children_rank_less</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀t' ∈ set (children t). rank t' &lt; rank t"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Node</span><span> </span><span>e</span><span> </span><span>a</span><span> </span><span>nat</span><span> </span><span>list</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>nat</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span> </span><span>e</span><span> </span><span>a</span><span> </span><span>list</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>nat</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>e1</span><span> </span><span>a1</span><span> </span><span>ts1</span><span> </span><span>e2</span><span> </span><span>a2</span><span> </span><span>ts2</span><span> </span><span>e'</span><span> </span><span>a'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>      </span><span>O</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar (Node e1 a1 nat ts1)"</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_invar (Node e2 a2 nat ts2)"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2) 
       ∨ t = skewlink e' a' (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>tree_invar.simps</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>ch_id</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"children t = (if a1 ≤ a2 then (Node e2 a2 nat ts2)#ts1 
                     else (Node e1 a1 nat ts1)#ts2) ∨
      children t = 
        (if a' ≤ a1 ∧ a' ≤ a2 then [(Node e1 a1 nat ts1), (Node e2 a2 nat ts2)]
         else (if a1 ≤ a2 then (Node e' a' 0 []) # (Node e2 a2 nat ts2) # ts1
         else (Node e' a' 0 []) # (Node e1 a1 nat ts1) # ts2))"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>O</span><span> </span><span>Suc</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Node e1 a1 nat ts1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ts1"</span></span></span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span>p1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀t'∈set ((Node e2 a2 nat ts2) # ts1). rank t' &lt; Suc nat"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>O</span><span> </span><span>Suc</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Node e2 a2 nat ts2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ts2"</span></span></span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>p2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀t'∈set ((Node e1 a1 nat ts1) # ts2). rank t' &lt; Suc nat"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>O</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>      </span><span>p3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀t' ∈ set [(Node e1 a1 nat ts1), (Node e2 a2 nat ts2)]. 
                 rank t' &lt; Suc nat"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>O</span><span> </span><span>Suc</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Node e1 a1 nat ts1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ts1"</span></span></span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>      </span><span>p4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀t' ∈ set ((Node e' a' 0 []) # (Node e2 a2 nat ts2) # ts1). 
                 rank t' &lt; Suc nat"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>O</span><span> </span><span>Suc</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Node e2 a2 nat ts2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ts2"</span></span></span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>p5</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"∀t' ∈ set ((Node e' a' 0 []) # (Node e1 a1 nat ts1) # ts2). 
                 rank t' &lt; Suc nat"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Suc</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>p1</span><span> </span><span>p2</span><span> </span><span>p3</span><span> </span><span>p4</span><span> </span><span>p5</span><span> </span><span>ch_id</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"children t = (if a1 ≤ a2 then Node e2 a2 nat ts2 # ts1 
                              else Node e1 a1 nat ts1 # ts2)"</span></span></span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strong_rev_children</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invar (rev [t ← children t. 0 &lt; rank t])"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Node</span><span> </span><span>e</span><span> </span><span>a</span><span> </span><span>nat</span><span> </span><span>list</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat"</span></span></span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span> </span><span>e</span><span> </span><span>a</span><span> </span><span>list</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>invar_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>nat</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Suc</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>e1</span><span> </span><span>a1</span><span> </span><span>e2</span><span> </span><span>a2</span><span> </span><span>e'</span><span> </span><span>a'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>        </span><span>O</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar (Node e1 a1 0 [])"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar (Node e2 a2 0 [])"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"t = link (Node e1 a1 0 []) (Node e2 a2 0 []) 
        ∨ t = skewlink e' a' (Node e1 a1 0 []) (Node e2 a2 0 [])"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>tree_invar.simps</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[t ← children t. 0 &lt; rank t] = []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>invar_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Suc'</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Suc</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>e1</span><span> </span><span>a1</span><span> </span><span>ts1</span><span> </span><span>e2</span><span> </span><span>a2</span><span> </span><span>ts2</span><span> </span><span>e'</span><span> </span><span>a'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>        </span><span>O</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar (Node e1 a1 nat ts1)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar (Node e2 a2 nat ts2)"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"t = link (Node e1 a1 nat ts1) (Node e2 a2 nat ts2) 
        ∨ t = skewlink e' a' (Node e1 a1 nat ts1) (Node e2 a2 nat ts2)"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>tree_invar.simps</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>ch_id</span><span class="delimiter">:</span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"children t = (if a1 ≤ a2 then 
          (Node e2 a2 nat ts2)#ts1 
        else (Node e1 a1 nat ts1)#ts2) 
        ∨ 
        children t = (if a' ≤ a1 ∧ a' ≤ a2 then 
          [(Node e1 a1 nat ts1), (Node e2 a2 nat ts2)]
        else (if a1 ≤ a2 then 
          (Node e' a' 0 []) # (Node e2 a2 nat ts2) # ts1
        else (Node e' a' 0 []) # (Node e1 a1 nat ts1) # ts2))"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>O</span><span> </span><span>Suc</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Node e1 a1 nat ts1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ts1"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>        </span><span>rev_ts1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar (rev [t ← ts1. 0 &lt; rank t])"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>O</span><span> </span><span>children_rank_less</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Node e1 a1 nat ts1"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"∀t∈set (rev [t ← ts1. 0 &lt; rank t]). rank t &lt; rank (Node e2 a2 nat ts2)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>O</span><span> </span><span>rev_ts1</span><span> 
</span><span>        </span><span>invar_app_single</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"rev [t ← ts1. 0 &lt; rank t]"</span></span></span><span> 
</span><span>                                  </span><span class="string"><span class="delete"><span class="delete">"Node e2 a2 nat ts2"</span></span></span><span class="delimiter">]</span><span>  
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"invar (rev ((Node e2 a2 nat ts2) # [t ← ts1. 0 &lt; rank t]))"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Suc'</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>p1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar (rev [t ← ((Node e2 a2 nat ts2) # ts1). 0 &lt; rank t])"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>O</span><span> </span><span>Suc</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Node e2 a2 nat ts2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ts2"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>rev_ts2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar (rev [t ← ts2. 0 &lt; rank t])"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>O</span><span> </span><span>children_rank_less</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Node e2 a2 nat ts2"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀t∈set (rev [t ← ts2. 0 &lt; rank t]). 
        rank t &lt; rank (Node e1 a1 nat ts1)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>O</span><span> </span><span>rev_ts2</span><span> </span><span>invar_app_single</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"rev [t ← ts2. 0 &lt; rank t]"</span></span></span><span> 
</span><span>                                         </span><span class="string"><span class="delete"><span class="delete">"Node e1 a1 nat ts1"</span></span></span><span class="delimiter">]</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invar (rev [t ← ts2. 0 &lt; rank t] @ [Node e1 a1 nat ts1])"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Suc'</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>p2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar (rev [t ← ((Node e1 a1 nat ts1) # ts2). 0 &lt; rank t])"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>O</span><span class="delimiter">(</span><span>1</span><span>-</span><span>2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>p3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar (rev (filter (λ t. 0 &lt; rank t)
                                 [(Node e1 a1 nat ts1), (Node e2 a2 nat ts2)]))"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>invar_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>p1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>p4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar (rev 
           [t ← ((Node e' a' 0 []) # (Node e2 a2 nat ts2) # ts1). 0 &lt; rank t])"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>p2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>p5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar (rev 
           [t ← ((Node e' a' 0 []) # (Node e1 a1 nat ts1) # ts2). 0 &lt; rank t])"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>p1</span><span> </span><span>p2</span><span> </span><span>p3</span><span> </span><span>p4</span><span> </span><span>p5</span><span> </span><span>ch_id</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"invar (rev [t←children t . 0 &lt; rank t])"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"children t = (if a1 ≤ a2 then (Node e2 a2 nat ts2)#ts1 
                                else (Node e1 a1 nat ts1)#ts2)"</span></span></span><span class="delimiter">)</span><span> </span><span>metis</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>first_less</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank_invar (t # bq) ⟹ ∀t' ∈ set bq. rank t &lt; rank t'"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>bq</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>List.set_simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>insert_iff</span><span> </span><span>not_le_imp_less</span><span> 
</span><span>    </span><span>not_less_iff_gr_or_eq</span><span> </span><span>order_less_le_trans</span><span> </span><span>rank_invar.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> 
</span><span>    </span><span>rank_invar_cons_down</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>first_less_eq</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rank_skew_invar (t # bq) ⟹ ∀t' ∈ set bq. rank t ≤ rank t'"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>bq</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>List.set_simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>insert_iff</span><span> </span><span>le_trans</span><span>
</span><span>    </span><span>rank_invar_rank_skew</span><span> </span><span>rank_skew_invar.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>rank_skew_rank_invar</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>remove1_tail_invar</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tail_invar bq ⟹ tail_invar (remove1 t bq)"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>bq</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>bq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"t = a"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tail_invar bq"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>tail_invar_cons_down</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>True</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tail_invar bq"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>tail_invar_cons_down</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"t"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>si1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tail_invar (remove1 t bq)"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tail_invar (remove1 t (a # bq)) = tail_invar (a # (remove1 t bq))"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"remove1 t bq"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>si1</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>False</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>tail_invar_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Cons'</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>aa</span><span> </span><span>list</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>tail_invar_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>first_less</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"a"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bq"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀t ∈ set (remove1 t bq). rank a &lt; rank t"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>notin_set_remove1</span><span> </span><span>tail_invar_def</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons'</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rank a &lt; rank aa"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>si1</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>False</span><span> </span><span>Cons'</span><span> </span><span>tail_invar_cons_up</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"aa"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"list"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>tail_invar_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>invar_cons_down</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar (t # bq) ⟹ invar bq"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>rank_invar_rank_skew</span><span> </span><span>tail_invar_def</span><span> 
</span><span>    </span><span>invar_def</span><span> </span><span>invar_tail_invar</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>remove1_invar</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar bq ⟹ invar (remove1 t bq)"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>bq</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>bq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"t = a"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invar bq"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>invar_cons_down</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>True</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invar bq"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>invar_cons_down</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"t"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>si1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar (remove1 t bq)"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invar (remove1 t (a # bq)) = invar (a # (remove1 t bq))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"remove1 t bq"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>si1</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>False</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>invar_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Cons'</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>aa</span><span> </span><span>list</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ti</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>invar_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sbq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tail_invar bq"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>invar_tail_invar</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>srm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tail_invar (remove1 t bq)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>remove1_tail_invar</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>first_less_eq</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"a"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bq"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀t ∈ set (remove1 t bq). rank a ≤ rank t"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>notin_set_remove1</span><span> </span><span>invar_def</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons'</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rank a ≤ rank aa"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>si1</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>False</span><span> </span><span>Cons'</span><span> </span><span>ti</span><span> </span><span>srm</span><span> </span><span>tail_invar_cons_up_invar</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"aa"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"list"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a"</span></span></span><span class="delimiter">]</span><span> 
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>deleteMin_invar</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invar bq"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bq ≠ []"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invar (deleteMin bq)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar (deleteMin bq) = 
    invar (insertList
    (filter (λ t. rank t = 0) (children (getMinTree bq)))
    (meld (rev (filter (λ t. rank t &gt; 0) (children (getMinTree bq)))) 
          (remove1 (getMinTree bq) bq)))"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deleteMin_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span>mintree_exists</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"bq"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ti</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_invar (getMinTree bq)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>invar_def</span><span> </span><span>queue_invar_def</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>queue_invar_simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>strong_rev_children</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"getMinTree bq"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>    </span><span>m1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar (rev [t ← children (getMinTree bq). 0 &lt; rank t])"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>remove1_invar</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"bq"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"getMinTree bq"</span></span></span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>m2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar (remove1 (getMinTree bq) bq)"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>meld_invar</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"rev [t ← children (getMinTree bq). 0 &lt; rank t]"</span></span></span><span> 
</span><span>                     </span><span class="string"><span class="delete"><span class="delete">"remove1 (getMinTree bq) bq"</span></span></span><span class="delimiter">]</span><span> </span><span>m1</span><span> </span><span>m2</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invar (meld (rev [t ← children (getMinTree bq). 0 &lt; rank t]) 
                    (remove1 (getMinTree bq) bq))"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>insertList_invar</span><span class="delimiter">[</span><span>of</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(meld (rev [t←children (getMinTree bq) . 0 &lt; rank t]) 
           (remove1 (getMinTree bq) bq))"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"[t←children (getMinTree bq) . rank t = 0]"</span></span></span><span class="delimiter">]</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invar
   (insertList
     [t←children (getMinTree bq) . rank t = 0]
     (meld (rev [t←children (getMinTree bq) . 0 &lt; rank t])
       (remove1 (getMinTree bq) bq)))"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>eq</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>deleteMin_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>I</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar q"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>NE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"q ≠ Nil"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invar (deleteMin q)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_to_multiset (deleteMin q) = queue_to_multiset q - {#findMin q#}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>deleteMin_invar</span><span class="delimiter">[</span><span>OF</span><span> </span><span>I</span><span> </span><span>NE</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>deleteMin_mset</span><span class="delimiter">[</span><span>of</span><span> </span><span>q</span><span class="delimiter">]</span><span> </span><span>I</span><span> </span><span>NE</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>invar_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>empty_correct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
fun foldt and foldq where
  "foldt f z (Node e a _ q) = f (foldq f z q) e a" |
  "foldq f z [] = z" |
  "foldq f z (t#q) = foldq f (foldt f z t) q"

lemma fold_plus:
  "foldt ((λm e a. m+{#(e,a)#})) zz t + z = foldt ((λm e a. m+{#(e,a)#})) (zz+z) t"
  "foldq ((λm e a. m+{#(e,a)#})) zz q + z = foldq ((λm e a. m+{#(e,a)#})) (zz+z) q"
  apply (induct t and q arbitrary: zz and zz 
    rule: tree_to_multiset_queue_to_multiset.induct)
  apply (auto simp add: union_ac)
  apply (subst union_ac, simp)
  done


lemma to_mset_fold:
  fixes t::"('e,'a::linorder) SkewBinomialTree" and
        q::"('e,'a) SkewBinomialQueue"
  shows
  "tree_to_multiset t = foldt (λm e a. m+{#(e,a)#}) {#} t"
  "queue_to_multiset q = foldq (λm e a. m+{#(e,a)#}) {#} q"
  apply (induct t and q rule: tree_to_multiset_queue_to_multiset.induct)
  apply (auto simp add: union_ac fold_plus)
  done
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>insert.simps</span><span> 
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>SkewBinomialHeapStruc</span><span class="delimiter">:</span><span> </span><span>SkewBinomialHeapStruc_loc</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Bootstrapping"</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  In this section, we implement datastructural bootstrapping, to
  reduce the complexity of meld-operations to $O(1)$.
  The bootstrapping also contains a {\em global root}, caching the
  minimal element of the queue, and thus also reducing the complexity of
  findMin-operations to $O(1)$.

  Bootstrapping adds one more level of recursion:
  An {\em element} is an entry and a priority queues of elements.

  In the original paper on skew binomial queues \cite{BrOk96}, higher order 
  functors and recursive structures are used to elegantly implement bootstrapped
  heaps on top of ordinary heaps. However, such concepts are not supported in
  Isabelle/HOL, nor in Standard ML. Hence we have to use the 
  ,,much less clean'' \cite{BrOk96} alternative:  
  We manually specialize the heap datastructure, and re-implement the functions
  on the specialized data structure.

  The correctness proofs are done by defining a mapping from teh specialized to 
  the original data structure, and reusing the correctness statements of the 
  original data structure.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Auxiliary"</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  We first have to state some auxiliary lemmas and functions, mainly
  about multisets.
›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Some of these should be moved into the multiset library, they are
  marked by *MOVE* *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Finding the preimage of an element›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*MOVE*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_image_msetE</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x∈#image_mset f M"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y∈#M"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x=f y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>M</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Very special lemma for images multisets of pairs, where the second
  component is a function of the first component›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mset_image_fst_dep_pair_diff_split</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(∀e a. (e,a)∈#M ⟶ a=f e) ⟹
  image_mset fst (M - {#(e, f e)#}) = image_mset fst M - {#e#}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>M</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>empty</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>add</span><span> </span><span>x</span><span> </span><span>M</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>e'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x=(e',f e')"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>add.prems</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀e a. (e, a) ∈# M ⟶ a = f e"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>add.hyps</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>    </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"image_mset fst (M - {#(e, f e)#}) = image_mset fst M - {#e#}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"e=e'"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>IH</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Bootstrapped</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Datatype"</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We manually specialize the binomial tree to contain elements, that, in, 
  turn, may contain trees.
  Note that we specify nodes without explicit priority,
  as the priority is contained in the elements stored in the nodes.
›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'e</span><span class="delimiter">,</span><span> </span><span class="tfree">'a</span><span class="delimiter">)</span><span> </span><span>BsSkewBinomialTree</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span>BsNode</span><span> </span><span class="delimiter">(</span><span>val</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'a::linorder) BsSkewElem"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>rank</span><span class="delimiter">:</span><span> </span><span>nat</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>children</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e , 'a) BsSkewBinomialTree list"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span class="delimiter">(</span><span class="tfree">'e</span><span class="delimiter">,</span><span class="tfree">'a</span><span class="delimiter">)</span><span> </span><span>BsSkewElem</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>Element</span><span> </span><span class="tfree">'e</span><span> </span><span class="delimiter">(</span><span>eprio</span><span class="delimiter">:</span><span> </span><span class="tfree">'a</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a) BsSkewBinomialTree list"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'e</span><span class="delimiter">,</span><span class="tfree">'a</span><span class="delimiter">)</span><span> </span><span>BsSkewHeap</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"unit + ('e,'a) BsSkewElem"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'e</span><span class="delimiter">,</span><span class="tfree">'a</span><span class="delimiter">)</span><span> </span><span>BsSkewBinomialQueue</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a) BsSkewBinomialTree list"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Specialization Boilerplate"</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  In this section, we re-define the functions
  on the specialized priority queues, and show there correctness.
  This is done by defining a mapping to original priority queues,
  and re-using the correctness lemmas proven there.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Mapping to original binomial trees and queues›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>bsmapt</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bsmapt (BsNode e r q) = SkewBinomialHeapStruc.Node e (eprio e) r (map bsmapt q)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>bsmap</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bsmap q == map bsmapt q"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Invariant and mapping to multiset are defined via the mapping›</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invar q == SkewBinomialHeapStruc.invar (bsmap q)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_to_multiset q 
  == image_mset fst (SkewBinomialHeapStruc.queue_to_multiset (bsmap q))"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_to_multiset t
  == image_mset fst (SkewBinomialHeapStruc.tree_to_multiset (bsmapt t))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"queue_to_multiset_aux q 
  == (SkewBinomialHeapStruc.queue_to_multiset (bsmap q))"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Now starts the re-implementation of the functions›</span></span></span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>prio</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'a::linorder) BsSkewBinomialTree ⇒ 'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"prio (BsNode e r ts) = eprio e"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>proj_xlate</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"val t = SkewBinomialHeapStruc.val (bsmapt t)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"prio t = SkewBinomialHeapStruc.prio (bsmapt t)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rank t = SkewBinomialHeapStruc.rank (bsmapt t)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bsmap (children t) = SkewBinomialHeapStruc.children (bsmapt t)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eprio (SkewBinomialHeapStruc.val (bsmapt t)) 
   = SkewBinomialHeapStruc.prio (bsmapt t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span>  </span><span>link</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'a::linorder) BsSkewBinomialTree 
  ⇒ ('e, 'a) BsSkewBinomialTree ⇒ 
  ('e, 'a) BsSkewBinomialTree"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"link (BsNode e1 r1 ts1) (BsNode e2 r2 ts2) = 
   (if  eprio e1≤eprio e2 
     then (BsNode e1 (Suc r1) ((BsNode e2 r2 ts2)#ts1))
     else (BsNode e2 (Suc r2) ((BsNode e1 r1 ts1)#ts2)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Link two trees of rank $r$ and a new element to a new tree of 
  rank $r+1$›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>skewlink</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a::linorder) BsSkewElem ⇒ ('e, 'a) BsSkewBinomialTree ⇒ 
  ('e, 'a) BsSkewBinomialTree ⇒ ('e, 'a) BsSkewBinomialTree"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"skewlink e t t' = (if eprio e ≤ (prio t) ∧ eprio e ≤ (prio t')
  then (BsNode e (Suc (rank t)) [t,t'])
  else (if (prio t) ≤ (prio t') 
   then 
    BsNode (val t) (Suc (rank t))  (BsNode e 0 [] # t' # children t)
   else 
    BsNode (val t') (Suc (rank t')) (BsNode e 0 [] # t # children t')))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>link_xlate</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bsmapt (link t t') = SkewBinomialHeapStruc.link (bsmapt t) (bsmapt t')"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bsmapt (skewlink e t t') = 
     SkewBinomialHeapStruc.skewlink e (eprio e) (bsmapt t) (bsmapt t')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span>t</span><span class="delimiter">,</span><span> </span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span>t'</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>ins</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'a::linorder) BsSkewBinomialTree ⇒ 
  ('e, 'a) BsSkewBinomialQueue ⇒ 
  ('e, 'a) BsSkewBinomialQueue"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ins t [] = [t]"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ins t' (t # bq) =
    (if (rank t') &lt; (rank t) 
      then t' # t # bq 
      else (if (rank t) &lt; (rank t')
        then t # (ins t' bq) 
        else ins (link t' t) bq))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ins_xlate</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bsmap (ins t q) = SkewBinomialHeapStruc.ins (bsmapt t) (bsmap q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>q</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>proj_xlate</span><span> </span><span>link_xlate</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Insert an element with priority into a queue using skewlinks.›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>insert</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a::linorder) BsSkewElem ⇒
  ('e, 'a) BsSkewBinomialQueue ⇒ 
  ('e, 'a) BsSkewBinomialQueue"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"insert e [] = [BsNode e 0 []]"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"insert e [t] = [BsNode e 0 [],t]"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"insert e (t # t' # bq) =
    (if rank t ≠ rank t' 
      then (BsNode e 0 []) # t # t' # bq
      else (skewlink e t t') # bq)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>insert_xlate</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bsmap (insert e q) = SkewBinomialHeapStruc.insert e (eprio e) (bsmap q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"(e,q)"</span></span></span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>insert.cases</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>proj_xlate</span><span> </span><span>link_xlate</span><span> </span><span>SkewBinomialHeapStruc.insert.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>insert_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>I</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"invar (insert e q)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"queue_to_multiset (insert e q) = queue_to_multiset q + {#(e)#}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>I</span><span> </span><span>SkewBinomialHeapStruc.insert_correct</span><span> </span><span>insert_xlate</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>uniqify</span><span> 
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'a::linorder) BsSkewBinomialQueue ⇒ ('e, 'a) BsSkewBinomialQueue"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"uniqify [] = []"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"uniqify (t#bq) = ins t bq"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>meldUniq</span><span> 
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'a::linorder) BsSkewBinomialQueue ⇒ ('e,'a) BsSkewBinomialQueue ⇒
  ('e, 'a) BsSkewBinomialQueue"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"meldUniq [] bq = bq"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"meldUniq bq [] = bq"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"meldUniq (t1#bq1) (t2#bq2) = (if rank t1 &lt; rank t2 
       then t1 # (meldUniq bq1 (t2#bq2))
       else (if rank t2 &lt; rank t1
              then t2 # (meldUniq (t1#bq1) bq2)
              else ins (link t1 t2) (meldUniq bq1 bq2)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>meld</span><span> 
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'a::linorder) BsSkewBinomialQueue ⇒ ('e, 'a) BsSkewBinomialQueue ⇒ 
      ('e, 'a) BsSkewBinomialQueue"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"meld bq1 bq2 = meldUniq (uniqify bq1) (uniqify bq2)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uniqify_xlate</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bsmap (uniqify q) = SkewBinomialHeapStruc.uniqify (bsmap q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>q</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ins_xlate</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>meldUniq_xlate</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bsmap (meldUniq q q') = SkewBinomialHeapStruc.meldUniq (bsmap q) (bsmap q')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>q</span><span> </span><span>q'</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>meldUniq.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>link_xlate</span><span> </span><span>proj_xlate</span><span> </span><span>uniqify_xlate</span><span> </span><span>ins_xlate</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>meld_xlate</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bsmap (meld q q') = SkewBinomialHeapStruc.meld (bsmap q) (bsmap q')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>meld_def</span><span> </span><span>meldUniq_xlate</span><span> </span><span>uniqify_xlate</span><span> 
</span><span>           </span><span>SkewBinomialHeapStruc.meld_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>meld_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>I</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar q"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invar q'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"invar (meld q q')"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"queue_to_multiset (meld q q') = queue_to_multiset q + queue_to_multiset q'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>I</span><span> </span><span>SkewBinomialHeapStruc.meld_correct</span><span> </span><span>meld_xlate</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>insertList</span><span> </span><span class="delimiter">::</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"('e, 'a::linorder) BsSkewBinomialQueue ⇒ ('e, 'a) BsSkewBinomialQueue ⇒ 
   ('e, 'a) BsSkewBinomialQueue"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"insertList [] tbq = tbq"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"insertList (t#bq) tbq = insertList bq (insert (val t) tbq)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>remove1Prio</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ ('e, 'a::linorder) BsSkewBinomialQueue ⇒
  ('e, 'a) BsSkewBinomialQueue"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"remove1Prio a [] = []"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"remove1Prio a (t#bq) = 
  (if (prio t) = a then bq else t # (remove1Prio a bq))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>getMinTree</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'a::linorder) BsSkewBinomialQueue ⇒ 
  ('e, 'a) BsSkewBinomialTree"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"getMinTree [t] = t"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"getMinTree (t#bq) =
    (if prio t ≤ prio (getMinTree bq)
      then t
      else (getMinTree bq))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>findMin</span><span> 
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'a::linorder) BsSkewBinomialQueue ⇒ ('e,'a) BsSkewElem"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"findMin bq = val (getMinTree bq)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>deleteMin</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'a::linorder) BsSkewBinomialQueue ⇒ 
  ('e, 'a) BsSkewBinomialQueue"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"deleteMin bq = (let min = getMinTree bq in insertList
    (filter (λ t. rank t = 0) (children min))
    (meld (rev (filter (λ t. rank t &gt; 0) (children min))) 
     (remove1Prio (prio min) bq)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>insertList_xlate</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bsmap (insertList q q') 
  = SkewBinomialHeapStruc.insertList (bsmap q) (bsmap q')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>q</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>q'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>insert_xlate</span><span> </span><span>proj_xlate</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>remove1Prio_xlate</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bsmap (remove1Prio a q) = SkewBinomialHeapStruc.remove1Prio a (bsmap q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>q</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>proj_xlate</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>getMinTree_xlate</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"q≠[] ⟹ bsmapt (getMinTree q) = SkewBinomialHeapStruc.getMinTree (bsmap q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>q</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>q</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>proj_xlate</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>findMin_xlate</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"q≠[] ⟹ findMin q = fst (SkewBinomialHeapStruc.findMin (bsmap q))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>findMin_def</span><span> </span><span>SkewBinomialHeapStruc.findMin_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>proj_xlate</span><span> </span><span>Let_def</span><span> </span><span>getMinTree_xlate</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>findMin_xlate_aux</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"q≠[] ⟹ (findMin q, eprio (findMin q)) = 
  (SkewBinomialHeapStruc.findMin (bsmap q))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>findMin_def</span><span> </span><span>SkewBinomialHeapStruc.findMin_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>proj_xlate</span><span> </span><span>Let_def</span><span> </span><span>getMinTree_xlate</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>q</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>q</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>proj_xlate</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Also possible in generic formulation. Then a candidate for Misc.thy *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bsmap_filter_xlate</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bsmap [ x←l . P (bsmapt x) ] = [ x ← bsmap l. P x ]"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>l</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bsmap_rev_xlate</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bsmap (rev q) = rev (bsmap q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>q</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>deleteMin_xlate</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"q≠[] ⟹ bsmap (deleteMin q) = SkewBinomialHeapStruc.deleteMin (bsmap q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> 
</span><span>    </span><span>deleteMin_def</span><span> </span><span>SkewBinomialHeapStruc.deleteMin_def</span><span>
</span><span>    </span><span>proj_xlate</span><span> </span><span>getMinTree_xlate</span><span> </span><span>insertList_xlate</span><span> </span><span>meld_xlate</span><span> </span><span>remove1Prio_xlate</span><span>
</span><span>    </span><span>Let_def</span><span> </span><span>bsmap_rev_xlate</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>bsmap_filter_xlate</span><span class="delimiter">)</span><span class="delimiter">?</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>deleteMin_correct_aux</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>I</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>NE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"q≠[]"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"invar (deleteMin q)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"queue_to_multiset_aux (deleteMin q) = queue_to_multiset_aux q - 
  {# (findMin q, eprio (findMin q)) #}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span>
</span><span>    </span><span>I</span><span> </span><span>NE</span><span> </span><span>deleteMin_xlate</span><span> </span><span>findMin_xlate_aux</span><span> 
</span><span>    </span><span>SkewBinomialHeapStruc.deleteMin_correct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bsmap_fs_dep</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(e,a)∈#SkewBinomialHeapStruc.tree_to_multiset (bsmapt t) ⟹ a=eprio e"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(e,a)∈#SkewBinomialHeapStruc.queue_to_multiset (bsmap q) ⟹ a=eprio e"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>SkewBinomialHeapStruc.tree_to_multiset_queue_to_multiset.induct</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"bsmapt t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bsmap q"</span></span></span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>q</span><span>
</span><span>    </span><span>rule</span><span class="delimiter">:</span><span> </span><span>SkewBinomialHeapStruc.tree_to_multiset_queue_to_multiset.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bsmap_fs_depD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(e,a)∈#SkewBinomialHeapStruc.tree_to_multiset (bsmapt t) 
  ⟹ e ∈# tree_to_multiset t ∧ a=eprio e"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(e,a)∈#SkewBinomialHeapStruc.queue_to_multiset (bsmap q) 
  ⟹ e ∈# queue_to_multiset q ∧ a=eprio e"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>bsmap_fs_dep</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>image_eqI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>findMin_correct_aux</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>I</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>NE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"q≠[]"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(findMin q, eprio (findMin q)) ∈# queue_to_multiset_aux q"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∀y∈set_mset (queue_to_multiset_aux q). snd (findMin q,eprio (findMin q)) ≤ snd y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span>
</span><span>    </span><span>I</span><span> </span><span>NE</span><span> </span><span>findMin_xlate_aux</span><span> 
</span><span>    </span><span>SkewBinomialHeapStruc.findMin_correct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>findMin_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>I</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar q"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>NE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"q≠[]"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"findMin q ∈# queue_to_multiset q"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀y∈set_mset (queue_to_multiset q). eprio (findMin q) ≤ eprio y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>findMin_correct_aux</span><span class="delimiter">[</span><span>OF</span><span> </span><span>I</span><span> </span><span>NE</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>bsmap_fs_depD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>goal_cases</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>prems</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>a</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>prems</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(a, eprio a) ∈# queue_to_multiset_aux q"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>bsmap_fs_dep</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>deleteMin_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>I</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>NE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"q≠[]"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"invar (deleteMin q)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"queue_to_multiset (deleteMin q) = queue_to_multiset q - 
  {# findMin q #}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>deleteMin_correct_aux</span><span class="delimiter">[</span><span>OF</span><span> </span><span>I</span><span> </span><span>NE</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>mset_image_fst_dep_pair_diff_split</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>bsmap_fs_dep</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>insert.simps</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Bootstrapping: Phase 1"</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  In this section, we define the ticked versions
  of the functions, as defined in \cite{BrOk96}.
  These functions work on elements, i.e. only on 
  heaps that contain at least one entry.
  Additionally, we define an invariant for elements, and
  a mapping to multisets of entries, and prove correct
  the ticked functions.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>findMin'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"findMin' (Element e a q) = (e,a)"</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>meld'</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a::linorder) BsSkewElem ⇒ 
  ('e,'a) BsSkewElem ⇒ ('e,'a) BsSkewElem"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"meld' (Element e1 a1 q1) (Element e2 a2 q2) =
  (if a1≤a2 then
    Element e1 a1 (insert (Element e2 a2 q2) q1)
   else
    Element e2 a2 (insert (Element e1 a1 q1) q2)
  )"</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>insert'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"insert' e a q = meld' (Element e a []) q"</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>deleteMin'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"deleteMin' (Element e a q) = (
    case (findMin q) of
      Element ey ay q1 ⇒
        Element ey ay (meld q1 (deleteMin q))
  )"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Size-function for termination proofs
›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>tree_level</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>queue_level</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_level (BsNode (Element _ _ qd) _ q) = 
  max (Suc (queue_level qd)) (queue_level q)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"queue_level [] = (0::nat)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"queue_level (t#q) = max (tree_level t) (queue_level q)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>level</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"level (Element _ _ q) = Suc (queue_level q)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>level_m</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"x∈#tree_to_multiset t ⟹ level x &lt; Suc (tree_level t)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"x∈#queue_to_multiset q ⟹ level x &lt; Suc (queue_level q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>q</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>tree_level_queue_level.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>less_max_iff_disj</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>level_measure</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"x ∈ set_mset (queue_to_multiset q) ⟹ (x,(Element e a q))∈measure level"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"x ∈# (queue_to_multiset q) ⟹ (x,(Element e a q))∈measure level"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>level_m</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>set_image_mset</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Invariant for elements
›</span></span></span><span>
</span><span class="keyword1"><span class="command">function</span></span><span> </span><span>elem_invar</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"elem_invar (Element e a q) ⟷
  (∀x. x∈# (queue_to_multiset q) ⟶ a ≤ eprio x ∧ elem_invar x) ∧ 
  invar q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>pat_completeness</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">termination</span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf (measure level)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>level_measure</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Abstraction to multisets
›</span></span></span><span>
</span><span class="keyword1"><span class="command">function</span></span><span> </span><span>elem_to_mset</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"elem_to_mset (Element e a q) = {# (e,a) #} 
  + Union_mset (image_mset elem_to_mset (queue_to_multiset q))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>pat_completeness</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">termination</span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf (measure level)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>level_measure</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>insert_correct'</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>I</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"elem_invar x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"elem_invar (insert' e a x)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"elem_to_mset (insert' e a x) = elem_to_mset x + {#(e,a)#}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>I</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>insert_correct</span><span> </span><span>union_ac</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>meld_correct'</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>I</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"elem_invar x"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"elem_invar x'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"elem_invar (meld' x x')"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"elem_to_mset (meld' x x') = elem_to_mset x + elem_to_mset x'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>I</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span>x'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>insert_correct</span><span> </span><span>union_ac</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>findMin'_min</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦elem_invar x; y∈#elem_to_mset x⟧ ⟹ snd (findMin' x) ≤ snd y"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>n</span><span class="delimiter">≡</span><span class="string"><span class="delete"><span class="delete">"level x"</span></span></span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>x</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>full_nat_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>IH</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"1.hyps"</span></span></span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>refl</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>PREMS</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"1.prems"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>e</span><span> </span><span>a</span><span> </span><span>q</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x=Element e a q"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>PREMS</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y=(e,a) ∨ 
    y∈#Union_mset (image_mset elem_to_mset (queue_to_multiset q))"</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?C1 ∨ ?C2"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y=(e,a)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>PREMS</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?C2</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>yx</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>      </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"yx ∈# queue_to_multiset q"</span></span></span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>B</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈# elem_to_mset yx"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>in_image_msetE</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A</span><span> </span><span>PREMS</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IYX</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"elem_invar yx"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>PREMS</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>A</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≤ eprio yx"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (findMin' x) ≤ snd (findMin' yx)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>yx</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>IH</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>IYX</span><span> </span><span>B</span><span class="delimiter">]</span><span> </span><span>level_m</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>A</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (findMin' yx) ≤ snd y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>findMin_correct'</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>I</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"elem_invar x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"findMin' x ∈# elem_to_mset x"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∀y∈set_mset (elem_to_mset x). snd (findMin' x) ≤ snd y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>I</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>findMin'_min</span><span class="delimiter">[</span><span>OF</span><span> </span><span>I</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>deleteMin_correct'</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>I</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"elem_invar (Element e a q)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>NE</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"q≠[]"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"elem_invar (deleteMin' (Element e a q))"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"elem_to_mset (deleteMin' (Element e a q)) = 
       elem_to_mset (Element e a q) - {# findMin' (Element e a q) #}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>I</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IQ</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar q"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>findMin_correct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>IQ</span><span> </span><span>NE</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span>FMIQ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"findMin q ∈# queue_to_multiset q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>FMIN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"!!y. y∈#(queue_to_multiset q) ⟹ eprio (findMin q) ≤ eprio y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>set_image_mset</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>FMIQ</span><span> </span><span>I</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>FMEI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"elem_invar (findMin q)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>I</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>FEI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"!!y. y∈#(queue_to_multiset q) ⟹ elem_invar y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ey</span><span> </span><span>ay</span><span> </span><span>qy</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"findMin q = Element ey ay qy"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"findMin q"</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>FMEI</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>    </span><span>IQY</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar qy"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>AYMIN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"!!x. x ∈# queue_to_multiset qy ⟹ ay ≤ eprio x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>    </span><span>QEI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"!!x. x ∈# queue_to_multiset qy ⟹ elem_invar x"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"elem_invar (deleteMin' (Element e a q))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AYMIN</span><span> </span><span>QEI</span><span> </span><span>FMIN</span><span> </span><span>FEI</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deleteMin_correct</span><span> </span><span>meld_correct</span><span> </span><span>in_diff_count</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>FMIQ</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>    </span><span>S</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(queue_to_multiset q - {#Element ey ay qy#}) + {#Element ey ay qy#} 
    = queue_to_multiset q"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"elem_to_mset (deleteMin' (Element e a q)) = 
    elem_to_mset (Element e a q) - {# findMin' (Element e a q) #}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deleteMin_correct</span><span> </span><span>meld_correct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>S</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>union_ac</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Bootstrapping: Phase 2"</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  In this phase, we extend the ticked versions to also work with
  empty priority queues.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>bs_empty</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bs_empty ≡ Inl ()"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>bs_findMin</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bs_findMin (Inr x) = findMin' x"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>bs_meld</span><span> 
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a::linorder) BsSkewHeap ⇒ ('e,'a) BsSkewHeap ⇒ ('e,'a) BsSkewHeap"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bs_meld (Inl _) x = x"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bs_meld x (Inl _) = x"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bs_meld (Inr x) (Inr x') = Inr (meld' x x')"</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bs_meld x (Inl u) = x"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>bs_insert</span><span> 
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'e ⇒ ('a::linorder) ⇒ ('e,'a) BsSkewHeap ⇒ ('e,'a) BsSkewHeap"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bs_insert e a (Inl _) = Inr (Element e a [])"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bs_insert e a (Inr x) = Inr (insert' e a x)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>bs_deleteMin</span><span> 
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a::linorder) BsSkewHeap ⇒ ('e,'a) BsSkewHeap"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bs_deleteMin (Inr (Element e a [])) = Inl ()"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bs_deleteMin (Inr (Element e a q)) = Inr (deleteMin' (Element e a q))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>bs_invar</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a::linorder) BsSkewHeap ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bs_invar (Inl _) ⟷ True"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bs_invar (Inr x) ⟷ elem_invar x"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bs_invar bs_empty"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bs_empty_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>bs_to_mset</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a::linorder) BsSkewHeap ⇒ ('e×'a) multiset"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bs_to_mset (Inl _) = {#}"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bs_to_mset (Inr x) = elem_to_mset x"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>bs_empty_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"h=bs_empty ⟷ bs_to_mset h = {#}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>bs_empty_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>h</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bs_mset_of_empty</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bs_to_mset bs_empty = {#}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bs_empty_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>bs_findMin_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>I</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bs_invar h"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>NE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"h≠bs_empty"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bs_findMin h ∈# bs_to_mset h"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"∀y∈set_mset (bs_to_mset h). snd (bs_findMin h) ≤ snd y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>I</span><span> </span><span>NE</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span>h</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bs_empty_def</span><span> </span><span>findMin_correct'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>bs_insert_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>I</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bs_invar h"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bs_invar (bs_insert e a h)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bs_to_mset (bs_insert e a h) = {#(e,a)#} + bs_to_mset h"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>I</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span>h</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>meld_correct'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>bs_meld_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>I</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bs_invar h"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bs_invar h'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bs_invar (bs_meld h h')"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bs_to_mset (bs_meld h h') = bs_to_mset h + bs_to_mset h'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>I</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span>h</span><span class="delimiter">,</span><span> </span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span>h'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>meld_correct'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>bs_deleteMin_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>I</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bs_invar h"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>NE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"h ≠ bs_empty"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bs_invar (bs_deleteMin h)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bs_to_mset (bs_deleteMin h) = bs_to_mset h - {#bs_findMin h#}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>I</span><span> </span><span>NE</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span>h</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bs_empty_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span>list</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span>list</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>elem_invar.simps</span><span> </span><span>deleteMin'.simps</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deleteMin_correct'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>BsSkewBinomialHeapStruc</span><span class="delimiter">:</span><span> </span><span>Bootstrapped</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Hiding the Invariant"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Datatype"</span></span></span><span>
</span><span class="keyword1"><span class="command">typedef</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">overloaded</span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span class="tfree">'e</span><span class="delimiter">,</span><span> </span><span class="tfree">'a</span><span class="delimiter">)</span><span> </span><span>SkewBinomialHeap</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"{q :: ('e,'a::linorder) BsSkewBinomialHeapStruc.BsSkewHeap. BsSkewBinomialHeapStruc.bs_invar q }"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"BsSkewBinomialHeapStruc.bs_empty"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Rep_SkewBinomialHeap_invar</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"BsSkewBinomialHeapStruc.bs_invar (Rep_SkewBinomialHeap x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Rep_SkewBinomialHeap</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"BsSkewBinomialHeapStruc.bs_invar q 
  ⟹ Rep_SkewBinomialHeap (Abs_SkewBinomialHeap q) = q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Abs_SkewBinomialHeap_inverse</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>code</span><span> </span><span>abstype</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Abs_SkewBinomialHeap (Rep_SkewBinomialHeap q) = q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Rep_SkewBinomialHeap_inverse</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>SkewBinomialHeap_loc</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Operations"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"to_mset t 
    == BsSkewBinomialHeapStruc.bs_to_mset (Rep_SkewBinomialHeap t)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>empty</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"empty == Abs_SkewBinomialHeap BsSkewBinomialHeapStruc.bs_empty"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>code</span><span> </span><span>abstract</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"Rep_SkewBinomialHeap empty = BsSkewBinomialHeapStruc.bs_empty"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>empty_def</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"isEmpty q == Rep_SkewBinomialHeap q = BsSkewBinomialHeapStruc.bs_empty"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>empty_rep</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"q=empty ⟷ Rep_SkewBinomialHeap q = BsSkewBinomialHeapStruc.bs_empty"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>empty_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Rep_SkewBinomialHeap_inverse</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isEmpty_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isEmpty q ⟷ q=empty"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>empty_rep</span><span> </span><span>isEmpty_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> 
</span><span>    </span><span>insert</span><span> 
</span><span>    </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'e  ⇒ ('a::linorder) ⇒ ('e,'a) SkewBinomialHeap 
        ⇒ ('e,'a) SkewBinomialHeap"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"insert e a q == 
            Abs_SkewBinomialHeap (
              BsSkewBinomialHeapStruc.bs_insert e a (Rep_SkewBinomialHeap q))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>code</span><span> </span><span>abstract</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"Rep_SkewBinomialHeap (insert e a q) 
    = BsSkewBinomialHeapStruc.bs_insert e a (Rep_SkewBinomialHeap q)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>insert_def</span><span> </span><span>BsSkewBinomialHeapStruc.bs_insert_correct</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"findMin q 
    == BsSkewBinomialHeapStruc.bs_findMin (Rep_SkewBinomialHeap q)"</span></span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"deleteMin q == 
    if q=empty then empty 
    else Abs_SkewBinomialHeap (
            BsSkewBinomialHeapStruc.bs_deleteMin (Rep_SkewBinomialHeap q))"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
    We don't use equality here, to prevent the code-generator
    from introducing equality-class parameter for type ‹'a›.
    Instead we use a case-distinction to check for emptiness.
›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>code</span><span> </span><span>abstract</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Rep_SkewBinomialHeap (deleteMin q) =
    (case (Rep_SkewBinomialHeap q) of Inl _ ⇒ BsSkewBinomialHeapStruc.bs_empty |
     _ ⇒ BsSkewBinomialHeapStruc.bs_deleteMin (Rep_SkewBinomialHeap q))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Rep_SkewBinomialHeap q)"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>Inl</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(Rep_SkewBinomialHeap q) = BsSkewBinomialHeapStruc.bs_empty"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>q</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>BsSkewBinomialHeapStruc.bs_empty_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deleteMin_def</span><span> 
</span><span>        </span><span>BsSkewBinomialHeapStruc.bs_deleteMin_correct</span><span> 
</span><span>        </span><span>BsSkewBinomialHeapStruc.bs_empty_correct</span><span> </span><span>empty_rep</span><span> </span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Inr</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(Rep_SkewBinomialHeap q) ≠ BsSkewBinomialHeapStruc.bs_empty"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>q</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>BsSkewBinomialHeapStruc.bs_empty_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Inr</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fold</span><span> </span><span>Inr</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deleteMin_def</span><span> 
</span><span>        </span><span>BsSkewBinomialHeapStruc.bs_deleteMin_correct</span><span> 
</span><span>        </span><span>BsSkewBinomialHeapStruc.bs_empty_correct</span><span> </span><span>empty_rep</span><span> </span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  lemma [code abstract]: "Rep_SkewBinomialHeap (deleteMin q) =
    (if (Rep_SkewBinomialHeap q = BsSkewBinomialHeapStruc.bs_empty) then BsSkewBinomialHeapStruc.bs_empty 
     else BsSkewBinomialHeapStruc.bs_deleteMin (Rep_SkewBinomialHeap q))"
    by (auto simp add: deleteMin_def BsSkewBinomialHeapStruc.bs_deleteMin_correct 
      BsSkewBinomialHeapStruc.bs_empty_correct empty_rep)
*)</span></span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"meld q1 q2 == 
    Abs_SkewBinomialHeap (BsSkewBinomialHeapStruc.bs_meld 
    (Rep_SkewBinomialHeap q1) (Rep_SkewBinomialHeap q2))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>code</span><span> </span><span>abstract</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"Rep_SkewBinomialHeap (meld q1 q2) 
    = BsSkewBinomialHeapStruc.bs_meld (Rep_SkewBinomialHeap q1) 
                                 (Rep_SkewBinomialHeap q2)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>meld_def</span><span> </span><span>BsSkewBinomialHeapStruc.bs_meld_correct</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Correctness"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>empty_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"to_mset q = {#} ⟷ q=empty"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>to_mset_def</span><span> </span><span>BsSkewBinomialHeapStruc.bs_empty_correct</span><span> </span><span>empty_rep</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>to_mset_of_empty</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"to_mset empty = {#}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>empty_correct</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>insert_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"to_mset (insert e a q) =  to_mset q + {#(e,a)#}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>insert_def</span><span> </span><span>to_mset_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>BsSkewBinomialHeapStruc.bs_insert_correct</span><span> </span><span>union_ac</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>findMin_correct</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q≠empty"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"findMin q ∈# to_mset q"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"∀y∈set_mset (to_mset q). snd (findMin q) ≤ snd y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>findMin_def</span><span> </span><span>to_mset_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>empty_rep</span><span> </span><span>BsSkewBinomialHeapStruc.bs_findMin_correct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>deleteMin_correct</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q≠empty"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"to_mset (deleteMin q) = to_mset q - {# findMin q #}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>findMin_def</span><span> </span><span>deleteMin_def</span><span> </span><span>to_mset_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>empty_rep</span><span> </span><span>BsSkewBinomialHeapStruc.bs_deleteMin_correct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>meld_correct</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"to_mset (meld q q') = to_mset q + to_mset q'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>to_mset_def</span><span> </span><span>meld_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>BsSkewBinomialHeapStruc.bs_meld_correct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Correctness lemmas to be used with simplifier›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>correct</span><span> </span><span class="delimiter">=</span><span> </span><span>empty_correct</span><span> </span><span>deleteMin_correct</span><span> </span><span>meld_correct</span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>SkewBinomialHeap</span><span class="delimiter">:</span><span> </span><span>SkewBinomialHeap_loc</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Documentation"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*#DOC
  fun [no_spec] SkewBinomialHeap.to_mset
    Abstraction to multiset.

  fun SkewBinomialHeap.empty
    The empty heap. ($O(1)$)

  fun SkewBinomialHeap.isEmpty
    Checks whether heap is empty. Mainly used to work around 
    code-generation issues. ($O(1)$)

  fun [long_type] SkewBinomialHeap.insert
    Inserts element ($O(1)$)

  fun SkewBinomialHeap.findMin
    Returns a minimal element ($O(1)$)

  fun [long_type] SkewBinomialHeap.deleteMin
    Deletes {\em the} element that is returned by {\em find\_min}. $O(\log(n))$

  fun [long_type] SkewBinomialHeap.meld
    Melds two heaps ($O(1)$)

*)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
   \underline{@{term_type "SkewBinomialHeap.to_mset"}}\\
        Abstraction to multiset.\\


    \underline{@{term_type "SkewBinomialHeap.empty"}}\\
        The empty heap. ($O(1)$)\\
    {\bf Spec} ‹SkewBinomialHeap.empty_correct›:
    @{thm [display] SkewBinomialHeap.empty_correct[no_vars]}


    \underline{@{term_type "SkewBinomialHeap.isEmpty"}}\\
        Checks whether heap is empty. Mainly used to work around
    code-generation issues. ($O(1)$)\\
    {\bf Spec} ‹SkewBinomialHeap.isEmpty_correct›:
    @{thm [display] SkewBinomialHeap.isEmpty_correct[no_vars]}


    \underline{@{term "SkewBinomialHeap.insert"}}
    @{term_type [display] "SkewBinomialHeap.insert"}
        Inserts element ($O(1)$)\\
    {\bf Spec} ‹SkewBinomialHeap.insert_correct›:
    @{thm [display] SkewBinomialHeap.insert_correct[no_vars]}


    \underline{@{term_type "SkewBinomialHeap.findMin"}}\\
        Returns a minimal element ($O(1)$)\\
    {\bf Spec} ‹SkewBinomialHeap.findMin_correct›:
    @{thm [display] SkewBinomialHeap.findMin_correct[no_vars]}


    \underline{@{term "SkewBinomialHeap.deleteMin"}}
    @{term_type [display] "SkewBinomialHeap.deleteMin"}
        Deletes {\em the} element that is returned by {\em find\_min}. $O(\log(n))$\\
    {\bf Spec} ‹SkewBinomialHeap.deleteMin_correct›:
    @{thm [display] SkewBinomialHeap.deleteMin_correct[no_vars]}


    \underline{@{term "SkewBinomialHeap.meld"}}
    @{term_type [display] "SkewBinomialHeap.meld"}
        Melds two heaps ($O(1)$)\\
    {\bf Spec} ‹SkewBinomialHeap.meld_correct›:
    @{thm [display] SkewBinomialHeap.meld_correct[no_vars]}

›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Test">
<div class="head"><h1>Theory Test</h1>
<span class="command">theory</span> <span class="name">Test</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL-Library/Code_Target_Numeral.html"><span class="name">Code_Target_Numeral</span></a> <a href="BinomialHeap.html"><span class="name">BinomialHeap</span></a> <a href="SkewBinomialHeap.html"><span class="name">SkewBinomialHeap</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Test</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Code_Target_Numeral"</span></span></span><span> </span><span>BinomialHeap</span><span> </span><span>SkewBinomialHeap</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
    This theory is included into teh session, in order to
    catch problems with code generation.
›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>sh_empty</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"unit ⇒ ('a,nat) SkewBinomialHeap"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sh_empty u ≡ SkewBinomialHeap.empty"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>sh_findMin</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,nat) SkewBinomialHeap ⇒ _"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sh_findMin ≡ SkewBinomialHeap.findMin"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>sh_deleteMin</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,nat) SkewBinomialHeap ⇒ ('a,nat) SkewBinomialHeap"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sh_deleteMin ≡ SkewBinomialHeap.deleteMin"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>sh_insert</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"_ ⇒ nat ⇒ _ ⇒ _"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sh_insert ≡ SkewBinomialHeap.insert"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>sh_meld</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,nat) SkewBinomialHeap ⇒ _"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sh_meld ≡ SkewBinomialHeap.meld"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>bh_empty</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"unit ⇒ ('a,nat) BinomialHeap"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bh_empty u ≡ BinomialHeap.empty"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>bh_findMin</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,nat) BinomialHeap ⇒ _"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bh_findMin ≡ BinomialHeap.findMin"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>bh_deleteMin</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,nat) BinomialHeap ⇒ ('a,nat) BinomialHeap"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bh_deleteMin ≡ BinomialHeap.deleteMin"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>bh_insert</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"_ ⇒ nat ⇒ _ ⇒ _"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bh_insert ≡ BinomialHeap.insert"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>bh_meld</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,nat) BinomialHeap ⇒ _"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bh_meld ≡ BinomialHeap.meld"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">export_code</span></span><span> 
</span><span>  </span><span>sh_empty</span><span>
</span><span>  </span><span>sh_findMin</span><span>
</span><span>  </span><span>sh_deleteMin</span><span>
</span><span>  </span><span>sh_insert</span><span>
</span><span>  </span><span>sh_meld</span><span>
</span><span>
</span><span>  </span><span>bh_empty</span><span>
</span><span>  </span><span>bh_findMin</span><span>
</span><span>  </span><span>bh_deleteMin</span><span>
</span><span>  </span><span>bh_insert</span><span>
</span><span>  </span><span>bh_meld</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>Haskell</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>OCaml</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>SML</span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  (* ** Binomial Heaps ** *)

  val q1 = @{code bh_insert} "a" (@{code nat_of_integer} 1)
    (@{code bh_insert} "b" (@{code nat_of_integer} 2) (@{code bh_empty} ()));
  val q2 = @{code bh_insert} "c" (@{code nat_of_integer} 3)
    (@{code bh_insert} "d" (@{code nat_of_integer} 4) (@{code bh_empty} ()));

  val q = @{code bh_meld} q1 q2;
  @{code bh_findMin} q;

  val q = @{code bh_deleteMin} q;
  @{code bh_findMin} q;


  (* ** Skew Binomial Heaps ** *)
  val q1 = @{code sh_insert} "a" (@{code nat_of_integer} 1)
    (@{code sh_insert} "b" (@{code nat_of_integer} 2) (@{code sh_empty} ()));
  val q2 = @{code sh_insert} "c" (@{code nat_of_integer} 3)
    (@{code sh_insert} "d" (@{code nat_of_integer} 4) (@{code sh_empty} ()));

  val q = @{code sh_meld} q1 q2;
  @{code sh_findMin} q;

  val q = @{code sh_deleteMin} q;
  @{code sh_findMin} q;
›</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div>