<div id="Preliminaries">
<div class="head">
<h1>Theory Preliminaries</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Preliminaries›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Preliminaries
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a> <a href="../LatticeProperties/Complete_Lattice_Prop.html">LatticeProperties.Complete_Lattice_Prop</a> 
  <a href="../LatticeProperties/Conj_Disj.html">LatticeProperties.Conj_Disj</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">notation</span></span>
  less_eq <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">⊑</span>"</span> 50<span class="main">)</span> <span class="keyword2"><span class="keyword">and</span></span>
  less <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">⊏</span>"</span> 50<span class="main">)</span> <span class="keyword2"><span class="keyword">and</span></span>
  inf <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">⊓</span>"</span> 70<span class="main">)</span> <span class="keyword2"><span class="keyword">and</span></span>
  sup <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">⊔</span>"</span> 65<span class="main">)</span> <span class="keyword2"><span class="keyword">and</span></span>
  top <span class="main">(</span><span class="quoted">"<span class="keyword1">⊤</span>"</span><span class="main">)</span> <span class="keyword2"><span class="keyword">and</span></span>
  bot <span class="main">(</span><span class="quoted">"<span class="keyword1">⊥</span>"</span><span class="main">)</span> <span class="keyword2"><span class="keyword">and</span></span>
  Inf <span class="main">(</span><span class="quoted">"<span class="keyword1">⨅</span>_"</span> <span class="main">[</span>900<span class="main">]</span> 900<span class="main">)</span> <span class="keyword2"><span class="keyword">and</span></span>
  Sup <span class="main">(</span><span class="quoted">"<span class="keyword1">⨆</span>_"</span> <span class="main">[</span>900<span class="main">]</span> 900<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Simplification Lemmas›</span></span>

<span class="keyword1"><span class="command">declare</span></span> fun_upd_idem<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>

<span class="keyword1" id="Preliminaries-simp_eq_emptyset"><span class="command">lemma</span></span> simp_eq_emptyset<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">X</span> <span class="main">=</span> <span class="main">{}</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∉</span> <span class="free">X</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="Preliminaries-mono_comp"><span class="command">lemma</span></span> mono_comp<span class="main">:</span> <span class="quoted"><span class="quoted">"mono <span class="free">f</span> <span class="main">⟹</span> mono <span class="free">g</span> <span class="main">⟹</span> mono <span class="main">(</span><span class="free">f</span> <span class="keyword1">o</span> <span class="free">g</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> mono_def<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Some lattice simplification rules›</span></span>

<span class="keyword1" id="Preliminaries-inf_bot_bot"><span class="command">lemma</span></span> inf_bot_bot<span class="main">:</span> <span class="comment1">(* FIXME *)</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span><span class="main">{</span>semilattice_inf<span class="main">,</span>order_bot<span class="main">}</span><span class="main">)</span> <span class="main">⊓</span> <span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> antisym<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Statements">
<div class="head">
<h1>Theory Statements</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Program Statements as Predicate Transformers›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Statements
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Preliminaries.html">Preliminaries</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Program statements are modeled as predicate transformers, functions from predicates to predicates.
  If $\mathit{State}$ is the type of program states, then a program $S$ is a a function from 
  $\mathit{State}\ \mathit{set}$ to
  $\mathit{State}\ \mathit{set}$. If $q \in \mathit{State}\ \mathit{set}$, then the elements of 
  $S\ q$ are the initial states from which
  $S$ is guarantied to terminate in a state from $q$.

  However, most of the time we will work with an arbitrary compleate lattice, or an arbitrary boolean algebra
  instead of the complete boolean algebra of predicate transformers. 

  We will introduce in this section assert, assume, demonic choice, angelic choice, demonic update, and 
  angelic update statements. We will prove also that these statements are monotonic.
›</span></span>

<span class="keyword1" id="Statements-mono_top"><span class="command">lemma</span></span> mono_top<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"mono top"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mono_def top_fun_def<span class="main">)</span>

<span class="keyword1" id="Statements-mono_choice"><span class="command">lemma</span></span> mono_choice<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"mono <span class="free">S</span> <span class="main">⟹</span> mono <span class="free">T</span> <span class="main">⟹</span> mono <span class="main">(</span><span class="free">S</span> <span class="main">⊓</span> <span class="free">T</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mono_def inf_fun_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> y <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="free">S</span> <span class="improper">x</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> order_trans<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> y <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="free">T</span> <span class="improper">x</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> order_trans<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Assert statement"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
The assert statement of a predicate $p$ when executed from a state $s$ fails
if $s\not\in p$ and behaves as skip otherwise.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">assert</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>semilattice_inf <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">{.</span> _ <span class="keyword1">.}</span>"</span> <span class="main">[</span>0<span class="main">]</span> 1000<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main"><span class="free">{.</span></span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main"><span class="free">.}</span></span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">≡</span>  <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">⊓</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span>"</span></span>

<span class="keyword1" id="Statements-mono_assert"><span class="command">lemma</span></span> mono_assert <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"mono <span class="main">{.</span><span class="free">p</span><span class="main">.}</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assert_def mono_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">safe</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> y <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="improper">x</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> order_trans<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Assume statement"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
The assume statement of a predicate $p$ when executed from a state $s$ is not enabled
if $s\not\in p$ and behaves as skip otherwise.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted">"<span class="entity">assume</span>"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>boolean_algebra <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">[.</span> _ <span class="keyword1">.]</span>"</span> <span class="main">[</span>0<span class="main">]</span> 1000<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main"><span class="free">[.</span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main"><span class="free">.]</span></span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">≡</span>  <span class="main">-</span><span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">⊔</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span>"</span></span>


<span class="keyword1" id="Statements-mono_assume"><span class="command">lemma</span></span> mono_assume <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"mono <span class="main">(</span>assume <span class="free">P</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assume_def mono_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> y <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="improper">y</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> order_trans<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Demonic update statement"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
The demonic update statement of a relation $Q: \mathit{State} \to \mathit{Sate} \to bool$,
when executed in a state $s$ computes nondeterministically a new state $s'$ such 
$Q\ s \ s'$ is true. In order for this statement to be correct all
possible choices of $s'$ should be correct. If there is no state $s'$
such that $Q\ s \ s'$, then the demonic update of $Q$ is not enabled
in $s$.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">demonic</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>ord<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>ord <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">[:</span> _ <span class="keyword1">:]</span>"</span> <span class="main">[</span>0<span class="main">]</span> 1000<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main"><span class="free">[:</span></span><span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main"><span class="free">:]</span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="bound">s</span> <span class="main">.</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="bound">s</span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1" id="Statements-mono_demonic"><span class="command">lemma</span></span> mono_demonic <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"mono <span class="main">[:</span><span class="free">Q</span><span class="main">:]</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mono_def demonic_def<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">theorem</span></span> demonic_bottom<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="free">R</span><span class="main">:]</span> <span class="main">(</span><span class="main">⊥</span><span class="main">::</span><span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>order_bot<span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound">s</span> <span class="main">.</span> <span class="main">(</span><span class="free">R</span> <span class="bound">s</span><span class="main">)</span> <span class="main">=</span> <span class="main">⊥</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> demonic_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">safe</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> antisym<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">theorem</span></span> demonic_bottom_top <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="main">(</span><span class="main">⊥</span><span class="main">::</span><span class="main">_</span><span class="main">::</span>order_bot<span class="main">)</span><span class="main">:]</span>  <span class="main">=</span> <span class="main">⊤</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff inf_fun_def sup_fun_def demonic_def top_fun_def bot_fun_def<span class="main">)</span>

<span class="keyword1"><span class="command">theorem</span></span> demonic_sup_inf<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="free">Q</span> <span class="main">⊔</span> <span class="free">Q'</span><span class="main">:]</span> <span class="main">=</span> <span class="main">[:</span><span class="free">Q</span><span class="main">:]</span> <span class="main">⊓</span> <span class="main">[:</span><span class="free">Q'</span><span class="main">:]</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff sup_fun_def inf_fun_def demonic_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Angelic update statement"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
The angelic update statement of a relation $Q: \mathit{State} \to \mathit{State} \to \mathit{bool}$ is similar
to the demonic version, except that it is enough that at least for one choice $s'$, $Q \ s \ s'$
is correct. If there is no state $s'$
such that $Q\ s \ s'$, then the angelic update of $Q$ fails in $s$.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">angelic</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span><span class="main">{</span>semilattice_inf<span class="main">,</span>order_bot<span class="main">}</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span> 
               <span class="main">(</span><span class="quoted">"<span class="keyword1">{:</span> _ <span class="keyword1">:}</span>"</span> <span class="main">[</span>0<span class="main">]</span> 1000<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main"><span class="free">{:</span></span><span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main"><span class="free">:}</span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="bound">s</span> <span class="main">.</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="bound">s</span><span class="main">)</span> <span class="main">⊓</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">syntax</span></span> <span class="quoted">"_update"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"patterns <span class="main">=&gt;</span> patterns <span class="main">=&gt;</span> logic <span class="main">=&gt;</span> logic"</span></span> <span class="main">(</span><span class="quoted">"_ <span class="keyword1">↝</span> _ <span class="keyword1">.</span> _"</span> 0<span class="main">)</span>
<span class="keyword1"><span class="command">translations</span></span>
  <span class="quoted">"_update <span class="main">(</span>_patterns <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>_patterns <span class="free">y</span> <span class="free">ys</span><span class="main">)</span> <span class="free">t</span>"</span> <span class="main">==</span> <span class="quoted">"<span class="keyword1">CONST</span> id <span class="main">(</span>_abs
           <span class="main">(</span>_pattern <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>_Coll <span class="main">(</span>_pattern <span class="free">y</span> <span class="free">ys</span><span class="main">)</span> <span class="free">t</span><span class="main">)</span><span class="main">)</span>"</span>
  <span class="quoted">"_update <span class="free">x</span> <span class="free">y</span> <span class="free">t</span>"</span> <span class="main">==</span> <span class="quoted">"<span class="keyword1">CONST</span> id <span class="main">(</span>_abs <span class="free">x</span> <span class="main">(</span>_Coll <span class="free">y</span> <span class="free">t</span><span class="main">)</span><span class="main">)</span>"</span>

<span class="keyword1"><span class="command">term</span></span> <span class="quoted"><span class="quoted">"<span class="main">{:</span> <span class="bound">y</span><span class="main">,</span> <span class="bound">z</span> <span class="main">↝</span> <span class="bound">x</span><span class="main">,</span> <span class="bound">z'</span> <span class="main">.</span> <span class="free">P</span> <span class="bound">x</span> <span class="bound">y</span> <span class="bound">z</span> <span class="bound">z'</span> <span class="main">:}</span>"</span></span>

<span class="keyword1"><span class="command">theorem</span></span> angelic_bottom <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"angelic <span class="free">R</span> <span class="main">⊥</span>  <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> angelic_def inf_bot_bot<span class="main">)</span>

<span class="keyword1"><span class="command">theorem</span></span> angelic_disjunctive <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">{:</span><span class="main">(</span><span class="free">R</span><span class="main">::</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_distrib_lattice<span class="main">)</span><span class="main">)</span><span class="main">:}</span> <span class="main">∈</span> Apply.Disjunctive"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Apply.Disjunctive_def angelic_def inf_Sup<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"The guard of a statement"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
The guard of a statement $S$ is the set of iniatial states from which $S$
is enabled or fails.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">grd</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span><span class="main">)</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>boolean_algebra<span class="main">)</span> <span class="main">=</span> <span class="main">-</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">S</span></span></span> bot<span class="main">)</span>"</span></span>

<span class="keyword1" id="Statements-grd_choice"><span class="command">lemma</span></span> grd_choice<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"grd <span class="main">(</span><span class="free">S</span> <span class="main">⊓</span> <span class="free">T</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>grd <span class="free">S</span><span class="main">)</span> <span class="main">⊔</span> <span class="main">(</span>grd <span class="free">T</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> grd_def inf_fun_def<span class="main">)</span>

<span class="keyword1" id="Statements-grd_demonic"><span class="command">lemma</span></span> grd_demonic<span class="main">:</span> <span class="quoted"><span class="quoted">"grd <span class="main">[:</span><span class="free">Q</span><span class="main">:]</span> <span class="main">=</span> <span class="main">{</span><span class="bound">s</span> <span class="main">.</span> <span class="main">∃</span> <span class="bound">s'</span> <span class="main">.</span> <span class="bound">s'</span> <span class="main">∈</span> <span class="main">(</span><span class="free">Q</span> <span class="bound">s</span><span class="main">)</span> <span class="main">}</span>"</span></span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> grd_def demonic_def<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="Statements-grd_demonic_2"><span class="command">lemma</span></span> grd_demonic_2<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">s</span> <span class="main">∉</span> grd <span class="main">[:</span><span class="free">Q</span><span class="main">:]</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">s'</span> <span class="main">.</span> <span class="bound">s'</span> <span class="main">∉</span>  <span class="main">(</span><span class="free">Q</span> <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> grd_demonic<span class="main">)</span>

<span class="keyword1"><span class="command">theorem</span></span> grd_angelic<span class="main">:</span>
  <span class="quoted"><span class="quoted">"grd <span class="main">{:</span><span class="free">R</span><span class="main">:}</span> <span class="main">=</span> UNIV"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> grd_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Hoare">
<div class="head">
<h1>Theory Hoare</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Hoare Triples›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Hoare
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Statements.html">Statements</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
A hoare triple for $p,q\in \mathit{State}\ \mathit{set}$, and 
$S : \mathit{State}\ \mathit{set} \to \mathit{State}\ \mathit{set}$ is valid,
denoted $\models p \{|S|\} q$, if every execution of $S$ starting from state $s\in p$
always terminates, and if it terminates in state $s'$, then $s'\in q$. When $S$ is
modeled as a predicate transformer, this definition is equivalent to requiring that
$p$ is a subset of the initial states from which the execution of $S$ is guaranteed
to terminate in $q$, that is $p \subseteq S\ q$.

The formal definition of a valid hoare triple only assumes that $p$ (and also $S\ q$) ranges
over a complete lattice.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">Hoare</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_distrib_lattice <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">⊨</span> <span class="keyword3">(</span>_<span class="keyword3">)</span><span class="keyword1">{|</span> _ <span class="keyword1">|}</span><span class="keyword3">(</span>_<span class="keyword3">)</span>"</span> <span class="main">[</span>0<span class="main">,</span>0<span class="main">,</span>900<span class="main">]</span> 900<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main"><span class="free">⊨</span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main"><span class="free">{|</span></span><span class="free"><span class="bound"><span class="entity">S</span></span></span><span class="main"><span class="free">|}</span></span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≤</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="free"><span class="bound"><span class="entity">q</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">theorem</span></span> hoare_sequential<span class="main">:</span>
  <span class="quoted"><span class="quoted">"mono <span class="free">S</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">⊨</span> <span class="free">p</span> <span class="main">{|</span> <span class="free">S</span> <span class="keyword1">o</span> <span class="free">T</span> <span class="main">|}</span> <span class="free">r</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">q</span><span class="main">.</span> <span class="main">⊨</span> <span class="free">p</span> <span class="main">{|</span> <span class="free">S</span> <span class="main">|}</span> <span class="bound">q</span> <span class="main">∧</span> <span class="main">⊨</span> <span class="bound">q</span> <span class="main">{|</span> <span class="free">T</span> <span class="main">|}</span> <span class="free">r</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">)</span></span> Hoare_def monoD o_def order_refl order_trans<span class="main">)</span>

<span class="keyword1"><span class="command">theorem</span></span> hoare_choice<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⊨</span> <span class="free">p</span> <span class="main">{|</span> <span class="free">S</span> <span class="main">⊓</span> <span class="free">T</span> <span class="main">|}</span> <span class="free">q</span> <span class="main">=</span> <span class="main">(</span><span class="main">⊨</span> <span class="free">p</span> <span class="main">{|</span> <span class="free">S</span> <span class="main">|}</span> <span class="free">q</span> <span class="main">∧</span> <span class="main">⊨</span> <span class="free">p</span> <span class="main">{|</span> <span class="free">T</span> <span class="main">|}</span> <span class="free">q</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Hoare_def inf_fun_def<span class="main">)</span>

<span class="keyword1"><span class="command">theorem</span></span> hoare_assume<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⊨</span> <span class="free">P</span> <span class="main">{|</span> <span class="main">[.</span><span class="free">R</span><span class="main">.]</span> <span class="main">|}</span> <span class="free">Q</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">P</span> <span class="main">⊓</span> <span class="free">R</span> <span class="main">≤</span> <span class="free">Q</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Hoare_def assume_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>inf <span class="free">P</span> <span class="free">R</span><span class="main">)</span> <span class="main">≤</span> <span class="main">(</span>inf <span class="main">(</span>sup <span class="main">(</span><span class="main">-</span> <span class="free">R</span><span class="main">)</span> <span class="free">Q</span><span class="main">)</span> <span class="free">R</span><span class="main">)</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inf_sup_distrib2<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> le_infI1<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>sup <span class="main">(</span><span class="main">-</span><span class="free">R</span><span class="main">)</span> <span class="main">(</span>inf <span class="free">P</span> <span class="free">R</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> sup <span class="main">(</span><span class="main">-</span> <span class="free">R</span><span class="main">)</span> <span class="free">Q</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sup_inf_distrib1<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> le_supI2<span class="main">)</span>

<span class="keyword1"><span class="command">theorem</span></span> hoare_mono<span class="main">:</span>
  <span class="quoted"><span class="quoted">"mono <span class="free">S</span> <span class="main">⟹</span> <span class="free">Q</span> <span class="main">≤</span> <span class="free">R</span> <span class="main">⟹</span> <span class="main">⊨</span> <span class="free">P</span> <span class="main">{|</span> <span class="free">S</span> <span class="main">|}</span> <span class="free">Q</span> <span class="main">⟹</span> <span class="main">⊨</span> <span class="free">P</span> <span class="main">{|</span> <span class="free">S</span> <span class="main">|}</span> <span class="free">R</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mono_def Hoare_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> y <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="free">S</span> <span class="free">Q</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> order_trans<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">theorem</span></span> hoare_pre<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">≤</span> <span class="free">P</span> <span class="main">⟹</span> <span class="main">⊨</span> <span class="free">P</span> <span class="main">{|</span> <span class="free">S</span> <span class="main">|}</span> <span class="free">Q</span> <span class="main">⟹</span> <span class="main">⊨</span> <span class="free">R</span> <span class="main">{|</span> <span class="free">S</span> <span class="main">|}</span> <span class="free">Q</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Hoare_def<span class="main">)</span>

<span class="keyword1"><span class="command">theorem</span></span> hoare_Sup<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span> <span class="bound">p</span> <span class="main">∈</span> <span class="free">P</span> <span class="main">.</span> <span class="main">⊨</span> <span class="bound">p</span> <span class="main">{|</span> <span class="free">S</span> <span class="main">|}</span> <span class="free">q</span><span class="main">)</span> <span class="main">=</span> <span class="main">⊨</span> Sup <span class="free">P</span> <span class="main">{|</span> <span class="free">S</span> <span class="main">|}</span> <span class="free">q</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Hoare_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">safe</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Sup_least<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> y <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="main">⨆</span><span class="free">P</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> order_trans<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Sup_upper<span class="main">)</span>
  
<span class="keyword1" id="Hoare-hoare_magic"><span class="command">lemma</span></span> hoare_magic <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⊨</span> <span class="free">P</span> <span class="main">{|</span> <span class="main">⊤</span> <span class="main">|}</span> <span class="free">Q</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Hoare_def top_fun_def<span class="main">)</span>

<span class="keyword1" id="Hoare-hoare_demonic"><span class="command">lemma</span></span> hoare_demonic<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⊨</span> <span class="free">P</span> <span class="main">{|</span> <span class="main">[:</span><span class="free">R</span><span class="main">:]</span> <span class="main">|}</span> <span class="free">Q</span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">s</span> <span class="main">.</span> <span class="bound">s</span> <span class="main">∈</span> <span class="free">P</span> <span class="main">⟶</span>  <span class="free">R</span> <span class="bound">s</span> <span class="main">⊆</span> <span class="free">Q</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> Hoare_def demonic_def<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Hoare-hoare_not_guard"><span class="command">lemma</span></span> hoare_not_guard<span class="main">:</span>
  <span class="quoted"><span class="quoted">"mono <span class="main">(</span><span class="free">S</span> <span class="main">::</span> <span class="main">(</span><span class="main">_</span><span class="main">::</span>order_bot<span class="main">)</span> <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">⊨</span> <span class="free">p</span> <span class="main">{|</span> <span class="free">S</span> <span class="main">|}</span> <span class="free">q</span> <span class="main">=</span> <span class="main">⊨</span> <span class="main">(</span><span class="free">p</span> <span class="main">⊔</span> <span class="main">(</span><span class="main">-</span> grd <span class="free">S</span><span class="main">)</span><span class="main">)</span> <span class="main">{|</span> <span class="free">S</span> <span class="main">|}</span> <span class="free">q</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Hoare_def grd_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">safe</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> monoD<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Hoare rule for recursive statements›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
A statement $S$ is refined by another statement $S'$ if $\models p \{| S' |\} q$ 
is true for all $p$ and $q$ such that  $\models p \{| S |\} q$ is true. This
is equivalent to $S \le S'$. 

Next theorem can be used to prove refinement of a recursive program. A recursive
program is modeled as the least fixpoint of a monotonic mapping from predicate
transformers to predicate transformers.
›</span></span>

<span class="keyword1"><span class="command">theorem</span></span> lfp_wf_induction<span class="main">:</span>
  <span class="quoted"><span class="quoted">"mono <span class="free">f</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">w</span> <span class="main">.</span> <span class="main">(</span><span class="free">p</span> <span class="bound">w</span><span class="main">)</span> <span class="main">≤</span> <span class="free">f</span> <span class="main">(</span>Sup_less <span class="free">p</span> <span class="bound">w</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> Sup <span class="main">(</span>range <span class="free">p</span><span class="main">)</span> <span class="main">≤</span> lfp <span class="free">f</span>"</span></span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> fp_wf_induction<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">drule</span> lfp_unfold<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">post_fun</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>order<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="keyword1">then</span> <span class="main">⊤</span> <span class="keyword1">else</span> <span class="main">⊥</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Hoare-post_mono"><span class="command">lemma</span></span> post_mono <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"mono <span class="main">(</span>post_fun <span class="free">p</span> <span class="main">::</span> <span class="main">(</span><span class="main">_</span><span class="main">::</span><span class="main">{</span>order_bot<span class="main">,</span>order_top<span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> post_fun_def  mono_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">safe</span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">≤</span> <span class="improper">y</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
   <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule_tac</span> y <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="improper">x</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> order_trans<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1" id="Hoare-post_top"><span class="command">lemma</span></span> post_top <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"post_fun <span class="free">p</span> <span class="free">p</span> <span class="main">=</span> <span class="main">⊤</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> post_fun_def<span class="main">)</span>

<span class="keyword1" id="Hoare-post_refin"><span class="command">lemma</span></span> post_refin <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"mono <span class="free">S</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">(</span><span class="free">S</span> <span class="free">p</span><span class="main">)</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>bounded_lattice<span class="main">)</span> <span class="main">⊓</span> <span class="main">(</span>post_fun <span class="free">p</span><span class="main">)</span> <span class="free">x</span> <span class="main">≤</span> <span class="free">S</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> le_fun_def post_fun_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">safe</span><span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule_tac</span> f <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="free">S</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> monoD<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
Next theorem shows the equivalence between the validity of Hoare
triples and refinement statements. This theorem together with the
theorem for refinement of recursive programs will be used to prove
a Hoare rule for recursive programs.
›</span></span>

<span class="keyword1"><span class="command">theorem</span></span> hoare_refinement_post<span class="main">:</span>
  <span class="quoted"><span class="quoted">"mono <span class="free">f</span> <span class="main">⟹</span>  <span class="main">(</span><span class="main">⊨</span> <span class="free">x</span> <span class="main">{|</span> <span class="free">f</span> <span class="main">|}</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">{.</span><span class="free">x</span><span class="main">.}</span> <span class="keyword1">o</span> <span class="main">(</span>post_fun <span class="free">y</span><span class="main">)</span> <span class="main">≤</span> <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Hoare_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> le_fun_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assert_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">safe</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> y <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="free">y</span> <span class="main">⊓</span> post_fun <span class="free">y</span> <span class="improper">xa</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> order_trans<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> y <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> order_trans<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assert_def<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">drule_tac</span> x <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
Next theorem gives a Hoare rule for recursive programs. If we can prove correct the unfolding 
of the recursive definition applid to a program $f$, $\models p\ w\ \{| F\  f |\}\  y$, assumming
that $f$ is correct when starting from $p\  v$, $v&lt;w$, $\models SUP-L\  p\  w\  \{| f |\}\  y$, then
the recursive program is correct $\models SUP\ p\ \{| lfp\  F |\}\  y$
›</span></span>

<span class="keyword1" id="Hoare-assert_Sup"><span class="command">lemma</span></span> assert_Sup<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{.</span><span class="main">⨆</span> <span class="main">(</span><span class="free">X</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>complete_distrib_lattice set<span class="main">)</span><span class="main">.}</span> <span class="main">=</span> <span class="main">⨆</span> <span class="main">(</span>assert <span class="main">`</span> <span class="free">X</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff assert_def Sup_inf image_comp<span class="main">)</span>

<span class="keyword1" id="Hoare-assert_Sup_range"><span class="command">lemma</span></span> assert_Sup_range<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{.</span><span class="main">⨆</span> <span class="main">(</span>range <span class="main">(</span><span class="free">p</span><span class="main">::</span><span class="tfree">'W</span> <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">::</span>complete_distrib_lattice<span class="main">)</span><span class="main">)</span><span class="main">.}</span> <span class="main">=</span> <span class="main">⨆</span> <span class="main">(</span>range <span class="main">(</span>assert <span class="keyword1">o</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff assert_def SUP_inf image_comp<span class="main">)</span>

<span class="keyword1" id="Hoare-Sup_range_comp"><span class="command">lemma</span></span> Sup_range_comp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⨆</span> range <span class="free">p</span><span class="main">)</span> <span class="keyword1">o</span> <span class="free">S</span> <span class="main">=</span> <span class="main">⨆</span> <span class="main">(</span>range <span class="main">(</span><span class="main">λ</span> <span class="bound">w</span> <span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="free">p</span> <span class="bound">w</span><span class="main">)</span> <span class="keyword1">o</span> <span class="free">S</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff image_comp<span class="main">)</span>

<span class="keyword1" id="Hoare-Sup_less_comp"><span class="command">lemma</span></span> Sup_less_comp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Sup_less <span class="free">P</span><span class="main">)</span> <span class="free">w</span> <span class="keyword1">o</span> <span class="free">S</span> <span class="main">=</span> Sup_less <span class="main">(</span><span class="main">λ</span> <span class="bound">w</span> <span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="free">P</span> <span class="bound">w</span><span class="main">)</span> <span class="keyword1">o</span> <span class="free">S</span><span class="main">)</span><span class="main">)</span> <span class="free">w</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Sup_less_def fun_eq_iff<span class="main"><span class="keyword3">,</span></span> <span class="operator">safe</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="main">(</span><span class="free">S</span> <span class="improper">x</span><span class="main">)</span><span class="main">)</span> <span class="main">`</span> <span class="main">{</span><span class="bound">y</span><span class="main">.</span> <span class="main">∃</span><span class="bound"><span class="bound">v</span></span><span class="main">&lt;</span><span class="free">w</span><span class="main">.</span> <span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">y</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">P</span> <span class="bound">v</span> <span class="bound">x</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="improper">x</span><span class="main">)</span> <span class="main">`</span> <span class="main">{</span><span class="bound">y</span><span class="main">.</span> <span class="main">∃</span><span class="bound"><span class="bound">v</span></span><span class="main">&lt;</span><span class="free">w</span><span class="main">.</span> <span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">y</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">P</span> <span class="bound">v</span> <span class="main">(</span><span class="free">S</span> <span class="bound">x</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">cong</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> SUP_cong_simp<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Hoare-Sup_less_assert"><span class="command">lemma</span></span> Sup_less_assert<span class="main">:</span> <span class="quoted"><span class="quoted">"Sup_less <span class="main">(</span><span class="main">λ</span><span class="bound">w</span><span class="main">.</span> <span class="main">{.</span> <span class="main">(</span><span class="free">p</span> <span class="bound">w</span><span class="main">)</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>complete_distrib_lattice <span class="main">.}</span><span class="main">)</span> <span class="free">w</span> <span class="main">=</span> <span class="main">{.</span>Sup_less <span class="free">p</span> <span class="free">w</span><span class="main">.}</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Sup_less_def assert_Sup image_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">y</span><span class="main">.</span> <span class="main">∃</span><span class="bound"><span class="bound">v</span></span><span class="main">&lt;</span><span class="free">w</span><span class="main">.</span> <span class="bound">y</span> <span class="main">=</span> <span class="main">{.</span> <span class="free">p</span> <span class="bound">v</span> <span class="main">.}</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span><span class="bound">y</span><span class="main">.</span> <span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="main">∃</span><span class="bound"><span class="bound">v</span></span><span class="main">&lt;</span><span class="free">w</span><span class="main">.</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">p</span> <span class="bound">v</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">=</span> <span class="main">{.</span> <span class="bound">x</span> <span class="main">.}</span><span class="main">}</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> image_def <span class="quasi_keyword">cong</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> SUP_cong_simp<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">declare</span></span> mono_comp<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>

<span class="keyword1"><span class="command">theorem</span></span> hoare_fixpoint<span class="main">:</span>
  <span class="quoted"><span class="quoted">"mono_mono <span class="free">F</span> <span class="main">⟹</span>
   <span class="main">(</span><span class="main">!!</span> <span class="bound">w</span> <span class="bound">f</span> <span class="main">.</span> mono <span class="bound">f</span> <span class="main">∧</span> <span class="main">⊨</span> Sup_less <span class="free">p</span> <span class="bound">w</span> <span class="main">{|</span> <span class="bound">f</span> <span class="main">|}</span> <span class="free">y</span> <span class="main">⟹</span> <span class="main">⊨</span> <span class="free">p</span> <span class="bound">w</span> <span class="main">{|</span> <span class="free">F</span> <span class="bound">f</span> <span class="main">|}</span> <span class="free">y</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">⊨</span> <span class="main">(</span>Sup <span class="main">(</span>range <span class="free">p</span><span class="main">)</span><span class="main">)</span> <span class="main">{|</span> lfp <span class="free">F</span> <span class="main">|}</span> <span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mono_mono_def hoare_refinement_post assert_Sup_range Sup_range_comp<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> lfp_wf_induction<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Sup_less_comp <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> sym<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Sup_less_assert<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="main">{.</span> Sup_less <span class="free">p</span> <span class="improper">w</span> <span class="main">.}</span> <span class="main">∘</span> post_fun <span class="free">y</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main"><span class="keyword3">,</span></span> <span class="operator">safe</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hoare_refinement_post<span class="main">)</span>

<span class="keyword1"><span class="command">theorem</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span> <span class="bound">t</span> <span class="main">.</span> <span class="main">⊨</span> <span class="main">(</span><span class="main">{</span><span class="bound">s</span> <span class="main">.</span> <span class="bound">t</span> <span class="main">∈</span> <span class="free">R</span> <span class="bound">s</span><span class="main">}</span><span class="main">)</span> <span class="main">{|</span><span class="free">S</span><span class="main">|}</span> <span class="free">q</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">⊨</span> <span class="main">(</span><span class="main">{:</span><span class="free">R</span><span class="main">:}</span> <span class="free">p</span><span class="main">)</span> <span class="main">{|</span> <span class="free">S</span> <span class="main">|}</span> <span class="free">q</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Hoare_def angelic_def subset_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Diagram">
<div class="head">
<h1>Theory Diagram</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Predicate Transformers Semantics of Invariant Diagrams›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Diagram
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Hoare.html">Hoare</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
This theory introduces the concept of a transition diagram and proves
a number of Hoare total corectness rules for these diagrams. As before
the diagrams are introduced using their predicate transformer semantics.

A transition diagram $D$ is a function from pairs of indexes to predicate
transformers: $D:I\times I \to (\mathit{State}\ \mathit{set}\to \mathit{State}\ \mathit{set})$, or more
general $D:I\times I \to \mathit{Ptran}$, where $\mathit{Ptran}$ is a complete lattice. The elements
of $I$ are called situations and intuitively a diagram is executed starting
in a situation $i\in I$ by choosing a transition $D (i,j)$ which is enabled
and continuing similarly from $j$ if there are enabled trasitions. The 
execution of a diagram stops when there are no more transitions enabled or
when it fails.

The semantics of a transition diagram is an indexed predicate transformer 
($I\to \mathit{State}\ \mathit{set}$).
If $Q:I\to \mathit{State}\ \mathit{set}$ is an indexed predicate, then $p = \mathit{pt}\ D\ Q\ i$ is a
weakest predicate such that if the executution of $D$ starts in a state
$s\in p$ from situation $i$, then it terminates, and if it terminates
in situation $j$ and state $s'$, then $s'\in Q \  j$.

We introduce first the indexed predicate transformer $\mathit{step}\ D$ of executing
one step of diagram $D$. The predicate $step\ D\ Q\ i$ is true for those
states $s$ from which the execution of one step of $D$ starting in situation 
$i$ ends in one of the situations $j$ such that $Q \, j$ is true.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">step</span> <span class="free"><span class="bound"><span class="entity">D</span></span></span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">INF</span> <span class="bound">j</span> <span class="main">.</span> <span class="free"><span class="bound"><span class="entity">D</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span> <span class="bound">j</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="bound">j</span><span class="main">)</span> <span class="main">::</span> <span class="main">_</span> <span class="main">::</span> complete_lattice<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">dmono</span> <span class="free"><span class="bound"><span class="entity">D</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">ij</span> <span class="main">.</span> mono <span class="main">(</span><span class="free"><span class="bound"><span class="entity">D</span></span></span> <span class="bound">ij</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Diagram-dmono_mono"><span class="command">lemma</span></span> dmono_mono <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"dmono <span class="free">D</span> <span class="main">⟹</span> mono <span class="main">(</span><span class="free">D</span> <span class="free">ij</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dmono_def<span class="main">)</span>

<span class="keyword1"><span class="command">theorem</span></span> mono_step <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"dmono <span class="free">D</span> <span class="main">⟹</span> mono <span class="main">(</span>step <span class="free">D</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dmono_def mono_def le_fun_def step_def Inf_fun_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> INF_greatest<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> y <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="free">D</span><span class="main">(</span><span class="improper">xa</span><span class="main">,</span> <span class="improper">j</span><span class="main">)</span> <span class="main">(</span><span class="improper">x</span> <span class="improper">j</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> order_trans<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> INF_lower<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
The indexed predicate transformer of a transition diagram is defined as the least
fixpoint of the unfolding of the execution of the diagram. The indexed predicate
transformer $dgr\ D\ U$ is the choice between executing one step of $D$ follwed by
$U$ ($(\mathit{step}\ D)\circ U$) or skip if no transion of $D$ is enabled 
($\mathit{assume}\ \neg \mathit{grd} (\mathit{step}\ D)$).
›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">dgr</span> <span class="free"><span class="bound"><span class="entity">D</span></span></span> <span class="free"><span class="bound"><span class="entity">U</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span>step <span class="free"><span class="bound"><span class="entity">D</span></span></span><span class="main">)</span> <span class="keyword1">o</span> <span class="free"><span class="bound"><span class="entity">U</span></span></span><span class="main">)</span> <span class="main">⊓</span> <span class="main">[.</span><span class="main">-</span><span class="main">(</span>grd <span class="main">(</span>step <span class="free"><span class="bound"><span class="entity">D</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">.]</span>"</span></span>

<span class="keyword1"><span class="command">theorem</span></span> mono_mono_dgr <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"dmono <span class="free">D</span> <span class="main">⟹</span> mono_mono <span class="main">(</span>dgr <span class="free">D</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mono_mono_def mono_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dgr_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> le_fun_def inf_fun_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> y <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>step <span class="free">D</span> <span class="main">(</span><span class="improper">x</span> <span class="improper">xa</span><span class="main">)</span> <span class="improper">xb</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> order_trans<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"mono <span class="main">(</span>step <span class="free">D</span><span class="main">)</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mono_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> le_fun_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> y <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>step <span class="free">D</span> <span class="main">(</span><span class="improper">f</span> <span class="improper">x</span><span class="main">)</span> <span class="improper">xa</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> order_trans<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"mono <span class="main">(</span>step <span class="free">D</span><span class="main">)</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mono_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> le_fun_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> y <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>assume <span class="main">(</span><span class="main">-</span> grd <span class="main">(</span>step <span class="free">D</span><span class="main">)</span><span class="main">)</span> <span class="improper">x</span> <span class="improper">xa</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> order_trans<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"mono <span class="main">(</span>assume <span class="main">(</span><span class="main">-</span> grd <span class="main">(</span>step <span class="free">D</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mono_def le_fun_def<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">pt</span> <span class="free"><span class="bound"><span class="entity">D</span></span></span> <span class="main">=</span> lfp <span class="main">(</span>dgr <span class="free"><span class="bound"><span class="entity">D</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
If $U$ is an indexed predicate transformer and if $P, Q:I\to \mathit{State} \ \mathit{set}$
are indexed predicates, then the meaning of the Hoare triple defined earlier,
$\models P \{ | U | \} Q$, is that if
we start $U$ in a state $s$ from a situation $i$ such that $s\in P\, i$,
then U terminates, and if it terminates in $s'$ and situation $j$, then
$s'\in Q\ j$ is true.

Next theorem shows that in a diagram all transitions are correct
if and only if $\mathit{step}\ D$ is correct.
›</span></span>

<span class="keyword1"><span class="command">theorem</span></span> hoare_step<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span> <span class="bound">i</span> <span class="bound">j</span> <span class="main">.</span> <span class="main">⊨</span> <span class="main">(</span><span class="free">P</span> <span class="bound">i</span><span class="main">)</span> <span class="main">{|</span> <span class="free">D</span><span class="main">(</span><span class="bound">i</span><span class="main">,</span><span class="bound">j</span><span class="main">)</span> <span class="main">|}</span> <span class="main">(</span><span class="free">Q</span> <span class="bound">j</span><span class="main">)</span> <span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⊨</span> <span class="free">P</span> <span class="main">{|</span> step <span class="free">D</span> <span class="main">|}</span> <span class="free">Q</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> le_fun_def Hoare_def step_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> INF_greatest<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> le_fun_def Hoare_def step_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule_tac</span> x <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="improper">i</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> allE<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> y <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">INF</span> <span class="bound">j</span><span class="main">.</span> <span class="free">D</span><span class="main">(</span><span class="improper">i</span><span class="main">,</span> <span class="bound">j</span><span class="main">)</span> <span class="main">(</span><span class="free">Q</span> <span class="bound">j</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> order_trans<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> INF_lower<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
Next theorem provides the first proof rule for total correctnes of transition
diagrams. If all transitions are correct and if a global variant decreases 
on every transition then the diagram is correct and it terminates. The variant
must decrease according to a well founded and transitive relation.
›</span></span>

<span class="keyword1"><span class="command">theorem</span></span> hoare_diagram<span class="main">:</span>
  <span class="quoted"><span class="quoted">"dmono <span class="free">D</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">w</span> <span class="bound">i</span> <span class="bound">j</span> <span class="main">.</span> <span class="main">⊨</span> <span class="free">X</span> <span class="bound">w</span> <span class="bound">i</span>  <span class="main">{|</span> <span class="free">D</span><span class="main">(</span><span class="bound">i</span><span class="main">,</span><span class="bound">j</span><span class="main">)</span> <span class="main">|}</span> Sup_less <span class="free">X</span> <span class="bound">w</span> <span class="bound">j</span><span class="main">)</span> <span class="main">⟹</span> 
    <span class="main">⊨</span> <span class="main">(</span>Sup <span class="main">(</span>range <span class="free">X</span><span class="main">)</span><span class="main">)</span> <span class="main">{|</span> pt <span class="free">D</span> <span class="main">|}</span> <span class="main">(</span>Sup<span class="main">(</span>range <span class="free">X</span><span class="main">)</span> <span class="main">⊓</span> <span class="main">-</span><span class="main">(</span>grd <span class="main">(</span>step <span class="free">D</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hoare_step pt_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> hoare_fixpoint<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dgr_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hoare_choice<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hoare_sequential<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hoare_assume<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> le_infI1<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> SUP_upper<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
This theorem is a more general form of the more familiar form with a variant $t$
which must decrease. If we take $X\ w\ i = (Y \ i \land t\ i = w)$, then the
second hypothesis of the theorem above becomes
$\models Y \ i \land t\ i = w \{| D(i,j) |\} Y \ i \land t \ i &lt; w$. However,
the more general form of the theorem is needed, because
in data refinements, the form $Y\ i \land t\ i = w$ cannot be preserved.
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
The drawback of this theorem is that the variant must be decreased on every
transitions which may be too cumbersome for practical applications. A similar 
situation occur when introducing proof rules for mutually recursive procedures.
There the straightforward generalization of the proof rule of a recursive procedure
to mutually recursive procedures suffers of a similar problem. We would need
to prove that the variant decreases before every recursive call. Nipkow
\cite{nipkow:2002} has introduced a rule for mutually recursive procedures
in which the variant is required to decrease only in a sequence of recursive
calls before calling again a procedure in this sequence. We introduce a
similar proof rule in which the variant depends also on the situation
indexes.
›</span></span>

<span class="keyword1"><span class="command">locale</span></span> DiagramTermination <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">pair</span><span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'c</span><span class="main">::</span>well_founded_transitive<span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">SUP_L_P</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">SUP</span> <span class="bound">v</span><span class="main">∈</span><span class="main">{</span><span class="bound">v</span><span class="main">.</span> <span class="free">pair</span> <span class="bound">v</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">}</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="bound">v</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">::</span> <span class="main">_</span> <span class="main">::</span> complete_lattice<span class="main">)</span>"</span></span> 

<span class="keyword1"><span class="command">definition</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">SUP_LE_P</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">SUP</span> <span class="bound">v</span><span class="main">∈</span><span class="main">{</span><span class="bound">v</span><span class="main">.</span> <span class="free">pair</span> <span class="bound">v</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">}</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="bound">v</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">::</span> <span class="main">_</span> <span class="main">::</span> complete_lattice<span class="main">)</span>"</span></span>

<span class="keyword1" id="Diagram-SUP_L_P_upper"><span class="command">lemma</span></span> SUP_L_P_upper<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">pair</span> <span class="free">v</span> <span class="free">i</span> <span class="main">&lt;</span> <span class="free">u</span> <span class="main">⟹</span> <span class="free">P</span> <span class="free">v</span> <span class="free">i</span> <span class="main">≤</span> SUP_L_P <span class="free">P</span> <span class="free">u</span> <span class="free">i</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> SUP_L_P_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> SUP_upper<span class="main">)</span>

<span class="keyword1" id="Diagram-SUP_L_P_least"><span class="command">lemma</span></span> SUP_L_P_least<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">!!</span> <span class="bound">v</span> <span class="main">.</span> <span class="free">pair</span> <span class="bound">v</span> <span class="free">i</span> <span class="main">&lt;</span> <span class="free">u</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">v</span> <span class="free">i</span> <span class="main">≤</span> <span class="free">Q</span><span class="main">)</span> <span class="main">⟹</span> SUP_L_P <span class="free">P</span> <span class="free">u</span> <span class="free">i</span> <span class="main">≤</span> <span class="free">Q</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> SUP_L_P_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> SUP_least<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="Diagram-SUP_LE_P_upper"><span class="command">lemma</span></span> SUP_LE_P_upper<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">pair</span> <span class="free">v</span> <span class="free">i</span> <span class="main">≤</span> <span class="free">u</span> <span class="main">⟹</span> <span class="free">P</span> <span class="free">v</span> <span class="free">i</span> <span class="main">≤</span> SUP_LE_P <span class="free">P</span> <span class="free">u</span> <span class="free">i</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> SUP_LE_P_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> SUP_upper<span class="main">)</span>

<span class="keyword1" id="Diagram-SUP_LE_P_least"><span class="command">lemma</span></span> SUP_LE_P_least<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">!!</span> <span class="bound">v</span> <span class="main">.</span> <span class="free">pair</span> <span class="bound">v</span> <span class="free">i</span> <span class="main">≤</span> <span class="free">u</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">v</span> <span class="free">i</span> <span class="main">≤</span> <span class="free">Q</span><span class="main">)</span> <span class="main">⟹</span> SUP_LE_P <span class="free">P</span> <span class="free">u</span> <span class="free">i</span> <span class="main">≤</span> <span class="free">Q</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> SUP_LE_P_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> SUP_least<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="Diagram-SUP_SUP_L"><span class="command">lemma</span></span> SUP_SUP_L <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Sup <span class="main">(</span>range <span class="main">(</span>SUP_LE_P <span class="free">X</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Sup <span class="main">(</span>range <span class="free">X</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff Sup_fun_def image_comp<span class="main"><span class="keyword3">,</span></span> <span class="operator">clarify</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> antisym<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> SUP_least<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> SUP_LE_P_least<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> SUP_upper<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> SUP_least<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> y <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"SUP_LE_P <span class="free">X</span> <span class="main">(</span><span class="free">pair</span> <span class="improper">xa</span> <span class="improper">x</span><span class="main">)</span> <span class="improper">x</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> order_trans<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> SUP_LE_P_upper<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> SUP_upper<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Diagram-SUP_L_SUP_LE_P"><span class="command">lemma</span></span> SUP_L_SUP_LE_P <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Sup_less <span class="main">(</span>SUP_LE_P <span class="free">X</span><span class="main">)</span> <span class="main">=</span> SUP_L_P <span class="free">X</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> antisym<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> le_fun_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">safe</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> Sup_less_least<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> le_fun_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">safe</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> SUP_LE_P_least<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> SUP_L_P_upper<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> le_fun_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">safe</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> SUP_L_P_least<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> y <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"SUP_LE_P <span class="free">X</span> <span class="main">(</span><span class="free">pair</span> <span class="improper">v</span> <span class="improper">xa</span><span class="main">)</span> <span class="improper">xa</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> order_trans<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> SUP_LE_P_upper<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cut_tac</span> P <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"SUP_LE_P <span class="free">X</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> Sup_less_upper<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> le_fun_def<span class="main">)</span>
  
<span class="keyword2"><span class="keyword">end</span></span>
    
<span class="keyword1"><span class="command">theorem</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> DiagramTermination<span class="main">)</span> hoare_diagram2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"dmono <span class="free">D</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">u</span> <span class="bound">i</span> <span class="bound">j</span> <span class="main">.</span> <span class="main">⊨</span> <span class="free">X</span> <span class="bound">u</span> <span class="bound">i</span>  <span class="main">{|</span> <span class="free">D</span><span class="main">(</span><span class="bound">i</span><span class="main">,</span> <span class="bound">j</span><span class="main">)</span> <span class="main">|}</span> SUP_L_P <span class="free">X</span> <span class="main">(</span><span class="free">pair</span> <span class="bound">u</span> <span class="bound">i</span><span class="main">)</span> <span class="bound">j</span><span class="main">)</span> <span class="main">⟹</span> 
    <span class="main">⊨</span> <span class="main">(</span>Sup <span class="main">(</span>range <span class="free">X</span><span class="main">)</span><span class="main">)</span> <span class="main">{|</span> pt <span class="free">D</span> <span class="main">|}</span> <span class="main">(</span><span class="main">(</span>Sup <span class="main">(</span>range  <span class="free">X</span><span class="main">)</span><span class="main">)</span> <span class="main">⊓</span> <span class="main">(</span><span class="main">-</span><span class="main">(</span>grd <span class="main">(</span>step <span class="free">D</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule_tac</span> X <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"SUP_LE_P <span class="free">X</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> hoare_diagram<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> SUP_LE_P_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> hoare_Sup <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> sym<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> Q <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"SUP_L_P <span class="free">X</span> <span class="main">(</span><span class="free">pair</span> <span class="improper">p</span> <span class="improper">i</span><span class="main">)</span> <span class="improper">j</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> hoare_mono<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> SUP_L_P_least<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> SUP_L_P_upper<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order_trans3<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Diagram-mono_pt"><span class="command">lemma</span></span> mono_pt <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"dmono <span class="free">D</span> <span class="main">⟹</span> mono <span class="main">(</span>pt <span class="free">D</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> mono_mono_dgr<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pt_def<span class="main">)</span>

<span class="keyword1"><span class="command">theorem</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> DiagramTermination<span class="main">)</span> hoare_diagram3<span class="main">:</span>
  <span class="quoted"><span class="quoted">"dmono <span class="free">D</span> <span class="main">⟹</span> 
     <span class="main">(</span><span class="main">∀</span> <span class="bound">u</span> <span class="bound">i</span> <span class="bound">j</span> <span class="main">.</span> <span class="main">⊨</span> <span class="free">X</span> <span class="bound">u</span> <span class="bound">i</span>  <span class="main">{|</span> <span class="free">D</span><span class="main">(</span><span class="bound">i</span><span class="main">,</span> <span class="bound">j</span><span class="main">)</span> <span class="main">|}</span> SUP_L_P <span class="free">X</span> <span class="main">(</span><span class="free">pair</span> <span class="bound">u</span> <span class="bound">i</span><span class="main">)</span> <span class="bound">j</span><span class="main">)</span> <span class="main">⟹</span> 
      <span class="free">P</span> <span class="main">≤</span> Sup <span class="main">(</span>range <span class="free">X</span><span class="main">)</span> <span class="main">⟹</span>  <span class="main">(</span><span class="main">(</span>Sup <span class="main">(</span>range <span class="free">X</span><span class="main">)</span><span class="main">)</span> <span class="main">⊓</span> <span class="main">(</span><span class="main">-</span><span class="main">(</span>grd <span class="main">(</span>step <span class="free">D</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> <span class="free">Q</span> <span class="main">⟹</span>
      <span class="main">⊨</span> <span class="free">P</span> <span class="main">{|</span> pt <span class="free">D</span> <span class="main">|}</span> <span class="free">Q</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> hoare_mono<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> hoare_pre<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> hoare_diagram2<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
The following definition introduces the concept of correct Hoare triples for diagrams.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> DiagramTermination<span class="main">)</span>
  <span class="entity">Hoare_dgr</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'b</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'u</span><span class="main">::</span><span class="main">{</span>complete_distrib_lattice<span class="main">,</span> boolean_algebra<span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span> <span class="main">×</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'u</span> <span class="main">⇒</span> <span class="tfree">'u</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'u</span><span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">⊢</span> <span class="keyword3">(</span>_<span class="keyword3">)</span><span class="keyword1">{|</span> _ <span class="keyword1">|}</span><span class="keyword3">(</span>_<span class="keyword3">)</span> "</span> 
  <span class="main">[</span>0<span class="main">,</span>0<span class="main">,</span>900<span class="main">]</span> 900<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main"><span class="free">⊢</span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main"><span class="free">{|</span></span> <span class="free"><span class="bound"><span class="entity">D</span></span></span> <span class="main"><span class="free">|}</span></span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">X</span> <span class="main">.</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">u</span> <span class="bound">i</span> <span class="bound">j</span> <span class="main">.</span> <span class="main">⊨</span> <span class="bound">X</span> <span class="bound">u</span> <span class="bound">i</span>  <span class="main">{|</span> <span class="free"><span class="bound"><span class="entity">D</span></span></span><span class="main">(</span><span class="bound">i</span><span class="main">,</span> <span class="bound">j</span><span class="main">)</span> <span class="main">|}</span> SUP_L_P <span class="bound">X</span> <span class="main">(</span><span class="free">pair</span> <span class="bound">u</span> <span class="bound">i</span><span class="main">)</span> <span class="bound">j</span><span class="main">)</span> <span class="main">∧</span> 
       <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">=</span> Sup <span class="main">(</span>range <span class="bound">X</span><span class="main">)</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span>Sup <span class="main">(</span>range  <span class="bound">X</span><span class="main">)</span><span class="main">)</span> <span class="main">⊓</span> <span class="main">(</span><span class="main">-</span><span class="main">(</span>grd <span class="main">(</span>step <span class="free"><span class="bound"><span class="entity">D</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> DiagramTermination<span class="main">)</span>
  <span class="entity">Hoare_dgr1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'b</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'u</span><span class="main">::</span><span class="main">{</span>complete_distrib_lattice<span class="main">,</span> boolean_algebra<span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span> <span class="main">×</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'u</span> <span class="main">⇒</span> <span class="tfree">'u</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'u</span><span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">⊢1</span> <span class="keyword3">(</span>_<span class="keyword3">)</span><span class="keyword1">{|</span> _ <span class="keyword1">|}</span><span class="keyword3">(</span>_<span class="keyword3">)</span> "</span> 
  <span class="main">[</span>0<span class="main">,</span>0<span class="main">,</span>900<span class="main">]</span> 900<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main"><span class="free">⊢1</span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main"><span class="free">{|</span></span> <span class="free"><span class="bound"><span class="entity">D</span></span></span> <span class="main"><span class="free">|}</span></span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">X</span> <span class="main">.</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">u</span> <span class="bound">i</span> <span class="bound">j</span> <span class="main">.</span> <span class="main">⊨</span> <span class="bound">X</span> <span class="bound">u</span> <span class="bound">i</span>  <span class="main">{|</span> <span class="free"><span class="bound"><span class="entity">D</span></span></span><span class="main">(</span><span class="bound">i</span><span class="main">,</span> <span class="bound">j</span><span class="main">)</span> <span class="main">|}</span> SUP_L_P <span class="bound">X</span> <span class="main">(</span><span class="free">pair</span> <span class="bound">u</span> <span class="bound">i</span><span class="main">)</span> <span class="bound">j</span><span class="main">)</span> <span class="main">∧</span> 
      <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">≤</span> Sup <span class="main">(</span>range <span class="bound">X</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">(</span>Sup <span class="main">(</span>range <span class="bound">X</span><span class="main">)</span><span class="main">)</span> <span class="main">⊓</span> <span class="main">(</span><span class="main">-</span><span class="main">(</span>grd <span class="main">(</span>step <span class="free"><span class="bound"><span class="entity">D</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">theorem</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> DiagramTermination<span class="main">)</span> hoare_dgr_correctness<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"dmono <span class="free">D</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">⊢</span> <span class="free">P</span> <span class="main">{|</span> <span class="free">D</span> <span class="main">|}</span> <span class="free">Q</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">⊨</span> <span class="free">P</span> <span class="main">{|</span> pt <span class="free">D</span> <span class="main">|}</span> <span class="free">Q</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Hoare_dgr_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> hoare_diagram3<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">theorem</span></span>  <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> DiagramTermination<span class="main">)</span> hoare_dgr_correctness1<span class="main">:</span>
  <span class="quoted"><span class="quoted">"dmono <span class="free">D</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">⊢1</span> <span class="free">P</span> <span class="main">{|</span> <span class="free">D</span> <span class="main">|}</span> <span class="free">Q</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">⊨</span> <span class="free">P</span> <span class="main">{|</span> pt <span class="free">D</span> <span class="main">|}</span> <span class="free">Q</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Hoare_dgr1_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> hoare_diagram3<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">dgr_demonic</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free"><span class="bound"><span class="entity">ij</span></span></span> <span class="main">=</span> <span class="main">[:</span><span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free"><span class="bound"><span class="entity">ij</span></span></span><span class="main">:]</span>"</span></span>

<span class="keyword1"><span class="command">theorem</span></span> dgr_demonic_mono<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"dmono <span class="main">(</span>dgr_demonic <span class="free">Q</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dmono_def dgr_demonic_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">dangelic</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">=</span> angelic <span class="main">(</span><span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Diagram-grd_dgr"><span class="command">lemma</span></span>  grd_dgr<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>grd <span class="main">(</span>step <span class="free">D</span><span class="main">)</span> <span class="free">i</span><span class="main">)</span><span class="main">::</span><span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>complete_boolean_algebra<span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">⨆</span> <span class="main">{</span><span class="bound">P</span> <span class="main">.</span> <span class="main">∃</span> <span class="bound">j</span> <span class="main">.</span> <span class="bound">P</span> <span class="main">=</span> grd <span class="main">(</span><span class="free">D</span><span class="main">(</span><span class="free">i</span><span class="main">,</span><span class="bound">j</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> grd_def step_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> step_def uminus_Inf<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>uminus <span class="main">`</span> range <span class="main">(</span><span class="main">λ</span><span class="bound">j</span><span class="main">::</span><span class="tfree">'b</span><span class="main">.</span> <span class="free">D</span> <span class="main">(</span><span class="free">i</span><span class="main">,</span> <span class="bound">j</span><span class="main">)</span> <span class="main">⊥</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound">P</span><span class="main">::</span><span class="tfree">'a</span><span class="main">.</span> <span class="main">∃</span><span class="bound">j</span><span class="main">::</span><span class="tfree">'b</span><span class="main">.</span> <span class="bound">P</span> <span class="main">=</span> <span class="main">-</span> <span class="free">D</span> <span class="main">(</span><span class="free">i</span><span class="main">,</span> <span class="bound">j</span><span class="main">)</span> <span class="main">⊥</span><span class="main">}</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">cong</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> SUP_cong_simp<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Diagram-grd_dgr_set"><span class="command">lemma</span></span>  grd_dgr_set<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>grd <span class="main">(</span>step <span class="free">D</span><span class="main">)</span> <span class="free">i</span><span class="main">)</span><span class="main">::</span><span class="main">(</span><span class="tfree">'a</span> set<span class="main">)</span><span class="main">)</span> <span class="main">=</span> Union <span class="main">{</span><span class="bound">P</span> <span class="main">.</span> <span class="main">∃</span> <span class="bound">j</span> <span class="main">.</span> <span class="bound">P</span> <span class="main">=</span> grd <span class="main">(</span><span class="free">D</span><span class="main">(</span><span class="free">i</span><span class="main">,</span><span class="bound">j</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> grd_dgr<span class="main">)</span>

<span class="keyword1" id="Diagram-not_grd_dgr"><span class="command">lemma</span></span> not_grd_dgr <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span> <span class="main">∈</span> <span class="main">(</span><span class="main">-</span> grd <span class="main">(</span>step <span class="free">D</span><span class="main">)</span> <span class="free">i</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">j</span> <span class="main">.</span> <span class="free">a</span> <span class="main">∉</span> grd <span class="main">(</span><span class="free">D</span><span class="main">(</span><span class="free">i</span><span class="main">,</span><span class="bound">j</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> grd_dgr<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Diagram-not_grd_dgr2"><span class="command">lemma</span></span> not_grd_dgr2 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">∉</span> <span class="main">(</span>grd <span class="main">(</span>step <span class="free">D</span><span class="main">)</span> <span class="free">i</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">j</span> <span class="main">.</span> <span class="free">a</span> <span class="main">∉</span> grd <span class="main">(</span><span class="free">D</span><span class="main">(</span><span class="free">i</span><span class="main">,</span><span class="bound">j</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> not_grd_dgr <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> sym<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="DataRefinement">
<div class="head">
<h1>Theory DataRefinement</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Data Refinement of Diagrams›</span></span>

<span class="keyword1"><span class="command">theory</span></span> DataRefinement
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Diagram.html">Diagram</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
Next definition introduces the concept of data refinement of $S1$
to $S2$ using the data abstractions $R$ and $R'$.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">DataRefinement</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>type <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>type<span class="main">)</span>
     <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">::</span>type <span class="main">⇒</span> <span class="tfree">'c</span><span class="main">::</span>ord<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>type <span class="main">⇒</span> <span class="tfree">'d</span><span class="main">::</span>type<span class="main">)</span> 
     <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'d</span><span class="main">::</span>type <span class="main">⇒</span> <span class="tfree">'c</span><span class="main">::</span>ord<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">DataRefinement</span> <span class="free"><span class="bound"><span class="entity">S1</span></span></span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">R'</span></span></span> <span class="free"><span class="bound"><span class="entity">S2</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="keyword1">o</span> <span class="free"><span class="bound"><span class="entity">S1</span></span></span><span class="main">)</span> <span class="main">≤</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">S2</span></span></span> <span class="keyword1">o</span> <span class="free"><span class="bound"><span class="entity">R'</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
If $\mathit{demonic}\ Q$ is correct with respect to $p$ and $q$, and 
$(\mathit{assert} \ p)\circ (\mathit{demonic}\  Q)$ is data refined
by $S$, then $S$ is correct with respect to $\mathit{angelic}\  R\  p$ and 
$\mathit{angelic} \ R' \ q$.
›</span></span>

<span class="keyword1"><span class="command">theorem</span></span> data_refinement<span class="main">:</span>
  <span class="quoted"><span class="quoted">"mono <span class="free">R</span> <span class="main">⟹</span> <span class="main">⊨</span> <span class="free">p</span> <span class="main">{|</span> <span class="free">S</span> <span class="main">|}</span> <span class="free">q</span> <span class="main">⟹</span>  DataRefinement <span class="free">S</span> <span class="free">R</span> <span class="free">R'</span> <span class="free">S'</span> <span class="main">⟹</span> 
         <span class="main">⊨</span> <span class="main">(</span><span class="free">R</span> <span class="free">p</span><span class="main">)</span> <span class="main">{|</span> <span class="free">S'</span> <span class="main">|}</span> <span class="main">(</span><span class="free">R'</span> <span class="free">q</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>  DataRefinement_def Hoare_def le_fun_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="free">q</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> y <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">(</span><span class="free">S</span> <span class="free">q</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> order_trans<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="free">p</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> y <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="free">S</span> <span class="free">q</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> monoD<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">theorem</span></span> data_refinement2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"mono <span class="free">R</span> <span class="main">⟹</span> <span class="main">⊨</span> <span class="free">p</span> <span class="main">{|</span> <span class="free">S</span> <span class="main">|}</span> <span class="free">q</span> <span class="main">⟹</span>  DataRefinement <span class="main">(</span><span class="main">{.</span><span class="free">p</span><span class="main">.}</span> <span class="keyword1">o</span> <span class="free">S</span><span class="main">)</span> <span class="free">R</span> <span class="free">R'</span> <span class="free">S'</span> <span class="main">⟹</span> 
         <span class="main">⊨</span> <span class="main">(</span><span class="free">R</span> <span class="free">p</span><span class="main">)</span> <span class="main">{|</span> <span class="free">S'</span> <span class="main">|}</span> <span class="main">(</span><span class="free">R'</span> <span class="free">q</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>  DataRefinement_def Hoare_def le_fun_def assert_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="free">q</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">⊓</span> <span class="free">S</span> <span class="free">q</span> <span class="main">=</span> <span class="free">p</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> antisym<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">theorem</span></span> data_refinement_hoare<span class="main">:</span>
  <span class="quoted"><span class="quoted">"mono <span class="free">S</span> <span class="main">⟹</span> mono <span class="free">D</span> <span class="main">⟹</span> DataRefinement <span class="main">(</span><span class="main">{.</span><span class="free">p</span><span class="main">.}</span> <span class="keyword1">o</span> <span class="main">[:</span><span class="free">Q</span><span class="main">:]</span><span class="main">)</span> <span class="main">{:</span><span class="free">R</span><span class="main">:}</span> <span class="free">D</span> <span class="free">S</span> <span class="main">=</span> 
         <span class="main">(</span><span class="main">∀</span> <span class="bound">s</span> <span class="main">.</span> <span class="main">⊨</span> <span class="main">{</span><span class="bound">s'</span> <span class="main">.</span> <span class="bound">s</span> <span class="main">∈</span> <span class="free">R</span> <span class="bound">s'</span> <span class="main">∧</span> <span class="bound">s</span> <span class="main">∈</span> <span class="free">p</span><span class="main">}</span> <span class="main">{|</span> <span class="free">S</span> <span class="main">|}</span> <span class="main">(</span><span class="free">D</span> <span class="main">(</span><span class="main">(</span><span class="free">Q</span> <span class="bound">s</span><span class="main">)</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>order<span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> le_fun_def assert_def angelic_def demonic_def Hoare_def DataRefinement_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="improper">s</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="improper">xb</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_eq_set_def le_fun_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="improper">xa</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mono_def<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">theorem</span></span> data_refinement_choice1<span class="main">:</span>
  <span class="quoted"><span class="quoted">"DataRefinement <span class="free">S1</span> <span class="free">D</span> <span class="free">D'</span> <span class="free">S2</span> <span class="main">⟹</span> DataRefinement <span class="free">S1</span> <span class="free">D</span> <span class="free">D'</span> <span class="free">S2'</span> <span class="main">⟹</span> DataRefinement <span class="free">S1</span> <span class="free">D</span> <span class="free">D'</span> <span class="main">(</span> <span class="free">S2</span> <span class="main">⊓</span> <span class="free">S2'</span><span class="main">)</span> "</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> DataRefinement_def hoare_choice le_fun_def inf_fun_def<span class="main">)</span>


<span class="keyword1"><span class="command">theorem</span></span> data_refinement_choice2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"mono <span class="free">D</span> <span class="main">⟹</span> DataRefinement <span class="free">S1</span> <span class="free">D</span> <span class="free">D'</span> <span class="free">S2</span> <span class="main">⟹</span> DataRefinement <span class="free">S1'</span> <span class="free">D</span> <span class="free">D'</span> <span class="free">S2'</span> <span class="main">⟹</span> 
     DataRefinement <span class="main">(</span><span class="free">S1</span> <span class="main">⊓</span> <span class="free">S1'</span><span class="main">)</span> <span class="free">D</span> <span class="free">D'</span> <span class="main">(</span><span class="free">S2</span> <span class="main">⊓</span> <span class="free">S2'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> DataRefinement_def inf_fun_def le_fun_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> y <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="free">D</span> <span class="main">(</span><span class="free">S1</span> <span class="improper">x</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> order_trans<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="free">S1</span> <span class="improper">x</span> <span class="main">⊓</span> <span class="free">S1'</span> <span class="improper">x</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> y <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="free">S1</span> <span class="improper">x</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> monoD<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> y <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="free">D</span> <span class="main">(</span><span class="free">S1'</span> <span class="improper">x</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> order_trans<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="free">S1</span> <span class="improper">x</span> <span class="main">⊓</span> <span class="free">S1'</span> <span class="improper">x</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> y <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="free">S1'</span> <span class="improper">x</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> monoD<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>


<span class="keyword1"><span class="command">theorem</span></span> data_refinement_top <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"DataRefinement <span class="free">S1</span> <span class="free">D</span> <span class="free">D'</span> <span class="main">(</span><span class="main">⊤</span><span class="main">::</span><span class="main">_</span><span class="main">::</span>order_top<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> DataRefinement_def le_fun_def top_fun_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">apply_fun</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">⇒</span><span class="tfree">'b</span><span class="main">⇒</span><span class="tfree">'c</span><span class="main">)</span><span class="main">⇒</span><span class="main">(</span><span class="tfree">'a</span><span class="main">⇒</span><span class="tfree">'b</span><span class="main">)</span><span class="main">⇒</span><span class="tfree">'a</span><span class="main">⇒</span><span class="tfree">'c</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">..</span>"</span> 5<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main"><span class="free">..</span></span> <span class="free"><span class="bound"><span class="entity">B</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">x</span> <span class="main">.</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">Disjunctive_fun</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">i</span> <span class="main">.</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="bound">i</span><span class="main">)</span> <span class="main">∈</span> Apply.Disjunctive<span class="main">)</span>"</span></span>

<span class="keyword1" id="DataRefinement-Disjunctive_Sup"><span class="command">lemma</span></span> Disjunctive_Sup<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Disjunctive_fun <span class="free">R</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">R</span> <span class="main">..</span> <span class="main">(</span>Sup <span class="free">X</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>  Sup <span class="main">{</span><span class="bound">y</span> <span class="main">.</span> <span class="main">∃</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span> <span class="main">.</span> <span class="bound">y</span> <span class="main">=</span> <span class="main">(</span><span class="free">R</span> <span class="main">..</span> <span class="bound">x</span><span class="main">)</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> fun_eq_iff<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> apply_fun_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> Disjunctive_fun_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="improper">x</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Apply.Disjunctive_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">R</span> <span class="improper">x</span> <span class="main">`</span> <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="improper">x</span><span class="main">)</span> <span class="main">`</span> <span class="free">X</span><span class="main">)</span> <span class="main">=</span><span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="improper">x</span><span class="main">)</span> <span class="main">`</span> <span class="main">{</span><span class="bound">y</span><span class="main">.</span> <span class="main">∃</span><span class="bound">x</span><span class="main">∈</span><span class="free">X</span><span class="main">.</span> <span class="bound">y</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">xa</span><span class="main">.</span> <span class="free">R</span> <span class="bound">xa</span> <span class="main">(</span><span class="bound">x</span> <span class="bound">xa</span><span class="main">)</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> image_image <span class="quasi_keyword">cong</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> SUP_cong_simp<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> DiagramTermination<span class="main">)</span> disjunctive_SUP_L_P<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Disjunctive_fun <span class="free">R</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">R</span> <span class="main">..</span> <span class="main">(</span>SUP_L_P <span class="free">P</span> <span class="main">(</span><span class="free">pair</span> <span class="free">u</span> <span class="free">i</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>  <span class="main">(</span>SUP_L_P <span class="main">(</span><span class="main">λ</span> <span class="bound">w</span> <span class="main">.</span> <span class="main">(</span><span class="free">R</span> <span class="main">..</span> <span class="main">(</span><span class="free">P</span> <span class="bound">w</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free">pair</span> <span class="free">u</span> <span class="free">i</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> SUP_L_P_def apply_fun_def Disjunctive_fun_def Apply.Disjunctive_def fun_eq_iff image_comp<span class="main">)</span>

<span class="keyword1" id="DataRefinement-apply_fun_range"><span class="command">lemma</span></span> apply_fun_range<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">y</span><span class="main">.</span> <span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="bound">y</span> <span class="main">=</span> <span class="main">(</span><span class="free">R</span> <span class="main">..</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span><span class="main">}</span> <span class="main">=</span> range <span class="main">(</span><span class="main">λ</span> <span class="bound">x</span> <span class="main">.</span> <span class="free">R</span> <span class="main">..</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fact</span> full_SetCompr_eq<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Disjunctive_fun <span class="free">R</span> <span class="main">⟹</span> mono <span class="main">(</span><span class="main">(</span><span class="free">R</span> <span class="free">i</span><span class="main">)</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Disjunctive_fun_def<span class="main">)</span>

<span class="keyword1"><span class="command">theorem</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> DiagramTermination<span class="main">)</span> dgr_data_refinement_1<span class="main">:</span>
  <span class="quoted"><span class="quoted">"dmono <span class="free">D'</span> <span class="main">⟹</span> Disjunctive_fun <span class="free">R</span> <span class="main">⟹</span>
   <span class="main">(</span><span class="main">∀</span> <span class="bound">w</span> <span class="bound">i</span> <span class="bound">j</span> <span class="main">.</span> <span class="main">⊨</span> <span class="free">P</span> <span class="bound">w</span> <span class="bound">i</span>  <span class="main">{|</span> <span class="free">D</span><span class="main">(</span><span class="bound">i</span><span class="main">,</span><span class="bound">j</span><span class="main">)</span> <span class="main">|}</span> SUP_L_P <span class="free">P</span> <span class="main">(</span><span class="free">pair</span> <span class="bound">w</span> <span class="bound">i</span><span class="main">)</span> <span class="bound">j</span><span class="main">)</span> <span class="main">⟹</span>
   <span class="main">(</span><span class="main">∀</span> <span class="bound">w</span> <span class="bound">i</span> <span class="bound">j</span> <span class="main">.</span> DataRefinement <span class="main">(</span><span class="main">(</span>assert <span class="main">(</span><span class="free">P</span> <span class="bound">w</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">o</span> <span class="main">(</span><span class="free">D</span> <span class="main">(</span><span class="bound">i</span><span class="main">,</span><span class="bound">j</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free">R</span> <span class="bound">i</span><span class="main">)</span> <span class="main">(</span><span class="free">R</span> <span class="bound">j</span><span class="main">)</span> <span class="main">(</span><span class="free">D'</span> <span class="main">(</span><span class="bound">i</span><span class="main">,</span> <span class="bound">j</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span>
   
   <span class="main">⊨</span> <span class="main">(</span><span class="free">R</span> <span class="main">..</span> <span class="main">(</span>Sup <span class="main">(</span>range <span class="free">P</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">{|</span> pt <span class="free">D'</span> <span class="main">|}</span> <span class="main">(</span><span class="main">(</span><span class="free">R</span> <span class="main">..</span> <span class="main">(</span>Sup <span class="main">(</span>range <span class="free">P</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">⊓</span> <span class="main">(</span><span class="main">-</span><span class="main">(</span>grd <span class="main">(</span>step <span class="free">D'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Disjunctive_Sup apply_fun_range<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> hoare_diagram2<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> disjunctive_SUP_L_P <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> sym<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> apply_fun_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> S <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="free">D</span> <span class="main">(</span><span class="improper">i</span><span class="main">,</span> <span class="improper">j</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> data_refinement2<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">DgrDataRefinement1</span> <span class="free"><span class="bound"><span class="entity">D</span></span></span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">D'</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">i</span> <span class="bound">j</span> <span class="main">.</span> DataRefinement <span class="main">(</span><span class="free"><span class="bound"><span class="entity">D</span></span></span> <span class="main">(</span><span class="bound">i</span> <span class="main">,</span> <span class="bound">j</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="bound">i</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="bound">j</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">D'</span></span></span> <span class="main">(</span><span class="bound">i</span><span class="main">,</span> <span class="bound">j</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">DgrDataRefinement2</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">D</span></span></span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">D'</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">i</span> <span class="bound">j</span> <span class="main">.</span> DataRefinement <span class="main">(</span><span class="main">{.</span><span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="bound">i</span><span class="main">.}</span> <span class="keyword1">o</span> <span class="free"><span class="bound"><span class="entity">D</span></span></span> <span class="main">(</span><span class="bound">i</span> <span class="main">,</span> <span class="bound">j</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="bound">i</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="bound">j</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">D'</span></span></span> <span class="main">(</span><span class="bound">i</span><span class="main">,</span> <span class="bound">j</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">theorem</span></span> DataRefinement_mono<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">T</span> <span class="main">≤</span> <span class="free">S</span> <span class="main">⟹</span> mono <span class="free">R</span> <span class="main">⟹</span> DataRefinement <span class="free">S</span> <span class="free">R</span> <span class="free">R'</span> <span class="free">S'</span> <span class="main">⟹</span> DataRefinement <span class="free">T</span> <span class="free">R</span> <span class="free">R'</span> <span class="free">S'</span> "</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> DataRefinement_def mono_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> le_fun_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> le_fun_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> y <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">(</span><span class="free">S</span> <span class="improper">x</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> order_trans<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">mono_fun</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">i</span> <span class="main">.</span> mono <span class="main">(</span><span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">theorem</span></span> DgrDataRefinement_mono<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="main">≤</span> <span class="free">P</span> <span class="main">⟹</span> mono_fun <span class="free">R</span> <span class="main">⟹</span> DgrDataRefinement2 <span class="free">P</span> <span class="free">D</span> <span class="free">R</span> <span class="free">D'</span> <span class="main">⟹</span> DgrDataRefinement2 <span class="free">Q</span> <span class="free">D</span> <span class="free">R</span> <span class="free">D'</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> DgrDataRefinement2_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> S <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="main">{.</span><span class="free">P</span> <span class="improper">i</span><span class="main">.}</span> <span class="keyword1">o</span> <span class="free">D</span><span class="main">(</span><span class="improper">i</span><span class="main">,</span> <span class="improper">j</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> DataRefinement_mono<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> le_fun_def assert_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> y <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="improper">i</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> order_trans<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mono_fun_def<span class="main">)</span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
Next theorem is the diagram version of the data refinement theorem. If the
diagram demonic choice $T$ is correct, and it is refined by $D$, then
$D$ is also correct. One important point in this theorem is that 
if the diagram demonic choice $T$ terminates, then $D$ also terminates.
›</span></span>
  

<span class="keyword1"><span class="command">theorem</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> DiagramTermination<span class="main">)</span> Diagram_DataRefinement1<span class="main">:</span>
  <span class="quoted"><span class="quoted">"dmono <span class="free">D</span> <span class="main">⟹</span> Disjunctive_fun <span class="free">R</span> <span class="main">⟹</span> <span class="main">⊢</span> <span class="free">P</span> <span class="main">{|</span> <span class="free">D</span> <span class="main">|}</span> <span class="free">Q</span> <span class="main">⟹</span> DgrDataRefinement1 <span class="free">D</span> <span class="free">R</span> <span class="free">D'</span> <span class="main">⟹</span>
      <span class="main">⊢</span> <span class="main">(</span><span class="free">R</span> <span class="main">..</span> <span class="free">P</span><span class="main">)</span> <span class="main">{|</span> <span class="free">D'</span> <span class="main">|}</span> <span class="main">(</span><span class="main">(</span><span class="free">R</span> <span class="main">..</span> <span class="free">P</span><span class="main">)</span> <span class="main">⊓</span> <span class="main">(</span><span class="main">-</span><span class="main">(</span>grd <span class="main">(</span>step <span class="free">D'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> Hoare_dgr_def DgrDataRefinement1_def dgr_demonic_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">w</span> <span class="main">.</span> <span class="free">R</span> <span class="main">..</span> <span class="main">(</span><span class="improper">X</span> <span class="bound">w</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> disjunctive_SUP_L_P <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> sym<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> apply_fun_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> S <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="free">D</span> <span class="main">(</span><span class="improper">i</span><span class="main">,</span><span class="improper">j</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> R <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="improper">i</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> R' <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="improper">j</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> data_refinement<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Disjunctive_Sup apply_fun_range<span class="main">)</span>


<span class="keyword1" id="DataRefinement-comp_left_mono"><span class="command">lemma</span></span> comp_left_mono <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">S</span> <span class="main">≤</span> <span class="free">S'</span> <span class="main">⟹</span> <span class="free">S</span> <span class="keyword1">o</span> <span class="free">T</span> <span class="main">≤</span> <span class="free">S'</span> <span class="keyword1">o</span> <span class="free">T</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> le_fun_def<span class="main">)</span>

<span class="keyword1" id="DataRefinement-assert_pred_mono"><span class="command">lemma</span></span> assert_pred_mono <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">≤</span> <span class="free">q</span> <span class="main">⟹</span> <span class="main">{.</span><span class="free">p</span><span class="main">.}</span> <span class="main">≤</span> <span class="main">{.</span><span class="free">q</span><span class="main">.}</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> le_fun_def assert_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> y <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="free">p</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> order_trans<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">theorem</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> DiagramTermination<span class="main">)</span> Diagram_DataRefinement2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"dmono <span class="free">D</span> <span class="main">⟹</span> Disjunctive_fun <span class="free">R</span> <span class="main">⟹</span> <span class="main">⊢</span> <span class="free">P</span> <span class="main">{|</span> <span class="free">D</span> <span class="main">|}</span> <span class="free">Q</span> <span class="main">⟹</span> DgrDataRefinement2 <span class="free">P</span> <span class="free">D</span> <span class="free">R</span> <span class="free">D'</span> <span class="main">⟹</span>
      <span class="main">⊢</span> <span class="main">(</span><span class="free">R</span> <span class="main">..</span> <span class="free">P</span><span class="main">)</span> <span class="main">{|</span> <span class="free">D'</span> <span class="main">|}</span> <span class="main">(</span><span class="main">(</span><span class="free">R</span> <span class="main">..</span> <span class="free">P</span><span class="main">)</span> <span class="main">⊓</span> <span class="main">(</span><span class="main">-</span><span class="main">(</span>grd <span class="main">(</span>step <span class="free">D'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> Hoare_dgr_def DgrDataRefinement2_def dgr_demonic_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">w</span> <span class="main">.</span> <span class="free">R</span> <span class="main">..</span> <span class="main">(</span><span class="improper">X</span> <span class="bound">w</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> disjunctive_SUP_L_P <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> sym<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> apply_fun_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> S <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="free">D</span> <span class="main">(</span><span class="improper">i</span><span class="main">,</span><span class="improper">j</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> R <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="improper">i</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> R' <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="improper">j</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> data_refinement2<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Disjunctive_Sup<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> S <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="main">{.</span>Sup <span class="main">(</span>range <span class="improper">X</span><span class="main">)</span> <span class="improper">i</span><span class="main">.}</span> <span class="main">∘</span> <span class="free">D</span> <span class="main">(</span><span class="improper">i</span><span class="main">,</span> <span class="improper">j</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> DataRefinement_mono<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> comp_left_mono<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> assert_pred_mono<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Sup_fun_def comp_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> SUP_upper<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> apply_fun_def apply_fun_range image_image fun_eq_iff<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> arg_cong <span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted">Sup</span><span class="main"><span class="main">]</span></span> arg_cong2 <span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted">inf</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">R'</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice<span class="main">)</span> <span class="main">∈</span> Apply.Disjunctive <span class="main">⟹</span>
   DataRefinement <span class="free">S</span> <span class="free">R</span> <span class="free">R'</span> <span class="free">S'</span> <span class="main">⟹</span> <span class="free">R</span> <span class="main">(</span><span class="main">-</span> grd <span class="free">S</span><span class="main">)</span> <span class="main">≤</span> <span class="main">-</span> grd <span class="free">S'</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> DataRefinement_def grd_def le_fun_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="main">⊥</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div>