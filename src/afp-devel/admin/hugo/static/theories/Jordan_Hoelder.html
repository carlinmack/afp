<div id="SndIsomorphismGrp">
<div class="head"><h1>Theory SndIsomorphismGrp</h1>
<span class="command">theory</span> <span class="name">SndIsomorphismGrp</span><br/>
<span class="keyword">imports</span> <a href="SubgroupConjugation.html"><span class="name">SubgroupConjugation</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:      The Second Isomorphism Theorem for Groups
    Author:     Jakob von Raumer, Karlsruhe Institute of Technology
    Maintainer: Jakob von Raumer &lt;jakob.raumer@student.kit.edu&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>SndIsomorphismGrp</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"HOL-Algebra.Coset"</span></span></span><span>
</span><span>    </span><span>Secondary_Sylow.SubgroupConjugation</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThe Second Isomorphism Theorem for Groups‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπPreliminaries‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>group</span><span class="delimiter">)</span><span> </span><span>triv_subgroup</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subgroup {ùü≠} G"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>subgroup_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>group</span><span class="delimiter">)</span><span> </span><span>triv_normal_subgroup</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{ùü≠} ‚ä≤ G"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>normal_def</span><span> </span><span>normal_axioms_def</span><span> </span><span>l_coset_def</span><span> </span><span>r_coset_def</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>is_group</span><span> </span><span>triv_subgroup</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>group</span><span class="delimiter">)</span><span> </span><span>normal_restrict_supergroup</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>SsubG</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"subgroup S G"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>Nnormal</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"N ‚ä≤ G"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"N ‚äÜ S"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"N ‚ä≤ (G‚¶ácarrier := S‚¶à)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>Sgrp</span><span class="delimiter">:</span><span> </span><span>group</span><span> </span><span class="string"><span class="delete"><span class="delete">"G‚¶ácarrier := S‚¶à"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SsubG</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subgroup_imp_group</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>Sgrp.normalI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subgroup N (G‚¶ácarrier := S‚¶à)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>is_group</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>subgroup.subgroup_of_subset</span><span> </span><span>normal_inv_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>SsubG</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S ‚äÜ carrier G"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subgroup.subset</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄx‚ààcarrier (G‚¶ácarrier := S‚¶à). N #&gt;<span class="hidden">‚áò</span><sub>G‚¶ácarrier := S‚¶à<span class="hidden">‚áô</span></sub> x = x &lt;#<span class="hidden">‚áò</span><sub>G‚¶ácarrier := S‚¶à<span class="hidden">‚áô</span></sub> N"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Nnormal</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>normal_def</span><span> </span><span>normal_axioms_def</span><span> </span><span>l_coset_def</span><span> </span><span>r_coset_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπAs this is maybe the best place this fits in: Factorizing by the trivial subgroup
is an isomorphism.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>group</span><span class="delimiter">)</span><span> </span><span>trivial_factor_iso</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"the_elem ‚àà iso (G Mod {ùü≠}) G"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"group_hom G G (Œªx. x)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>group_hom_def</span><span> </span><span>group_hom_axioms_def</span><span> </span><span>hom_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>is_group</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(Œªx. x) ` carrier G = carrier G"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kernel G G (Œªx. x) = {ùü≠}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>kernel_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>group_hom.FactGroup_iso_set</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπAnd the dual theorem to the previous one: Factorizing by the group itself gives the trivial group‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>group</span><span class="delimiter">)</span><span> </span><span>self_factor_iso</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ŒªX. the_elem ((Œªx. ùü≠) ` X)) ‚àà iso (G Mod (carrier G)) (G‚¶á carrier := {ùü≠} ‚¶à)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"group (G‚¶ácarrier := {ùü≠}‚¶à)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>subgroup_imp_group</span><span> </span><span>triv_subgroup</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"group_hom G (G‚¶ácarrier := {ùü≠}‚¶à) (Œªx. ùü≠)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>group_hom_def</span><span> </span><span>group_hom_axioms_def</span><span> </span><span>hom_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>is_group</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(Œªx. ùü≠) ` carrier G = carrier (G‚¶ácarrier := {ùü≠}‚¶à)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kernel G (G‚¶ácarrier := {ùü≠}‚¶à) (Œªx. ùü≠) = carrier G"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>kernel_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>group_hom.FactGroup_iso_set</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThis theory provides a proof of the second isomorphism theorems for groups. 
The theorems consist of several facts about normal subgroups.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThe first lemma states that whenever we have a subgroup @{term S} and
a normal subgroup @{term H} of a group @{term G}, their intersection is normal
in @{term G}‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>second_isomorphism_grp</span><span> </span><span class="delimiter">=</span><span> </span><span>normal</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>S</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'a set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>subgrpS</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"subgroup S G"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>second_isomorphism_grp</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>groupS</span><span class="delimiter">:</span><span> </span><span>group</span><span> </span><span class="string"><span class="delete"><span class="delete">"G‚¶ácarrier := S‚¶à"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subgrpS</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>subgroup_imp_group</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normal_subgrp_intersection_normal</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S ‚à© H ‚ä≤ (G‚¶ácarrier := S‚¶à)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>groupS.normal_inv_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>subgrpS</span><span> </span><span>is_subgroup</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄx. x ‚àà {S, H} ‚üπ subgroup x G"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subgroup (‚ãÇ {S, H}) G"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subgroups_Inter</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subgroup (S ‚à© H) G"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S ‚à© H ‚äÜ S"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subgroup (S ‚à© H) (G‚¶ácarrier := S‚¶à)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>is_group</span><span> </span><span>subgroup.subgroup_of_subset</span><span> </span><span>subgrpS</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>g</span><span> </span><span>h</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>g</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"g ‚àà S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hH</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"h ‚àà H"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hS</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"h ‚àà S"</span></span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>g</span><span> </span><span>hH</span><span> </span><span>subgrpS</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g ‚äó h ‚äó inv<span class="hidden">‚áò</span><sub>G‚¶ácarrier := S‚¶à<span class="hidden">‚áô</span></sub> g ‚àà H"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inv_op_closed2</span><span> </span><span>subgroup.mem_carrier</span><span> </span><span>m_inv_consistent</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>g</span><span> </span><span>hS</span><span> </span><span>subgrpS</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g ‚äó h ‚äó inv<span class="hidden">‚áò</span><sub>G‚¶ácarrier := S‚¶à<span class="hidden">‚áô</span></sub> g ‚àà S"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>subgroup.m_closed</span><span> </span><span>subgroup.m_inv_closed</span><span> </span><span>m_inv_consistent</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normal_set_mult_subgroup</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subgroup (H &lt;#&gt; S) G"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>subgroupI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H &lt;#&gt; S ‚äÜ carrier G"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>setmult_subset_G</span><span> </span><span>subgroup.subset</span><span> </span><span>subgrpS</span><span> </span><span>subset</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùü≠ ‚àà H"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùü≠ ‚àà S"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>is_subgroup</span><span> </span><span>subgrpS</span><span> </span><span>subgroup.one_closed</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùü≠ ‚äó ùü≠ ‚àà H &lt;#&gt; S"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>set_mult_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H &lt;#&gt; S ‚â† {}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>g</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>g</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"g ‚àà H &lt;#&gt; S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>h</span><span> </span><span>s</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>h</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"h ‚àà H"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"s ‚àà S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ghs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"g = h ‚äó s"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>set_mult_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ‚àà carrier G"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>subgroup.mem_carrier</span><span> </span><span>subgrpS</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>h</span><span> </span><span>ghs</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>h'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>h'</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"h' ‚àà H"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g = s ‚äó h'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>coset_eq</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>r_coset_def</span><span> </span><span>l_coset_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>s</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv g = (inv h') ‚äó (inv s)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inv_mult_group</span><span> </span><span>mem_carrier</span><span> </span><span>subgroup.mem_carrier</span><span> </span><span>subgrpS</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>h'</span><span> </span><span>s</span><span> </span><span>subgrpS</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv h' ‚àà H"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv s ‚àà S"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subgroup.m_inv_closed</span><span> </span><span>m_inv_closed</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv g ‚àà H &lt;#&gt; S"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>set_mult_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>g</span><span> </span><span>g'</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>g</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"g ‚àà H &lt;#&gt; S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"g' ‚àà H &lt;#&gt; S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>h</span><span> </span><span>h'</span><span> </span><span>s</span><span> </span><span>s'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>hh'ss'</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"h ‚àà H"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h' ‚àà H"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ‚àà S"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s' ‚àà S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g = h ‚äó s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g' = h' ‚äó s'"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>set_mult_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g ‚äó g' = (h ‚äó s) ‚äó (h' ‚äó s')"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>hh'ss'</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inG</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"h ‚àà carrier G"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h' ‚àà carrier G"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ‚àà carrier G"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s' ‚àà carrier G"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subgrpS</span><span> </span><span>mem_carrier</span><span> </span><span>subgroup.mem_carrier</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(h ‚äó s) ‚äó (h' ‚äó s') = h ‚äó (s ‚äó h') ‚äó s'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>m_assoc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>hh'ss'</span><span> </span><span>inG</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>h''</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>h''</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"h'' ‚àà H"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ‚äó h' = h'' ‚äó s"</span></span></span><span class="keyword1"><span class="command">using</span></span><span> </span><span>coset_eq</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>r_coset_def</span><span> </span><span>l_coset_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h ‚äó (s ‚äó h') ‚äó s' = h ‚äó (h'' ‚äó s) ‚äó s'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>h''</span><span> </span><span>inG</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (h ‚äó h'') ‚äó (s ‚äó s')"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>m_assoc</span><span> </span><span>mem_carrier</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g ‚äó g' = h ‚äó h'' ‚äó (s ‚äó s')"</span></span></span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>h''</span><span> </span><span>hh'ss'</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ‚àà H &lt;#&gt; S"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>set_mult_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subgrpS</span><span> </span><span>subgroup.m_closed</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g ‚äó g' ‚àà H &lt;#&gt; S"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>oneH</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ùü≠ ‚àà H"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>is_subgroup</span><span> </span><span>subgroup.one_closed</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>H_contained_in_set_mult</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H ‚äÜ H &lt;#&gt; S"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùü≠ ‚àà S"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>subgroup.one_closed</span><span> </span><span>subgrpS</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"x ‚àà H"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπùü≠ ‚àà S‚Ä∫</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ‚äó ùü≠ ‚àà H &lt;#&gt; S"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>set_mult_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>x</span><span> </span><span class="keyword3"><span class="command">show</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"x ‚àà H &lt;#&gt; S"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mem_carrier</span><span> </span><span>r_one</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>S_contained_in_set_mult</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S ‚äÜ H &lt;#&gt; S"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>s</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"s ‚àà S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>oneH</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùü≠ ‚äó s ‚àà H &lt;#&gt; S"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>set_mult_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>s</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ‚àà H &lt;#&gt; S"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subgrpS</span><span> </span><span>subgroup.mem_carrier</span><span> </span><span>l_one</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normal_intersection_hom</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"group_hom (G‚¶ácarrier := S‚¶à) ((G‚¶ácarrier := H &lt;#&gt; S‚¶à) Mod H) (Œªg. H #&gt; g)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>equalityI</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>group_hom_def</span><span> </span><span>group_hom_axioms_def</span><span> </span><span>hom_def</span><span> </span><span>groupS.is_group</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span>gr</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"group (G‚¶ácarrier := H &lt;#&gt; S‚¶à)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>normal_set_mult_subgroup</span><span> </span><span>subgroup_imp_group</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H ‚äÜ H &lt;#&gt; S"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>H_contained_in_set_mult</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subgroup (H &lt;#&gt; S) G"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>normal_set_mult_subgroup</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H ‚ä≤ (G‚¶ácarrier := H &lt;#&gt; S‚¶à)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>normal_restrict_supergroup</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inv_op_closed2</span><span> </span><span>is_subgroup</span><span> </span><span>normal_inv_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>gr</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"group ((G‚¶ácarrier := H &lt;#&gt; S‚¶à) Mod H)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>normal.factorgroup_is_group</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>g</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>g</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g ‚àà S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>subgrpS</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùü≠ ‚äó g ‚àà H &lt;#&gt; S"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>set_mult_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>g</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g ‚àà H &lt;#&gt; S"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>l_one</span><span> </span><span>subgroup.mem_carrier</span><span> </span><span>subgrpS</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H #&gt; g ‚àà carrier ((G‚¶ácarrier := H &lt;#&gt; S‚¶à) Mod H)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FactGroup_def</span><span> </span><span>RCOSETS_def</span><span> </span><span>r_coset_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄx y. ‚ü¶x ‚àà S; y ‚àà S‚üß ‚üπ H #&gt; x ‚äó y = H #&gt; x &lt;#&gt; (H #&gt; y)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>normal.rcos_sum</span><span> </span><span>normal_axioms</span><span> </span><span>subgroup.mem_carrier</span><span> </span><span>subgrpS</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normal_intersection_hom_kernel</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kernel (G‚¶ácarrier := S‚¶à) ((G‚¶ácarrier := H &lt;#&gt; S‚¶à) Mod H) (Œªg. H #&gt; g) = H ‚à© S"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kernel (G‚¶ácarrier := S‚¶à) ((G‚¶ácarrier := H &lt;#&gt; S‚¶à) Mod H) (Œªg. H #&gt; g)
                 = {g ‚àà S. H #&gt; g = ùü≠<span class="hidden">‚áò</span><sub>(G‚¶ácarrier := H &lt;#&gt; S‚¶à) Mod H<span class="hidden">‚áô</span></sub>}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>kernel_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = {g ‚àà S. H #&gt; g = H}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FactGroup_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = {g ‚àà S. g ‚àà H}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>coset_eq</span><span> </span><span>is_subgroup</span><span> </span><span>lcoset_join2</span><span> </span><span>rcos_self</span><span> </span><span>subgroup.mem_carrier</span><span> </span><span>subgrpS</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = H ‚à© S"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normal_intersection_hom_surj</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(Œªg. H #&gt; g) ` carrier (G‚¶ácarrier := S‚¶à) = carrier ((G‚¶ácarrier := H &lt;#&gt; S‚¶à) Mod H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>g</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g ‚àà S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g ‚àà H &lt;#&gt; S"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_contained_in_set_mult</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H #&gt; g ‚àà carrier ((G‚¶ácarrier := H &lt;#&gt; S‚¶à) Mod H)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FactGroup_def</span><span> </span><span>RCOSETS_def</span><span> </span><span>r_coset_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ‚àà carrier (G‚¶ácarrier := H &lt;#&gt; S‚¶à Mod H)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>h</span><span> </span><span>s</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>h</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"h ‚àà H"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"s ‚àà S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = H #&gt; (h ‚äó s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FactGroup_def</span><span> </span><span>RCOSETS_def</span><span> </span><span>r_coset_def</span><span> </span><span>set_mult_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = (H #&gt; h) #&gt; s"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>h</span><span> </span><span>s</span><span> </span><span>coset_mult_assoc</span><span> </span><span>mem_carrier</span><span> </span><span>subgroup.mem_carrier</span><span> </span><span>subgrpS</span><span> </span><span>subset</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = H #&gt; s"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>h</span><span> </span><span>is_group</span><span> </span><span>rcos_const</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = H #&gt; s"</span></span></span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>s</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ‚àà (#&gt;) H ` S"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπFinally we can prove the actual isomorphism theorem:‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>normal_intersection_quotient_isom</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ŒªX. the_elem ((Œªg. H #&gt; g) ` X)) ‚àà iso ((G‚¶ácarrier := S‚¶à) Mod (H ‚à© S)) (((G‚¶ácarrier := H &lt;#&gt; S‚¶à)) Mod H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>normal_intersection_hom_kernel</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>normal_intersection_hom</span><span> </span><span>normal_intersection_hom_surj</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>group_hom.FactGroup_iso_set</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="SubgroupsAndNormalSubgroups">
<div class="head"><h1>Theory SubgroupsAndNormalSubgroups</h1>
<span class="command">theory</span> <span class="name">SubgroupsAndNormalSubgroups</span><br/>
<span class="keyword">imports</span> <a href="SndSylow.html"><span class="name">SndSylow</span></a> <a href="SndIsomorphismGrp.html"><span class="name">SndIsomorphismGrp</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:      Additional Facts about Subgroups and Normal Subgroups
    Author:     Jakob von Raumer, Karlsruhe Institute of Technology
    Maintainer: Jakob von Raumer &lt;jakob.raumer@student.kit.edu&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>SubgroupsAndNormalSubgroups</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Secondary_Sylow.SndSylow</span><span>
</span><span>  </span><span>SndIsomorphismGrp</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Algebra.Coset"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπPreliminary lemmas‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπA group of order 1 is always the trivial group.‚Ä∫</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>group</span><span class="delimiter">)</span><span> </span><span>order_one_triv_iff</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(order G = 1) = (carrier G = {ùü≠})"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>order</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"order G = 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"carrier G = {x}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>order_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>card_Suc_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùü≠ = x"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>one_closed</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>x</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"carrier G = {ùü≠}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"carrier G = {ùü≠}"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"order G = 1"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>order_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>group</span><span class="delimiter">)</span><span> </span><span>finite_pos_order</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>finite</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"finite (carrier G)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; order G"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>one_closed</span><span> </span><span>finite</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>order_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>card_gt_0_iff</span><span> </span><span>subgroup_nonempty</span><span> </span><span>subgroup_self</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>iso_order_closed</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"œÜ ‚àà iso G H"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"order G = order H"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>order_def</span><span> </span><span>iso_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>bij_betw_same_card</span><span> </span><span>mem_Collect_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπMore Facts about Subgroups‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>subgroup</span><span class="delimiter">)</span><span> </span><span>subgroup_of_restricted_group</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subgroup U (G‚¶á carrier := H‚¶à)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"U ‚äÜ H"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>subgroup.subset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>subgroup</span><span class="delimiter">)</span><span> </span><span>subgroup_of_subgroup</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"group G"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subgroup U (G‚¶á carrier := H‚¶à)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subgroup U G"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"U ‚äÜ H"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subgroup_of_restricted_group</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"U ‚äÜ carrier G"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>subset</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"x ‚äó y = x ‚äó<span class="hidden">‚áò</span><sub>G‚¶á carrier := H‚¶à<span class="hidden">‚áô</span></sub> y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ‚àà U"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ‚àà U"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span>a</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" x ‚äó y ‚àà U"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>subgroup.m_closed</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùü≠<span class="hidden">‚áò</span><sub>G‚¶á carrier := H‚¶à<span class="hidden">‚áô</span></sub> = ùü≠"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùü≠ ‚àà U"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>subgroup.one_closed</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subgroup H G"</span></span></span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ‚àà U"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">‚áò</span><sub>G‚¶á carrier := H‚¶à<span class="hidden">‚áô</span></sub> x ‚àà U"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subgroup.m_inv_closed</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπx ‚àà U‚Ä∫</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ‚àà H"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>in_mono</span><span> </span><span>subgroup_of_restricted_group</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπsubgroup H G‚Ä∫</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">‚áò</span><sub>G‚¶á carrier := H‚¶à<span class="hidden">‚áô</span></sub> x = inv x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>group.m_inv_consistent</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv x ‚àà U"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπBeing a subgroup is preserved by surjective homomorphisms‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>subgroup</span><span class="delimiter">)</span><span> </span><span>surj_hom_subgroup</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>œÜ</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"group_hom G F œÜ"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>œÜsurj</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"œÜ ` (carrier G) = carrier F"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subgroup (œÜ ` H) F"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>œÜsurj</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>img_subset</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"œÜ ` H ‚äÜ carrier F"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>iso_def</span><span> </span><span>bij_betw_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>f</span><span> </span><span>f'</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>h</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"f ‚àà œÜ ` H"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h'</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"f' ‚àà œÜ ` H"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>œÜsurj</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>g</span><span> </span><span>g'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>g</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"g ‚àà H"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f = œÜ g"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>g'</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"g' ‚àà H"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f' = œÜ g'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g ‚äó<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub> g' ‚àà H"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>m_closed</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"œÜ (g ‚äó<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub> g') ‚àà œÜ ` H"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>g</span><span> </span><span>g'</span><span> </span><span>œÜ</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ‚äó<span class="hidden">‚áò</span><sub>F<span class="hidden">‚áô</span></sub> f' ‚àà œÜ ` H"</span></span></span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>group_hom.hom_mult</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"œÜ ùü≠ ‚àà œÜ ` H"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>œÜ</span><span> </span><span class="keyword3"><span class="command">show</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"ùü≠<span class="hidden">‚áò</span><sub>F<span class="hidden">‚áô</span></sub> ‚àà œÜ ` H"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>group_hom.hom_one</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>f</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>f</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"f ‚àà œÜ ` H"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>g</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>g</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"g ‚àà H"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f = œÜ g"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv g ‚àà H"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"œÜ (inv g) ‚àà œÜ ` H"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>œÜ</span><span> </span><span>g</span><span> </span><span>subset</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">‚áò</span><sub>F<span class="hidden">‚áô</span></sub> f ‚àà œÜ ` H"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>group_hom.hom_inv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ... and thus of course by isomorphisms of groups.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>iso_subgroup</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>groups</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"group G"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"group F"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>HG</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"subgroup H G"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>œÜ</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"œÜ ‚àà iso G F"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subgroup (œÜ ` H) F"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>groups</span><span> </span><span>œÜ</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"group_hom G F œÜ"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>group_hom_def</span><span> </span><span>group_hom_axioms_def</span><span> </span><span>iso_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>œÜ</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"œÜ ` (carrier G) = carrier F"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>iso_def</span><span> </span><span>bij_betw_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>HG</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>subgroup.surj_hom_subgroup</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπAn isomorphism restricts to an isomorphism of subgroups.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>iso_restrict</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>groups</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"group G"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"group F"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>HG</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"subgroup H G"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>œÜ</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"œÜ ‚àà iso G F"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(restrict œÜ H) ‚àà iso (G‚¶ácarrier := H‚¶à) (F‚¶ácarrier := œÜ ` H‚¶à)"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>iso_def</span><span> </span><span>hom_def</span><span> </span><span>bij_betw_def</span><span> </span><span>inj_on_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>g</span><span> </span><span>h</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g ‚àà H"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h ‚àà H"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g ‚àà carrier G"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h ‚àà carrier G"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>HG</span><span> </span><span>subgroup.mem_carrier</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"œÜ (g ‚äó<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub> h) = œÜ g ‚äó<span class="hidden">‚áò</span><sub>F<span class="hidden">‚áô</span></sub> œÜ h"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>œÜ</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>iso_def</span><span> </span><span>hom_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>g</span><span> </span><span>h</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g ‚àà H"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h ‚àà H"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g ‚äó<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub> h ‚àâ H"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>HG</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>subgroup_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"undefined = œÜ g ‚äó<span class="hidden">‚áò</span><sub>F<span class="hidden">‚áô</span></sub> œÜ h"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>g</span><span> </span><span>h</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>g</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"g ‚àà H"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"h ‚àà H"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"œÜ g = œÜ h"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g ‚àà carrier G"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h ‚àà carrier G"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>HG</span><span> </span><span>subgroup.mem_carrier</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>eq</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g = h"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>œÜ</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>iso_def</span><span> </span><span>bij_betw_def</span><span> </span><span>inj_on_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThe intersection of two subgroups is, again, a subgroup‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>group</span><span class="delimiter">)</span><span> </span><span>subgroup_intersect</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subgroup H G"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subgroup H' G"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subgroup (H ‚à© H') G"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>subgroup_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπFacts about Normal Subgroups‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>normal</span><span class="delimiter">)</span><span> </span><span>is_normal</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H ‚ä≤ G"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>coset_eq</span><span> </span><span>is_subgroup</span><span> </span><span>normalI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπBeing a normal subgroup is preserved by surjective homomorphisms.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>normal</span><span class="delimiter">)</span><span> </span><span>surj_hom_normal_subgroup</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>œÜ</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"group_hom G F œÜ"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>œÜsurj</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"œÜ ` (carrier G) = carrier F"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(œÜ ` H) ‚ä≤ F"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>group.normalI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>œÜ</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"group F"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>group_hom_def</span><span> </span><span>group_hom_axioms_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>œÜ</span><span> </span><span>œÜsurj</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subgroup (œÜ ` H) F"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>surj_hom_subgroup</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄx‚ààcarrier F. œÜ ` H #&gt;<span class="hidden">‚áò</span><sub>F<span class="hidden">‚áô</span></sub> x = x &lt;#<span class="hidden">‚áò</span><sub>F<span class="hidden">‚áô</span></sub> œÜ ` H"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>f</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>f</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"f ‚àà carrier F"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>œÜsurj</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>g</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>g</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"g ‚àà carrier G"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f = œÜ g"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"œÜ ` H #&gt;<span class="hidden">‚áò</span><sub>F<span class="hidden">‚áô</span></sub> f = œÜ ` H #&gt;<span class="hidden">‚áò</span><sub>F<span class="hidden">‚áô</span></sub> œÜ g"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (Œªx. (œÜ x) ‚äó<span class="hidden">‚áò</span><sub>F<span class="hidden">‚áô</span></sub> (œÜ g)) ` H"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>r_coset_def</span><span> </span><span>image_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (Œªx. œÜ (x ‚äó g)) ` H"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset</span><span> </span><span>g</span><span> </span><span>œÜ</span><span> </span><span>group_hom.hom_mult</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>image_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = œÜ ` (H #&gt; g)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>œÜ</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>r_coset_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = œÜ ` (g &lt;# H)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>coset_eq</span><span> </span><span>g</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (Œªx. œÜ (g ‚äó x)) ` H"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>œÜ</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>l_coset_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (Œªx. (œÜ g) ‚äó<span class="hidden">‚áò</span><sub>F<span class="hidden">‚áô</span></sub> (œÜ x)) ` H"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset</span><span> </span><span>g</span><span> </span><span>œÜ</span><span> </span><span>group_hom.hom_mult</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = œÜ g &lt;#<span class="hidden">‚áò</span><sub>F<span class="hidden">‚áô</span></sub> œÜ ` H"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>l_coset_def</span><span> </span><span>image_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = f &lt;#<span class="hidden">‚áò</span><sub>F<span class="hidden">‚áô</span></sub> œÜ ` H"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>g</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"œÜ ` H #&gt;<span class="hidden">‚áò</span><sub>F<span class="hidden">‚áô</span></sub> f = f &lt;#<span class="hidden">‚áò</span><sub>F<span class="hidden">‚áô</span></sub> œÜ ` H"</span></span></span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπBeing a normal subgroup is preserved by group isomorphisms.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>iso_normal_subgroup</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>groups</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"group G"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"group F"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>HG</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"H ‚ä≤ G"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>œÜ</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"œÜ ‚àà iso G F"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(œÜ ` H) ‚ä≤ F"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>groups</span><span> </span><span>œÜ</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"group_hom G F œÜ"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>group_hom_def</span><span> </span><span>group_hom_axioms_def</span><span> </span><span>iso_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>œÜ</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"œÜ ` (carrier G) = carrier F"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>iso_def</span><span> </span><span>bij_betw_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>HG</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>normal.surj_hom_normal_subgroup</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThe trivial subgroup is a subgroup:‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>group</span><span class="delimiter">)</span><span> </span><span>triv_subgroup</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subgroup {ùü≠} G"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>subgroup_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThe cardinality of the right cosets of the trivial subgroup is the cardinality of the group itself:‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>group</span><span class="delimiter">)</span><span> </span><span>card_rcosets_triv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (carrier G)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (rcosets {ùü≠}) = order G"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subgroup {ùü≠} G"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>triv_subgroup</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (rcosets {ùü≠}) * card {ùü≠} = order G"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lagrange</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>card_Suc_eq</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThe intersection of two normal subgroups is, again, a normal subgroup.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>group</span><span class="delimiter">)</span><span> </span><span>normal_subgroup_intersect</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M ‚ä≤ G"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"N ‚ä≤ G"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M ‚à© N ‚ä≤ G"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>subgroup_intersect</span><span> </span><span>is_group</span><span> </span><span>normal_inv_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThe set product of two normal subgroups is a normal subgroup.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>group</span><span class="delimiter">)</span><span> </span><span>setmult_lcos_assoc</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"‚ü¶H ‚äÜ carrier G; K ‚äÜ carrier G; x ‚àà carrier G‚üß
      ‚üπ (x &lt;# H) &lt;#&gt; K = x &lt;# (H &lt;#&gt; K)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>l_coset_def</span><span> </span><span>set_mult_def</span><span> </span><span>m_assoc</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>group</span><span class="delimiter">)</span><span> </span><span>normal_subgroup_set_mult_closed</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M ‚ä≤ G"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"N ‚ä≤ G"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M &lt;#&gt; N ‚ä≤ G"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>normalI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subgroup (M &lt;#&gt; N) G"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>second_isomorphism_grp.normal_set_mult_subgroup</span><span> </span><span>normal_imp_subgroup</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>second_isomorphism_grp_def</span><span> </span><span>second_isomorphism_grp_axioms_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄx‚ààcarrier G. M &lt;#&gt; N #&gt; x = x &lt;# (M &lt;#&gt; N)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"x ‚àà carrier G"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M &lt;#&gt; N #&gt; x = M &lt;#&gt; (N #&gt; x)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span>normal_inv_iff</span><span> </span><span>setmult_rcos_assoc</span><span> </span><span>subgroup.subset</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = M &lt;#&gt; (x &lt;# N)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>normal.coset_eq</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = (M #&gt; x) &lt;#&gt; N"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span>normal_imp_subgroup</span><span> </span><span>rcos_assoc_lcos</span><span> </span><span>subgroup.subset</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = (x &lt;# M) &lt;#&gt; N"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>normal.coset_eq</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = x &lt;# (M &lt;#&gt; N)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span>normal_imp_subgroup</span><span> </span><span>setmult_lcos_assoc</span><span> </span><span>subgroup.subset</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M &lt;#&gt; N #&gt; x = x &lt;# (M &lt;#&gt; N)"</span></span></span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThe following is a very basic lemma about subgroups: If restricting the carrier of
  a group yields a group it's a subgroup of the group we've started with.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>group</span><span class="delimiter">)</span><span> </span><span>restrict_group_imp_subgroup</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H ‚äÜ carrier G"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"group (G‚¶ácarrier := H‚¶à)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subgroup H G"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H ‚äÜ carrier G"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ‚àà H"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ‚àà H"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ‚àà carrier (G‚¶ácarrier := H‚¶à)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ‚àà carrier (G‚¶ácarrier := H‚¶à)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ‚äó y ‚àà H"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>group.is_monoid</span><span> </span><span>monoid.m_closed</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùü≠ ‚àà H"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>group.is_monoid</span><span> </span><span>monoid.one_closed</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ‚àà H"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"x ‚àà carrier (G‚¶ácarrier := H‚¶à)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">‚áò</span><sub>G‚¶ácarrier := H‚¶à<span class="hidden">‚áô</span></sub> x ‚àà carrier (G‚¶ácarrier := H‚¶à)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>group.inv_closed</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">‚áò</span><sub>G‚¶ácarrier := H‚¶à<span class="hidden">‚áô</span></sub> x ‚àà carrier G"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">‚áò</span><sub>G‚¶ácarrier := H‚¶à<span class="hidden">‚áô</span></sub> x ‚äó x = ùü≠"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>group.l_inv</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ‚àà carrier G"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">‚áò</span><sub>G‚¶ácarrier := H‚¶à<span class="hidden">‚áô</span></sub> x = inv x"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv_equality</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv x ‚àà H"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>group.inv_closed</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπA subgroup relation survives factoring by a normal subgroup.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>group</span><span class="delimiter">)</span><span> </span><span>normal_subgroup_factorize</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"N ‚ä≤ G"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"N ‚äÜ H"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subgroup H G"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subgroup (rcosets<span class="hidden">‚áò</span><sub>G‚¶ácarrier := H‚¶à<span class="hidden">‚áô</span></sub> N) (G Mod N)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>GModN</span><span class="delimiter">:</span><span> </span><span>group</span><span> </span><span class="string"><span class="delete"><span class="delete">"G Mod N"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>normal.factorgroup_is_group</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"N ‚ä≤ G‚¶ácarrier := H‚¶à"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>normal_restrict_supergroup</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>grpHN</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"group (G‚¶ácarrier := H‚¶à Mod N)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>normal.factorgroup_is_group</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(&lt;#&gt;<span class="hidden">‚áò</span><sub>G‚¶ácarrier:=H‚¶à<span class="hidden">‚áô</span></sub>) = (ŒªU K. (‚ãÉh‚ààU. ‚ãÉk‚ààK. {h ‚äó<span class="hidden">‚áò</span><sub>G‚¶ácarrier := H‚¶à<span class="hidden">‚áô</span></sub> k}))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>set_mult_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = (ŒªU K. (‚ãÉh‚ààU. ‚ãÉk‚ààK. {h ‚äó<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub> k}))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(&lt;#&gt;) = (ŒªU K. (‚ãÉh‚ààU. ‚ãÉk‚ààK. {h ‚äó k}))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>set_mult_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(&lt;#&gt;<span class="hidden">‚áò</span><sub>G‚¶ácarrier:=H‚¶à<span class="hidden">‚áô</span></sub>) = (&lt;#&gt;<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub>)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>grpHN</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"group ((G Mod N)‚¶ácarrier := (rcosets<span class="hidden">‚áò</span><sub>G‚¶ácarrier := H‚¶à<span class="hidden">‚áô</span></sub> N)‚¶à)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FactGroup_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rcosets<span class="hidden">‚áò</span><sub>G‚¶ácarrier := H‚¶à<span class="hidden">‚áô</span></sub> N ‚äÜ carrier (G Mod N)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FactGroup_def</span><span> </span><span>RCOSETS_def</span><span> </span><span>r_coset_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>subgroup.subset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>GModN.is_group</span><span> </span><span>group.restrict_group_imp_subgroup</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπA normality relation survives factoring by a normal subgroup.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>group</span><span class="delimiter">)</span><span> </span><span>normality_factorization</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>NG</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"N ‚ä≤ G"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>NH</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"N ‚äÜ H"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>HG</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"H ‚ä≤ G"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(rcosets<span class="hidden">‚áò</span><sub>G‚¶ácarrier := H‚¶à<span class="hidden">‚áô</span></sub> N) ‚ä≤ (G Mod N)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>GModN</span><span class="delimiter">:</span><span> </span><span>group</span><span> </span><span class="string"><span class="delete"><span class="delete">"G Mod N"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>normal.factorgroup_is_group</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>GModN.normal_inv_iff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subgroup (rcosets<span class="hidden">‚áò</span><sub>G‚¶ácarrier := H‚¶à<span class="hidden">‚áô</span></sub> N) (G Mod N)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>normal_imp_subgroup</span><span> </span><span>normal_subgroup_factorize</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>U</span><span> </span><span>V</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>U</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"U ‚àà carrier (G Mod N)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>V</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"V ‚àà rcosets<span class="hidden">‚áò</span><sub>G‚¶ácarrier := H‚¶à<span class="hidden">‚áô</span></sub> N"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>g</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>g</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"g ‚àà carrier G"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"U = N #&gt; g"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FactGroup_def</span><span> </span><span>RCOSETS_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>V</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>h</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>h</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"h ‚àà H"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V = N #&gt; h"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FactGroup_def</span><span> </span><span>RCOSETS_def</span><span> </span><span>r_coset_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>hG</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"h ‚àà carrier G"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>HG</span><span> </span><span>normal_imp_subgroup</span><span> </span><span>subgroup.mem_carrier</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>ghG</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"g ‚äó h ‚àà carrier G"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>g</span><span> </span><span>m_closed</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>g</span><span> </span><span>h</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g ‚äó h ‚äó inv g ‚àà H"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>HG</span><span> </span><span>normal_inv_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"U &lt;#&gt; V &lt;#&gt; inv<span class="hidden">‚áò</span><sub>G Mod N<span class="hidden">‚áô</span></sub> U = N #&gt; (g ‚äó h ‚äó inv g)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>g</span><span> </span><span>U</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">‚áò</span><sub>G Mod N<span class="hidden">‚áô</span></sub> U = N #&gt; inv g"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NG</span><span> </span><span>normal.inv_FactGroup</span><span> </span><span>normal.rcos_inv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"U &lt;#&gt; V &lt;#&gt; inv<span class="hidden">‚áò</span><sub>G Mod N<span class="hidden">‚áô</span></sub> U = (N #&gt; g) &lt;#&gt; (N #&gt; h) &lt;#&gt; (N #&gt; inv g)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>g</span><span> </span><span>h</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = N #&gt; (g ‚äó h) &lt;#&gt; (N #&gt; inv g)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>g</span><span> </span><span>hG</span><span> </span><span>NG</span><span> </span><span>normal.rcos_sum</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = N #&gt; (g ‚äó h ‚äó inv g)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>g</span><span> </span><span>inv_closed</span><span> </span><span>ghG</span><span> </span><span>NG</span><span> </span><span>normal.rcos_sum</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"U &lt;#&gt; V &lt;#&gt; inv<span class="hidden">‚áò</span><sub>G Mod N<span class="hidden">‚áô</span></sub> U ‚àà rcosets<span class="hidden">‚áò</span><sub>G‚¶ácarrier := H‚¶à<span class="hidden">‚áô</span></sub> N"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>RCOSETS_def</span><span> </span><span>r_coset_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπFactoring by a normal subgroups yields the trivial group iff the subgroup is the whole group.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>normal</span><span class="delimiter">)</span><span> </span><span>fact_group_trivial_iff</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (carrier G)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(carrier (G Mod H) = {ùü≠<span class="hidden">‚áò</span><sub>G Mod H<span class="hidden">‚áô</span></sub>}) = (H = carrier G)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"carrier (G Mod H) = {ùü≠<span class="hidden">‚áò</span><sub>G Mod H<span class="hidden">‚áô</span></sub>}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span>lagrange</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"order (G Mod H) * card H = order G"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FactGroup_def</span><span> </span><span>order_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>is_subgroup</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card H = order G"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>order_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H = carrier G"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subgroup.subset</span><span> </span><span>is_subgroup</span><span> </span><span>assms</span><span> </span><span>card_subset_eq</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>order_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ordergt0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"order G &gt; 0"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>order_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>subgroup.finite_imp_card_positive</span><span> </span><span>subgroup_self</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H = carrier G"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card H = order G"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>order_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span>is_subgroup</span><span> </span><span>lagrange</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (rcosets H) * order G = order G"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ordergt0</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (rcosets H) = 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mult_eq_self_implies_10</span><span> </span><span>mult.commute</span><span> </span><span>neq0_conv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"order (G Mod H) = 1"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>order_def</span><span> </span><span>FactGroup_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"carrier (G Mod H) = {ùü≠<span class="hidden">‚áò</span><sub>G Mod H<span class="hidden">‚áô</span></sub>}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>factorgroup_is_group</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>group.order_one_triv_iff</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπFinite groups have finite quotients.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>normal</span><span class="delimiter">)</span><span> </span><span>factgroup_finite</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (carrier G)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (rcosets H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>RCOSETS_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThe union of all the cosets contained in a subgroup of a quotient group acts as a represenation for that subgroup.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>normal</span><span class="delimiter">)</span><span> </span><span>factgroup_subgroup_union_char</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subgroup A (G Mod H)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(‚ãÉA) = {x ‚àà carrier G. H #&gt; x ‚àà A}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÉA ‚äÜ {x ‚àà carrier G. H #&gt; x ‚àà A}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"x ‚àà ‚ãÉA"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>a</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"a ‚àà A"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ‚àà a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>xx</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"x ‚àà carrier G"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subgroup.subset</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FactGroup_def</span><span> </span><span>RCOSETS_def</span><span> </span><span>r_coset_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span>a</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>y</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"y ‚àà carrier G"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a = H #&gt; y"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subgroup.subset</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FactGroup_def</span><span> </span><span>RCOSETS_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ‚àà H #&gt; y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H #&gt; y = H #&gt; x"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>y</span><span> </span><span>is_subgroup</span><span> </span><span>repr_independence</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>y</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>a</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H #&gt; x ‚àà A"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>xx</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ‚àà {x ‚àà carrier G. H #&gt; x ‚àà A}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{x ‚àà carrier G. H #&gt; x ‚àà A} ‚äÜ ‚ãÉA"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"x ‚àà {x ‚àà carrier G. H #&gt; x ‚àà A}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>xx</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"x ‚àà carrier G"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H #&gt; x ‚àà A"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ‚àà H #&gt; x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>is_subgroup</span><span> </span><span>rcos_self</span><span> </span><span>xx</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ‚àà ‚ãÉA"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>normal</span><span class="delimiter">)</span><span> </span><span>factgroup_subgroup_union_subgroup</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subgroup A (G Mod H)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subgroup (‚ãÉA) G"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subgroup {x ‚àà carrier G. H #&gt; x ‚àà A} G"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{x ‚àà carrier G. H #&gt; x ‚àà A} ‚äÜ carrier G"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ‚àà {x ‚àà carrier G. H #&gt; x ‚àà A}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ‚àà {x ‚àà carrier G. H #&gt; x ‚àà A}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"x ‚àà carrier G"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H #&gt; x ‚àà A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"y ‚àà carrier G"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H #&gt; y ‚àà A"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>xyG</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"x ‚äó y ‚àà carrier G"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>m_closed</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(H #&gt; x) &lt;#&gt; (H #&gt; y) ‚àà A"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subgroup.m_closed</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FactGroup_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H #&gt; (x ‚äó y) ‚àà A"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>rcos_sum</span><span> </span><span>x</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>y</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>xyG</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ‚äó y ‚àà {x ‚àà carrier G. H #&gt; x ‚àà A}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H #&gt; ùü≠ ‚àà A"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>subgroup.one_closed</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FactGroup_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>coset_mult_one</span><span> </span><span>monoid.select_convs</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>subset</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span>one_closed</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùü≠ ‚àà {x ‚àà carrier G. H #&gt; x ‚àà A}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ‚àà {x ‚àà carrier G. H #&gt; x ‚àà A}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"x ‚àà carrier G"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H #&gt; x ‚àà A"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>invx</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"inv x ‚àà carrier G"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv_closed</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_inv (H #&gt; x) ‚àà A"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subgroup.m_inv_closed</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inv_FactGroup</span><span> </span><span>subgroup.mem_carrier</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H #&gt; (inv x) ‚àà A"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>rcos_inv</span><span> </span><span>x</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>invx</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv x ‚àà {x ‚àà carrier G. H #&gt; x ‚àà A}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span>factgroup_subgroup_union_char</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>normal</span><span class="delimiter">)</span><span> </span><span>factgroup_subgroup_union_normal</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A ‚ä≤ (G Mod H)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÉA ‚ä≤ G"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{x ‚àà carrier G. H #&gt; x ‚àà A} ‚ä≤ G"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>normal_def</span><span> </span><span>normal_axioms_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>auto</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*(auto del: equalityI)*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subgroup {x ‚àà carrier G. H #&gt; x ‚àà A} G"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>factgroup_subgroup_union_char</span><span> </span><span>factgroup_subgroup_union_subgroup</span><span> </span><span>normal_imp_subgroup</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>Anormal</span><span class="delimiter">:</span><span> </span><span>normal</span><span> </span><span>A</span><span> </span><span class="string"><span class="delete"><span class="delete">"(G Mod H)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"x ‚àà carrier G"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ‚àà {x ‚àà carrier G. H #&gt; x ‚àà A} #&gt; x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x' ‚àà {x ‚àà carrier G. H #&gt; x ‚àà A}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y = x' ‚äó x"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>r_coset_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>x'</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"x' ‚àà carrier G"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H #&gt; x' ‚àà A"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>x</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Hx</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"H #&gt; x ‚àà carrier (G Mod H)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FactGroup_def</span><span> </span><span>RCOSETS_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>x'</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(inv<span class="hidden">‚áò</span><sub>G Mod H<span class="hidden">‚áô</span></sub> (H #&gt; x)) ‚äó<span class="hidden">‚áò</span><sub>G Mod H<span class="hidden">‚áô</span></sub> (H #&gt; x') ‚äó<span class="hidden">‚áò</span><sub>G Mod H<span class="hidden">‚áô</span></sub> (H #&gt; x) ‚àà A"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Anormal.inv_op_closed1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(set_inv (H #&gt; x)) &lt;#&gt; (H #&gt; x') &lt;#&gt; (H #&gt; x) ‚àà A"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv_FactGroup</span><span> </span><span>Hx</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FactGroup_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(H #&gt; (inv x)) &lt;#&gt; (H #&gt; x') &lt;#&gt; (H #&gt; x) ‚àà A"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>rcos_inv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(H #&gt; (inv x ‚äó x')) &lt;#&gt; (H #&gt; x) ‚àà A"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inv_closed</span><span> </span><span>rcos_sum</span><span> </span><span>x'</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>x</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H #&gt; (inv x ‚äó x' ‚äó x) ‚àà A"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inv_closed</span><span> </span><span>m_closed</span><span> </span><span>rcos_sum</span><span> </span><span>x'</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>x</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv x ‚äó x' ‚äó x ‚àà carrier G"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x</span><span> </span><span>x'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inv_closed</span><span> </span><span>m_closed</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv x ‚äó x' ‚äó x ‚àà {x ‚àà carrier G. H #&gt; x ‚àà A}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>xcoset</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"x ‚äó (inv x ‚äó x' ‚äó x) ‚àà x &lt;# {x ‚àà carrier G. H #&gt; x ‚àà A}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>l_coset_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ‚äó (inv x ‚äó x' ‚äó x) = (x ‚äó inv x) ‚äó x' ‚äó x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Units_eq</span><span> </span><span>Units_inv_Units</span><span> </span><span>m_assoc</span><span> </span><span>m_closed</span><span> </span><span>x'</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>x</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = x' ‚äó x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>l_one</span><span> </span><span>r_inv</span><span> </span><span>x'</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>x</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπy = x' ‚äó x‚Ä∫</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ‚äó (inv x ‚äó x' ‚äó x) = y"</span></span></span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>xcoset</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ‚àà x &lt;# {x ‚àà carrier G. H #&gt; x ‚àà A}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>Anormal</span><span class="delimiter">:</span><span> </span><span>normal</span><span> </span><span>A</span><span> </span><span class="string"><span class="delete"><span class="delete">"(G Mod H)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"x ‚àà carrier G"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ‚àà x &lt;# {x ‚àà carrier G. H #&gt; x ‚àà A}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x' ‚àà {x ‚àà carrier G. H #&gt; x ‚àà A}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y = x ‚äó x'"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>l_coset_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>x'</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"x' ‚àà carrier G"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H #&gt; x' ‚àà A"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>x</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>invx</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"inv x ‚àà carrier G"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>inv_closed</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>Hinvx</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"H #&gt; (inv x) ‚àà carrier (G Mod H)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FactGroup_def</span><span> </span><span>RCOSETS_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>x'</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(inv<span class="hidden">‚áò</span><sub>G Mod H<span class="hidden">‚áô</span></sub> (H #&gt; inv x)) ‚äó<span class="hidden">‚áò</span><sub>G Mod H<span class="hidden">‚áô</span></sub> (H #&gt; x') ‚äó<span class="hidden">‚áò</span><sub>G Mod H<span class="hidden">‚áô</span></sub> (H #&gt; inv x) ‚àà A"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invx</span><span> </span><span>Anormal.inv_op_closed1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(set_inv (H #&gt; inv x)) &lt;#&gt; (H #&gt; x') &lt;#&gt; (H #&gt; inv x) ‚àà A"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv_FactGroup</span><span> </span><span>Hinvx</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FactGroup_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(H #&gt; inv (inv x)) &lt;#&gt; (H #&gt; x') &lt;#&gt; (H #&gt; inv x) ‚àà A"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invx</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>rcos_inv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(H #&gt; x) &lt;#&gt; (H #&gt; x') &lt;#&gt; (H #&gt; inv x) ‚àà A"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inv_inv</span><span> </span><span>x</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(H #&gt; (x ‚äó x')) &lt;#&gt; (H #&gt; inv x) ‚àà A"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>rcos_sum</span><span> </span><span>x'</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>x</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H #&gt; (x ‚äó x' ‚äó inv x) ‚àà A"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inv_closed</span><span> </span><span>m_closed</span><span> </span><span>rcos_sum</span><span> </span><span>x'</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>x</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ‚äó x' ‚äó inv x ‚àà carrier G"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x</span><span> </span><span>x'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inv_closed</span><span> </span><span>m_closed</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ‚äó x' ‚äó inv x ‚àà {x ‚àà carrier G. H #&gt; x ‚àà A}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>xcoset</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(x ‚äó x' ‚äó inv x) ‚äó x ‚àà {x ‚àà carrier G. H #&gt; x ‚àà A} #&gt; x"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>r_coset_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invx</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x ‚äó x' ‚äó inv x) ‚äó x = (x ‚äó x') ‚äó (inv x ‚äó x)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Units_eq</span><span> </span><span>Units_inv_Units</span><span> </span><span>m_assoc</span><span> </span><span>m_closed</span><span> </span><span>x'</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>x</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = x ‚äó x'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>l_inv</span><span> </span><span>x'</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>m_closed</span><span> </span><span>r_one</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπy = x ‚äó x'‚Ä∫</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ‚äó x' ‚äó inv x ‚äó x = y"</span></span></span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>xcoset</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ‚àà {x ‚àà carrier G. H #&gt; x ‚àà A} #&gt; x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>factgroup_subgroup_union_char</span><span> </span><span>normal_imp_subgroup</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>normal</span><span class="delimiter">)</span><span> </span><span>factgroup_subgroup_union_factor</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subgroup A (G Mod H)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A = rcosets<span class="hidden">‚áò</span><sub>G‚¶ácarrier := ‚ãÉA‚¶à<span class="hidden">‚áô</span></sub> H"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A = rcosets<span class="hidden">‚áò</span><sub>G‚¶ácarrier := {x ‚àà carrier G. H #&gt; x ‚àà A}‚¶à<span class="hidden">‚áô</span></sub> H"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>U</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>U</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"U ‚àà A"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x'</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"x' ‚àà carrier G"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"U = H #&gt; x'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>subgroup.subset</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FactGroup_def</span><span> </span><span>RCOSETS_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>U</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H #&gt; x' ‚àà A"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>x'</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"U ‚àà rcosets<span class="hidden">‚áò</span><sub>G‚¶ácarrier := {x ‚àà carrier G. H #&gt; x ‚àà A}‚¶à<span class="hidden">‚áô</span></sub> H"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>RCOSETS_def</span><span> </span><span>r_coset_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>U</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>U</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"U ‚àà rcosets<span class="hidden">‚áò</span><sub>G‚¶ácarrier := {x ‚àà carrier G. H #&gt; x ‚àà A}‚¶à<span class="hidden">‚áô</span></sub> H"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x'</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"x' ‚àà {x ‚àà carrier G. H #&gt; x ‚àà A}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"U = H #&gt; x'"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>RCOSETS_def</span><span> </span><span>r_coset_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x' ‚àà carrier G"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H #&gt; x' ‚àà A"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>x'</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"U ‚àà A"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>factgroup_subgroup_union_char</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπFlattening the type of group carriers‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπFlattening here means to convert the type of group elements from 'a set to 'a.
This is possible whenever the empty set is not an element of the group.‚Ä∫</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>flatten</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"flatten (G::('a set, 'b) monoid_scheme) rep = ‚¶ácarrier=(rep ` (carrier G)),
      monoid.mult=(Œª x y. rep ((the_inv_into (carrier G) rep x) ‚äó<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub> (the_inv_into (carrier G) rep y))), 
      one=rep ùü≠<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub> ‚¶à"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flatten_set_group_hom</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>group</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"group G"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>inj</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"inj_on rep (carrier G)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rep ‚àà hom G (flatten G rep)"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hom_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>g</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>g</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"g ‚àà carrier G"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rep g ‚àà carrier (flatten G rep)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>flatten_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>g</span><span> </span><span>h</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>g</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"g ‚àà carrier G"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"h ‚àà carrier G"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rep g ‚àà carrier (flatten G rep)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rep h ‚àà carrier (flatten G rep)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>flatten_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rep g ‚äó<span class="hidden">‚áò</span><sub>flatten G rep<span class="hidden">‚áô</span></sub> rep h
    = rep (the_inv_into (carrier G) rep (rep g) ‚äó<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub> the_inv_into (carrier G) rep (rep h))"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>flatten_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = rep (g ‚äó<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub> h)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inj</span><span> </span><span>g</span><span> </span><span>h</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>the_inv_into_f_f</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rep (g ‚äó<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub> h) = rep g ‚äó<span class="hidden">‚áò</span><sub>flatten G rep<span class="hidden">‚áô</span></sub> rep h"</span></span></span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flatten_set_group</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>group</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"group G"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>inj</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"inj_on rep (carrier G)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"group (flatten G rep)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>groupI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"x ‚àà carrier (flatten G rep)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"y ‚àà carrier (flatten G rep)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>g</span><span> </span><span>h</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g = the_inv_into (carrier G) rep x"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h = the_inv_into (carrier G) rep y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ‚äó<span class="hidden">‚áò</span><sub>flatten G rep<span class="hidden">‚áô</span></sub> y = rep (g ‚äó<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub> h)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>flatten_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>g_def</span><span> </span><span>h_def</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g ‚àà carrier G"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h ‚àà carrier G"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inj</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>the_inv_into_into</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>flatten_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>partial_object.select_convs</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>subset_refl</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g ‚äó<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub> h ‚àà carrier G"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>group</span><span> </span><span>group.is_monoid</span><span> </span><span>monoid.m_closed</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rep (g ‚äó<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub> h) ‚àà carrier (flatten G rep)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>flatten_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ‚äó<span class="hidden">‚áò</span><sub>flatten G rep<span class="hidden">‚áô</span></sub> y ‚àà carrier (flatten G rep)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùü≠<span class="hidden">‚áò</span><sub>flatten G rep<span class="hidden">‚áô</span></sub> ‚àà carrier (flatten G rep)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>flatten_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>group</span><span> </span><span>group.is_monoid</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"x ‚àà carrier (flatten G rep)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"y ‚àà carrier (flatten G rep)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>z</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"z ‚àà carrier (flatten G rep)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>g</span><span> </span><span>h</span><span> </span><span>k</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g = the_inv_into (carrier G) rep x"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h = the_inv_into (carrier G) rep y"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k = the_inv_into (carrier G) rep z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ‚äó<span class="hidden">‚áò</span><sub>flatten G rep<span class="hidden">‚áô</span></sub> y ‚äó<span class="hidden">‚áò</span><sub>flatten G rep<span class="hidden">‚áô</span></sub> z = (rep (g ‚äó<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub> h)) ‚äó <span class="hidden">‚áò</span><sub>flatten G rep<span class="hidden">‚áô</span></sub> z"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>flatten_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = rep (the_inv_into (carrier G) rep (rep (g ‚äó<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub> h)) ‚äó<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub> k)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>k_def</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>flatten_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>g_def</span><span> </span><span>h_def</span><span> </span><span>k_def</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ghkG</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"g ‚àà carrier G"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h ‚àà carrier G"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k ‚àà carrier G"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inj</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span> </span><span>the_inv_into_into</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>flatten_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>gh</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"g ‚äó<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub> h ‚àà carrier G"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hk</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"h ‚äó<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub> k ‚àà carrier G"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>group</span><span> </span><span>group.is_monoid</span><span> </span><span>monoid.m_closed</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rep (the_inv_into (carrier G) rep (rep (g ‚äó<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub> h)) ‚äó<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub> k) = rep ((g ‚äó<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub> h) ‚äó<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub> k)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>flatten_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inj</span><span> </span><span>the_inv_into_f_f</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = rep (g ‚äó<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub> (h ‚äó<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub> k))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>group</span><span> </span><span>group.is_monoid</span><span> </span><span>ghkG</span><span> </span><span>monoid.m_assoc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = x ‚äó<span class="hidden">‚áò</span><sub>flatten G rep<span class="hidden">‚áô</span></sub> (rep (h ‚äó<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub> k))"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>g_def</span><span> </span><span>flatten_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hk</span><span> </span><span>inj</span><span> </span><span>the_inv_into_f_f</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = x ‚äó<span class="hidden">‚áò</span><sub>flatten G rep<span class="hidden">‚áô</span></sub> (y ‚äó<span class="hidden">‚áò</span><sub>flatten G rep<span class="hidden">‚áô</span></sub> z)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>h_def</span><span> </span><span>k_def</span><span> </span><span>flatten_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ‚äó<span class="hidden">‚áò</span><sub>flatten G rep<span class="hidden">‚áô</span></sub> y ‚äó<span class="hidden">‚áò</span><sub>flatten G rep<span class="hidden">‚áô</span></sub> z = x ‚äó<span class="hidden">‚áò</span><sub>flatten G rep<span class="hidden">‚áô</span></sub> (y ‚äó<span class="hidden">‚áò</span><sub>flatten G rep<span class="hidden">‚áô</span></sub> z)"</span></span></span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"x ‚àà carrier (flatten G rep)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>g</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g = the_inv_into (carrier G) rep x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>gG</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"g ‚àà carrier G"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inj</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>flatten_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>the_inv_into_into</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùü≠<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub> ‚àà (carrier G)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>group</span><span> </span><span>group.is_monoid</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"the_inv_into (carrier G) rep (ùü≠<span class="hidden">‚áò</span><sub>flatten G rep<span class="hidden">‚áô</span></sub>) = ùü≠<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>flatten_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>the_inv_into_f_f</span><span> </span><span>inj</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùü≠<span class="hidden">‚áò</span><sub>flatten G rep<span class="hidden">‚áô</span></sub> ‚äó<span class="hidden">‚áò</span><sub>flatten G rep<span class="hidden">‚áô</span></sub> x = rep (ùü≠<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub> ‚äó<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub> g)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>flatten_def</span><span> </span><span>g_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = rep g"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gG</span><span> </span><span>group</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>group.is_monoid</span><span> </span><span>monoid.l_one</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = x"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>g_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inj</span><span> </span><span>x</span><span> </span><span>f_the_inv_into_f</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>flatten_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùü≠<span class="hidden">‚áò</span><sub>flatten G rep<span class="hidden">‚áô</span></sub> ‚äó<span class="hidden">‚áò</span><sub>flatten G rep<span class="hidden">‚áô</span></sub> x = x"</span></span></span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>group</span><span> </span><span>inj</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>hom</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"rep ‚àà hom G (flatten G rep)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>flatten_set_group_hom</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"x ‚àà carrier (flatten G rep)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>g</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g = the_inv_into (carrier G) rep x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>gG</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"g ‚àà carrier G"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inj</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>flatten_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>the_inv_into_into</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>invG</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"inv<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub> g ‚àà carrier G"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>group</span><span> </span><span>group.inv_closed</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rep (inv<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub> g) ‚àà carrier (flatten G rep)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>flatten_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rep (inv<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub> g) ‚äó<span class="hidden">‚áò</span><sub>flatten G rep<span class="hidden">‚áô</span></sub> x = rep (inv<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub> g) ‚äó<span class="hidden">‚áò</span><sub>flatten G rep<span class="hidden">‚áô</span></sub> (rep g)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>g_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_the_inv_into_f</span><span> </span><span>inj</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>flatten_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rep (inv<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub> g) ‚äó<span class="hidden">‚áò</span><sub>flatten G rep<span class="hidden">‚áô</span></sub> x = rep (inv<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub> g ‚äó<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub> g)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hom</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hom_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gG</span><span> </span><span>invG</span><span> </span><span>hom_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rep (inv<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub> g) ‚äó<span class="hidden">‚áò</span><sub>flatten G rep<span class="hidden">‚áô</span></sub> x = rep ùü≠<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invG</span><span> </span><span>gG</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>group</span><span> </span><span>group.l_inv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rep (inv<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub> g) ‚äó<span class="hidden">‚áò</span><sub>flatten G rep<span class="hidden">‚áô</span></sub> x = ùü≠<span class="hidden">‚áò</span><sub>flatten G rep<span class="hidden">‚áô</span></sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>flatten_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÉy‚ààcarrier (flatten G rep). y ‚äó<span class="hidden">‚áò</span><sub>flatten G rep<span class="hidden">‚áô</span></sub> x = ùü≠<span class="hidden">‚áò</span><sub>flatten G rep<span class="hidden">‚áô</span></sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>normal</span><span class="delimiter">)</span><span> </span><span>flatten_set_group_mod_inj</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inj_on (ŒªU. SOME g. g ‚àà U) (carrier (G Mod H))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>inj_onI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>U</span><span> </span><span>V</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>U</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"U ‚àà carrier (G Mod H)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>V</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"V ‚àà carrier (G Mod H)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>g</span><span> </span><span>h</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>g</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"U = H #&gt; g"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g ‚àà carrier G"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"V = H #&gt; h"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h ‚àà carrier G"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FactGroup_def</span><span> </span><span>RCOSETS_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>notempty</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"U ‚â† {}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ‚â† {}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>empty_iff</span><span> </span><span>is_subgroup</span><span> </span><span>rcos_self</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(SOME g. g ‚àà U) = (SOME g. g ‚àà V)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>notempty</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(SOME g. g ‚àà U) ‚àà U ‚à© V"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>IntI</span><span> </span><span>ex_in_conv</span><span> </span><span>someI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"U = V"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Int_iff</span><span> </span><span>g</span><span> </span><span>h</span><span> </span><span>is_subgroup</span><span> </span><span>repr_independence</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>normal</span><span class="delimiter">)</span><span> </span><span>flatten_set_group_mod</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"group (flatten (G Mod H) (ŒªU. SOME g. g ‚àà U))"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>factorgroup_is_group</span><span> </span><span>flatten_set_group_mod_inj</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>flatten_set_group</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>normal</span><span class="delimiter">)</span><span> </span><span>flatten_set_group_mod_iso</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ŒªU. SOME g. g ‚àà U) ‚àà iso (G Mod H) (flatten (G Mod H) (ŒªU. SOME g. g ‚àà U))"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>iso_def</span><span> </span><span>bij_betw_def</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>flatten_set_group_mod_inj</span><span> </span><span>factorgroup_is_group</span><span> </span><span>flatten_set_group_hom</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>flatten_set_group_mod_inj</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>flatten_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="SimpleGroups">
<div class="head"><h1>Theory SimpleGroups</h1>
<span class="command">theory</span> <span class="name">SimpleGroups</span><br/>
<span class="keyword">imports</span> <a href="SubgroupsAndNormalSubgroups.html"><span class="name">SubgroupsAndNormalSubgroups</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:      Simple Groups
    Author:     Jakob von Raumer, Karlsruhe Institute of Technology
    Maintainer: Jakob von Raumer &lt;jakob.raumer@student.kit.edu&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>SimpleGroups</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>SubgroupsAndNormalSubgroups</span><span>
</span><span>  </span><span>Secondary_Sylow.SndSylow</span><span>
</span><span>  </span><span>SndIsomorphismGrp</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπSimple Groups‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>simple_group</span><span> </span><span class="delimiter">=</span><span> </span><span>group</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>order_gt_one</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"order G &gt; 1"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>no_real_normal_subgroup</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"‚ãÄH. H ‚ä≤ G ‚üπ (H = carrier G ‚à® H = {ùü≠})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>simple_group</span><span class="delimiter">)</span><span> </span><span>is_simple_group</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"simple_group G"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>simple_group_axioms</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπSimple groups are non-trivial.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>simple_group</span><span class="delimiter">)</span><span> </span><span>simple_not_triv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"carrier G ‚â† {ùü≠}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>order_gt_one</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>order_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπEvery group of prime order is simple‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>group</span><span class="delimiter">)</span><span> </span><span>prime_order_simple</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>prime</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"prime (order G)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"simple_group G"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>prime</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1 &lt; order G"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>prime_nat_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>H</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H ‚ä≤ G"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>HG</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"subgroup H G"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>normal_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card H dvd order G"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>card_subgrp_dvd</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>prime</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card H = 1 ‚à® card H = order G"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>prime_nat_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H = carrier G ‚à® H = {ùü≠}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card H = 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>HG</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùü≠ ‚àà H"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>subgroup.one_closed</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>card_Suc_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card H = order G"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>HG</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H ‚äÜ carrier G"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>subgroup_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>prime</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (carrier G) &gt; 1"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>order_def</span><span> </span><span>prime_nat_iff</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (carrier G)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>card_ge_0_finite</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>order_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>card_subset_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπBeing simple is a property that is preserved by isomorphisms.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>simple_group</span><span class="delimiter">)</span><span> </span><span>iso_simple</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>H</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"group H"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>iso</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"œÜ ‚àà iso G H"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"simple_group H"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>simple_group_def</span><span> </span><span>simple_group_axioms_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>equalityI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>iso</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"order G = order H"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>iso_def</span><span> </span><span>order_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bij_betw_same_card</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>order_gt_one</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc 0 &lt; order H"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inv_iso</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(inv_into (carrier G) œÜ) ‚àà iso H G"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>iso</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>iso_set_sym</span><span class="delimiter">)</span><span>    
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>N</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>NH</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"N ‚ä≤ H"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Nneq1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"N ‚â† {ùü≠<span class="hidden">‚áò</span><sub>H<span class="hidden">‚áô</span></sub>}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>Nnormal</span><span class="delimiter">:</span><span> </span><span>normal</span><span> </span><span>N</span><span> </span><span>H</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>M</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M = (inv_into (carrier G) œÜ) ` N"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>MG</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"M ‚ä≤ G"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv_iso</span><span> </span><span>NH</span><span> </span><span>H</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>is_group</span><span> </span><span>iso_normal_subgroup</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>surj</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"œÜ ` carrier G = carrier H"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>iso</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>iso_def</span><span> </span><span>bij_betw_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>MN</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"œÜ ` M = N"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Nnormal.subset</span><span> </span><span>image_inv_into_cancel</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M ‚â† {ùü≠}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>notI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M = {ùü≠}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"œÜ ` M = {œÜ ùü≠}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>image_empty</span><span> </span><span>image_insert</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"œÜ ` M = {ùü≠<span class="hidden">‚áò</span><sub>H<span class="hidden">‚áô</span></sub>}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Nnormal.is_subgroup</span><span> </span><span>MN</span><span> </span><span>calculation</span><span> </span><span>singleton_iff</span><span> </span><span>subgroup.one_closed</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Nneq1</span><span> </span><span>MN</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M = carrier G"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_real_normal_subgroup</span><span> </span><span>MG</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"N = carrier H"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>surj</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπAs a corollary of this: Factorizing a group by itself does not result in a simple group!‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>group</span><span class="delimiter">)</span><span> </span><span>self_factor_not_simple</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"¬¨ simple_group (G Mod (carrier G))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>assm</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"simple_group (G Mod (carrier G))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"group (G‚¶ácarrier :=  {ùü≠}‚¶à)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>subgroup_imp_group</span><span> </span><span>triv_subgroup</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assm</span><span> </span><span>self_factor_iso</span><span> </span><span>simple_group.iso_simple</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"simple_group (G‚¶ácarrier := {ùü≠}‚¶à)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>simple_group.simple_not_triv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="MaximalNormalSubgroups">
<div class="head"><h1>Theory MaximalNormalSubgroups</h1>
<span class="command">theory</span> <span class="name">MaximalNormalSubgroups</span><br/>
<span class="keyword">imports</span> <a href="SimpleGroups.html"><span class="name">SimpleGroups</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:      A locale for and a characterization of maximal normal subgroups
    Author:     Jakob von Raumer, Karlsruhe Institute of Technology
    Maintainer: Jakob von Raumer &lt;jakob.raumer@student.kit.edu&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>MaximalNormalSubgroups</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>SubgroupsAndNormalSubgroups</span><span>
</span><span>  </span><span>SimpleGroups</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπFacts about maximal normal subgroups‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπA maximal normal subgroup of $G$ is a normal subgroup which is not contained in other any proper
  normal subgroup of $G$.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>max_normal_subgroup</span><span> </span><span class="delimiter">=</span><span> </span><span>normal</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>proper</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"H ‚â† carrier G"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>max_normal</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"‚ãÄJ. J ‚ä≤ G ‚üπ J ‚â† H ‚üπ J ‚â† carrier G ‚üπ ¬¨ (H ‚äÜ J)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπAnother characterization of maximal normal subgroups: The factor group is simple.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>normal</span><span class="delimiter">)</span><span> </span><span>max_normal_simple_quotient</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>finite</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"finite (carrier G)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"max_normal_subgroup H G = simple_group (G Mod H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"max_normal_subgroup H G"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>maxH</span><span class="delimiter">:</span><span> </span><span>max_normal_subgroup</span><span> </span><span>H</span><span> </span><span>G</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"simple_group (G Mod H)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>simple_group_def</span><span> </span><span>simple_group_axioms_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>factorgroup_is_group</span><span> </span><span>allI</span><span> </span><span>impI</span><span> </span><span>disjCI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>finite</span><span> </span><span>factgroup_finite</span><span> </span><span>factorgroup_is_group</span><span> </span><span>group.finite_pos_order</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gt0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"0 &lt; card (rcosets H)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FactGroup_def</span><span> </span><span>order_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>maxH.proper</span><span> </span><span>finite</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"carrier (G Mod H) ‚â† {ùü≠<span class="hidden">‚áò</span><sub>G Mod H<span class="hidden">‚áô</span></sub>}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fact_group_trivial_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1 ‚â† order (G Mod H)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>factorgroup_is_group</span><span> </span><span>group.order_one_triv_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>gt0</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1 &lt; order (G Mod H)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>order_def</span><span> </span><span>FactGroup_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>A'</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A'normal</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"A' ‚ä≤ G Mod H"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>A'nottriv</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"A' ‚â† {ùü≠<span class="hidden">‚áò</span><sub>G Mod H<span class="hidden">‚áô</span></sub>}"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>A</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A = ‚ãÉA'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>A2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"A ‚ä≤ G"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A'normal</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>A_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>factgroup_subgroup_union_normal</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H ‚àà A'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A'normal</span><span> </span><span>normal_imp_subgroup</span><span> </span><span>subgroup.one_closed</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FactGroup_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H ‚äÜ A"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>A_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>A1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"H ‚ä≤ (G‚¶ácarrier := A‚¶à)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A2</span><span> </span><span>is_normal</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>is_subgroup</span><span> </span><span>maxH.max_normal</span><span> </span><span>normal_restrict_supergroup</span><span> </span><span>subgroup_self</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>A3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"A' = rcosets<span class="hidden">‚áò</span><sub>G‚¶ácarrier := A‚¶à<span class="hidden">‚áô</span></sub> H"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>A_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>factgroup_subgroup_union_factor</span><span> </span><span>A'normal</span><span> </span><span>normal_imp_subgroup</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A1</span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>normalHA</span><span class="delimiter">:</span><span> </span><span>normal</span><span> </span><span>H</span><span> </span><span class="string"><span class="delete"><span class="delete">"(G‚¶ácarrier := A‚¶à)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H ‚äÜ A"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>normalHA.is_subgroup</span><span> </span><span>subgroup.subset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A = H ‚à® A = carrier G"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>maxH.max_normal</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A' = carrier (G Mod H)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> 
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A = H"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"carrier (G‚¶ácarrier := A‚¶à Mod H) = {ùü≠<span class="hidden">‚áò</span><sub>(G‚¶ácarrier := A‚¶à Mod H)<span class="hidden">‚áô</span></sub>}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>finite</span><span> </span><span>is_group</span><span> </span><span>normalHA.fact_group_trivial_iff</span><span> </span><span>normalHA.subgroup_self</span><span> </span><span>normalHA.subset</span><span> </span><span>subgroup_finite</span><span> </span><span>subgroup_of_restricted_group</span><span> </span><span>subgroup_of_subgroup</span><span> </span><span>subset_antisym</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = {ùü≠<span class="hidden">‚áò</span><sub>G Mod H<span class="hidden">‚áô</span></sub>}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FactGroup_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A' = {ùü≠<span class="hidden">‚áò</span><sub>G Mod H<span class="hidden">‚áô</span></sub>}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A3</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FactGroup_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A'nottriv</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A = carrier G"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(G‚¶ácarrier := A‚¶à Mod H) = G Mod H"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A' = carrier (G Mod H)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A3</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FactGroup_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>simple</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"simple_group (G Mod H)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"max_normal_subgroup H G"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>simple</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"carrier (G Mod H) ‚â† {ùü≠<span class="hidden">‚áò</span><sub>G Mod H<span class="hidden">‚áô</span></sub>}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>simple_group_def</span><span> </span><span>simple_group_axioms_def</span><span> </span><span>order_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>finite</span><span> </span><span>fact_group_trivial_iff</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H ‚â† carrier G"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>A</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"A ‚ä≤ G"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A ‚â† H"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A ‚â† carrier G"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬¨ H ‚äÜ A"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>HA</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"H ‚äÜ A"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H ‚ä≤ (G‚¶ácarrier := A‚¶à)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>A</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>inv_op_closed2</span><span> </span><span>is_subgroup</span><span> </span><span>normal_inv_iff</span><span> </span><span>normal_restrict_supergroup</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>normalHA</span><span class="delimiter">:</span><span> </span><span>normal</span><span> </span><span>H</span><span> </span><span class="string"><span class="delete"><span class="delete">"(G‚¶ácarrier := A‚¶à)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>finite</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>finiteA</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"finite A"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>normal_imp_subgroup</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>subgroup_finite</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rcosets<span class="hidden">‚áò</span><sub>(G‚¶ácarrier := A‚¶à)<span class="hidden">‚áô</span></sub> H ‚ä≤ G Mod H"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>normality_factorization</span><span> </span><span>is_normal</span><span> </span><span>HA</span><span> </span><span>A</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>simple</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rcosets<span class="hidden">‚áò</span><sub>(G‚¶ácarrier := A‚¶à)<span class="hidden">‚áô</span></sub> H = {ùü≠<span class="hidden">‚áò</span><sub>G Mod H<span class="hidden">‚áô</span></sub>} ‚à® rcosets<span class="hidden">‚áò</span><sub>(G‚¶ácarrier := A‚¶à)<span class="hidden">‚áô</span></sub> H = carrier (G Mod H)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>simple_group_def</span><span> </span><span>simple_group_axioms_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rcosets<span class="hidden">‚áò</span><sub>G‚¶ácarrier := A‚¶à<span class="hidden">‚áô</span></sub> H = {ùü≠<span class="hidden">‚áò</span><sub>G Mod H<span class="hidden">‚áô</span></sub>}"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rcosets<span class="hidden">‚áò</span><sub>G‚¶ácarrier := A‚¶à<span class="hidden">‚áô</span></sub> H = {ùü≠<span class="hidden">‚áò</span><sub>(G‚¶ácarrier := A‚¶à) Mod H<span class="hidden">‚áô</span></sub>}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FactGroup_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>finiteA</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H = A"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>normalHA.fact_group_trivial_iff</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FactGroup_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>AHGH</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"rcosets<span class="hidden">‚áò</span><sub>G‚¶ácarrier := A‚¶à<span class="hidden">‚áô</span></sub> H = carrier (G Mod H)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A = carrier G"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FactGroup_def</span><span> </span><span>RCOSETS_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A ‚äÜ carrier G"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>normal_imp_subgroup</span><span> </span><span>subgroup.subset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"carrier G ‚äÜ A"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>            </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"x ‚àà carrier G"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H #&gt; x ‚àà rcosets H"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>RCOSETS_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>AHGH</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H #&gt; x ‚àà rcosets<span class="hidden">‚áò</span><sub>G‚¶ácarrier := A‚¶à<span class="hidden">‚áô</span></sub> H"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FactGroup_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x'</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"x' ‚àà A"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H #&gt;x = H #&gt;<span class="hidden">‚áò</span><sub>G‚¶ácarrier := A‚¶à<span class="hidden">‚áô</span></sub> x'"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>RCOSETS_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H #&gt; x = H #&gt; x'"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>r_coset_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ‚àà H #&gt; x'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>is_subgroup</span><span> </span><span>rcos_self</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ‚àà A #&gt; x'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>HA</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>r_coset_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ‚àà A"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x'</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>r_coset_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subgroup.m_closed</span><span> </span><span>A</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>normal_imp_subgroup</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="CompositionSeries">
<div class="head"><h1>Theory CompositionSeries</h1>
<span class="command">theory</span> <span class="name">CompositionSeries</span><br/>
<span class="keyword">imports</span> <a href="MaximalNormalSubgroups.html"><span class="name">MaximalNormalSubgroups</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:      Composition Series
    Author:     Jakob von Raumer, Karlsruhe Institute of Technology
    Maintainer: Jakob von Raumer &lt;jakob.raumer@student.kit.edu&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>CompositionSeries</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>SimpleGroups</span><span>
</span><span>  </span><span>MaximalNormalSubgroups</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπNormal series and Composition series‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπPreliminaries‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπA subgroup which is unique in cardinality is normal:‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>group</span><span class="delimiter">)</span><span> </span><span>unique_sizes_subgrp_normal</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>fin</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"finite (carrier G)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÉ!Q. Q ‚àà subgroups_of_size q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(THE Q. Q ‚àà subgroups_of_size q) ‚ä≤ G"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Q</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Q ‚àà subgroups_of_size q"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>Q</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Q = (THE Q. Q ‚àà subgroups_of_size q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Qsize</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"Q ‚àà subgroups_of_size q"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>theI</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>QG</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"subgroup Q G"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cardQ</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"card Q = q"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>subgroups_of_size_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>QG</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Q ‚ä≤ G"</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>normalI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>g</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>g</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"g ‚àà carrier G"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>invg</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"inv g ‚àà carrier G"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inv_closed</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>fin</span><span> </span><span>Qsize</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"conjugation_action q (inv g) Q ‚àà subgroups_of_size q"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>conjugation_is_size_invariant</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>g</span><span> </span><span>Qsize</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(inv g) &lt;# (Q #&gt; inv (inv g)) ‚àà subgroups_of_size q"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conjugation_action_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>invg</span><span> </span><span>g</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv g &lt;# (Q #&gt; g) = Q"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Qsize</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>inv_inv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>QG</span><span> </span><span>QG</span><span> </span><span>g</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Q #&gt; g = g &lt;# Q"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conj_wo_inv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Q_def</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπA group whose order is the product of two distinct
primes $p$ and $q$ where $p &lt; q$ has a unique subgroup of size $q$:‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>group</span><span class="delimiter">)</span><span> </span><span>pq_order_unique_subgrp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>finite</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"finite (carrier G)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>orderG</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"order G = q * p"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>primep</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"prime p"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>primeq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"prime q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"p &lt; q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÉ!Q. Q ‚àà (subgroups_of_size q)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>primep</span><span> </span><span>primeq</span><span> </span><span>pq</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nqdvdp</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"¬¨ (q dvd p)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>less_not_refl3</span><span> </span><span>prime_nat_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>calM</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"calM = {s. s ‚äÜ carrier G ‚àß card s = q ^ 1}"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>RelM</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"RelM = {(N1, N2). N1 ‚àà calM ‚àß N2 ‚àà calM ‚àß (‚àÉg‚ààcarrier G. N1 = N2 #&gt; g)}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>syl</span><span class="delimiter">:</span><span> </span><span>snd_sylow</span><span> </span><span>G</span><span> </span><span>q</span><span> </span><span>1</span><span> </span><span>p</span><span> </span><span>calM</span><span> </span><span>RelM</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>snd_sylow_def</span><span> </span><span>sylow_def</span><span> </span><span>snd_sylow_axioms_def</span><span> </span><span>sylow_axioms_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>is_group</span><span> </span><span>primeq</span><span> </span><span>orderG</span><span> </span><span>finite</span><span> </span><span>nqdvdp</span><span> </span><span>calM_def</span><span> </span><span>RelM_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Q</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Q</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"Q ‚àà subgroups_of_size q"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>lifting</span><span class="delimiter">,</span><span> </span><span>mono_tags</span><span class="delimiter">)</span><span> </span><span>mem_Collect_eq</span><span> </span><span>power_one_right</span><span> </span><span>subgroups_of_size_def</span><span> </span><span>syl.sylow_thm</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ex1I</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>P</span><span>
</span><span>     </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>P</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"P ‚àà subgroups_of_size q"</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (subgroups_of_size q) mod q = 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>power_one_right</span><span> </span><span>syl.p_sylow_mod_p</span><span class="delimiter">)</span><span>     
</span><span>     </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (subgroups_of_size q) dvd p"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>power_one_right</span><span> </span><span>syl.num_sylow_dvd_remainder</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (subgroups_of_size q) = p ‚à® card (subgroups_of_size q) = 1"</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>primep</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>prime_nat_iff</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (subgroups_of_size q) = 1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pq</span><span>
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>     </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Q</span><span> </span><span>P</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P = Q"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>card_Suc_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ... And this unique subgroup is normal.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>group</span><span class="delimiter">)</span><span> </span><span>pq_order_subgrp_normal</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>finite</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"finite (carrier G)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>orderG</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"order G = q * p"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>primep</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"prime p"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>primeq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"prime q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"p &lt; q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(THE Q. Q ‚àà subgroups_of_size q) ‚ä≤ G"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>pq_order_unique_subgrp</span><span> </span><span>unique_sizes_subgrp_normal</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThe trivial subgroup is normal in every group.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>group</span><span class="delimiter">)</span><span> </span><span>trivial_subgroup_is_normal</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{ùü≠} ‚ä≤ G"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>normal_def</span><span> </span><span>normal_axioms_def</span><span> </span><span>r_coset_def</span><span> </span><span>l_coset_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>normalI</span><span> </span><span>subgroupI</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_group</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπNormal Series‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπWe define a normal series as a locale which fixes one group
@{term G} and a list @{term ùîä} of subsets of @{term G}'s carrier. This list
must begin with the trivial subgroup, end with the carrier of the group itself
and each of the list items must be a normal subgroup of its successor.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>normal_series</span><span> </span><span class="delimiter">=</span><span> </span><span>group</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>ùîä</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>notempty</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ùîä ‚â† []"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>hd</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"hd ùîä = {ùü≠}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>last</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"last ùîä = carrier G"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>normal</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"‚ãÄi. i + 1 &lt; length ùîä ‚üπ (ùîä ! i) ‚ä≤ G‚¶ácarrier := ùîä ! (i + 1)‚¶à"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>normal_series</span><span class="delimiter">)</span><span> </span><span>is_normal_series</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"normal_series G ùîä"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>normal_series_axioms</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπFor every group there is a "trivial" normal series consisting
only of the group itself and its trivial subgroup.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>group</span><span class="delimiter">)</span><span> </span><span>trivial_normal_series</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"normal_series G [{ùü≠}, carrier G]"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>normal_series_def</span><span> </span><span>normal_series_axioms_def</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>is_group</span><span> </span><span>trivial_subgroup_is_normal</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπWe can also show that the normal series presented above is the only such with
a length of two:‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>normal_series</span><span class="delimiter">)</span><span> </span><span>length_two_unique</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length ùîä = 2"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä = [{ùü≠}, carrier G]"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>nth_equalityI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length ùîä = length [{ùü≠}, carrier G]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä ! i = [{ùü≠}, carrier G] ! i"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>i</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"i &lt; length ùîä"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i = 0 ‚à® i = 1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä ! i = [{ùü≠}, carrier G] ! i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>i</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"i = 0"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä ! i = hd ùîä"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hd_conv_nth</span><span> </span><span>notempty</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä ! i = [{ùü≠}, carrier G] ! i"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hd</span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>i</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"i = 1"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä ! i = last ùîä"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>diff_add_inverse</span><span> </span><span>last_conv_nth</span><span> </span><span>nat_1_add_1</span><span> </span><span>notempty</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä ! i = [{ùü≠}, carrier G] ! i"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>last</span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπWe can construct new normal series by expanding existing ones: If we
append the carrier of a group @{term G} to a normal series for a normal subgroup
@{term "H ‚ä≤ G"} we receive a normal series for @{term G}.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>group</span><span class="delimiter">)</span><span> </span><span>normal_series_extend</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>normal</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"normal_series (G‚¶ácarrier := H‚¶à) ‚Ñå"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>HG</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"H ‚ä≤ G"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"normal_series G (‚Ñå @ [carrier G])"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>normal</span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>normalH</span><span class="delimiter">:</span><span> </span><span>normal_series</span><span> </span><span class="string"><span class="delete"><span class="delete">"(G‚¶ácarrier := H‚¶à)"</span></span></span><span> </span><span>‚Ñå</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>normalH.hd</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hd ‚Ñå = {ùü≠}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>normalH.notempty</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>hdTriv</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"hd (‚Ñå @ [carrier G]) = {ùü≠}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hd_append2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>normal_series_def</span><span> </span><span>normal_series_axioms_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>is_group</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ‚àà hd (‚Ñå @ [carrier G])"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>hdTriv</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = ùü≠"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>hdTriv</span><span> </span><span class="keyword3"><span class="command">show</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"ùü≠ ‚àà hd (‚Ñå @ [carrier G])"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>i</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"i &lt; length ‚Ñå"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(‚Ñå @ [carrier G]) ! i ‚ä≤ G‚¶ácarrier := (‚Ñå @ [carrier G]) ! Suc i‚¶à"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"i + 1 &lt; length ‚Ñå"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>normalH.normal</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ñå ! i ‚ä≤ G‚¶ácarrier := ‚Ñå ! (i + 1)‚¶à"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(‚Ñå @ [carrier G]) ! i ‚ä≤ G‚¶ácarrier := ‚Ñå ! (i + 1)‚¶à"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nth_append</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>True</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(‚Ñå @ [carrier G]) ! i ‚ä≤ G‚¶ácarrier := (‚Ñå @ [carrier G]) ! (Suc i)‚¶à"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nth_append</span><span> </span><span>Suc_eq_plus1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>i2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"i + 1 = length ‚Ñå"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(‚Ñå @ [carrier G]) ! i = ‚Ñå ! i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>nth_append</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>i2</span><span> </span><span>normalH.notempty</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = last ‚Ñå"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_diff_cancel_right'</span><span> </span><span>last_conv_nth</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>normalH.last</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = H"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(‚Ñå @ [carrier G]) ! i = H"</span></span></span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>i2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(‚Ñå @ [carrier G]) ! (i + 1) = carrier G"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>nth_append_length</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>HG</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπAll entries of a normal series for $G$ are subgroups of $G$.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>normal_series</span><span class="delimiter">)</span><span> </span><span>normal_series_subgroups</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length ùîä ‚üπ subgroup (ùîä ! i) G"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i + 1 &lt; length ùîä ‚üπ subgroup (ùîä ! i) G"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span class="string"><span class="delete"><span class="delete">"length ùîä - (i + 2)"</span></span></span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>i</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"i + 2 = length ùîä"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>ii</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"i + 1 = length ùîä - 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>i</span><span> </span><span>normal</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä ! i ‚ä≤ G‚¶ácarrier := ùîä ! (i + 1)‚¶à"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ii</span><span> </span><span>last</span><span> </span><span>notempty</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subgroup (ùîä ! i) G"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>last_conv_nth</span><span> </span><span>normal_imp_subgroup</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>k</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Suc</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>  </span><span>normal</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>i</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"subgroup (ùîä ! i) (G‚¶ácarrier := ùîä ! (i + 1)‚¶à)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>normal_imp_subgroup</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Suc</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>k</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"k = length ùîä - ((i + 1) + 2)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>arith</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Suc</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subgroup (ùîä ! (i + 1)) G"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>i</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subgroup (ùîä ! i) G"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>is_group</span><span> </span><span>subgroup.subgroup_of_subgroup</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i + 1 = length ùîä ‚üπ subgroup (ùîä ! i) G"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>last</span><span> </span><span>notempty</span><span> </span><span>last_conv_nth</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_diff_cancel_right'</span><span> </span><span>subgroup_self</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length ùîä ‚üπ subgroup (ùîä ! i) G"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThe second to last entry of a normal series is a normal subgroup of G.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>normal_series</span><span class="delimiter">)</span><span> </span><span>normal_series_snd_to_last</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä ! (length ùîä - 2) ‚ä≤ G"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"2 ‚â§ length ùîä"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>notempty</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>length</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"length ùîä = 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_eq_plus1</span><span> </span><span>leI</span><span> </span><span>length_0_conv</span><span> </span><span>less_2_cases</span><span> </span><span>plus_nat.add_0</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>hd</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä ! (length ùîä - 2) = {ùü≠}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hd_conv_nth</span><span> </span><span>notempty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>length</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>trivial_subgroup_is_normal</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(length ùîä - 2) + 1 &lt; length ùîä"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>arith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>normal</span><span> </span><span>last</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä ! (length ùîä - 2) ‚ä≤ G‚¶ácarrier := ùîä ! ((length ùîä - 2) + 1)‚¶à"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1 + (1 + (length ùîä - (1 + 1))) = length ùîä"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span> </span><span>le_add_diff_inverse</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä ! (length ùîä - 2) ‚ä≤ G‚¶ácarrier :=  ùîä ! (length ùîä - 1)‚¶à"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπùîä ! (length ùîä - 2) ‚ä≤ G ‚¶ácarrier := ùîä ! (length ùîä - 2 + 1)‚¶à‚Ä∫</span></span></span><span> </span><span>add.commute</span><span> </span><span>add_diff_cancel_left'</span><span> </span><span>one_add_one</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>notempty</span><span> </span><span>last</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>last_conv_nth</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπJust like the expansion of normal series, every prefix of a normal series is again a normal series.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>normal_series</span><span class="delimiter">)</span><span> </span><span>normal_series_prefix_closed</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ‚â§ length ùîä"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; i"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"normal_series (G‚¶ácarrier := ùîä ! (i - 1)‚¶à) (take i ùîä)"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>normal_series_def</span><span> </span><span>normal_series_axioms_def</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hd</span><span> </span><span>del</span><span class="delimiter">:</span><span>equalityI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_group</span><span> </span><span>normal_series_subgroups</span><span> </span><span>subgroup.subgroup_is_group</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_conv_nth</span><span> </span><span>min.absorb2</span><span> </span><span>notempty</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>normal</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπIf a group's order is the product of two distinct primes @{term p} and @{term q}, where
@{term "p &lt; q"}, we can construct a normal series using the only subgroup of size  @{term q}.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>group</span><span class="delimiter">)</span><span> </span><span>pq_order_normal_series</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>finite</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"finite (carrier G)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>orderG</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"order G = q * p"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>primep</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"prime p"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>primeq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"prime q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"p &lt; q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"normal_series G [{ùü≠}, (THE H. H ‚àà subgroups_of_size q), carrier G]"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>H</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H = (THE H. H ‚àà subgroups_of_size q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>HG</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"H ‚ä≤ G"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>pq_order_subgrp_normal</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>groupH</span><span class="delimiter">:</span><span> </span><span>group</span><span> </span><span class="string"><span class="delete"><span class="delete">"G‚¶ácarrier := H‚¶à"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>normal_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>subgroup_imp_group</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"normal_series (G‚¶ácarrier := H‚¶à) [{ùü≠}, H]"</span></span></span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>groupH.trivial_normal_series</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>HG</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>H_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append_Cons</span><span> </span><span>append_Nil</span><span> </span><span>normal_series_extend</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThe following defines the list of all quotient groups of the normal series:‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>normal_series</span><span class="delimiter">)</span><span> </span><span>quotients</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"quotients = map (Œªi. G‚¶ácarrier := ùîä ! (i + 1)‚¶à Mod ùîä ! i) [0..&lt;((length ùîä) - 1)]"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThe list of quotient groups has one less entry than the series itself:‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>normal_series</span><span class="delimiter">)</span><span> </span><span>quotients_length</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length quotients + 1 = length ùîä"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length quotients + 1 = length [0..&lt;((length ùîä) - 1)] + 1"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>quotients_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (length ùîä - 1) + 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>diff_zero</span><span> </span><span>length_upt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>notempty</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = length ùîä"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ac_simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>normal_series</span><span class="delimiter">)</span><span> </span><span>last_quotient</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length ùîä &gt; 1"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"last quotients = G Mod ùîä ! (length ùîä - 1 - 1)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lsimp</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"length ùîä - 1 - 1 + 1 = length ùîä - 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"quotients ‚â† []"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>quotients_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"last quotients = quotients ! (length quotients - 1)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>last_conv_nth</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = quotients ! (length ùîä - 1 - 1)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_diff_cancel_left'</span><span> </span><span>quotients_length</span><span> </span><span>add.commute</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = G‚¶ácarrier := ùîä ! ((length ùîä - 1 - 1) + 1)‚¶à Mod ùîä ! (length ùîä - 1 - 1)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>quotients_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = G‚¶ácarrier := ùîä ! (length ùîä - 1)‚¶à Mod ùîä ! (length ùîä - 1 - 1)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lsimp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = G Mod ùîä ! (length ùîä - 1 - 1)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>last</span><span> </span><span>last_conv_nth</span><span> </span><span>notempty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThe next lemma transports the constituting properties of a normal series
along an isomorphism of groups.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>normal_series</span><span class="delimiter">)</span><span> </span><span>normal_series_iso</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>H</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"group H"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>iso</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"Œ® ‚àà iso G H"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"normal_series H (map (image Œ®) ùîä)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>normal_series_def</span><span> </span><span>normal_series_axioms_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H</span><span> </span><span>notempty</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>H</span><span> </span><span>is_group</span><span> </span><span>iso</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>group_hom</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"group_hom G H Œ®"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>group_hom_def</span><span> </span><span>group_hom_axioms_def</span><span> </span><span>iso_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hd (map (image Œ®) ùîä) = Œ® ` {ùü≠}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hd_map</span><span> </span><span>hd</span><span> </span><span>notempty</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = {Œ® ùü≠}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>image_empty</span><span> </span><span>image_insert</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = {ùü≠<span class="hidden">‚áò</span><sub>H<span class="hidden">‚áô</span></sub>}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>group_hom</span><span> </span><span>group_hom.hom_one</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hd (map ((`) Œ®) ùîä) = {ùü≠<span class="hidden">‚áò</span><sub>H<span class="hidden">‚áô</span></sub>}"</span></span></span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"last (map ((`) Œ®) ùîä) = carrier H ‚àß (‚àÄi. Suc i &lt; length ùîä ‚ü∂ Œ® ` ùîä ! i ‚ä≤ H‚¶ácarrier := Œ® ` ùîä ! Suc i‚¶à)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>equalityI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"last (map ((`) Œ®) ùîä) = Œ® ` (carrier G)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>last</span><span> </span><span>last_map</span><span> </span><span>notempty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = carrier H"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>iso</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>iso_def</span><span> </span><span>bij_betw_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"last (map ((`) Œ®) ùîä) = carrier H"</span></span></span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>i</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"Suc i &lt; length ùîä"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>norm</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ùîä ! i ‚ä≤ G‚¶ácarrier := ùîä ! Suc i‚¶à"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>normal</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"restrict Œ® (ùîä ! Suc i) ‚àà iso (G‚¶ácarrier := ùîä ! Suc i‚¶à) (H‚¶ácarrier := Œ® ` ùîä ! Suc i‚¶à)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>H</span><span> </span><span>i</span><span> </span><span>is_group</span><span> </span><span>iso</span><span> </span><span>iso_restrict</span><span> </span><span>normal_series_subgroups</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"group (G‚¶ácarrier := ùîä ! Suc i‚¶à)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>i</span><span> </span><span>normal_series_subgroups</span><span> </span><span>subgroup_imp_group</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subgroup (ùîä ! Suc i) G"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>i</span><span> </span><span>normal_series_subgroups</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subgroup (Œ® ` ùîä ! Suc i) H"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>H</span><span> </span><span>is_group</span><span> </span><span>iso</span><span> </span><span>iso_subgroup</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"group (H‚¶ácarrier := Œ® ` ùîä ! Suc i‚¶à)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>H</span><span> </span><span>subgroup.subgroup_is_group</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"restrict Œ® (ùîä ! Suc i) ` ùîä ! i ‚ä≤ H‚¶ácarrier := Œ® ` ùîä ! Suc i‚¶à"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>is_group</span><span> </span><span>H</span><span> </span><span>iso_normal_subgroup</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>cong</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>image_cong_simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>norm</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä ! i ‚äÜ ùîä ! Suc i"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>normal_def</span><span> </span><span>subgroup_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{y. ‚àÉx‚ààùîä ! i. y = (if x ‚àà ùîä ! Suc i then Œ® x else undefined)} = {y. ‚àÉx‚ààùîä ! i. y = Œ® x}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Œ® ` ùîä ! i ‚ä≤ H‚¶ácarrier := Œ® ` ùîä ! Suc i‚¶à"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>restrict_def</span><span> </span><span>image_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπComposition Series‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπA composition series is a normal series where all consecutive factor groups are simple:‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>composition_series</span><span> </span><span class="delimiter">=</span><span> </span><span>normal_series</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>simplefact</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"‚ãÄi. i + 1 &lt;  length ùîä ‚üπ simple_group (G‚¶ácarrier := ùîä ! (i + 1)‚¶à Mod ùîä ! i)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>composition_series</span><span class="delimiter">)</span><span> </span><span>is_composition_series</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"composition_series G ùîä"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>composition_series_axioms</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπA composition series for a group $G$ has length one if and only if $G$ is the trivial group.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>composition_series</span><span class="delimiter">)</span><span> </span><span>composition_series_length_one</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(length ùîä = 1) = (ùîä = [{ùü≠}])"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length ùîä = 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>hd</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length ùîä = length [{ùü≠}] ‚àß (‚àÄi &lt; length ùîä. ùîä ! i = [{ùü≠}] ! i)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hd_conv_nth</span><span> </span><span>notempty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä = [{ùü≠}]"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>list_eq_iff_nth_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä = [{ùü≠}]"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length ùîä = 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>composition_series</span><span class="delimiter">)</span><span> </span><span>composition_series_triv_group</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(carrier G = {ùü≠}) = (ùîä = [{ùü≠}])"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>G</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"carrier G = {ùü≠}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length ùîä = 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length ùîä ‚â† 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>notempty</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>length</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"length ùîä ‚â• 2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_eq_plus1</span><span> </span><span>length_0_conv</span><span> </span><span>less_2_cases</span><span> </span><span>not_less</span><span> </span><span>plus_nat.add_0</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>simplefact</span><span> </span><span>hd</span><span> </span><span>hd_conv_nth</span><span> </span><span>notempty</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"simple_group (G‚¶ácarrier := ùîä ! 1‚¶à Mod {ùü≠})"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>SG</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"subgroup (ùîä ! 1) G"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>length</span><span> </span><span>normal_series_subgroups</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"group (G‚¶ácarrier := ùîä ! 1‚¶à)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>subgroup_imp_group</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"simple_group (G‚¶ácarrier := ùîä ! 1‚¶à)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>group.trivial_factor_iso</span><span> </span><span>simple_group.iso_simple</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>SG</span><span> </span><span>G</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"carrier (G‚¶ácarrier := ùîä ! 1‚¶à) = {ùü≠}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>subgroup_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>simple_group.simple_not_triv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä = [{ùü≠}]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>composition_series_length_one</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä = [{ùü≠}]"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>last</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"carrier G = {ùü≠}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThe inner elements of a composition series may not consist of the trivial subgroup or the
group itself.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>composition_series</span><span class="delimiter">)</span><span> </span><span>inner_elements_not_triv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i + 1 &lt; length ùîä"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &gt; 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä ! i ‚â† {ùü≠}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(i - 1) + 1 &lt; length ùîä"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>simple</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"simple_group (G‚¶ácarrier := ùîä ! ((i - 1) + 1)‚¶à Mod ùîä ! (i - 1))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>simplefact</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>i</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ùîä ! i = {ùü≠}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(i - 1) + 1 = i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"G‚¶ácarrier := ùîä ! ((i - 1) + 1)‚¶à Mod ùîä ! (i - 1) = G‚¶ácarrier := {ùü≠}‚¶à Mod ùîä ! (i - 1)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"order (G‚¶ácarrier := ùîä ! ((i - 1) + 1)‚¶à Mod ùîä ! (i - 1)) = 1"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FactGroup_def</span><span> </span><span>order_def</span><span> </span><span>RCOSETS_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i</span><span> </span><span>simple</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>simple_group_def</span><span> </span><span>simple_group_axioms_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπA composition series of a simple group always is its trivial one.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>composition_series</span><span class="delimiter">)</span><span> </span><span>composition_series_simple_group</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(simple_group G) = (ùîä = [{ùü≠}, carrier G])"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä = [{ùü≠}, carrier G]"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>simplefact</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"simple_group (G Mod {ùü≠})"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"the_elem ‚àà iso (G Mod {ùü≠}) G"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>trivial_factor_iso</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"simple_group G"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>is_group</span><span> </span><span>simple_group.iso_simple</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>simple</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"simple_group G"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length ùîä &gt; 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬¨ 1 &lt; length ùîä"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length ùîä = 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Suc_leI</span><span> </span><span>antisym</span><span> </span><span>notempty</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"carrier G = {ùü≠}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hd</span><span> </span><span>last</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>composition_series_length_one</span><span> </span><span>composition_series_triv_group</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"order G = 1"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>order_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>simple</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>simple_group_def</span><span> </span><span>simple_group_axioms_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length ùîä ‚â§ 2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>k</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k = length ùîä - 2"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬¨ (length ùîä ‚â§ 2)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>gt2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"length ùîä &gt; 2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>ksmall</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"k + 1 &lt; length ùîä"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>k_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>gt2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>carrier</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ùîä ! (k + 1) = carrier G"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>notempty</span><span> </span><span>last</span><span> </span><span>last_conv_nth</span><span> </span><span>k_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Nat.add_diff_assoc</span><span> </span><span>Nat.diff_cancel</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ¬¨ length ùîä ‚â§ 2‚Ä∫</span></span></span><span> </span><span>add.commute</span><span> </span><span>nat_le_linear</span><span> </span><span>one_add_one</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>normal</span><span> </span><span>ksmall</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä ! k ‚ä≤ G‚¶á carrier := ùîä ! (k + 1)‚¶à"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>simplefact</span><span> </span><span>ksmall</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>simplek</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"simple_group (G‚¶ácarrier := ùîä ! (k + 1)‚¶à Mod ùîä ! k)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>simplefact</span><span> </span><span>ksmall</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>simplek'</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"simple_group (G‚¶ácarrier := ùîä ! ((k - 1) + 1)‚¶à Mod ùîä ! (k - 1))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä ! k ‚ä≤ G"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>carrier</span><span> </span><span>k_def</span><span> </span><span>gt2</span><span> </span><span>normal</span><span> </span><span>ksmall</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>simple</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ùîä ! k) = carrier G ‚à® (ùîä ! k) = {ùü≠}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>simple_group_def</span><span> </span><span>simple_group_axioms_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä ! k = carrier G"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"G‚¶ácarrier := ùîä ! (k + 1)‚¶à Mod ùîä ! k = G Mod (carrier G)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>carrier</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>simplek</span><span> </span><span>self_factor_not_simple</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä ! k = {ùü≠}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ksmall</span><span> </span><span>k_def</span><span> </span><span>gt2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inner_elements_not_triv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length ùîä = 2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä = [{ùü≠}, carrier G]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>length_two_unique</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπTwo consecutive elements in a composition series are distinct.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>composition_series</span><span class="delimiter">)</span><span> </span><span>entries_distinct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>finite</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"finite (carrier G)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>i</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"i + 1 &lt; length ùîä"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä ! i ‚â† ùîä ! (i + 1)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>finite</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite  (ùîä ! (i + 1))"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i</span><span> </span><span>normal_series_subgroups</span><span> </span><span>subgroup.subset</span><span> </span><span>rev_finite_subset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>fin</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"finite (carrier (G‚¶ácarrier := ùîä ! (i + 1)‚¶à))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>norm</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ùîä ! i ‚ä≤ (G‚¶ácarrier := ùîä ! (i + 1)‚¶à)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>normal</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä ! i = ùîä ! (i + 1)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä ! i = carrier (G‚¶ácarrier := ùîä ! (i + 1)‚¶à)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"carrier ((G‚¶ácarrier := (ùîä ! (i + 1))‚¶à) Mod (ùîä ! i)) = {ùü≠<span class="hidden">‚áò</span><sub>(G‚¶ácarrier := ùîä ! (i + 1)‚¶à) Mod ùîä ! i<span class="hidden">‚áô</span></sub>}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>norm</span><span> </span><span>fin</span><span> </span><span>normal.fact_group_trivial_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬¨ simple_group ((G‚¶ácarrier := (ùîä ! (i + 1))‚¶à) Mod (ùîä ! i))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>simple_group.simple_not_triv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>i</span><span> </span><span>simplefact</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThe normal series for groups of order @{term "p * q"} is even a composition series:‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>group</span><span class="delimiter">)</span><span> </span><span>pq_order_composition_series</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>finite</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"finite (carrier G)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>orderG</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"order G = q * p"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>primep</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"prime p"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>primeq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"prime q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"p &lt; q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"composition_series G [{ùü≠}, (THE H. H ‚àà subgroups_of_size q), carrier G]"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>composition_series_def</span><span> </span><span>composition_series_axioms_def</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>pq_order_normal_series</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>H</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H = (THE H. H ‚àà subgroups_of_size q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>exi</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"‚àÉ!Q. Q ‚àà (subgroups_of_size q)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pq_order_unique_subgrp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>Hsize</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"H ‚àà subgroups_of_size q"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>H_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>theI'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>HsubG</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"subgroup H G"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>subgroups_of_size_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>Hgroup</span><span class="delimiter">:</span><span> </span><span>group</span><span> </span><span class="string"><span class="delete"><span class="delete">"G‚¶ácarrier := H‚¶à"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>subgroup_imp_group</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; Suc (Suc 0)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i = 0 ‚à® i = 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"simple_group (G‚¶ácarrier := [H, carrier G] ! i‚¶à Mod [{ùü≠}, H, carrier G] ! i)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>i</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"i = 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Hsize</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>orderH</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"order (G‚¶ácarrier := H‚¶à) = q"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>subgroups_of_size_def</span><span> </span><span>order_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"order (G‚¶ácarrier := H‚¶à Mod {ùü≠}) = q"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FactGroup_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_rcosets_triv</span><span> </span><span>order_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Hgroup.card_rcosets_triv</span><span> </span><span>HsubG</span><span> </span><span>finite</span><span> </span><span>monoid.cases_scheme</span><span> </span><span>monoid.select_convs</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>partial_object.select_convs</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>partial_object.update_convs</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>subgroup_finite</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"normal {ùü≠} (G‚¶ácarrier := H‚¶à)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Hgroup.is_group</span><span> </span><span>Hgroup.normal_inv_iff</span><span> </span><span>HsubG</span><span> </span><span>group.trivial_subgroup_is_normal</span><span> </span><span>is_group</span><span> </span><span>singleton_iff</span><span> </span><span>subgroup.one_closed</span><span> </span><span>subgroup.subgroup_of_subgroup</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"group (G‚¶ácarrier := H‚¶à Mod {ùü≠})"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>normal.factorgroup_is_group</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>orderH</span><span> </span><span>primeq</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"simple_group (G‚¶ácarrier := H‚¶à Mod {ùü≠})"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπorder (G‚¶ácarrier := H‚¶à Mod {ùü≠}) = q‚Ä∫</span></span></span><span> </span><span>group.prime_order_simple</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>i</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>i</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"i = 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span>exi</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H ‚ä≤ G"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>H_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>pq_order_subgrp_normal</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>groupGH</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"group (G Mod H)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>normal.factorgroup_is_group</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>primeq</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q ‚â† 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>not_prime_0</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>HsubG</span><span> </span><span>finite</span><span> </span><span>orderG</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (rcosets H) * card H = q * p"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>subgroups_of_size_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lagrange</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Hsize</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (rcosets H) * q = q * p"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>subgroups_of_size_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπq ‚â† 0‚Ä∫</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (rcosets H) = p"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"order (G Mod H) = p"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>order_def</span><span> </span><span>FactGroup_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>groupGH</span><span> </span><span>primep</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"simple_group (G Mod H)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>group.prime_order_simple</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>i</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπPrefixes of composition series are also composition series.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>composition_series</span><span class="delimiter">)</span><span> </span><span>composition_series_prefix_closed</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ‚â§ length ùîä"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; i"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"composition_series (G‚¶ácarrier := ùîä ! (i - 1)‚¶à) (take i ùîä)"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>composition_series_def</span><span> </span><span>composition_series_axioms_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"normal_series (G‚¶ácarrier := ùîä ! (i - Suc 0)‚¶à) (take i ùîä)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>normal_series_prefix_closed</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>j</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>j</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"Suc j &lt; length ùîä"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc j &lt; i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>simplefact</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"simple_group (G‚¶ácarrier := ùîä ! Suc j‚¶à Mod ùîä ! j)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_eq_plus1</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThe second element in a composition series is simple group.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>composition_series</span><span class="delimiter">)</span><span> </span><span>composition_series_snd_simple</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 ‚â§ length ùîä"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"simple_group (G‚¶ácarrier := ùîä ! 1‚¶à)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>compTake</span><span class="delimiter">:</span><span> </span><span>composition_series</span><span> </span><span class="string"><span class="delete"><span class="delete">"G‚¶ácarrier := ùîä ! 1‚¶à"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"take 2 ùîä"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_diff_cancel_right'</span><span> </span><span>composition_series_prefix_closed</span><span> </span><span>one_add_one</span><span> </span><span>zero_less_numeral</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (take 2 ùîä) = 2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_diff_cancel_right'</span><span> </span><span>append_take_drop_id</span><span> </span><span>diff_diff_cancel</span><span> </span><span>length_append</span><span> </span><span>length_drop</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(take 2 ùîä) = [{ùü≠<span class="hidden">‚áò</span><sub>(G‚¶ácarrier := ùîä ! 1‚¶à)<span class="hidden">‚áô</span></sub>}, carrier (G‚¶ácarrier := ùîä ! 1‚¶à)]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>compTake.length_two_unique</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>compTake.composition_series_simple_group</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπAs a stronger way to state the previous lemma: An entry of a composition series is 
  simple if and only if it is the second one.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>composition_series</span><span class="delimiter">)</span><span> </span><span>composition_snd_simple_iff</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length ùîä"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(simple_group (G‚¶ácarrier :=  ùîä ! i‚¶à)) = (i = 1)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>simpi</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"simple_group (G‚¶ácarrier := ùîä ! i‚¶à)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä ! i ‚â† {ùü≠}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>simple_group.simple_not_triv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ‚â† 0"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hd</span><span> </span><span>hd_conv_nth</span><span> </span><span>notempty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>compTake</span><span class="delimiter">:</span><span> </span><span>composition_series</span><span> </span><span class="string"><span class="delete"><span class="delete">"G‚¶ácarrier := ùîä ! i‚¶à"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"take (Suc i) ùîä"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>composition_series_prefix_closed</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>diff_Suc_1</span><span> </span><span>less_eq_Suc_le</span><span> </span><span>zero_less_Suc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>simpi</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(take (Suc i) ùîä) = [{ùü≠<span class="hidden">‚áò</span><sub>G‚¶ácarrier := ùîä ! i‚¶à<span class="hidden">‚áô</span></sub>}, carrier (G‚¶ácarrier := ùîä ! i‚¶à)]"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>compTake.composition_series_simple_group</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (take (Suc i) ùîä) = 2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"min (length ùîä) (Suc i) = 2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>length_take</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc i = 2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i = 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>i</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"i = 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 ‚â§ length ùîä"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>i</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"simple_group (G‚¶ácarrier := ùîä ! i‚¶à)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>composition_series_snd_simple</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThe second to last entry of a normal series is not only a normal subgroup but
  actually even a \emph{maximal} normal subgroup.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>composition_series</span><span class="delimiter">)</span><span> </span><span>snd_to_last_max_normal</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>finite</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"finite (carrier G)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>length</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"length ùîä &gt; 1"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"max_normal_subgroup (ùîä ! (length ùîä - 2)) G"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>max_normal_subgroup_def</span><span> </span><span>max_normal_subgroup_axioms_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>equalityI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä ! (length ùîä - 2) ‚ä≤ G"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>normal_series_snd_to_last</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>G'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"G' = ùîä ! (length ùîä - 2)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>length</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>length21</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"length ùîä - 2 + 1 = length ùîä - 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>arith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>length</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length ùîä - 2 + 1 &lt; length ùîä"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>arith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>simplefact</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"simple_group (G‚¶ácarrier := ùîä ! ((length ùîä - 2) + 1)‚¶à Mod G')"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>G'_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>length21</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>simple_last</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"simple_group (G Mod G')"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>last</span><span> </span><span>notempty</span><span> </span><span>last_conv_nth</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>snd_to_last_eq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"G' = carrier G"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"carrier (G Mod G') = {ùü≠<span class="hidden">‚áò</span><sub>G Mod G'<span class="hidden">‚áô</span></sub>}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>normal_series_snd_to_last</span><span> </span><span>finite</span><span> </span><span>normal.fact_group_trivial_iff</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>G'_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>snd_to_last_eq</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬¨ simple_group (G Mod G')"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>self_factor_not_simple</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>simple_last</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>G'_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>G'G</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"G' ‚ä≤ G"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>G'_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>normal_series_snd_to_last</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>J</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>J</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"J ‚ä≤ G"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"J ‚â† G'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"J ‚â† carrier G"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"G' ‚äÜ J"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>JG'GG'</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"rcosets<span class="hidden">‚áò</span><sub>(G‚¶ácarrier := J‚¶à)<span class="hidden">‚áô</span></sub> G' ‚ä≤ G Mod G'"</span></span></span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>normality_factorization</span><span> </span><span>normal_series_snd_to_last</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>G'_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>G'G</span><span> </span><span>J</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>G'J</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"G' ‚ä≤ (G‚¶ácarrier := J‚¶à)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>normal_imp_subgroup</span><span> </span><span>normal_restrict_supergroup</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>finite</span><span> </span><span>J</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>finJ</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"finite J"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>normal_imp_subgroup</span><span> </span><span>subgroup_finite</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>JG'GG'</span><span> </span><span>simple_last</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rcosets<span class="hidden">‚áò</span><sub>G‚¶ácarrier := J‚¶à<span class="hidden">‚áô</span></sub> G' = {ùü≠<span class="hidden">‚áò</span><sub>G Mod G'<span class="hidden">‚áô</span></sub>} ‚à® rcosets<span class="hidden">‚áò</span><sub>G‚¶ácarrier := J‚¶à<span class="hidden">‚áô</span></sub> G' = carrier (G Mod G')"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>simple_group_def</span><span> </span><span>simple_group_axioms_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>False</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rcosets<span class="hidden">‚áò</span><sub>G‚¶ácarrier := J‚¶à<span class="hidden">‚áô</span></sub> G' = {ùü≠<span class="hidden">‚áò</span><sub>G Mod G'<span class="hidden">‚áô</span></sub>}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rcosets<span class="hidden">‚áò</span><sub>G‚¶ácarrier := J‚¶à<span class="hidden">‚áô</span></sub> G' = {ùü≠<span class="hidden">‚áò</span><sub>(G‚¶ácarrier := J‚¶à) Mod G'<span class="hidden">‚áô</span></sub>}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FactGroup_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"G' = J"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>G'J</span><span> </span><span>finJ</span><span> </span><span>normal.fact_group_trivial_iff</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FactGroup_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>J</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>facts_eq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"rcosets<span class="hidden">‚áò</span><sub>G‚¶ácarrier := J‚¶à<span class="hidden">‚áô</span></sub> G' = carrier (G Mod G')"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"J = carrier G"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"J ‚äÜ carrier G"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>J</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>normal_imp_subgroup</span><span> </span><span>subgroup.subset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"carrier G ‚äÜ J"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"x ‚àà carrier G"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"G' #&gt; x ‚àà carrier (G Mod G')"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FactGroup_def</span><span> </span><span>RCOSETS_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"G' #&gt; x ‚àà rcosets<span class="hidden">‚áò</span><sub>G‚¶ácarrier := J‚¶à<span class="hidden">‚áô</span></sub> G'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>facts_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>j</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>j</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"j ‚àà J"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"G' #&gt; x = G' #&gt; j"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>RCOSETS_def</span><span> </span><span>r_coset_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ‚àà G' #&gt; j"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>G'G</span><span> </span><span>normal_imp_subgroup</span><span> </span><span>x</span><span> </span><span>repr_independenceD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>g'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>g'</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"g' ‚àà G'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = g' ‚äó j"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>r_coset_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g' ‚àà J"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>G'J</span><span> </span><span>normal_imp_subgroup</span><span> </span><span>subgroup.subset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>g'</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>j</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"x ‚àà J"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>J</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>normal_imp_subgroup</span><span> </span><span>subgroup.m_closed</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>J</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπFor the next lemma we need a few facts about removing adjacent duplicates.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>remdups_adj_obtain_adjacency</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i + 1 &lt; length (remdups_adj xs)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length xs &gt; 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>j</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j + 1 &lt; length xs"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(remdups_adj xs) ! i = xs ! j"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(remdups_adj xs) ! (i + 1) = xs ! (j + 1)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>xs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>i</span><span> </span><span>thesis</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>length_greater_0_conv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>thesis</span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs ‚â† []"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>y</span><span> </span><span>xs'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>xs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"xs = y # xs'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπxs ‚â† []‚Ä∫</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lenxs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"length xs &gt; 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>xs</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>rem</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"remdups_adj (x # xs) = (if x = y then remdups_adj (y # xs') else x # remdups_adj (y # xs'))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>remdups_adj.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"x = y"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>rem</span><span> </span><span>xs</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>rem2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"remdups_adj (x # xs) = remdups_adj xs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i + 1 &lt; length (remdups_adj xs)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons.IH</span><span> </span><span>lenxs</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>k</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>j</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"k + 1 &lt; length xs"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"remdups_adj xs ! i = xs ! k"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"remdups_adj xs ! (i + 1) = xs ! (k + 1)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>rem2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>rem</span><span> </span><span>xs</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>rem2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"remdups_adj (x # xs) = x # remdups_adj xs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 + 1 &lt; length (x # xs)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lenxs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"remdups_adj (x # xs) ! i = (x # xs) ! 0"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"remdups_adj (x # xs) ! i = (x # remdups_adj (y # xs')) ! 0"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xs</span><span> </span><span>rem2</span><span> </span><span>0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = (x # xs) ! 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"remdups_adj (x # xs) ! (i + 1) = (x # xs) ! (0 + 1)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"remdups_adj (x # xs) ! (i + 1) = (x # remdups_adj (y # xs')) ! 1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xs</span><span> </span><span>rem2</span><span> </span><span>0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = remdups_adj (y # xs') ! 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = (y # (remdups (y # xs'))) ! 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>nth_Cons'</span><span> </span><span>remdups_adj_Cons_alt</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = (x # xs) ! (0 + 1)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>xs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>k</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k + 1 &lt; length (remdups_adj (x # xs)) - 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ ‚â§ length (remdups_adj xs) + 1 - 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>le_refl</span><span> </span><span>list.size</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>rem2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = length (remdups_adj xs)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k + 1 &lt; length (remdups_adj xs)"</span></span></span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons.IH</span><span> </span><span>lenxs</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>j</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>j</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"j + 1 &lt; length xs"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"remdups_adj xs ! k = xs ! j"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"remdups_adj xs ! (k + 1) = xs ! (j + 1)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>j</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc j + 1 &lt; length (x # xs)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"remdups_adj (x # xs) ! i = (x # xs) ! (Suc j)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"remdups_adj (x # xs) ! i = (x # remdups_adj xs) ! i"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rem2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = (remdups_adj xs) ! k"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = xs ! j"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>j</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = (x # xs) ! (Suc j)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"remdups_adj (x # xs) ! (i + 1) = (x # xs) ! (Suc j + 1)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"remdups_adj (x # xs) ! (i + 1) = (x # remdups_adj xs) ! (i + 1)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rem2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = (remdups_adj xs) ! (k + 1)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = xs ! (j + 1)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>j</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = (x # xs) ! (Suc j + 1)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hd_remdups_adj</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hd (remdups_adj xs) = hd xs"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>xs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>remdups_adj.induct</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>remdups_adj_adjacent</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Suc i &lt; length (remdups_adj xs) ‚üπ remdups_adj xs ! i ‚â† remdups_adj xs ! Suc i"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>xs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>i</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>remdups_adj.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>3</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>xs</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>i</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"x = y"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hd_conv_nth</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπIntersecting each entry of a composition series with a normal subgroup of $G$ and removing
  all adjacent duplicates yields another composition series.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>composition_series</span><span class="delimiter">)</span><span> </span><span>intersect_normal</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>finite</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"finite (carrier G)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>KG</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"K ‚ä≤ G"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"composition_series (G‚¶ácarrier := K‚¶à) (remdups_adj (map (ŒªH. K ‚à© H) ùîä))"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>composition_series_def</span><span> </span><span>composition_series_axioms_def</span><span> </span><span>normal_series_def</span><span> </span><span>normal_series_axioms_def</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>conjI</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>equalityI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"group (G‚¶ácarrier := K‚¶à)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>KG</span><span> </span><span>normal_imp_subgroup</span><span> </span><span>subgroup_imp_group</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="comment">‚Äï ‚ÄπShow, that removing adjacent duplicates doesn't result in an empty list.‚Ä∫</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"remdups_adj (map ((‚à©) K) ùîä) = []"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map ((‚à©) K) ùîä = []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>remdups_adj_Nil_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä = []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Nil_is_map_conv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>notempty</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="comment">‚Äï ‚ÄπShow, that the head of the reduced list is still the trivial group‚Ä∫</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä = {ùü≠} # tl ùîä"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>notempty</span><span> </span><span>hd</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span>neq_Nil_conv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map ((‚à©) K) ùîä = map ((‚à©) K) ({ùü≠} # tl ùîä)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"remdups_adj (map ((‚à©) K) ùîä) = remdups_adj ((K ‚à© {ùü≠}) # (map ((‚à©) K) (tl ùîä)))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = (K ‚à© {ùü≠}) # tl (remdups_adj ((K ‚à© {ùü≠}) # (map ((‚à©) K) (tl ùîä))))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hd (remdups_adj (map ((‚à©) K) ùîä)) = K ‚à© {ùü≠}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hd (remdups_adj (map ((‚à©) K) ùîä)) = {ùü≠<span class="hidden">‚áò</span><sub>G‚¶ácarrier := K‚¶à<span class="hidden">‚áô</span></sub>}"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>KG</span><span> </span><span>normal_imp_subgroup</span><span> </span><span>subgroup.one_closed</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="comment">‚Äï ‚ÄπShow that the last entry is really @{text "K ‚à© G"}. Since we don't have a lemma ready to talk about the
    last entry of a reduced list, we reverse the list twice.‚Ä∫</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rev ùîä = (carrier G) # tl (rev ùîä)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span>last</span><span> </span><span>last_rev</span><span> </span><span>neq_Nil_conv</span><span> </span><span>notempty</span><span> </span><span>rev_is_Nil_conv</span><span> </span><span>rev_rev_ident</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rev (map ((‚à©) K) ùîä) = map ((‚à©) K) ((carrier G) # tl (rev ùîä))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>rev_map</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>rev</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"rev (map ((‚à©) K) ùîä) = (K ‚à© (carrier G)) # (map ((‚à©) K) (tl (rev ùîä)))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"last (remdups_adj (map ((‚à©) K) ùîä)) = hd (rev (remdups_adj (map ((‚à©) K) ùîä)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hd_rev</span><span> </span><span>map_is_Nil_conv</span><span> </span><span>notempty</span><span> </span><span>remdups_adj_Nil_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = hd (remdups_adj (rev (map ((‚à©) K) ùîä)))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>remdups_adj_rev</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = hd (remdups_adj ((K ‚à© (carrier G)) # (map ((‚à©) K) (tl (rev ùîä)))))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>rev</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = hd ((K ‚à© (carrier G)) # (remdups_adj ((K ‚à© (carrier G)) # (map ((‚à©) K) (tl (rev ùîä))))))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>remdups_adj_Cons_alt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = K"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>KG</span><span> </span><span>normal_imp_subgroup</span><span> </span><span>subgroup.subset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"last (remdups_adj (map ((‚à©) K) ùîä)) = carrier (G‚¶ácarrier := K‚¶à)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="comment">‚Äï ‚ÄπThe induction step, using the second isomorphism theorem for groups.‚Ä∫</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>j</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>j</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"j + 1 &lt; length (remdups_adj (map ((‚à©) K) ùîä))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>KGnotempty</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(map ((‚à©) K) ùîä) ‚â† []"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>notempty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Nil_is_map_conv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>j</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"i + 1 &lt; length (map ((‚à©) K) ùîä)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(remdups_adj (map ((‚à©) K) ùîä)) ! j = (map ((‚à©) K) ùîä) ! i"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(remdups_adj (map ((‚à©) K) ùîä)) ! (j + 1) = (map ((‚à©) K) ùîä) ! (i + 1)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>remdups_adj_obtain_adjacency</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>i</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>i'</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"i + 1 &lt; length ùîä"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>length_map</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>GiSi</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ùîä ! i ‚ä≤ G‚¶ácarrier := ùîä ! (i + 1)‚¶à"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>normal</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>GiSi'</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ùîä ! i ‚äÜ ùîä ! (i + 1)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>normal_imp_subgroup</span><span> </span><span>subgroup.subset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>i'</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>finGSi</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"finite (ùîä ! (i + 1))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>normal_series_subgroups</span><span> </span><span>finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>subgroup_finite</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>GiSi</span><span> </span><span>KG</span><span> </span><span>i'</span><span> </span><span>normal_series_subgroups</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>GSiKnormGSi</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ùîä ! (i + 1) ‚à© K ‚ä≤ G‚¶ácarrier := ùîä ! (i + 1)‚¶à"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>second_isomorphism_grp.normal_subgrp_intersection_normal</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>second_isomorphism_grp_def</span><span> </span><span>second_isomorphism_grp_axioms_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>GiSi</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä ! i ‚à© (ùîä ! (i + 1) ‚à© K) ‚ä≤ G‚¶ácarrier := ùîä ! (i + 1)‚¶à"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>group.normal_subgroup_intersect</span><span> </span><span>group.subgroup_imp_group</span><span> </span><span>i'</span><span> </span><span>is_group</span><span> </span><span>is_normal_series</span><span> </span><span>normal_series.normal_series_subgroups</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"K ‚à© (ùîä ! i ‚à© ùîä ! (i + 1)) ‚ä≤ G‚¶ácarrier := ùîä ! (i + 1)‚¶à"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inf_commute</span><span> </span><span>inf_left_commute</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>KGinormGSi</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"K ‚à© ùîä ! i ‚ä≤ G‚¶ácarrier := ùîä ! (i + 1)‚¶à"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>GiSi'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>le_iff_inf</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"K ‚à© ùîä ! i ‚äÜ K ‚à© ùîä ! (i + 1)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>GiSi'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>groupGSi</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"group (G‚¶ácarrier := ùîä ! (i + 1)‚¶à)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i</span><span> </span><span>normal_series_subgroups</span><span> </span><span>subgroup_imp_group</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>subKGSiGSi</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"subgroup (K ‚à© ùîä ! (i + 1)) (G‚¶ácarrier := ùîä ! (i + 1)‚¶à)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>GSiKnormGSi</span><span> </span><span>inf_sup_aci</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>normal_imp_subgroup</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fstgoal</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"K ‚à© ùîä ! i ‚ä≤ G‚¶ácarrier := ùîä ! (i + 1), carrier := K ‚à© ùîä ! (i + 1)‚¶à"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>group.normal_restrict_supergroup</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"remdups_adj (map ((‚à©) K) ùîä) ! j ‚ä≤ G‚¶ácarrier := K, carrier := remdups_adj (map ((‚à©) K) ùîä) ! (j + 1)‚¶à"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>simplefact</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Gisimple</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"simple_group (G‚¶ácarrier := ùîä ! (i + 1)‚¶à Mod ùîä ! i)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>Gimax</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"max_normal_subgroup (ùîä ! i) (G‚¶ácarrier := ùîä ! (i + 1)‚¶à)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>normal.max_normal_simple_quotient</span><span> </span><span>GiSi</span><span> </span><span>finGSi</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>GSiKnormGSi</span><span> </span><span>GiSi</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä ! i &lt;#&gt;<span class="hidden">‚áò</span><sub>G‚¶ácarrier := ùîä ! (i + 1)‚¶à<span class="hidden">‚áô</span></sub> ùîä ! (i + 1) ‚à© K ‚ä≤ (G‚¶ácarrier := ùîä ! (i + 1)‚¶à)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>groupGSi</span><span> </span><span>group.normal_subgroup_set_mult_closed</span><span> </span><span>set_mult_consistent</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä ! i &lt;#&gt; ùîä ! (i + 1) ‚à© K ‚ä≤ G‚¶ácarrier := ùîä ! (i + 1)‚¶à"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>set_mult_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä ! i &lt;#&gt; K ‚à© ùîä ! (i + 1) ‚ä≤ G‚¶ácarrier := ùîä ! (i + 1)‚¶à"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inf_commute</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä ! i ‚äÜ ùîä ! i &lt;#&gt;<span class="hidden">‚áò</span><sub>G‚¶ácarrier := ùîä ! (i + 1)‚¶à<span class="hidden">‚áô</span></sub> K ‚à© ùîä ! (i + 1)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>second_isomorphism_grp.H_contained_in_set_mult</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>second_isomorphism_grp_def</span><span> </span><span>second_isomorphism_grp_axioms_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subKGSiGSi</span><span> </span><span>GiSi</span><span> </span><span>normal_imp_subgroup</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä ! i ‚äÜ ùîä ! i &lt;#&gt; K ‚à© ùîä ! (i + 1)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>set_mult_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>KGdisj</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ùîä ! i &lt;#&gt; K ‚à© ùîä ! (i + 1) = ùîä ! i ‚à® ùîä ! i &lt;#&gt; K ‚à© ùîä ! (i + 1) = ùîä ! (i + 1)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Gimax</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>max_normal_subgroup_def</span><span> </span><span>max_normal_subgroup_axioms_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>œÜ</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"œÜ ‚àà iso  (G‚¶ácarrier := K ‚à© ùîä ! (i + 1)‚¶à Mod (ùîä ! i ‚à© (K ‚à© ùîä ! (i + 1))))
             (G‚¶ácarrier := ùîä ! i &lt;#&gt;<span class="hidden">‚áò</span><sub>G‚¶ácarrier := ùîä ! (i + 1)‚¶à<span class="hidden">‚áô</span></sub> K ‚à© ùîä ! (i + 1)‚¶à Mod ùîä ! i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>second_isomorphism_grp.normal_intersection_quotient_isom</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>second_isomorphism_grp_def</span><span> </span><span>second_isomorphism_grp_axioms_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>GiSi</span><span> </span><span>subKGSiGSi</span><span> </span><span>normal_imp_subgroup</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"œÜ ‚àà iso  (G‚¶ácarrier := K ‚à© ùîä ! (i + 1)‚¶à Mod (K ‚à© ùîä ! (i + 1) ‚à© ùîä ! i))
                  (G‚¶ácarrier := ùîä ! i &lt;#&gt;<span class="hidden">‚áò</span><sub>G‚¶ácarrier := ùîä ! (i + 1)‚¶à<span class="hidden">‚áô</span></sub> K ‚à© ùîä ! (i + 1)‚¶à Mod ùîä ! i)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inf_commute</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"œÜ ‚àà iso (G‚¶ácarrier := K ‚à© ùîä ! (i + 1)‚¶à Mod (K ‚à© (ùîä ! (i + 1) ‚à© ùîä ! i)))
                 (G‚¶ácarrier := ùîä ! i &lt;#&gt;<span class="hidden">‚áò</span><sub>G‚¶ácarrier := ùîä ! (i + 1)‚¶à<span class="hidden">‚áô</span></sub> K ‚à© ùîä ! (i + 1)‚¶à Mod ùîä ! i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Int_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"œÜ ‚àà iso (G‚¶ácarrier := K ‚à© ùîä ! (i + 1)‚¶à Mod (K ‚à© ùîä ! i))
                 (G‚¶ácarrier := ùîä ! i &lt;#&gt;<span class="hidden">‚áò</span><sub>G‚¶ácarrier := ùîä ! (i + 1)‚¶à<span class="hidden">‚áô</span></sub> K ‚à© ùîä ! (i + 1)‚¶à Mod ùîä ! i)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>GiSi'</span><span> </span><span>Int_absorb2</span><span> </span><span>Int_commute</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>œÜ</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"œÜ ‚àà iso (G‚¶ácarrier := K ‚à© ùîä ! (i + 1)‚¶à Mod (K ‚à© ùîä ! i))
                   (G‚¶ácarrier := ùîä ! i &lt;#&gt; K ‚à© ùîä ! (i + 1)‚¶à Mod ùîä ! i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>set_mult_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>fstgoal</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>KGsiKGigroup</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"group (G‚¶ácarrier := K ‚à© ùîä ! (i + 1)‚¶à Mod (K ‚à© ùîä ! i))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>normal.factorgroup_is_group</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>KGdisj</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"simple_group (G‚¶ácarrier := K, carrier := remdups_adj (map ((‚à©) K) ùîä) ! (j + 1)‚¶à Mod remdups_adj (map ((‚à©) K) ùîä) ! j)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>groupGi</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"group (G‚¶ácarrier := ùîä ! i‚¶à)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i'</span><span> </span><span>normal_series_subgroups</span><span> </span><span>subgroup_imp_group</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä ! i &lt;#&gt; K ‚à© ùîä ! Suc i = ùîä ! i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>œÜ</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"œÜ ‚àà iso (G‚¶ácarrier := K ‚à© ùîä ! (i + 1)‚¶à Mod (K ‚à© ùîä ! i)) (G‚¶ácarrier := ùîä ! i‚¶à Mod ùîä ! i)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>œà</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"œà ‚àà iso (G‚¶ácarrier := ùîä ! i‚¶à Mod (carrier (G‚¶ácarrier := ùîä ! i‚¶à))) (G‚¶ácarrier := {ùü≠<span class="hidden">‚áò</span><sub>G‚¶ácarrier := ùîä ! i‚¶à<span class="hidden">‚áô</span></sub>}‚¶à)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>group.self_factor_iso</span><span> </span><span>groupGi</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>œÄ</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"œÄ ‚àà iso (G‚¶ácarrier := K ‚à© ùîä ! (i + 1)‚¶à Mod (K ‚à© ùîä ! i)) (G‚¶ácarrier := {ùü≠}‚¶à)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>iso_set_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"order (G‚¶ácarrier := K ‚à© ùîä ! (i + 1)‚¶à Mod (K ‚à© ùîä ! i)) = order (G‚¶ácarrier := {ùü≠}‚¶à)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>iso_order_closed</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"order (G‚¶ácarrier := K ‚à© ùîä ! (i + 1)‚¶à Mod (K ‚à© ùîä ! i)) = 1"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>order_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"carrier (G‚¶ácarrier := K ‚à© ùîä ! (i + 1)‚¶à Mod (K ‚à© ùîä ! i)) = {ùü≠<span class="hidden">‚áò</span><sub>G‚¶ácarrier := K ‚à© ùîä ! (i + 1)‚¶à Mod (K ‚à© ùîä ! i)<span class="hidden">‚áô</span></sub>}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>group.order_one_triv_iff</span><span> </span><span>KGsiKGigroup</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>fstgoal</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"K ‚à© ùîä ! i ‚ä≤ G‚¶ácarrier := K ‚à© ùîä ! (i + 1)‚¶à"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>finGSi</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (carrier (G‚¶ácarrier := K ‚à© ùîä ! (i + 1)‚¶à))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"K ‚à© ùîä ! i = carrier (G‚¶ácarrier := K ‚à© ùîä ! (i + 1)‚¶à)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>normal.fact_group_trivial_iff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(remdups_adj (map ((‚à©) K) ùîä)) ! j = (remdups_adj (map ((‚à©) K) ùîä)) ! (j + 1)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>j</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>remdups_adj_adjacent</span><span> </span><span>KGnotempty</span><span> </span><span>Suc_eq_plus1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"simple_group (G‚¶ácarrier := remdups_adj (map ((‚à©) K) ùîä) ! Suc j‚¶à Mod remdups_adj (map ((‚à©) K) ùîä) ! j)"</span></span></span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä ! i &lt;#&gt; K ‚à© ùîä ! Suc i = ùîä ! Suc i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>œÜ</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"œÜ ‚àà iso (G‚¶ácarrier := K ‚à© ùîä ! (i + 1)‚¶à Mod (K ‚à© ùîä ! i)) (G‚¶ácarrier := ùîä ! (i + 1)‚¶à Mod ùîä ! i)"</span></span></span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>œÜ'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"œÜ' ‚àà iso (G‚¶ácarrier := ùîä ! (i + 1)‚¶à Mod ùîä ! i) (G‚¶ácarrier := K ‚à© ùîä ! (i + 1)‚¶à Mod (K ‚à© ùîä ! i))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>KGsiKGigroup</span><span> </span><span>group.iso_set_sym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Gisimple</span><span> </span><span>KGsiKGigroup</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"simple_group (G‚¶ácarrier := K ‚à© ùîä ! (i + 1)‚¶à Mod (K ‚à© ùîä ! i))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>simple_group.iso_simple</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>i</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"simple_group (G‚¶ácarrier := remdups_adj (map ((‚à©) K) ùîä) ! Suc j‚¶à Mod remdups_adj (map ((‚à©) K) ùîä) ! j)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>group</span><span class="delimiter">)</span><span> </span><span>composition_series_extend</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"composition_series (G‚¶ácarrier := H‚¶à) ‚Ñå"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"simple_group (G Mod H)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H ‚ä≤ G"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"composition_series G (‚Ñå @ [carrier G])"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>composition_series_def</span><span> </span><span>composition_series_axioms_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>comp‚Ñå</span><span class="delimiter">:</span><span> </span><span>composition_series</span><span> </span><span class="string"><span class="delete"><span class="delete">"G‚¶ácarrier := H‚¶à"</span></span></span><span> </span><span>‚Ñå</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"normal_series G (‚Ñå @ [carrier G])"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>comp‚Ñå.is_normal_series</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>normal_series_extend</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>i</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"i &lt; length ‚Ñå"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"simple_group (G‚¶ácarrier := (‚Ñå @ [carrier G]) ! Suc i‚¶à Mod (‚Ñå @ [carrier G]) ! i)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"i = length ‚Ñå - 1"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(‚Ñå @ [carrier G]) ! Suc i = carrier G"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>i</span><span> </span><span>diff_Suc_1</span><span> </span><span>lessE</span><span> </span><span>nth_append_length</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(‚Ñå @ [carrier G]) ! i = ‚Ñå ! i"</span></span></span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>butlast_snoc</span><span> </span><span>i</span><span> </span><span>nth_butlast</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(‚Ñå @ [carrier G]) ! i = H"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span> </span><span>last_conv_nth</span><span> </span><span>comp‚Ñå.notempty</span><span> </span><span>comp‚Ñå.last</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc i &lt; length ‚Ñå"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(‚Ñå @ [carrier G]) ! Suc i = ‚Ñå ! Suc i"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nth_append</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(‚Ñå @ [carrier G]) ! i = ‚Ñå ! i"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nth_append</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπSuc i &lt; length ‚Ñå‚Ä∫</span></span></span><span> </span><span>comp‚Ñå.simplefact</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>composition_series</span><span class="delimiter">)</span><span> </span><span>entries_mono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ‚â§ j"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j &lt; length ùîä"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä ! i ‚äÜ ùîä ! j"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span class="string"><span class="delete"><span class="delete">"j - i"</span></span></span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>i</span><span> </span><span>j</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i = j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä ! i ‚äÜ ùîä ! j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>k</span><span> </span><span>i</span><span> </span><span>j</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>i'</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"i + (Suc k) = j"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i + 1 &lt; length ùîä"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>ij</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"i + 1 ‚â§ j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä ! i ‚äÜ ùîä ! (i + 1)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i'</span><span> </span><span>normal</span><span> </span><span>normal_imp_subgroup</span><span> </span><span>subgroup.subset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j - (i + 1) = k"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j &lt; length ùîä"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä ! (i + 1) ‚äÜ ùîä ! j"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>ij</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä ! i ‚äÜ ùîä ! j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="GroupIsoClasses">
<div class="head"><h1>Theory GroupIsoClasses</h1>
<span class="command">theory</span> <span class="name">GroupIsoClasses</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL-Algebra/Coset.html"><span class="name">Coset</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:      Isomorphism Classes of Groups
    Author:     Jakob von Raumer, Karlsruhe Institute of Technology
    Maintainer: Jakob von Raumer &lt;jakob.raumer@student.kit.edu&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>GroupIsoClasses</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Algebra.Coset"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπIsomorphism Classes of Groups‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπWe construct a quotient type for isomorphism classes of groups.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">typedef</span></span><span> </span><span class="tfree">'a</span><span> </span><span>group</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"{G :: 'a monoid. group G}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄa. ‚¶ácarrier = {a}, mult = (Œªx y. x), one = a‚¶à ‚àà {G. group G}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>group_def</span><span> </span><span>group_axioms_def</span><span> </span><span>monoid_def</span><span> </span><span>Units_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>group_iso_rel</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a group ‚áí 'a group ‚áí bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"group_iso_rel G H = (‚àÉœÜ. œÜ ‚àà iso (Rep_group G) (Rep_group H))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">quotient_type</span></span><span> </span><span class="tfree">'a</span><span> </span><span>group_iso_class</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a group"</span></span></span><span> </span><span class="delimiter">/</span><span> </span><span>group_iso_rel</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">morphisms</span></span><span> </span><span>Rep_group_iso</span><span> </span><span>Abs_group_iso</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>equivpI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reflp group_iso_rel"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>reflpI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>G</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'b group"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"group_iso_rel G G"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>group_iso_rel_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>iso_set_refl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"symp group_iso_rel"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sympI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>G</span><span> </span><span>H</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'b group"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"group_iso_rel G H"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>œÜ</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"œÜ ‚àà iso (Rep_group G) (Rep_group H)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>group_iso_rel_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>œÜ'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"œÜ' ‚àà iso (Rep_group H) (Rep_group G)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>group.iso_sym</span><span> </span><span>Rep_group</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>group.iso_set_sym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"group_iso_rel H G"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>group_iso_rel_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"transp group_iso_rel"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>transpI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>G</span><span> </span><span>H</span><span> </span><span>I</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'b group"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"group_iso_rel G H"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"group_iso_rel H I"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>œÜ</span><span> </span><span>œà</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"œÜ ‚àà iso (Rep_group G) (Rep_group H)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"œà ‚àà iso (Rep_group H) (Rep_group I)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>group_iso_rel_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>œÄ</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"œÄ ‚àà iso (Rep_group G) (Rep_group I)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>iso_set_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"group_iso_rel G I"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>group_iso_rel_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThis assigns to a given group the group isomorphism class‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>group</span><span class="delimiter">)</span><span> </span><span>iso_class</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a group_iso_class"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"iso_class = Abs_group_iso (Abs_group (monoid.truncate G))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπTwo isomorphic groups do indeed have the same isomorphism class:‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>iso_classes_iff</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"group G"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"group H"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(‚àÉœÜ. œÜ ‚àà iso G H) = (group.iso_class G = group.iso_class H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>groups</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"group (monoid.truncate G)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"group (monoid.truncate H)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>monoid.truncate_def</span><span> </span><span>group_def</span><span> </span><span>group_axioms_def</span><span> </span><span>Units_def</span><span> </span><span>monoid_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(‚àÉœÜ. œÜ ‚àà iso G H) = (‚àÉœÜ. œÜ ‚àà iso (monoid.truncate G) (monoid.truncate H))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>iso_def</span><span> </span><span>hom_def</span><span> </span><span>monoid.truncate_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = group_iso_rel (Abs_group (monoid.truncate G)) (Abs_group (monoid.truncate H))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>group_iso_rel_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>groups</span><span> </span><span>group.Abs_group_inverse</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mem_Collect_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = (group.iso_class G = group.iso_class H)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>group.iso_class_def</span><span> </span><span>assms</span><span> </span><span>group_iso_class.abs_eq_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="JordanHolder">
<div class="head"><h1>Theory JordanHolder</h1>
<span class="command">theory</span> <span class="name">JordanHolder</span><br/>
<span class="keyword">imports</span> <a href="CompositionSeries.html"><span class="name">CompositionSeries</span></a> <a href="GroupIsoClasses.html"><span class="name">GroupIsoClasses</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:      The Jordan-H√∂lder Theorem
    Author:     Jakob von Raumer, Karlsruhe Institute of Technology
    Maintainer: Jakob von Raumer &lt;jakob.raumer@student.kit.edu&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>JordanHolder</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>CompositionSeries</span><span>
</span><span>  </span><span>MaximalNormalSubgroups</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Multiset"</span></span></span><span>
</span><span>  </span><span>GroupIsoClasses</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThe Jordan-H\"older Theorem‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>jordan_hoelder</span><span> </span><span class="delimiter">=</span><span> </span><span>group</span><span>
</span><span>  </span><span class="delimiter">+</span><span> </span><span>comp‚Ñå</span><span class="delimiter">?</span><span class="delimiter">:</span><span> </span><span>composition_series</span><span> </span><span>G</span><span> </span><span>‚Ñå</span><span>
</span><span>  </span><span class="delimiter">+</span><span> </span><span>compùîä</span><span class="delimiter">?</span><span class="delimiter">:</span><span> </span><span>composition_series</span><span> </span><span>G</span><span> </span><span>ùîä</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>‚Ñå</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ùîä</span><span>
</span><span>  </span><span class="delimiter">+</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>finite</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"finite (carrier G)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπBefore we finally start the actual proof of the theorem, one last lemma: Cancelling
  the last entry of a normal series results in a normal series with quotients being all but the last
  of the original ones.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>normal_series</span><span class="delimiter">)</span><span> </span><span>quotients_butlast</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length ùîä &gt; 1"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"butlast quotients = normal_series.quotients (G‚¶ácarrier := ùîä ! (length ùîä - 1 - 1)‚¶à) (take (length ùîä - 1) ùîä)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>nth_equalityI</span><span> </span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n = length ùîä - 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n = length (take n ùîä)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n &gt; 0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n &lt; length ùîä"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>notempty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>normalùîäbutlast</span><span class="delimiter">:</span><span> </span><span>normal_series</span><span> </span><span class="string"><span class="delete"><span class="delete">"(G‚¶ácarrier := ùîä ! (n - 1)‚¶à)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"take n ùîä"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>normal_series_prefix_closed</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπn &gt; 0‚Ä∫</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπn &lt; length ùîä‚Ä∫</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (butlast quotients) = length quotients - 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>length_butlast</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = length ùîä - 1 - 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_diff_cancel_right'</span><span> </span><span>quotients_length</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = length (take n ùîä) - 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπn = length (take n ùîä)‚Ä∫</span></span></span><span> </span><span>n_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = length normalùîäbutlast.quotients"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>normalùîäbutlast.quotients_length</span><span> </span><span>diff_add_inverse2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (butlast quotients) = length normalùîäbutlast.quotients"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄi&lt;length (butlast quotients). butlast quotients ! i = normalùîäbutlast.quotients ! i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>i</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"i &lt; length quotients - Suc 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>i'</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"i &lt; length ùîä - 1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; n"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i + 1 &lt; n"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>n_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>quotients_length</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"butlast quotients ! i = quotients ! i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>length_butlast</span><span> </span><span>nth_butlast</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = G‚¶ácarrier := ùîä ! (i + 1)‚¶à Mod ùîä ! i"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>quotients_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i'</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = G‚¶ácarrier := (take n ùîä) ! (i + 1)‚¶à Mod (take n ùîä) ! i"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i'</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span>nth_take</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = normalùîäbutlast.quotients ! i"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>normalùîäbutlast.quotients_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"butlast (normal_series.quotients G ùîä) ! i = normal_series.quotients (G‚¶ácarrier := ùîä ! (n - Suc 0)‚¶à) (take n ùîä) ! i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄi. i &lt; length (butlast quotients) 
            ‚üπ butlast quotients ! i
              = normal_series.quotients (G‚¶ácarrier := ùîä ! (length ùîä - 1 - 1)‚¶à)  (take (length ùîä - 1) ùîä) ! i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>n_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThe main part of the Jordan H√∂lder theorem is its statement about the uniqueness of 
  a composition series. Here, uniqueness up to reordering and isomorphism is modelled by stating
  that the multisets of isomorphism classes of all quotients are equal.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>jordan_hoelder_multisets</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"group G"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (carrier G)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"composition_series G ùîä"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"composition_series G ‚Ñå"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mset (map group.iso_class (normal_series.quotients G ùîä))
    = mset (map group.iso_class (normal_series.quotients G ‚Ñå))"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span class="string"><span class="delete"><span class="delete">"length ùîä"</span></span></span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>ùîä</span><span> </span><span>‚Ñå</span><span> </span><span>G</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>full_nat_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>ùîä</span><span> </span><span>‚Ñå</span><span> </span><span>G</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>compùîä</span><span class="delimiter">:</span><span> </span><span>composition_series</span><span> </span><span>G</span><span> </span><span>ùîä</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>1</span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>comp‚Ñå</span><span class="delimiter">:</span><span> </span><span>composition_series</span><span> </span><span>G</span><span> </span><span>‚Ñå</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>1</span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>grpG</span><span class="delimiter">:</span><span> </span><span>group</span><span> </span><span>G</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"length ùîä ‚â§ 2"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"length ùîä = 0 ‚à® length ùîä = 1 ‚à® length ùîä = 2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>arith</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>compùîä.notempty</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"length ùîä = 1 ‚à® length ùîä = 2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>mset_map</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="comment">‚Äï ‚ÄπFirst trivial case: @{text ùîä} is the trivial group.‚Ä∫</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length ùîä = Suc 0"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>length</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"length ùîä = 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length [] + 1 = length ùîä"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>length</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>charùîä</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ùîä = [{ùü≠<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub>}]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>compùîä.composition_series_length_one</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"carrier G = {ùü≠<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub>}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>compùîä.composition_series_triv_group</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>length</span><span> </span><span>charùîä</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä = ‚Ñå"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp‚Ñå.composition_series_triv_group</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="comment">‚Äï ‚ÄπSecond trivial case: @{text ùîä} is simple.‚Ä∫</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length ùîä = 2"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>ùîächar</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ùîä = [{ùü≠<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub>}, carrier G]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>compùîä.length_two_unique</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>simple</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"simple_group G"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>compùîä.composition_series_simple_group</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ñå = [{ùü≠<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub>}, carrier G]"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp‚Ñå.composition_series_simple_group</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ùîächar</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä = ‚Ñå"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="comment">‚Äï ‚ÄπNon-trivial case: @{text ùîä} has length at least 3.‚Ä∫</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>length</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"length ùîä ‚â• 3"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="comment">‚Äï ‚ÄπFirst we show that @{text ‚Ñå} must have a length of at least 3.‚Ä∫</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬¨ simple_group G"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compùîä.composition_series_simple_group</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ñå ‚â† [{ùü≠<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub>}, carrier G]"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp‚Ñå.composition_series_simple_group</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length ‚Ñå ‚â† 2"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp‚Ñå.length_two_unique</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>length</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"carrier G ‚â† {ùü≠<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub>}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compùîä.composition_series_length_one</span><span> </span><span>compùîä.composition_series_triv_group</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length ‚Ñå ‚â† 1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp‚Ñå.composition_series_length_one</span><span> </span><span>comp‚Ñå.composition_series_triv_group</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>comp‚Ñå.notempty</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length ‚Ñå ‚â† 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>length‚Ñåbig</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"length ‚Ñå ‚â• 3"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp‚Ñå.notempty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>arith</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>m</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m = length ‚Ñå - 1"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n = length ùîä - 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>length‚Ñåbig</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>m'</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"m &gt; 0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m &lt; length ‚Ñå"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(m - 1) + 1 &lt; length ‚Ñå"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m - 1 = length ‚Ñå - 2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m - 1 + 1 = length ‚Ñå - 1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m - 1 &lt; length ‚Ñå"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>m_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>length</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n'</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"n &gt; 0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n &lt; length ùîä"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(n - 1) + 1 &lt; length ùîä"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n - 1 &lt; length ùîä"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc n ‚â§ length ùîä"</span></span></span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"n - 1 = length ùîä - 2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n - 1 + 1 = length ùîä - 1"</span></span></span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>n_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>ùîäPn</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîäPn = G‚¶ácarrier := ùîä ! (n - 1)‚¶à"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>‚ÑåPm</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ÑåPm = G‚¶ácarrier := ‚Ñå ! (m - 1)‚¶à"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>grpùîäPn</span><span class="delimiter">:</span><span> </span><span>group</span><span> </span><span>ùîäPn</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ùîäPn_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>compùîä.normal_series_subgroups</span><span> </span><span>compùîä.subgroup_imp_group</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>grp‚ÑåPm</span><span class="delimiter">:</span><span> </span><span>group</span><span> </span><span>‚ÑåPm</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>‚ÑåPm_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>m'</span><span> </span><span>comp‚Ñå.normal_series_subgroups</span><span> </span><span>1</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>group.subgroup_imp_group</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>finGbl</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"finite (carrier ùîäPn)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπn - 1 &lt; length ùîä‚Ä∫</span></span></span><span> </span><span>1</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ùîäPn_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compùîä.normal_series_subgroups</span><span> </span><span>compùîä.subgroup_finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>finHbl</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"finite (carrier ‚ÑåPm)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπm - 1 &lt; length ‚Ñå‚Ä∫</span></span></span><span> </span><span>1</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>‚ÑåPm_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp‚Ñå.normal_series_subgroups</span><span> </span><span>compùîä.subgroup_finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>quotsùîänotempty</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"compùîä.quotients ‚â† []"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compùîä.quotients_length</span><span> </span><span>length</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>quots‚Ñånotempty</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"comp‚Ñå.quotients ‚â† []"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp‚Ñå.quotients_length</span><span> </span><span>length‚Ñåbig</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    
</span><span>    </span><span class="comment">‚Äï ‚ÄπInstantiate truncated composition series since they are used for both cases‚Ä∫</span><span>
</span><span>    </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>‚Ñåbutlast</span><span class="delimiter">:</span><span> </span><span>composition_series</span><span> </span><span>‚ÑåPm</span><span> </span><span class="string"><span class="delete"><span class="delete">"take m ‚Ñå"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp‚Ñå.composition_series_prefix_closed</span><span> </span><span>m'</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span>‚ÑåPm_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>ùîäbutlast</span><span class="delimiter">:</span><span> </span><span>composition_series</span><span> </span><span>ùîäPn</span><span> </span><span class="string"><span class="delete"><span class="delete">"take n ùîä"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compùîä.composition_series_prefix_closed</span><span> </span><span>n'</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span>ùîäPn_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ltaken</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"n = length (take n ùîä)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>length_take</span><span> </span><span>n'</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ltakem</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"m = length (take m ‚Ñå)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>length_take</span><span> </span><span>m'</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ñå ! (m - 1)  = ùîä ! (n - 1)"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="comment">‚Äï ‚ÄπIf @{term "‚Ñå ! (l - 1) = ùîä ! 1"}, everything is simple...‚Ä∫</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>      </span><span class="comment">‚Äï ‚ÄπThe last quotients of @{term ùîä} and @{term ‚Ñå} are equal.‚Ä∫</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lasteq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"last compùîä.quotients = last comp‚Ñå.quotients"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>length</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lg</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"length ùîä - 1 - 1 + 1 = length ùîä - 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_diff_1</span><span> </span><span>Suc_eq_plus1</span><span> </span><span>n'</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>n_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>length‚Ñåbig</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lh</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"length ‚Ñå - 1 - 1 + 1 = length ‚Ñå - 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_diff_1</span><span> </span><span>Suc_eq_plus1</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ0 &lt; m‚Ä∫</span></span></span><span> </span><span>m_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"last compùîä.quotients =  G Mod ùîä ! (n - 1)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>length</span><span> </span><span>compùîä.last_quotient</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>n_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = G Mod ‚Ñå ! (m - 1)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = last comp‚Ñå.quotients"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>length‚Ñåbig</span><span> </span><span>comp‚Ñå.last_quotient</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>m_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ltaken</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ind</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"mset (map group.iso_class ùîäbutlast.quotients) = mset (map group.iso_class ‚Ñåbutlast.quotients)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>True</span><span> </span><span>n'</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>grpùîäPn.is_group</span><span> </span><span>finGbl</span><span> </span><span>ùîäbutlast.is_composition_series</span><span> </span><span>‚Ñåbutlast.is_composition_series</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ùîäPn_def</span><span> </span><span>‚ÑåPm_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mset (map group.iso_class compùîä.quotients)
                    = mset (map group.iso_class (butlast compùîä.quotients @ [last compùîä.quotients]))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>quotsùîänotempty</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = mset (map group.iso_class (ùîäbutlast.quotients @ [last (compùîä.quotients)]))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compùîä.quotients_butlast</span><span> </span><span>length</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>n_def</span><span> </span><span>ùîäPn_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = mset ((map group.iso_class ùîäbutlast.quotients) @ [group.iso_class (last (compùîä.quotients))])"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = mset (map group.iso_class ùîäbutlast.quotients) + {# group.iso_class (last (compùîä.quotients)) #}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = mset (map group.iso_class ‚Ñåbutlast.quotients) + {# group.iso_class (last (compùîä.quotients)) #}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ind</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = mset (map group.iso_class ‚Ñåbutlast.quotients) + {# group.iso_class (last (comp‚Ñå.quotients)) #}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lasteq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = mset ((map group.iso_class ‚Ñåbutlast.quotients) @ [group.iso_class (last (comp‚Ñå.quotients))])"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = mset (map group.iso_class (‚Ñåbutlast.quotients @ [last (comp‚Ñå.quotients)]))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = mset (map group.iso_class (butlast comp‚Ñå.quotients @ [last comp‚Ñå.quotients]))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>length‚Ñåbig</span><span> </span><span>comp‚Ñå.quotients_butlast</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>m_def</span><span> </span><span>‚ÑåPm_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = mset (map group.iso_class comp‚Ñå.quotients)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>append_butlast_last_id</span><span> </span><span>quots‚Ñånotempty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> 
</span><span>      </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>‚ÑåPmIntùîäPn</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ÑåPmIntùîäPn = G‚¶ácarrier := ‚Ñå ! (m - 1) ‚à© ùîä ! (n - 1)‚¶à"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>ùîäPnmax</span><span class="delimiter">:</span><span> </span><span>max_normal_subgroup</span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä ! (n - 1)"</span></span></span><span> </span><span>G</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>n_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_lessD1</span><span> </span><span>diff_diff_add</span><span> </span><span>n'</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>add.commute</span><span> </span><span>one_add_one</span><span> </span><span>1</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>compùîä.snd_to_last_max_normal</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>‚ÑåPmmax</span><span class="delimiter">:</span><span> </span><span>max_normal_subgroup</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ñå ! (m - 1)"</span></span></span><span> </span><span>G</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>m_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_lessD1</span><span> </span><span>diff_diff_add</span><span> </span><span>m'</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>add.commute</span><span> </span><span>one_add_one</span><span> </span><span>1</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>comp‚Ñå.snd_to_last_max_normal</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>‚ÑåPmnormG</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"‚Ñå ! (m - 1) ‚ä≤ G"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp‚Ñå.normal_series_snd_to_last</span><span> </span><span>m'</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>m_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ùîäPnnormG</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ùîä ! (n - 1) ‚ä≤ G"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compùîä.normal_series_snd_to_last</span><span> </span><span>n'</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>n_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>‚ÑåPmintùîäPnnormG</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"‚Ñå ! (m - 1) ‚à© ùîä ! (n - 1) ‚ä≤ G"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>‚ÑåPmnormG</span><span> </span><span>ùîäPnnormG</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>compùîä.normal_subgroup_intersect</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IntnormùîäPn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"‚Ñå ! (m - 1) ‚à© ùîä ! (n - 1) ‚ä≤ ùîäPn"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ùîäPnnormG</span><span> </span><span>‚ÑåPmnormG</span><span> </span><span>Int_lower2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ùîäPn_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>compùîä.normal_restrict_supergroup</span><span> </span><span>compùîä.normal_series_subgroups</span><span> </span><span>compùîä.normal_subgroup_intersect</span><span> </span><span>n'</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>grpùîäPnMod‚ÑåPmintùîäPn</span><span class="delimiter">:</span><span> </span><span>group</span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîäPn Mod ‚Ñå ! (m - 1) ‚à© ùîä ! (n - 1)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>normal.factorgroup_is_group</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Intnorm‚ÑåPm</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"‚Ñå ! (m - 1) ‚à© ùîä ! (n - 1) ‚ä≤ ‚ÑåPm"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>‚ÑåPmnormG</span><span> </span><span>ùîäPnnormG</span><span> </span><span>Int_lower2</span><span> </span><span>Int_commute</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>‚ÑåPm_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>compùîä.normal_restrict_supergroup</span><span> </span><span>compùîä.normal_subgroup_intersect</span><span> </span><span>comp‚Ñå.normal_series_subgroups</span><span> </span><span>m'</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>grp‚ÑåPmMod‚ÑåPmintùîäPn</span><span class="delimiter">:</span><span> </span><span>group</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ÑåPm Mod ‚Ñå ! (m - 1) ‚à© ùîä ! (n - 1)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>normal.factorgroup_is_group</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="comment">‚Äï ‚ÄπShow that the second to last entries are not contained in each other.‚Ä∫</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>not‚ÑåPmSubùîäPn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"¬¨ (‚Ñå ! (m - 1) ‚äÜ ùîä ! (n - 1))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>‚ÑåPmmax.max_normal</span><span> </span><span>ùîäPnnormG</span><span> </span><span>False</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>ùîäPnmax.proper</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>notùîäPnSub‚ÑåPm</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"¬¨ (ùîä ! (n - 1) ‚äÜ ‚Ñå ! (m - 1))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ùîäPnmax.max_normal</span><span> </span><span>‚ÑåPmnormG</span><span> </span><span>False</span><span> </span><span>‚ÑåPmmax.proper</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      
</span><span>      </span><span class="comment">‚Äï ‚ÄπShow that @{term "G Mod (‚Ñå ! (m - 1) ‚à© ùîä ! (n - 1))"} is a simple group.‚Ä∫</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>‚ÑåPmSubSetmult</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"‚Ñå ! (m - 1) ‚äÜ ‚Ñå ! (m - 1) &lt;#&gt;<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub> ùîä ! (n - 1)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>second_isomorphism_grp.H_contained_in_set_mult</span><span> </span><span>ùîäPnmax.is_normal</span><span> </span><span>‚ÑåPmnormG</span><span> </span><span>normal_imp_subgroup</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>second_isomorphism_grp_def</span><span> </span><span>second_isomorphism_grp_axioms_def</span><span> </span><span>max_normal_subgroup_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ùîäPnSubSetmult</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ùîä ! (n - 1) ‚äÜ ‚Ñå ! (m - 1) &lt;#&gt;<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub> ùîä ! (n - 1)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>second_isomorphism_grp.S_contained_in_set_mult</span><span> </span><span>ùîäPnmax.is_normal</span><span> </span><span>‚ÑåPmnormG</span><span> </span><span>normal_imp_subgroup</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>second_isomorphism_grp_def</span><span> </span><span>second_isomorphism_grp_axioms_def</span><span> </span><span>max_normal_subgroup_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîä ! (n - 1) ‚â† (‚Ñå ! (m - 1)) &lt;#&gt;<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub> (ùîä ! (n - 1))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>‚ÑåPmSubSetmult</span><span> </span><span>not‚ÑåPmSubùîäPn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>set_multG</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(‚Ñå ! (m - 1)) &lt;#&gt;<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub> (ùîä ! (n - 1)) = carrier G"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ùîäPnmax.max_normal</span><span> </span><span>ùîäPnmax.is_normal</span><span> </span><span>‚ÑåPmnormG</span><span> </span><span>compùîä.normal_subgroup_set_mult_closed</span><span> </span><span>ùîäPnSubSetmult</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>œÜ</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"œÜ ‚àà iso (ùîäPn Mod (‚Ñå ! (m - 1) ‚à© ùîä ! (n - 1))) (G‚¶ácarrier := carrier G‚¶à Mod ‚Ñå ! (m - 1))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>second_isomorphism_grp.normal_intersection_quotient_isom</span><span> </span><span>‚ÑåPmnormG</span><span> </span><span>ùîäPnmax.is_normal</span><span> </span><span>normal_imp_subgroup</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>second_isomorphism_grp_def</span><span> </span><span>second_isomorphism_grp_axioms_def</span><span> </span><span>max_normal_subgroup_def</span><span> </span><span>ùîäPn_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>œÜ</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"œÜ ‚àà iso (ùîäPn Mod (‚Ñå ! (m - 1) ‚à© ùîä ! (n - 1))) (G Mod ‚Ñå ! (m - 1))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>œÜ2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>œÜ2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"œÜ2 ‚àà iso (G Mod ‚Ñå ! (m - 1)) (ùîäPn Mod (‚Ñå ! (m - 1) ‚à© ùîä ! (n - 1)))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>group.iso_set_sym</span><span> </span><span>grpùîäPnMod‚ÑåPmintùîäPn.is_group</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"simple_group (G‚¶ácarrier := ‚Ñå ! (m - 1 + 1)‚¶à Mod ‚Ñå ! (m - 1))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp‚Ñå.simplefact</span><span> </span><span>m'</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"simple_group (G Mod ‚Ñå ! (m - 1))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp‚Ñå.last</span><span> </span><span>last_conv_nth</span><span> </span><span>comp‚Ñå.notempty</span><span> </span><span>m'</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>simpleùîäPnModInt</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"simple_group (ùîäPn Mod (‚Ñå ! (m - 1) ‚à© ùîä ! (n - 1)))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>simple_group.iso_simple</span><span> </span><span>grpùîäPnMod‚ÑåPmintùîäPn.is_group</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>grpGMod‚ÑåPm</span><span class="delimiter">:</span><span> </span><span>group</span><span> </span><span class="string"><span class="delete"><span class="delete">"(G Mod ‚Ñå ! (m - 1))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>‚ÑåPmnormG</span><span> </span><span>normal.factorgroup_is_group</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="comment">‚Äï ‚ÄπShow analogues of the previous statements for @{term "‚Ñå ! (m - 1)"} instead of @{term "ùîä ! (n - 1)"}.‚Ä∫</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>‚ÑåPmSubSetmult'</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"‚Ñå ! (m - 1) ‚äÜ ùîä ! (n - 1) &lt;#&gt;<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub> ‚Ñå ! (m - 1)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>second_isomorphism_grp.S_contained_in_set_mult</span><span> </span><span>ùîäPnmax.is_normal</span><span> </span><span>‚ÑåPmnormG</span><span> </span><span>normal_imp_subgroup</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>second_isomorphism_grp_def</span><span> </span><span>second_isomorphism_grp_axioms_def</span><span> </span><span>max_normal_subgroup_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ùîäPnSubSetmult'</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ùîä ! (n - 1) ‚äÜ ùîä ! (n - 1) &lt;#&gt;<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub> ‚Ñå ! (m - 1)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>second_isomorphism_grp.H_contained_in_set_mult</span><span> </span><span>ùîäPnmax.is_normal</span><span> </span><span>‚ÑåPmnormG</span><span> </span><span>normal_imp_subgroup</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>second_isomorphism_grp_def</span><span> </span><span>second_isomorphism_grp_axioms_def</span><span> </span><span>max_normal_subgroup_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ñå ! (m - 1) ‚â† (ùîä ! (n - 1)) &lt;#&gt;<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub> (‚Ñå ! (m - 1))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ùîäPnSubSetmult'</span><span> </span><span>notùîäPnSub‚ÑåPm</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>set_multG</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(ùîä ! (n - 1)) &lt;#&gt;<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub> (‚Ñå ! (m - 1)) = carrier G"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>‚ÑåPmmax.max_normal</span><span> </span><span>‚ÑåPmmax.is_normal</span><span> </span><span>ùîäPnnormG</span><span> </span><span>compùîä.normal_subgroup_set_mult_closed</span><span> </span><span>‚ÑåPmSubSetmult'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>set_multG</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>œà</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"œà ‚àà iso (‚ÑåPm Mod (ùîä ! (n - 1) ‚à© ‚Ñå ! (m - 1))) (G‚¶ácarrier := carrier G‚¶à Mod ùîä ! (n - 1))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>second_isomorphism_grp.normal_intersection_quotient_isom</span><span> </span><span>ùîäPnnormG</span><span> </span><span>‚ÑåPmmax.is_normal</span><span> </span><span>normal_imp_subgroup</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>second_isomorphism_grp_def</span><span> </span><span>second_isomorphism_grp_axioms_def</span><span> </span><span>max_normal_subgroup_def</span><span> </span><span>‚ÑåPm_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>œà</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"œà ‚àà iso (‚ÑåPm Mod (‚Ñå ! (m - 1) ‚à© (ùîä ! (n - 1)))) (G‚¶ácarrier := carrier G‚¶à Mod ùîä ! (n - 1))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Int_commute</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>œà2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>             </span><span>œà2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"œà2 ‚àà iso (G Mod ùîä ! (n - 1)) (‚ÑåPm Mod (‚Ñå ! (m - 1) ‚à© ùîä ! (n - 1)))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>group.iso_set_sym</span><span> </span><span>grp‚ÑåPmMod‚ÑåPmintùîäPn.is_group</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"simple_group (G‚¶ácarrier := ùîä ! (n - 1 + 1)‚¶à Mod ùîä ! (n - 1))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compùîä.simplefact</span><span> </span><span>n'</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"simple_group (G Mod ùîä ! (n - 1))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compùîä.last</span><span> </span><span>last_conv_nth</span><span> </span><span>compùîä.notempty</span><span> </span><span>n'</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>simple‚ÑåPmModInt</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"simple_group (‚ÑåPm Mod (‚Ñå ! (m - 1) ‚à© ùîä ! (n - 1)))"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>simple_group.iso_simple</span><span> </span><span>grp‚ÑåPmMod‚ÑåPmintùîäPn.is_group</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>grpGModùîäPn</span><span class="delimiter">:</span><span> </span><span>group</span><span> </span><span class="string"><span class="delete"><span class="delete">"(G Mod ùîä ! (n - 1))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ùîäPnnormG</span><span> </span><span>normal.factorgroup_is_group</span><span class="delimiter">)</span><span>
</span><span>      
</span><span>      </span><span class="comment">‚Äï ‚ÄπInstantiate several composition series used to build up the equality of quotient multisets.‚Ä∫</span><span>
</span><span>      </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>ùîé</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîé = remdups_adj (map ((‚à©) (‚Ñå ! (m - 1))) ùîä)"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>ùîè</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîè = remdups_adj (map ((‚à©) (ùîä ! (n - 1))) ‚Ñå)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>ùîé</span><span class="delimiter">:</span><span> </span><span>composition_series</span><span> </span><span>‚ÑåPm</span><span> </span><span>ùîé</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compùîä.intersect_normal</span><span> </span><span>1</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>‚ÑåPmnormG</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ùîé_def</span><span> </span><span>‚ÑåPm_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>ùîè</span><span class="delimiter">:</span><span> </span><span>composition_series</span><span> </span><span>ùîäPn</span><span> </span><span>ùîè</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp‚Ñå.intersect_normal</span><span> </span><span>1</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>ùîäPnnormG</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ùîè_def</span><span> </span><span>ùîäPn_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span>      </span><span class="comment">‚Äï ‚ÄπApply the induction hypothesis on @{text ùîäbutlast} and @{text ùîè}‚Ä∫</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>n'</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc (length (take n ùîä)) ‚â§ length ùîä"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>multisetsùîäbutlastùîè</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"mset (map group.iso_class ùîäbutlast.quotients) = mset (map group.iso_class ùîè.quotients)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"1.hyps"</span></span></span><span> </span><span>grpùîäPn.is_group</span><span> </span><span>finGbl</span><span> </span><span>ùîäbutlast.is_composition_series</span><span> </span><span>ùîè.is_composition_series</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>lengthùîè</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"n = length ùîè"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ùîäbutlast.quotients_length</span><span> </span><span>ùîè.quotients_length</span><span> </span><span>length_map</span><span> </span><span>size_mset</span><span> </span><span>ltaken</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>lengthùîè'</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"length ùîè &gt; 1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length ùîè - 1 &gt; 0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length ùîè - 1 ‚â§ length ùîè"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n'</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>length</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Inteqùîèsndlast</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"‚Ñå ! (m - 1) ‚à© ùîä ! (n - 1) = ùîè ! (length ùîè - 1 - 1)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length ùîè - 1 - 1 + 1 &lt; length ùîè"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lengthùîè'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>KGnotempty</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(map ((‚à©) (ùîä ! (n - 1))) ‚Ñå) ‚â† []"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp‚Ñå.notempty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Nil_is_map_conv</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"i + 1 &lt; length (map ((‚à©) (ùîä ! (n - 1))) ‚Ñå)"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"ùîè ! (length ùîè - 1 - 1) = (map ((‚à©) (ùîä ! (n - 1))) ‚Ñå) ! i"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîè ! (length ùîè - 1 - 1 + 1) = (map ((‚à©) (ùîä ! (n - 1))) ‚Ñå) ! (i + 1)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>remdups_adj_obtain_adjacency</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ùîè_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîè ! (length ùîè - 1 - 1) = ‚Ñå ! i ‚à© ùîä ! (n - 1)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîè ! (length ùîè - 1 - 1 + 1) = ‚Ñå ! (i + 1) ‚à© ùîä ! (n - 1)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîè ! (length ùîè - 1) = ‚Ñå ! (i + 1) ‚à© ùîä ! (n - 1)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lengthùîè'</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_diff_1</span><span> </span><span>Suc_eq_plus1</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>ùîäPnsub‚ÑåPm</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ùîä ! (n - 1) ‚äÜ ‚Ñå ! (i + 1)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ùîè.last</span><span> </span><span>ùîè.notempty</span><span> </span><span>last_conv_nth</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ùîäPn_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>i</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i + 1 &lt; m + 1"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>m_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬¨ (i + 1 ‚â§ m - 1)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp‚Ñå.entries_mono</span><span> </span><span>m'</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>notùîäPnSub‚ÑåPm</span><span> </span><span>ùîäPnsub‚ÑåPm</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m - 1 = i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>i</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>ùîèsndlast</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"‚ÑåPmIntùîäPn = (ùîäPn‚¶ácarrier := ùîè ! (length ùîè - 1 - 1)‚¶à)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>‚ÑåPmIntùîäPn_def</span><span> </span><span>ùîäPn_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>ùîèbutlast</span><span class="delimiter">:</span><span> </span><span>composition_series</span><span> </span><span>‚ÑåPmIntùîäPn</span><span> </span><span class="string"><span class="delete"><span class="delete">"take (length ùîè - 1) ùîè"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lengthùîè'</span><span> </span><span>ùîè.composition_series_prefix_closed</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπlength ùîè &gt; 1‚Ä∫</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>quotsùîènotemtpy</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ùîè.quotients ‚â† []"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ùîè.quotients_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>      </span><span class="comment">‚Äï ‚ÄπApply the induction hypothesis on @{text ùîèbutlast} and @{text ùîébutlast}‚Ä∫</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length ùîé &gt; 1"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬¨ length ùîé &gt; 1"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ùîé.notempty</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length ùîé = 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>Suc_lessI</span><span> </span><span>length_greater_0_conv</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"carrier ‚ÑåPm = {ùü≠<span class="hidden">‚áò</span><sub>‚ÑåPm<span class="hidden">‚áô</span></sub>}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ùîé.composition_series_length_one</span><span> </span><span>ùîé.composition_series_triv_group</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"carrier ‚ÑåPm = {ùü≠<span class="hidden">‚áò</span><sub>G<span class="hidden">‚áô</span></sub>}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>‚ÑåPm_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"carrier ‚ÑåPm ‚äÜ ùîä ! (n - 1)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ùîäPnmax.is_subgroup</span><span> </span><span>subgroup.one_closed</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>not‚ÑåPmSubùîäPn</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>‚ÑåPm_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>lengthùîé'</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"length ùîé - 1 &gt; 0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length ùîé - 1 ‚â§ length ùîé"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Inteqùîésndlast</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"‚Ñå ! (m - 1) ‚à© ùîä ! (n - 1) = ùîé ! (length ùîé - 1 - 1)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length ùîé - 1 - 1 + 1 &lt; length ùîé"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lengthùîé'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>KGnotempty</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(map ((‚à©) (‚Ñå ! (m - 1))) ùîä) ‚â† []"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compùîä.notempty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Nil_is_map_conv</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"i + 1 &lt; length (map ((‚à©) (‚Ñå ! (m - 1))) ùîä)"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"ùîé ! (length ùîé - 1 - 1) = (map ((‚à©) (‚Ñå ! (m - 1))) ùîä) ! i"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîé ! (length ùîé - 1 - 1 + 1) = (map ((‚à©) (‚Ñå ! (m - 1))) ùîä) ! (i + 1)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>remdups_adj_obtain_adjacency</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ùîé_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîé ! (length ùîé - 1 - 1) = ùîä ! i ‚à© ‚Ñå ! (m - 1)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîé ! (length ùîé - 1 - 1 + 1) = ùîä ! (i + 1) ‚à© ‚Ñå ! (m - 1)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ùîé ! (length ùîé - 1) = ùîä ! (i + 1) ‚à© ‚Ñå ! (m - 1)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lengthùîé'</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_diff_1</span><span> </span><span>Suc_eq_plus1</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>‚ÑåPmsubùîäPn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"‚Ñå ! (m - 1) ‚äÜ ùîä ! (i + 1)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ùîé.last</span><span> </span><span>ùîé.notempty</span><span> </span><span>last_conv_nth</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>‚ÑåPm_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>i</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i + 1 &lt; n + 1"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>n_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬¨ (i + 1 ‚â§ n - 1)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compùîä.entries_mono</span><span> </span><span>n'</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>not‚ÑåPmSubùîäPn</span><span> </span><span>‚ÑåPmsubùîäPn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n - 1 = i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>i</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"composition_series (G‚¶ácarrier := ùîé ! (length ùîé - 1 - 1)‚¶à) (take (length ùîé - 1) ùîé)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lengthùîé'</span><span> </span><span>ùîé.composition_series_prefix_closed</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>‚ÑåPmIntùîäPn_def</span><span> </span><span>‚ÑåPm_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>ùîébutlast</span><span class="delimiter">:</span><span> </span><span>composition_series</span><span> </span><span>‚ÑåPmIntùîäPn</span><span> </span><span class="string"><span class="delete"><span class="delete">"(take (length ùîé - 1) ùîé)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Inteqùîésndlast</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>‚ÑåPmIntùîäPn_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>finGbl</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>finInt</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"finite (carrier ‚ÑåPmIntùîäPn)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>‚ÑåPmIntùîäPn_def</span><span> </span><span>ùîäPn_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc (length (take (length ùîè - 1) ùîè)) ‚â§ length ùîä"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lengthùîè</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>n_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n'</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>multisetsùîéùîèbutlast</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"mset (map group.iso_class ùîèbutlast.quotients) = mset (map group.iso_class ùîébutlast.quotients)"</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1.hyps"</span></span></span><span> </span><span>ùîèbutlast.is_group</span><span> </span><span>ùîébutlast.is_composition_series</span><span> </span><span>ùîèbutlast.is_composition_series</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (take (length ùîé - 1) ùîé) = length (take (length ùîè - 1) ùîè)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ùîébutlast.quotients_length</span><span> </span><span>ùîèbutlast.quotients_length</span><span> </span><span>length_map</span><span> </span><span>size_mset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (take (length ùîé - 1) ùîé) = n - 1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lengthùîè</span><span> </span><span>n'</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>lengthùîé</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"length ùîé = n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_diff_1</span><span> </span><span>ùîé.notempty</span><span> </span><span>butlast_conv_take</span><span> </span><span>length_butlast</span><span> </span><span>length_greater_0_conv</span><span> </span><span>n'</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      
</span><span>      </span><span class="comment">‚Äï ‚ÄπApply the induction hypothesis on @{text ùîé} and @{text ‚Ñåbutlast}‚Ä∫</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Inteqùîésndlast</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ùîésndlast</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"‚ÑåPmIntùîäPn = (‚ÑåPm‚¶ácarrier := ùîé ! (length ùîé - 1 - 1)‚¶à)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>‚ÑåPmIntùîäPn_def</span><span> </span><span>‚ÑåPm_def</span><span> </span><span>ùîé_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>lengthùîé</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc (length ùîé) ‚â§ length ùîä"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n'</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>multisets‚Ñåbutlastùîé</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"mset (map group.iso_class ‚Ñåbutlast.quotients) = mset (map group.iso_class ùîé.quotients)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"1.hyps"</span></span></span><span> </span><span>grp‚ÑåPm.is_group</span><span> </span><span>finHbl</span><span> </span><span>‚Ñåbutlast.is_composition_series</span><span> </span><span>ùîé.is_composition_series</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>lengthùîé</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"m = length ùîé"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>‚Ñåbutlast.quotients_length</span><span> </span><span>ùîé.quotients_length</span><span> </span><span>length_map</span><span> </span><span>size_mset</span><span> </span><span>ltakem</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"length ùîé &gt; 1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length ùîé - 1 &gt; 0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length ùîé - 1 ‚â§ length ùîé"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>m'</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>length‚Ñåbig</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>quotsùîénotemtpy</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ùîé.quotients ‚â† []"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ùîé.quotients_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      
</span><span>      </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>ùîébutlastaddùîäPn</span><span class="delimiter">:</span><span> </span><span>composition_series</span><span> </span><span>ùîäPn</span><span> </span><span class="string"><span class="delete"><span class="delete">"(take (length ùîé - 1) ùîé) @ [ùîä ! (n - 1)]"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>grpùîäPn.composition_series_extend</span><span> </span><span>ùîébutlast.is_composition_series</span><span> </span><span>simpleùîäPnModInt</span><span> </span><span>IntnormùîäPn</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ùîäPn_def</span><span> </span><span>‚ÑåPmIntùîäPn_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>ùîèbutlastadd‚ÑåPm</span><span class="delimiter">:</span><span> </span><span>composition_series</span><span> </span><span>‚ÑåPm</span><span> </span><span class="string"><span class="delete"><span class="delete">"(take (length ùîè - 1) ùîè) @ [‚Ñå ! (m - 1)]"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>grp‚ÑåPm.composition_series_extend</span><span> </span><span>ùîèbutlast.is_composition_series</span><span> </span><span>simple‚ÑåPmModInt</span><span> </span><span>Intnorm‚ÑåPm</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>‚ÑåPm_def</span><span> </span><span>‚ÑåPmIntùîäPn_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      
</span><span>      </span><span class="comment">‚Äï ‚ÄπProve equality of those composition series.‚Ä∫</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mset (map group.iso_class compùîä.quotients)
                    = mset (map group.iso_class ((butlast compùîä.quotients) @ [last compùîä.quotients]))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>quotsùîänotempty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = mset (map group.iso_class (ùîäbutlast.quotients @ [G Mod ùîä ! (n - 1)]))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compùîä.quotients_butlast</span><span> </span><span>compùîä.last_quotient</span><span> </span><span>length</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>n_def</span><span> </span><span>ùîäPn_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = mset (map group.iso_class ((butlast ùîè.quotients) @ [last ùîè.quotients])) + {# group.iso_class (G Mod ùîä ! (n - 1)) #}"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>multisetsùîäbutlastùîè</span><span> </span><span>quotsùîènotemtpy</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = mset (map group.iso_class (ùîèbutlast.quotients @ [ùîäPn Mod ‚Ñå ! (m - 1) ‚à© ùîä ! (n - 1)])) + {# group.iso_class (G Mod ùîä ! (n - 1)) #}"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ùîè.quotients_butlast</span><span> </span><span>ùîè.last_quotient</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπlength ùîè &gt; 1‚Ä∫</span></span></span><span> </span><span>ùîèsndlast</span><span> </span><span>Inteqùîèsndlast</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>n_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = mset (map group.iso_class ùîébutlast.quotients) + {# group.iso_class (ùîäPn Mod ‚Ñå ! (m - 1) ‚à© ùîä ! (n - 1)) #} + {# group.iso_class (G Mod ùîä ! (n - 1)) #}"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>multisetsùîéùîèbutlast</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = mset (map group.iso_class ùîébutlast.quotients) + {# group.iso_class (G Mod ‚Ñå ! (m - 1)) #} + {# group.iso_class (‚ÑåPm Mod ‚Ñå ! (m - 1) ‚à© ùîä ! (n - 1)) #}"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>œÜ</span><span> </span><span>œà2</span><span> </span><span>iso_classes_iff</span><span> </span><span>grpùîäPnMod‚ÑåPmintùîäPn.is_group</span><span> </span><span>grpGMod‚ÑåPm.is_group</span><span> </span><span>grpGModùîäPn.is_group</span><span> </span><span>grp‚ÑåPmMod‚ÑåPmintùîäPn.is_group</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = mset (map group.iso_class ùîébutlast.quotients) + {# group.iso_class (‚ÑåPm Mod ‚Ñå ! (m - 1) ‚à© ùîä ! (n - 1)) #} + {# group.iso_class (G Mod ‚Ñå ! (m - 1)) #}"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = mset (map group.iso_class ((butlast ùîé.quotients) @ [last ùîé.quotients])) + {# group.iso_class (G Mod ‚Ñå ! (m - 1)) #}"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ùîé.quotients_butlast</span><span> </span><span>ùîé.last_quotient</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπlength ùîé &gt; 1‚Ä∫</span></span></span><span> </span><span>ùîésndlast</span><span> </span><span>Inteqùîésndlast</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>m_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = mset (map group.iso_class ‚Ñåbutlast.quotients) + {# group.iso_class (G Mod ‚Ñå ! (m - 1)) #}"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>multisets‚Ñåbutlastùîé</span><span> </span><span>quotsùîénotemtpy</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = mset (map group.iso_class ((butlast comp‚Ñå.quotients) @ [last comp‚Ñå.quotients]))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp‚Ñå.quotients_butlast</span><span> </span><span>comp‚Ñå.last_quotient</span><span> </span><span>length‚Ñåbig</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>m_def</span><span> </span><span>‚ÑåPm_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = mset (map group.iso_class comp‚Ñå.quotients)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>quots‚Ñånotempty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπAs a corollary, we see that the composition series of a fixed group all have the same length.‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>jordan_hoelder</span><span class="delimiter">)</span><span> </span><span>jordan_hoelder_size</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length ùîä = length ‚Ñå"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length ùîä = length compùîä.quotients + 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>compùîä.quotients_length</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = length (map group.iso_class compùîä.quotients) + 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>length_map</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = size (mset (map group.iso_class compùîä.quotients)) + 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>size_mset</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = size (mset (map group.iso_class comp‚Ñå.quotients)) + 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>jordan_hoelder_multisets</span><span> </span><span>is_group</span><span> </span><span>finite</span><span> </span><span>is_composition_series</span><span> </span><span>comp‚Ñå.is_composition_series</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = length (map group.iso_class comp‚Ñå.quotients) + 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>size_mset</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = length comp‚Ñå.quotients + 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>length_map</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚Ä¶ = length ‚Ñå"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>comp‚Ñå.quotients_length</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div>