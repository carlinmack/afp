<div id="Tagged_Prod_Sum">
<div class="head">
<h1>Theory Tagged_Prod_Sum</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">chapter</span></span> <span class="quoted"><span class="plain_text">‹Tagged Sum-of-Products Representation›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
This theory sets up a version of the sum-of-products representation that includes constructor and 
selector names. For an example of a type class that uses this representation see Derive\_Show.
›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Tagged_Prod_Sum
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1"><span class="command">datatype</span></span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> prod <span class="main">=</span> Prod <span class="quoted"><span class="quoted">"string option"</span></span> <span class="quoted"><span class="quoted">"string option"</span></span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="tfree"><span class="quoted"><span class="tfree">'b</span></span></span>
<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1"><span class="command">datatype</span></span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> sum <span class="main">=</span> Inl <span class="quoted"><span class="quoted">"string option"</span></span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="main">|</span> Inr <span class="quoted"><span class="quoted">"string option"</span></span> <span class="tfree"><span class="quoted"><span class="tfree">'b</span></span></span>

<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="entity">fst</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">fst</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="keyword1">of</span> <span class="main">(</span>Prod <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="bound">a</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">⇒</span> <span class="bound">a</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="entity">snd</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">snd</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="keyword1">of</span> <span class="main">(</span>Prod <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="bound">b</span><span class="main">)</span> <span class="main">⇒</span> <span class="bound">b</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="entity">sel_name_fst</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">sel_name_fst</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="keyword1">of</span> <span class="main">(</span>Prod <span class="bound">s</span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">⇒</span> <span class="bound">s</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="entity">sel_name_snd</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">sel_name_snd</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="keyword1">of</span> <span class="main">(</span>Prod <span class="main"><span class="bound">_</span></span> <span class="bound">s</span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">⇒</span> <span class="bound">s</span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="entity">constr_name</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">constr_name</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">of</span> <span class="main">(</span>Inl <span class="bound">s</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">⇒</span> <span class="bound">s</span> <span class="main">|</span> <span class="main">(</span>Inr <span class="bound">s</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">⇒</span> <span class="bound">s</span><span class="main">)</span>"</span></span> 

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Tagged_Prod_Sum-measure_tagged_fst"><span class="command">lemma</span></span> measure_tagged_fst<span class="main">[</span><span class="operator">measure_function</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"is_measure <span class="free">f</span> <span class="main">⟹</span> is_measure <span class="main">(</span><span class="main">λ</span> <span class="bound">p</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span>Tagged_Prod_Sum.fst <span class="bound">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> is_measure_trivial<span class="main">)</span>

<span class="keyword1" id="Tagged_Prod_Sum-measure_tagged_snd"><span class="command">lemma</span></span> measure_tagged_snd<span class="main">[</span><span class="operator">measure_function</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"is_measure <span class="free">f</span> <span class="main">⟹</span> is_measure <span class="main">(</span><span class="main">λ</span> <span class="bound">p</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span>Tagged_Prod_Sum.snd <span class="bound">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> is_measure_trivial<span class="main">)</span>

<span class="keyword1" id="Tagged_Prod_Sum-size_tagged_prod_simp"><span class="command">lemma</span></span> size_tagged_prod_simp<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"Tagged_Prod_Sum.prod.size_prod <span class="free">f</span> <span class="free">g</span> <span class="free">p</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span>Tagged_Prod_Sum.fst <span class="free">p</span><span class="main">)</span> <span class="main">+</span> <span class="free">g</span> <span class="main">(</span>Tagged_Prod_Sum.snd <span class="free">p</span><span class="main">)</span> <span class="main">+</span> Suc <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Tagged_Prod_Sum.fst_def Tagged_Prod_Sum.snd_def<span class="main">)</span> 

<span class="keyword1" id="Tagged_Prod_Sum-size_tagged_sum_simp"><span class="command">lemma</span></span> size_tagged_sum_simp<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"Tagged_Prod_Sum.sum.size_sum <span class="free">f</span> <span class="free">g</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">x</span> <span class="keyword1">of</span> Tagged_Prod_Sum.Inl <span class="main"><span class="bound">_</span></span> <span class="bound">a</span> <span class="main">⇒</span> <span class="free">f</span> <span class="bound">a</span> <span class="main">+</span> Suc <span class="main">0</span> <span class="main">|</span> Tagged_Prod_Sum.Inr <span class="main"><span class="bound">_</span></span> <span class="bound">b</span> <span class="main">⇒</span> <span class="free">g</span> <span class="bound">b</span> <span class="main">+</span> Suc <span class="main">0</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Tagged_Prod_Sum-size_tagged_prod_measure"><span class="command">lemma</span></span> size_tagged_prod_measure<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"is_measure <span class="free">f</span> <span class="main">⟹</span> is_measure <span class="free">g</span> <span class="main">⟹</span> is_measure <span class="main">(</span>Tagged_Prod_Sum.prod.size_prod <span class="free">f</span> <span class="free">g</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> is_measure_trivial<span class="main">)</span>

<span class="keyword1" id="Tagged_Prod_Sum-size_tagged_sum_measure"><span class="command">lemma</span></span> size_tagged_sum_measure<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"is_measure <span class="free">f</span> <span class="main">⟹</span> is_measure <span class="free">g</span> <span class="main">⟹</span> is_measure <span class="main">(</span>Tagged_Prod_Sum.sum.size_sum <span class="free">f</span> <span class="free">g</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> is_measure_trivial<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="Derive">
<div class="head">
<h1>Theory Derive</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">chapter</span></span> <span class="quoted"><span class="plain_text">‹Derive›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
This theory includes the Isabelle/ML code needed for the derivation and exports the two keywords
\texttt{derive\_generic} and \texttt{derive\_generic\_setup}.
›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Derive
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a> <a href="Tagged_Prod_Sum.html">Tagged_Prod_Sum</a>
  <span class="keyword2"><span class="keyword">keywords</span></span> <span class="quoted">"derive_generic"</span> <span class="quoted">"derive_generic_setup"</span> <span class="main">::</span> thy_goal
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="entity">iso</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">iso</span> <span class="free"><span class="bound"><span class="entity">from</span></span></span> <span class="free"><span class="bound"><span class="entity">to</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="main">∀</span> <span class="bound">a</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">to</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">from</span></span></span> <span class="bound">a</span><span class="main">)</span> <span class="main">=</span> <span class="bound">a</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">b</span> <span class="main">.</span> <span class="free"><span class="bound"><span class="entity">from</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">to</span></span></span> <span class="bound">b</span><span class="main">)</span> <span class="main">=</span> <span class="bound">b</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Derive-iso_intro"><span class="command">lemma</span></span> iso_intro<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">a</span><span class="main">.</span> <span class="free">to</span> <span class="main">(</span><span class="free">from</span> <span class="bound">a</span><span class="main">)</span> <span class="main">=</span> <span class="bound">a</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">⋀</span><span class="bound">b</span><span class="main">.</span> <span class="free">from</span> <span class="main">(</span><span class="free">to</span> <span class="bound">b</span><span class="main">)</span> <span class="main">=</span> <span class="bound">b</span><span class="main">)</span> <span class="main">⟹</span> iso <span class="free">from</span> <span class="free">to</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> iso_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹derive_util.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹derive_laws.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹derive_setup.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹derive.ML›</span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="files/derive_util.ML">
<div class="head">
<h1>File ‹derive_util.ML›</h1>
</div>
<pre class="source"><span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">DERIVE_UTIL</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">ctr_info</span> <span class="main">=</span> <span class="main">(</span>string * <span class="main">(</span>string * typ list<span class="main">)</span> list<span class="main">)</span> list

  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">rep_type_info</span> <span class="main">=</span>
    <span class="main">{</span>repname <span class="main">:</span> string<span class="main">,</span>
     rep_type <span class="main">:</span> typ<span class="main">,</span>
     tFrees_mapping <span class="main">:</span> <span class="main">(</span>typ * typ<span class="main">)</span> list<span class="main">,</span>
     from_info <span class="main">:</span> <span class="entity">Function_Common.info</span> option<span class="main">,</span>
     to_info <span class="main">:</span> <span class="entity">Function_Common.info</span> option<span class="main">}</span>

  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">comb_type_info</span> <span class="main">=</span>
    <span class="main">{</span>combname <span class="main">:</span> string<span class="main">,</span>
     combname_full <span class="main">:</span> string<span class="main">,</span>
     comb_type <span class="main">:</span> typ<span class="main">,</span>
     ctr_type <span class="main">:</span> typ<span class="main">,</span>
     inConst <span class="main">:</span> term<span class="main">,</span>
     inConst_free <span class="main">:</span> term<span class="main">,</span>
     inConst_type <span class="main">:</span> typ<span class="main">,</span>
     rep_type_instantiated <span class="main">:</span> typ<span class="main">}</span>

  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">type_info</span> <span class="main">=</span>
     <span class="main">{</span>tname <span class="main">:</span> string<span class="main">,</span>
     uses_metadata <span class="main">:</span> bool<span class="main">,</span>
     tfrees <span class="main">:</span> <span class="main">(</span>typ * sort<span class="main">)</span> list<span class="main">,</span>
     mutual_tnames <span class="main">:</span> string list<span class="main">,</span>
     mutual_Ts <span class="main">:</span> typ list<span class="main">,</span>
     mutual_ctrs <span class="main">:</span> <span class="entity">ctr_info</span><span class="main">,</span>
     mutual_sels <span class="main">:</span> <span class="main">(</span>string * string list list<span class="main">)</span> list<span class="main">,</span>
     is_rec <span class="main">:</span> bool<span class="main">,</span>
     is_mutually_rec <span class="main">:</span> bool<span class="main">,</span>
     rep_info <span class="main">:</span> <span class="entity">rep_type_info</span><span class="main">,</span>
     comb_info <span class="main">:</span> <span class="entity">comb_type_info</span> option<span class="main">,</span>
     iso_thm <span class="main">:</span> thm option<span class="main">}</span>

  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">class_info</span> <span class="main">=</span>
    <span class="main">{</span>classname <span class="main">:</span> string<span class="main">,</span>
     class <span class="main">:</span> sort<span class="main">,</span>
     params <span class="main">:</span> <span class="main">(</span>class * <span class="main">(</span>string * typ<span class="main">)</span><span class="main">)</span> list option<span class="main">,</span>
     class_law <span class="main">:</span> thm option<span class="main">,</span>
     class_law_const <span class="main">:</span> term option<span class="main">,</span>
     ops <span class="main">:</span> term list option<span class="main">,</span>
     transfer_law <span class="main">:</span> <span class="main">(</span>string * thm list<span class="main">)</span> list option<span class="main">,</span>
     axioms <span class="main">:</span> thm list option<span class="main">,</span>
     axioms_def <span class="main">:</span> thm option<span class="main">,</span>
     class_def <span class="main">:</span> thm option<span class="main">,</span>
     equivalence_thm <span class="main">:</span> thm option<span class="main">}</span>

  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">instance_info</span> <span class="main">=</span>
    <span class="main">{</span>defs <span class="main">:</span> thm list<span class="main">}</span>

  <span class="keyword1"><span class="keyword">val</span></span> is_typeT <span class="main">:</span> typ <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> insert_application <span class="main">:</span> term <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> add_tvars <span class="main">:</span> string <span class="main">-&gt;</span> string list <span class="main">-&gt;</span> string
  <span class="keyword1"><span class="keyword">val</span></span> replace_tfree <span class="main">:</span> string list <span class="main">-&gt;</span> string <span class="main">-&gt;</span> string <span class="main">-&gt;</span> string
  <span class="keyword1"><span class="keyword">val</span></span> ctrs_arguments <span class="main">:</span> <span class="entity">ctr_info</span> <span class="main">-&gt;</span> typ list
  <span class="keyword1"><span class="keyword">val</span></span> collect_tfrees <span class="main">:</span> <span class="entity">ctr_info</span> <span class="main">-&gt;</span> <span class="main">(</span>typ * sort<span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> collect_tfree_names <span class="main">:</span> <span class="entity">ctr_info</span> <span class="main">-&gt;</span> string list
  <span class="keyword1"><span class="keyword">val</span></span> combs_to_list <span class="main">:</span> term <span class="main">-&gt;</span> term list
  <span class="keyword1"><span class="keyword">val</span></span> get_tvar <span class="main">:</span> typ list <span class="main">-&gt;</span> typ
  <span class="keyword1"><span class="keyword">val</span></span> not_instantiated <span class="main">:</span> theory <span class="main">-&gt;</span> string <span class="main">-&gt;</span> class <span class="main">-&gt;</span> bool
  <span class="comment1">(* version of add_fun that doesn't throw away info *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> add_fun' <span class="main">:</span> <span class="main">(</span>binding * typ option * mixfix<span class="main">)</span> list <span class="main">-&gt;</span>
    <span class="entity">Specification.multi_specs</span> <span class="main">-&gt;</span> <span class="entity">Function_Common.function_config</span> <span class="main">-&gt;</span>
    local_theory <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">Function_Common.info</span> * <span class="entity">Proof.context</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> add_conversion_info <span class="main">:</span> <span class="entity">Function_Common.info</span> <span class="main">-&gt;</span> <span class="entity">Function_Common.info</span> <span class="main">-&gt;</span> <span class="entity">type_info</span> <span class="main">-&gt;</span> <span class="entity">type_info</span>
  <span class="keyword1"><span class="keyword">val</span></span> add_iso_info <span class="main">:</span> thm option <span class="main">-&gt;</span> <span class="entity">type_info</span> <span class="main">-&gt;</span> <span class="entity">type_info</span>
  <span class="keyword1"><span class="keyword">val</span></span> has_class_law <span class="main">:</span> string <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> zero_tvarsT <span class="main">:</span> typ <span class="main">-&gt;</span> typ
  <span class="keyword1"><span class="keyword">val</span></span> zero_tvars <span class="main">:</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> get_superclasses <span class="main">:</span> sort <span class="main">-&gt;</span> string <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> string list
  <span class="keyword1"><span class="keyword">val</span></span> tagged_function_termination_tac <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">Function.info</span> * local_theory
  <span class="keyword1"><span class="keyword">val</span></span> get_mapping_function <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> typ <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> is_polymorphic <span class="main">:</span> typ <span class="main">-&gt;</span> bool

  <span class="comment1">(* determines all mutual recursive types of a given BNF-least-fixpoint-type *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> mutual_recursive_types <span class="main">:</span> string <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string list * typ list
  <span class="keyword1"><span class="keyword">val</span></span> freeify_tvars <span class="main">:</span> typ <span class="main">-&gt;</span> typ
  <span class="comment1">(* delivers a full type from a type name by instantiating the type-variables of that
   type with different variables of a given sort, also returns the chosen variables
   as second component *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> typ_and_vs_of_typname <span class="main">:</span> theory <span class="main">-&gt;</span> string <span class="main">-&gt;</span> sort <span class="main">-&gt;</span> typ * <span class="main">(</span>string * sort<span class="main">)</span> list

  <span class="keyword1"><span class="keyword">val</span></span> constr_terms <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string <span class="main">-&gt;</span> term list
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Derive_Util</span> <span class="main">:</span> <span class="entity">DERIVE_UTIL</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">ctr_info</span> <span class="main">=</span> <span class="main">(</span>string * <span class="main">(</span>string * typ list<span class="main">)</span> list<span class="main">)</span> list

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">rep_type_info</span> <span class="main">=</span>
  <span class="main">{</span>repname <span class="main">:</span> string<span class="main">,</span>
   rep_type <span class="main">:</span> typ<span class="main">,</span>
   tFrees_mapping <span class="main">:</span> <span class="main">(</span>typ * typ<span class="main">)</span> list<span class="main">,</span>
   from_info <span class="main">:</span> <span class="entity">Function_Common.info</span> option<span class="main">,</span>
   to_info <span class="main">:</span> <span class="entity">Function_Common.info</span> option<span class="main">}</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">comb_type_info</span> <span class="main">=</span>
  <span class="main">{</span>combname <span class="main">:</span> string<span class="main">,</span>
   combname_full <span class="main">:</span> string<span class="main">,</span>
   comb_type <span class="main">:</span> typ<span class="main">,</span>
   ctr_type <span class="main">:</span> typ<span class="main">,</span>
   inConst <span class="main">:</span> term<span class="main">,</span>
   inConst_free <span class="main">:</span> term<span class="main">,</span>
   inConst_type <span class="main">:</span> typ<span class="main">,</span>
   rep_type_instantiated <span class="main">:</span> typ<span class="main">}</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">type_info</span> <span class="main">=</span>
  <span class="main">{</span>tname <span class="main">:</span> string<span class="main">,</span>
   uses_metadata <span class="main">:</span> bool<span class="main">,</span>
   tfrees <span class="main">:</span> <span class="main">(</span>typ * sort<span class="main">)</span> list<span class="main">,</span>
   mutual_tnames <span class="main">:</span> string list<span class="main">,</span>
   mutual_Ts <span class="main">:</span> typ list<span class="main">,</span>
   mutual_ctrs <span class="main">:</span> <span class="entity">ctr_info</span><span class="main">,</span>
   mutual_sels <span class="main">:</span> <span class="main">(</span>string * string list list<span class="main">)</span> list<span class="main">,</span>
   is_rec <span class="main">:</span> bool<span class="main">,</span>
   is_mutually_rec <span class="main">:</span> bool<span class="main">,</span>
   rep_info <span class="main">:</span> <span class="entity">rep_type_info</span><span class="main">,</span>
   comb_info <span class="main">:</span> <span class="entity">comb_type_info</span> option<span class="main">,</span>
   iso_thm <span class="main">:</span> thm option<span class="main">}</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">class_info</span> <span class="main">=</span>
    <span class="main">{</span>classname <span class="main">:</span> string<span class="main">,</span>
     class <span class="main">:</span> sort<span class="main">,</span>
     params <span class="main">:</span> <span class="main">(</span>class * <span class="main">(</span>string * typ<span class="main">)</span><span class="main">)</span> list option<span class="main">,</span>
     class_law <span class="main">:</span> thm option<span class="main">,</span>
     class_law_const <span class="main">:</span> term option<span class="main">,</span>
     ops <span class="main">:</span> term list option<span class="main">,</span>
     transfer_law <span class="main">:</span> <span class="main">(</span>string * thm list<span class="main">)</span> list option<span class="main">,</span>
     axioms <span class="main">:</span> thm list option<span class="main">,</span>
     axioms_def <span class="main">:</span> thm option<span class="main">,</span>
     class_def <span class="main">:</span> thm option<span class="main">,</span>
     equivalence_thm <span class="main">:</span> thm option<span class="main">}</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">instance_info</span> <span class="main">=</span>
    <span class="main">{</span>defs <span class="main">:</span> thm list<span class="main">}</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">is_typeT</span> <span class="main">=</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span>Type <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> true <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">insert_application</span> <span class="main">(</span><span class="entity">t1</span> $ <span class="entity">t2</span><span class="main">)</span> <span class="entity">t3</span> <span class="main">=</span> <span class="entity">insert_application</span> <span class="entity">t1</span> <span class="main">(</span><span class="entity">insert_application</span> <span class="entity">t2</span> <span class="entity">t3</span><span class="main">)</span> <span class="main">|</span>
    <span class="entity">insert_application</span> <span class="entity">t</span>         <span class="entity">t3</span> <span class="main">=</span> <span class="entity">t</span> $ <span class="entity">t3</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_tvars</span> <span class="entity">tname</span> <span class="entity">tvar_names</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">zip_tvars</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> <span class="inner_quoted">""</span> <span class="main">|</span>
            <span class="entity">zip_tvars</span> <span class="main">[</span><span class="entity">x</span><span class="main">]</span> <span class="main">=</span> <span class="entity">x</span> <span class="main">|</span>
            <span class="entity">zip_tvars</span> <span class="main">(</span><span class="entity">x</span>::<span class="entity">xs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">x</span> ^ <span class="inner_quoted">", "</span> ^ <span class="main">(</span><span class="entity">zip_tvars</span> <span class="entity">xs</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">tvar_names</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="entity">tname</span> <span class="main">|</span> <span class="entity">xs</span> <span class="main">=&gt;</span> <span class="inner_quoted">"("</span> ^ <span class="entity">zip_tvars</span> <span class="entity">xs</span> ^ <span class="inner_quoted">") "</span> ^ <span class="entity">tname</span>
      <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* replace tfree by replacement_name if it occurs in tfree_names *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">replace_tfree</span> <span class="entity">tfree_names</span> <span class="entity">replacement_name</span> <span class="entity">tfree</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> List.find <span class="main">(</span>curry <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">tfree</span><span class="main">)</span> <span class="entity">tfree_names</span>
        <span class="keyword2"><span class="keyword">of</span></span> SOME <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">replacement_name</span>
         <span class="main">|</span> NONE <span class="main">=&gt;</span> <span class="entity">tfree</span><span class="main">)</span>

<span class="comment1">(* Operations on constructor information *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctrs_arguments</span> <span class="main">=</span> <span class="main">(</span>map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">l</span> <span class="main">=&gt;</span> map snd <span class="main">(</span>snd <span class="entity">l</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> #&gt; flat #&gt; flat
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">collect_tfrees</span> <span class="entity">ctrs</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span><span class="entity">s</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span>TFree <span class="main">(</span><span class="entity">t</span><span class="main">,</span><span class="entity">s</span><span class="main">)</span><span class="main">,</span><span class="entity">s</span><span class="main">)</span><span class="main">)</span>
                              <span class="main">(</span>fold Term.add_tfreesT <span class="main">(</span><span class="entity">ctrs_arguments</span> <span class="entity">ctrs</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">collect_tfree_names</span> <span class="entity">ctrs</span> <span class="main">=</span> fold Term.add_tfree_namesT <span class="main">(</span><span class="entity">ctrs_arguments</span> <span class="entity">ctrs</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">not_instantiated</span> <span class="entity">thy</span> <span class="entity">tname</span> <span class="entity">class</span> <span class="main">=</span>
  null <span class="main">(</span>Thm.thynames_of_arity <span class="entity">thy</span> <span class="main">(</span><span class="entity">tname</span><span class="main">,</span> <span class="entity">class</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">combs_to_list</span> <span class="entity">t</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span>
      <span class="entity">combs_to_list_aux</span> <span class="main">(</span><span class="entity">t1</span> $ <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">t2</span> :: <span class="main">(</span><span class="entity">combs_to_list_aux</span> <span class="entity">t1</span><span class="main">)</span> <span class="main">|</span>
      <span class="entity">combs_to_list_aux</span> <span class="entity">t</span> <span class="main">=</span> <span class="main">[</span><span class="entity">t</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    rev <span class="main">(</span><span class="entity">combs_to_list_aux</span> <span class="entity">t</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_tvar</span> <span class="entity">ts</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ts</span> <span class="keyword2"><span class="keyword">of</span></span>
    <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> TFree <span class="main">(</span><span class="inner_quoted">"'a"</span><span class="main">,</span> <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">sort</span><span class="hidden">&gt;</span></span><span class="quoted">‹type›</span></span><span class="main">)</span> <span class="main">|</span>
    <span class="main">(</span><span class="entity">t</span>::<span class="entity">ts</span><span class="main">)</span> <span class="main">=&gt;</span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="entity">T</span> <span class="keyword1"><span class="keyword">as</span></span> TFree <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">T</span> <span class="main">|</span>
                Type <span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="entity">xs</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">get_tvar</span> <span class="main">(</span><span class="entity">xs</span>@<span class="entity">ts</span><span class="main">)</span> <span class="main">|</span>
                <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">get_tvar</span> <span class="entity">ts</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_fun'</span> <span class="entity">binding</span> <span class="entity">specs</span> <span class="entity">config</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pat_completeness_auto</span> <span class="entity">ctxt</span> <span class="main">=</span>
      <span class="entity">Pat_Completeness.pat_completeness_tac</span> <span class="entity">ctxt</span> <span class="inner_numeral">1</span>
      THEN <span class="entity">auto_tac</span> <span class="entity">ctxt</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove_termination</span> <span class="entity">lthy</span> <span class="main">=</span>
      <span class="entity">Function.prove_termination</span> NONE <span class="main">(</span><span class="entity">Function_Common.termination_prover_tac</span> false <span class="entity">lthy</span><span class="main">)</span> <span class="entity">lthy</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">lthy</span> |&gt;
    <span class="main">(</span><span class="entity">Function.add_function</span> <span class="entity">binding</span> <span class="entity">specs</span> <span class="entity">config</span><span class="main">)</span> <span class="entity">pat_completeness_auto</span> |&gt; snd
    |&gt; <span class="entity">prove_termination</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_conversion_info</span> <span class="entity">from_info</span> <span class="entity">to_info</span> <span class="main">(</span><span class="entity">ty_info</span> <span class="main">:</span> <span class="entity">type_info</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">tname</span><span class="main">,</span> <span class="entity">uses_metadata</span><span class="main">,</span> <span class="entity">tfrees</span><span class="main">,</span>  <span class="entity">mutual_tnames</span><span class="main">,</span> <span class="entity">mutual_Ts</span><span class="main">,</span> <span class="entity">mutual_ctrs</span><span class="main">,</span> <span class="entity">mutual_sels</span><span class="main">,</span> <span class="entity">is_rec</span><span class="main">,</span> <span class="entity">is_mutually_rec</span><span class="main">,</span> <span class="entity">rep_info</span><span class="main">,</span> <span class="entity">comb_info</span><span class="main">,</span> <span class="entity">iso_thm</span><span class="main">}</span> <span class="main">=</span> <span class="entity">ty_info</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">repname</span><span class="main">,</span> <span class="entity">rep_type</span><span class="main">,</span> <span class="entity">tFrees_mapping</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">rep_info</span>
  <span class="keyword2"><span class="keyword">in</span></span>
   <span class="main">{</span>tname <span class="main">=</span> <span class="entity">tname</span><span class="main">,</span> uses_metadata <span class="main">=</span> <span class="entity">uses_metadata</span><span class="main">,</span> tfrees <span class="main">=</span> <span class="entity">tfrees</span><span class="main">,</span>  mutual_tnames <span class="main">=</span> <span class="entity">mutual_tnames</span><span class="main">,</span> mutual_Ts <span class="main">=</span> <span class="entity">mutual_Ts</span><span class="main">,</span>
    mutual_ctrs <span class="main">=</span> <span class="entity">mutual_ctrs</span><span class="main">,</span> mutual_sels <span class="main">=</span> <span class="entity">mutual_sels</span><span class="main">,</span> is_rec <span class="main">=</span> <span class="entity">is_rec</span><span class="main">,</span> is_mutually_rec <span class="main">=</span> <span class="entity">is_mutually_rec</span><span class="main">,</span>
    rep_info <span class="main">=</span> <span class="main">{</span>repname <span class="main">=</span> <span class="entity">repname</span><span class="main">,</span> rep_type <span class="main">=</span> <span class="entity">rep_type</span><span class="main">,</span> tFrees_mapping <span class="main">=</span> <span class="entity">tFrees_mapping</span><span class="main">,</span> from_info <span class="main">=</span> SOME <span class="entity">from_info</span><span class="main">,</span> to_info <span class="main">=</span>  SOME <span class="entity">to_info</span><span class="main">}</span>
    <span class="main">,</span> comb_info <span class="main">=</span> <span class="entity">comb_info</span><span class="main">,</span> iso_thm <span class="main">=</span> <span class="entity">iso_thm</span><span class="main">}</span> <span class="main">:</span> <span class="entity">type_info</span>
  <span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_iso_info</span> <span class="entity">iso_thm</span> <span class="main">(</span><span class="entity">ty_info</span> <span class="main">:</span> <span class="entity">type_info</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">tname</span><span class="main">,</span> <span class="entity">uses_metadata</span><span class="main">,</span> <span class="entity">tfrees</span><span class="main">,</span>  <span class="entity">mutual_tnames</span><span class="main">,</span> <span class="entity">mutual_Ts</span><span class="main">,</span> <span class="entity">mutual_ctrs</span><span class="main">,</span> <span class="entity">mutual_sels</span><span class="main">,</span> <span class="entity">is_rec</span><span class="main">,</span> <span class="entity">is_mutually_rec</span><span class="main">,</span> <span class="entity">rep_info</span><span class="main">,</span> <span class="entity">comb_info</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">ty_info</span>
  <span class="keyword2"><span class="keyword">in</span></span>
   <span class="main">{</span>tname <span class="main">=</span> <span class="entity">tname</span><span class="main">,</span> uses_metadata <span class="main">=</span> <span class="entity">uses_metadata</span><span class="main">,</span> tfrees <span class="main">=</span> <span class="entity">tfrees</span><span class="main">,</span>  mutual_tnames <span class="main">=</span> <span class="entity">mutual_tnames</span><span class="main">,</span> mutual_Ts <span class="main">=</span> <span class="entity">mutual_Ts</span><span class="main">,</span>
    mutual_ctrs <span class="main">=</span> <span class="entity">mutual_ctrs</span><span class="main">,</span> mutual_sels <span class="main">=</span> <span class="entity">mutual_sels</span><span class="main">,</span> is_rec <span class="main">=</span> <span class="entity">is_rec</span><span class="main">,</span> is_mutually_rec <span class="main">=</span> <span class="entity">is_mutually_rec</span><span class="main">,</span>
    rep_info <span class="main">=</span> <span class="entity">rep_info</span><span class="main">,</span> comb_info <span class="main">=</span> <span class="entity">comb_info</span><span class="main">,</span> iso_thm <span class="main">=</span> <span class="entity">iso_thm</span><span class="main">}</span> <span class="main">:</span> <span class="entity">type_info</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">has_class_law</span> <span class="entity">classname</span> <span class="entity">thy</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">class</span> <span class="main">=</span> Syntax.parse_sort <span class="main">(</span>Proof_Context.init_global <span class="entity">thy</span><span class="main">)</span> <span class="entity">classname</span> |&gt; hd
<span class="keyword2"><span class="keyword">in</span></span>
  is_some <span class="main">(</span><span class="entity">Class.rules</span> <span class="entity">thy</span> <span class="entity">class</span> |&gt; fst<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span>
  <span class="entity">zero_tvarsT</span> <span class="main">(</span>Type <span class="main">(</span><span class="entity">s</span><span class="main">,</span><span class="entity">ts</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Type <span class="main">(</span><span class="entity">s</span><span class="main">,</span> map <span class="entity">zero_tvarsT</span> <span class="entity">ts</span><span class="main">)</span> <span class="main">|</span>
  <span class="entity">zero_tvarsT</span> <span class="main">(</span>TVar <span class="main">(</span><span class="main">(</span><span class="entity">n</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">,</span><span class="entity">s</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> TVar <span class="main">(</span><span class="main">(</span><span class="entity">n</span><span class="main">,</span><span class="inner_numeral">0</span><span class="main">)</span><span class="main">,</span><span class="entity">s</span><span class="main">)</span> <span class="main">|</span>
  <span class="entity">zero_tvarsT</span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">T</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">zero_tvars</span> <span class="entity">t</span> <span class="main">=</span> map_types <span class="entity">zero_tvarsT</span> <span class="entity">t</span>

<span class="keyword1"><span class="keyword">fun</span></span>
  <span class="entity">unique</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="main">]</span> <span class="main">|</span>
  <span class="entity">unique</span> <span class="main">(</span><span class="entity">x</span>::<span class="entity">xs</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">remove</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> <span class="main">[</span><span class="main">]</span>
            <span class="main">|</span> <span class="entity">remove</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span><span class="entity">y</span>::<span class="entity">ys</span><span class="main">)</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">x</span> <span class="main">=</span> <span class="entity">y</span>
                                      <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">remove</span><span class="main">(</span><span class="entity">x</span><span class="main">,</span><span class="entity">ys</span><span class="main">)</span>
                                      <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">y</span>::<span class="entity">remove</span><span class="main">(</span><span class="entity">x</span><span class="main">,</span><span class="entity">ys</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="entity">x</span>::<span class="entity">unique</span><span class="main">(</span><span class="entity">remove</span><span class="main">(</span><span class="entity">x</span><span class="main">,</span><span class="entity">xs</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_superclasses</span> <span class="entity">class</span> <span class="entity">classname</span> <span class="entity">thy</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_classes</span> <span class="main">=</span> <span class="main">(</span><span class="entity">Class.these_params</span> <span class="entity">thy</span> <span class="entity">class</span><span class="main">)</span> |&gt; map <span class="main">(</span>snd #&gt; fst<span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">superclasses</span> <span class="main">=</span> filter <span class="main">(</span>curry <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">classname</span> #&gt; not<span class="main">)</span> <span class="entity">all_classes</span>
<span class="keyword2"><span class="keyword">in</span></span>
  <span class="entity">unique</span> <span class="entity">superclasses</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tagged_function_termination_tac</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prod_simp_thm</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> size_tagged_prod_simp<span class="antiquote">}</span></span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">measure_tac</span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="entity">Function_Relation.relation_infer_tac</span> <span class="entity">ctxt</span>
      <span class="main">(</span><span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span>‹measure›</span><span class="main">,</span>dummyT<span class="main">)</span><span class="main">)</span> $ <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span>‹size›</span><span class="main">,</span>dummyT<span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove_termination</span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="entity">auto_tac</span> <span class="main">(</span><span class="entity">Simplifier.add_simp</span> <span class="entity">prod_simp_thm</span> <span class="entity">ctxt</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">Function.prove_termination</span> NONE <span class="main">(</span><span class="main">(</span>HEADGOAL <span class="main">(</span><span class="entity">measure_tac</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span> THEN <span class="main">(</span><span class="entity">prove_termination</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span> <span class="entity">ctxt</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_mapping_function</span> <span class="entity">lthy</span> <span class="entity">T</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">map_thms</span> <span class="main">=</span> <span class="entity">BNF_GFP_Rec_Sugar.map_thms_of_type</span> <span class="entity">lthy</span> <span class="entity">T</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">map_const</span> <span class="main">=</span> Thm.full_prop_of <span class="main">(</span>hd <span class="entity">map_thms</span><span class="main">)</span> |&gt; <span class="entity">HOLogic.dest_Trueprop</span> |&gt; <span class="entity">HOLogic.dest_eq</span> |&gt; fst
                  |&gt; strip_comb |&gt; fst |&gt; dest_Const |&gt; apsnd <span class="main">(</span>K dummyT<span class="main">)</span> |&gt; Const
<span class="keyword2"><span class="keyword">in</span></span>
  <span class="entity">map_const</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_polymorphic</span> <span class="entity">T</span> <span class="main">=</span> not <span class="main">(</span>null <span class="main">(</span>Term.add_tfreesT <span class="entity">T</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>

<span class="comment1">(* Code copied from generator_aux.ML in AFP entry Deriving by Sternagel and Thiemann *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">typ_and_vs_of_typname</span> <span class="entity">thy</span> <span class="entity">typ_name</span> <span class="entity">sort</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ar</span> <span class="main">=</span> Sign.arity_number <span class="entity">thy</span> <span class="entity">typ_name</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sorts</span> <span class="main">=</span> map <span class="main">(</span>K <span class="entity">sort</span><span class="main">)</span> <span class="main">(</span><span class="inner_numeral">1</span> upto <span class="entity">ar</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty_vars</span> <span class="main">=</span> Name.invent_names <span class="main">(</span>Name.make_context <span class="main">[</span><span class="entity">typ_name</span><span class="main">]</span><span class="main">)</span> <span class="inner_quoted">"a"</span> <span class="entity">sorts</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty</span> <span class="main">=</span> Type <span class="main">(</span><span class="entity">typ_name</span><span class="main">,</span>map TFree <span class="entity">ty_vars</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">ty</span><span class="main">,</span><span class="entity">ty_vars</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">freeify_tvars</span> <span class="main">=</span> map_type_tvar <span class="main">(</span>TFree o apfst fst<span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mutual_recursive_types</span> <span class="entity">tyco</span> <span class="entity">lthy</span> <span class="main">=</span>
      <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">BNF_FP_Def_Sugar.fp_sugar_of</span> <span class="entity">lthy</span> <span class="entity">tyco</span> <span class="keyword2"><span class="keyword">of</span></span>
        SOME <span class="entity">sugar</span> <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">if</span></span> Sign.arity_number <span class="main">(</span>Proof_Context.theory_of <span class="entity">lthy</span><span class="main">)</span> <span class="entity">tyco</span> -
            <span class="entity">BNF_Def.live_of_bnf</span> <span class="main">(</span><span class="main">#</span>fp_bnf <span class="entity">sugar</span><span class="main">)</span> &gt; <span class="inner_numeral">0</span>
          <span class="keyword2"><span class="keyword">then</span></span> error <span class="inner_quoted">"only datatypes without dead type parameters are supported"</span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="main">#</span>fp <span class="entity">sugar</span> <span class="main">=</span> <span class="entity">BNF_Util.Least_FP</span> <span class="keyword2"><span class="keyword">then</span></span>
            <span class="entity">sugar</span> |&gt; <span class="main">#</span>fp_res |&gt; <span class="main">#</span>Ts |&gt; `<span class="main">(</span>map <span class="main">(</span>fst o dest_Type<span class="main">)</span><span class="main">)</span>
            ||&gt; map <span class="entity">freeify_tvars</span>
          <span class="keyword2"><span class="keyword">else</span></span> error <span class="inner_quoted">"only least fixpoints are supported"</span>
      <span class="main">|</span> NONE <span class="main">=&gt;</span> error <span class="main">(</span><span class="inner_quoted">"type "</span> ^ quote <span class="entity">tyco</span> ^ <span class="inner_quoted">" does not appear to be a new style datatype"</span><span class="main">)</span><span class="main">)</span>

<span class="comment1">(* Code copied from bnf_access.ML in AFP entry Deriving by Sternagel and Thiemann *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">constr_terms</span> <span class="entity">lthy</span> <span class="main">=</span> <span class="entity">BNF_FP_Def_Sugar.fp_sugar_of</span> <span class="entity">lthy</span>
  #&gt; the #&gt; <span class="main">#</span>fp_ctr_sugar #&gt; <span class="main">#</span>ctr_sugar #&gt; <span class="main">#</span>ctrs

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Type_Data</span> <span class="main">=</span> Theory_Data
<span class="main">(</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">Derive_Util.type_info</span> Symreltab.table<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">empty</span> <span class="main">=</span> Symreltab.empty<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">extend</span> <span class="main">=</span> I<span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">merge</span> <span class="entity">data</span> <span class="main">:</span> <span class="entity">T</span> <span class="main">=</span> Symreltab.merge <span class="main">(</span>K true<span class="main">)</span> <span class="entity">data</span><span class="main">;</span>
<span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Class_Data</span> <span class="main">=</span> Theory_Data
<span class="main">(</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">Derive_Util.class_info</span> Symtab.table<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">empty</span> <span class="main">=</span> Symtab.empty<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">extend</span> <span class="main">=</span> I<span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">merge</span> <span class="entity">data</span> <span class="main">:</span> <span class="entity">T</span> <span class="main">=</span> Symtab.merge <span class="main">(</span>K true<span class="main">)</span> <span class="entity">data</span><span class="main">;</span>
<span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Instance_Data</span> <span class="main">=</span> Theory_Data
<span class="main">(</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">Derive_Util.instance_info</span> Symreltab.table<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">empty</span> <span class="main">=</span> Symreltab.empty<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">extend</span> <span class="main">=</span> I<span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">merge</span> <span class="entity">data</span> <span class="main">:</span> <span class="entity">T</span> <span class="main">=</span> Symreltab.merge <span class="main">(</span>K true<span class="main">)</span> <span class="entity">data</span><span class="main">;</span>
<span class="main">)</span><span class="main">;</span></pre>
</div><div id="files/derive_laws.ML">
<div class="head">
<h1>File ‹derive_laws.ML›</h1>
</div>
<pre class="source"><span class="keyword3"><span class="keyword">open</span></span> Derive_Util

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">DERIVE_LAWS</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="comment1">(* prove the iso theorem*)</span>
  <span class="keyword1"><span class="keyword">val</span></span> prove_isomorphism <span class="main">:</span> <span class="entity">type_info</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> thm option * <span class="entity">Proof.context</span>
  <span class="keyword1"><span class="keyword">val</span></span> prove_instance_tac <span class="main">:</span> typ <span class="main">-&gt;</span> <span class="entity">class_info</span> <span class="main">-&gt;</span> <span class="entity">instance_info</span> <span class="main">-&gt;</span> <span class="entity">type_info</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> tactic
  <span class="keyword1"><span class="keyword">val</span></span> prove_equivalence_law <span class="main">:</span> <span class="entity">class_info</span> <span class="main">-&gt;</span> <span class="entity">instance_info</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> prove_combinator_instance <span class="main">:</span> <span class="main">(</span>thm list list <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span> <span class="entity">Proof.context</span><span class="main">)</span> <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span> <span class="entity">Proof.state</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Derive_Laws</span> <span class="main">:</span> <span class="entity">DERIVE_LAWS</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_class_info</span> <span class="entity">thy</span> <span class="entity">classname</span> <span class="main">=</span> Symtab.lookup <span class="main">(</span>Class_Data.get <span class="entity">thy</span><span class="main">)</span> <span class="entity">classname</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove_isomorphism</span> <span class="entity">type_info</span> <span class="entity">lthy</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tname_short</span> <span class="main">=</span> Long_Name.base_name <span class="main">(</span><span class="main">#</span>tname <span class="entity">type_info</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">from_info</span> <span class="main">=</span> the <span class="main">(</span><span class="main">#</span>from_info <span class="main">(</span><span class="main">#</span>rep_info <span class="entity">type_info</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">to_info</span> <span class="main">=</span> the <span class="main">(</span><span class="main">#</span>to_info <span class="main">(</span><span class="main">#</span>rep_info <span class="entity">type_info</span><span class="main">)</span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">from_f</span> <span class="main">=</span> hd <span class="main">(</span><span class="main">#</span>fs <span class="entity">from_info</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">to_f</span> <span class="main">=</span> hd <span class="main">(</span><span class="main">#</span>fs <span class="entity">to_info</span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">from_induct</span> <span class="main">=</span> hd <span class="main">(</span>the <span class="main">(</span><span class="main">#</span>inducts <span class="entity">from_info</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">to_induct</span> <span class="main">=</span> hd <span class="main">(</span>the <span class="main">(</span><span class="main">#</span>inducts <span class="entity">to_info</span><span class="main">)</span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">iso_thm</span> <span class="main">=</span>
  <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span>‹Derive.iso›</span><span class="main">,</span> dummyT<span class="main">)</span> $ <span class="entity">from_f</span> $ <span class="entity">to_f</span><span class="main">)</span>
    |&gt; Syntax.check_term <span class="entity">lthy</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">induct_tac_to</span> <span class="main">=</span> <span class="main">(</span><span class="entity">Induct_Tacs.induct_tac</span> <span class="entity">lthy</span> <span class="main">[</span><span class="main">[</span>SOME <span class="inner_quoted">"b"</span><span class="main">]</span><span class="main">]</span> <span class="main">(</span>SOME <span class="main">[</span><span class="entity">to_induct</span><span class="main">]</span><span class="main">)</span> <span class="inner_numeral">2</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">induct_tac_from</span> <span class="main">=</span> <span class="main">(</span><span class="entity">Induct_Tacs.induct_tac</span> <span class="entity">lthy</span> <span class="main">[</span><span class="main">[</span>SOME <span class="inner_quoted">"a"</span><span class="main">]</span><span class="main">]</span> <span class="main">(</span>SOME <span class="main">[</span><span class="entity">from_induct</span><span class="main">]</span><span class="main">)</span> <span class="inner_numeral">1</span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">iso_thm_proved</span> <span class="main">=</span> Goal.prove <span class="entity">lthy</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">iso_thm</span>
                        <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">(</span>resolve_tac <span class="entity">lthy</span> <span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Derive.iso_intro<span class="antiquote">}</span></span></span><span class="main">]</span> <span class="inner_numeral">1</span><span class="main">)</span> THEN
                                 <span class="entity">induct_tac_to</span> THEN <span class="entity">induct_tac_from</span> THEN
                                 <span class="main">(</span>ALLGOALS <span class="main">(</span><span class="entity">asm_full_simp_tac</span> <span class="entity">lthy</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="entity">thms</span><span class="main">)</span><span class="main">,</span><span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span> Local_Theory.note <span class="main">(</span><span class="main">(</span>Binding.name <span class="main">(</span><span class="inner_quoted">"conversion_iso_"</span> ^ <span class="entity">tname_short</span><span class="main">)</span><span class="main">,</span><span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="entity">iso_thm_proved</span><span class="main">]</span><span class="main">)</span> <span class="entity">lthy</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt_thy</span> <span class="main">=</span> Proof_Context.init_global <span class="main">(</span>Proof_Context.theory_of <span class="entity">lthy'</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm</span> <span class="main">=</span> singleton <span class="main">(</span>Proof_Context.export <span class="entity">lthy'</span> <span class="entity">ctxt_thy</span><span class="main">)</span> <span class="main">(</span>hd <span class="entity">thms</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">in</span></span>
  <span class="main">(</span>SOME <span class="entity">thm</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove_equivalence_law</span> <span class="entity">cl_info</span> <span class="entity">inst_info</span> <span class="entity">ctxt</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">class</span> <span class="main">=</span> <span class="main">#</span>class <span class="entity">cl_info</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">classname</span> <span class="main">=</span> <span class="main">#</span>classname <span class="entity">cl_info</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">class_law</span> <span class="main">=</span> the <span class="main">(</span><span class="main">#</span>class_law <span class="entity">cl_info</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">op_defs</span> <span class="main">=</span> <span class="main">#</span>defs <span class="entity">inst_info</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">axioms</span> <span class="main">=</span> the <span class="main">(</span><span class="main">#</span>axioms <span class="entity">cl_info</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">axioms_def</span> <span class="main">=</span> the_list <span class="main">(</span><span class="main">#</span>axioms_def <span class="entity">cl_info</span><span class="main">)</span> 
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">class_def</span> <span class="main">=</span> the <span class="main">(</span><span class="main">#</span>class_def <span class="entity">cl_info</span><span class="main">)</span>
  
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ops_raw</span> <span class="main">=</span> map <span class="main">(</span>Thm.full_prop_of #&gt; <span class="entity">HOLogic.dest_Trueprop</span> #&gt; <span class="entity">HOLogic.dest_eq</span> #&gt; fst #&gt; strip_comb #&gt; fst<span class="main">)</span> <span class="entity">op_defs</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ops</span> <span class="main">=</span> map <span class="main">(</span>dest_Const #&gt; apsnd <span class="main">(</span>K dummyT<span class="main">)</span> #&gt; Const<span class="main">)</span> <span class="entity">ops_raw</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">class_law_const</span> <span class="main">=</span> Thm.full_prop_of <span class="entity">class_law</span> |&gt; <span class="entity">HOLogic.dest_Trueprop</span> |&gt; <span class="entity">HOLogic.dest_eq</span> |&gt; fst |&gt; strip_comb |&gt; fst
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">class_law_const_dummy</span> <span class="main">=</span> dest_Const <span class="entity">class_law_const</span> |&gt; apsnd <span class="main">(</span>K dummyT<span class="main">)</span> |&gt; Const
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">axioms_thms</span> <span class="main">=</span> map <span class="main">(</span>Local_Defs.unfold <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">class_def</span> :: <span class="entity">axioms_def</span><span class="main">)</span><span class="main">)</span> <span class="entity">axioms</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">superclasses</span> <span class="main">=</span> <span class="entity">get_superclasses</span> <span class="entity">class</span> <span class="entity">classname</span> <span class="main">(</span>Proof_Context.theory_of <span class="entity">ctxt</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">superclass_laws</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">get_class_info</span> <span class="main">(</span>Proof_Context.theory_of <span class="entity">ctxt</span><span class="main">)</span> #&gt; the #&gt; <span class="main">#</span>equivalence_thm #&gt; the<span class="main">)</span> <span class="entity">superclasses</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> list_comb <span class="main">(</span><span class="entity">class_law_const_dummy</span><span class="main">,</span><span class="entity">ops</span><span class="main">)</span> |&gt; <span class="entity">HOLogic.mk_Trueprop</span> |&gt; Syntax.check_term <span class="entity">ctxt</span>
<span class="keyword2"><span class="keyword">in</span></span>
  Goal.prove <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">t</span>
  <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">(</span>Local_Defs.unfold_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">class_law</span><span class="main">]</span><span class="main">)</span>
           THEN <span class="main">(</span>HEADGOAL <span class="main">(</span><span class="entity">Method.insert_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">axioms_thms</span>@<span class="entity">superclass_laws</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
           THEN <span class="main">(</span>HEADGOAL <span class="main">(</span><span class="entity">asm_full_simp_tac</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>  

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove_instance_tac</span> <span class="entity">T</span> <span class="entity">cl_info</span> <span class="entity">inst_info</span> <span class="entity">ty_info</span> <span class="entity">ctxt</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">transfer_thms</span> <span class="main">=</span> the <span class="main">(</span><span class="main">#</span>transfer_law <span class="entity">cl_info</span><span class="main">)</span> |&gt; map snd |&gt; flat
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">iso_thm</span> <span class="main">=</span> the <span class="main">(</span><span class="main">#</span>iso_thm <span class="entity">ty_info</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ops</span> <span class="main">=</span> map <span class="main">(</span>Thm.full_prop_of #&gt; <span class="entity">HOLogic.dest_Trueprop</span> #&gt; <span class="entity">HOLogic.dest_eq</span> #&gt; fst #&gt; strip_comb #&gt; fst<span class="main">)</span> <span class="main">(</span><span class="main">#</span>defs <span class="entity">inst_info</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">op_defs</span> <span class="main">=</span> <span class="main">#</span>defs <span class="entity">inst_info</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">class_law</span> <span class="main">=</span> the <span class="main">(</span><span class="main">#</span>class_law <span class="entity">cl_info</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">equivalence_thm</span> <span class="main">=</span> the <span class="main">(</span><span class="main">#</span>equivalence_thm <span class="entity">cl_info</span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">class_law_const</span> <span class="main">=</span> Thm.full_prop_of <span class="entity">class_law</span> |&gt; <span class="entity">HOLogic.dest_Trueprop</span> |&gt; <span class="entity">HOLogic.dest_eq</span> |&gt; fst |&gt; strip_comb |&gt; fst

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ops</span> <span class="main">=</span> map <span class="main">(</span>dest_Const #&gt; apsnd <span class="main">(</span>K dummyT<span class="main">)</span> #&gt; Const<span class="main">)</span> <span class="entity">ops</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">class_law_const_dummy</span> <span class="main">=</span> dest_Const <span class="entity">class_law_const</span> |&gt; apsnd <span class="main">(</span>K dummyT<span class="main">)</span> |&gt; Const

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">class_law_inst</span> <span class="main">=</span>
    <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span>list_comb <span class="main">(</span><span class="entity">class_law_const_dummy</span><span class="main">,</span> <span class="entity">ops</span><span class="main">)</span><span class="main">)</span>
    |&gt; singleton <span class="main">(</span>Type_Infer_Context.infer_types <span class="entity">ctxt</span><span class="main">)</span>
    |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> subst_TVars <span class="main">(</span><span class="main">[</span><span class="main">(</span>Term.add_tvar_names <span class="entity">t</span> <span class="main">[</span><span class="main">]</span> |&gt; hd<span class="main">,</span><span class="entity">T</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="entity">t</span> <span class="main">)</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">transfer_thm_inst</span> <span class="main">=</span> <span class="main">(</span>hd <span class="entity">transfer_thms</span><span class="main">)</span> OF <span class="main">[</span><span class="entity">iso_thm</span><span class="main">,</span><span class="entity">equivalence_thm</span><span class="main">]</span>
  
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">class_law_inst_proved</span> <span class="main">=</span> Goal.prove <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">class_law_inst</span>
                              <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">(</span>Local_Defs.unfold_tac <span class="entity">ctxt</span> <span class="entity">op_defs</span><span class="main">)</span>
                                       THEN <span class="main">(</span>Proof_Context.fact_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">transfer_thm_inst</span><span class="main">]</span> <span class="inner_numeral">1</span><span class="main">)</span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt_thy</span> <span class="main">=</span> Proof_Context.init_global <span class="main">(</span>Proof_Context.theory_of <span class="entity">ctxt</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">class_law_inst_def</span> <span class="main">=</span> singleton <span class="main">(</span>Proof_Context.export <span class="entity">ctxt</span> <span class="entity">ctxt_thy</span><span class="main">)</span> <span class="entity">class_law_inst_proved</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">class_law_unfolded</span> <span class="main">=</span> Local_Defs.unfold <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">class_law</span><span class="main">]</span> <span class="entity">class_law_inst_def</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">class_tac</span> <span class="main">=</span> <span class="entity">Class.intro_classes_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span>
                  THEN <span class="main">(</span>ALLGOALS <span class="main">(</span><span class="entity">Method.insert_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">class_law_unfolded</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
                  THEN <span class="main">(</span>ALLGOALS <span class="main">(</span><span class="entity">blast_tac</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">in</span></span>
  <span class="entity">class_tac</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove_combinator_instance</span> <span class="entity">after_qed</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">class_tac</span> <span class="entity">thms</span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="entity">Class.intro_classes_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span>
                  THEN <span class="main">(</span>ALLGOALS <span class="main">(</span><span class="entity">Method.insert_tac</span> <span class="entity">ctxt</span> <span class="entity">thms</span><span class="main">)</span><span class="main">)</span>
                  THEN <span class="main">(</span>ALLGOALS <span class="main">(</span><span class="entity">blast_tac</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove_class_laws_manually</span> <span class="entity">st</span> <span class="entity">ctxt</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm</span> <span class="main">=</span> <span class="main">#</span>goal <span class="main">(</span><span class="entity">Proof.simple_goal</span> <span class="entity">st</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goal</span> <span class="main">=</span> <span class="main">(</span><span class="entity">Class.intro_classes_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="entity">thm</span> |&gt; Seq.hd
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goals</span> <span class="main">=</span> Thm.prems_of <span class="entity">goal</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goals_formatted</span> <span class="main">=</span> <span class="main">(</span>map single <span class="main">(</span><span class="entity">goals</span> ~~ <span class="main">(</span>replicate <span class="main">(</span>length <span class="entity">goals</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove_class</span> <span class="entity">thms</span> <span class="main">=</span> 
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt_thy</span> <span class="main">=</span> Proof_Context.init_global <span class="main">(</span>Proof_Context.theory_of <span class="entity">ctxt</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thms'</span> <span class="main">=</span> <span class="main">(</span>Proof_Context.export <span class="entity">ctxt</span> <span class="entity">ctxt_thy</span><span class="main">)</span> <span class="main">(</span>flat <span class="entity">thms</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="entity">Class.prove_instantiation_exit</span> <span class="main">(</span><span class="entity">class_tac</span> <span class="entity">thms'</span><span class="main">)</span> <span class="entity">ctxt</span>
          <span class="keyword2"><span class="keyword">end</span></span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">after_qed'</span> <span class="entity">thms</span> <span class="main">_</span> <span class="main">=</span>  <span class="entity">prove_class</span> <span class="entity">thms</span> |&gt; <span class="entity">Named_Target.theory_init</span> |&gt; <span class="entity">after_qed</span> <span class="main">[</span><span class="main">]</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">st'</span> <span class="main">=</span> <span class="entity">Proof.theorem</span> NONE <span class="entity">after_qed'</span> <span class="entity">goals_formatted</span> <span class="entity">ctxt</span> 
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="entity">st'</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">st</span> <span class="main">=</span> <span class="entity">Class.instantiation_instance</span> I <span class="entity">lthy</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">prove_class_laws_manually</span> <span class="entity">st</span> <span class="entity">lthy</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="files/derive_setup.ML">
<div class="head">
<h1>File ‹derive_setup.ML›</h1>
</div>
<pre class="source"><span class="keyword3"><span class="keyword">open</span></span> Derive_Util

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">DERIVE_SETUP</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> prove_class_transfer <span class="main">:</span> string <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> <span class="entity">Proof.state</span>
  <span class="keyword1"><span class="keyword">val</span></span> define_class_law <span class="main">:</span> string <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="main">(</span>thm * thm * thm option * term list * local_theory<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Derive_Setup</span> <span class="main">:</span> <span class="entity">DERIVE_SETUP</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>     

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_class_info</span> <span class="entity">thy</span> <span class="entity">classname</span> <span class="main">=</span> Symtab.lookup <span class="main">(</span>Class_Data.get <span class="entity">thy</span><span class="main">)</span> <span class="entity">classname</span>

<span class="keyword1"><span class="keyword">fun</span></span> 
  <span class="entity">replace_superclasses</span> <span class="entity">lthy</span> <span class="main">(</span><span class="entity">s</span> $ <span class="entity">t</span><span class="main">)</span> <span class="main">=</span> <span class="entity">replace_superclasses</span> <span class="entity">lthy</span> <span class="entity">s</span> $ <span class="entity">replace_superclasses</span> <span class="entity">lthy</span> <span class="entity">t</span> <span class="main">|</span>
  <span class="entity">replace_superclasses</span> <span class="entity">lthy</span> <span class="main">(</span>Const <span class="main">(</span><span class="entity">n</span><span class="main">,</span><span class="entity">T</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> 
    <span class="keyword2"><span class="keyword">let</span></span> 
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">is_class</span> <span class="main">=</span> Long_Name.base_name <span class="entity">n</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">class</span> <span class="main">=</span> Syntax.parse_sort <span class="entity">lthy</span> <span class="entity">is_class</span> <span class="keyword3"><span class="keyword">handle</span></span> ERROR <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">class</span> <span class="keyword2"><span class="keyword">then</span></span> Const <span class="main">(</span><span class="entity">n</span><span class="main">,</span><span class="entity">T</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">class_data</span> <span class="main">=</span> <span class="entity">get_class_info</span> <span class="main">(</span>Proof_Context.theory_of <span class="entity">lthy</span><span class="main">)</span> <span class="main">(</span>hd <span class="entity">class</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="keyword2"><span class="keyword">if</span></span> is_some <span class="entity">class_data</span> <span class="keyword2"><span class="keyword">then</span></span> the <span class="main">(</span><span class="main">#</span>class_law_const <span class="main">(</span>the <span class="entity">class_data</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> Const <span class="main">(</span><span class="entity">n</span><span class="main">,</span><span class="entity">T</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span> <span class="main">|</span>
  <span class="entity">replace_superclasses</span> <span class="main">_</span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">t</span>   

<span class="keyword1"><span class="keyword">fun</span></span> 
  <span class="entity">contains_axioms</span> <span class="entity">cn</span> <span class="main">(</span><span class="entity">s</span> $ <span class="entity">t</span><span class="main">)</span> <span class="main">=</span> <span class="entity">contains_axioms</span> <span class="entity">cn</span> <span class="entity">s</span> <span class="keyword1"><span class="keyword">orelse</span></span> <span class="entity">contains_axioms</span> <span class="entity">cn</span> <span class="entity">t</span> <span class="main">|</span>
  <span class="entity">contains_axioms</span> <span class="entity">cn</span> <span class="main">(</span>Const <span class="main">(</span><span class="entity">n</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">is_class</span> <span class="main">=</span> Long_Name.base_name <span class="entity">n</span>
    <span class="keyword2"><span class="keyword">in</span></span> 
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_class</span> <span class="main">=</span> <span class="entity">cn</span> ^ <span class="inner_quoted">"_axioms"</span> 
        <span class="keyword2"><span class="keyword">then</span></span> true
        <span class="keyword2"><span class="keyword">else</span></span> false
    <span class="keyword2"><span class="keyword">end</span></span> <span class="main">|</span>
  <span class="entity">contains_axioms</span> <span class="main">_</span> <span class="main">_</span> <span class="main">=</span> false

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">define_class_law</span> <span class="entity">classname</span> <span class="entity">lthy</span>  <span class="main">=</span>
<span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">class_def</span> <span class="main">=</span> Proof_Context.get_thm <span class="entity">lthy</span> <span class="main">(</span><span class="inner_quoted">"class."</span> ^ <span class="entity">classname</span> ^ <span class="inner_quoted">"_def"</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">has_axioms</span> <span class="main">=</span> 
    <span class="entity">contains_axioms</span> <span class="entity">classname</span> 
                    <span class="main">(</span><span class="entity">class_def</span> |&gt; Thm.full_prop_of |&gt; Logic.unvarify_global |&gt;  Logic.dest_equals |&gt; snd<span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">axioms_def</span><span class="main">,</span><span class="main">(</span><span class="entity">vars</span><span class="main">,</span><span class="entity">class_law</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">class_def</span> 
                   |&gt; <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">has_axioms</span> 
                        <span class="keyword2"><span class="keyword">then</span></span> 
                          <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">axioms_def</span> <span class="main">=</span> Proof_Context.get_thm <span class="entity">lthy</span> <span class="main">(</span><span class="inner_quoted">"class."</span> ^ <span class="entity">classname</span> ^ <span class="inner_quoted">"_axioms_def"</span><span class="main">)</span>
                          <span class="keyword2"><span class="keyword">in</span></span> Local_Defs.unfold <span class="entity">lthy</span> <span class="main">[</span><span class="entity">axioms_def</span><span class="main">]</span> #&gt; pair <span class="main">(</span>SOME <span class="entity">axioms_def</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>
                        <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span>pair NONE<span class="main">)</span><span class="main">)</span>
                   ||&gt; Thm.full_prop_of ||&gt; Logic.unvarify_global ||&gt; Logic.dest_equals 
                   ||&gt; apfst <span class="main">(</span>strip_comb #&gt; snd<span class="main">)</span> ||&gt; apsnd <span class="main">(</span><span class="entity">replace_superclasses</span> <span class="entity">lthy</span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">class_law_name</span> <span class="main">=</span> <span class="entity">classname</span> ^ <span class="inner_quoted">"_class_law"</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">class_law_lhs</span> <span class="main">=</span> list_comb <span class="main">(</span><span class="main">(</span>Free <span class="main">(</span><span class="entity">class_law_name</span><span class="main">,</span><span class="main">(</span>map <span class="main">(</span>dest_Free #&gt; snd<span class="main">)</span> <span class="entity">vars</span><span class="main">)</span> ---&gt; <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span><span class="quoted">‹bool›</span></span><span class="main">)</span><span class="main">)</span><span class="main">,</span><span class="entity">vars</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">class_law_eq</span> <span class="main">=</span> <span class="entity">HOLogic.Trueprop</span> $ <span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">class_law_lhs</span><span class="main">,</span><span class="entity">class_law</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="entity">class_law_thm</span><span class="main">)</span><span class="main">)</span><span class="main">,</span><span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Specification.definition</span> NONE <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span><span class="main">(</span>Binding.empty<span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">class_law_eq</span><span class="main">)</span> <span class="entity">lthy</span>
  
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt_thy</span> <span class="main">=</span> Proof_Context.init_global <span class="main">(</span>Proof_Context.theory_of <span class="entity">lthy'</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">class_law_thm_export</span> <span class="main">=</span> singleton <span class="main">(</span>Proof_Context.export <span class="entity">lthy'</span> <span class="entity">ctxt_thy</span><span class="main">)</span> <span class="entity">class_law_thm</span>
<span class="keyword2"><span class="keyword">in</span></span>
  <span class="main">(</span><span class="entity">class_law_thm_export</span><span class="main">,</span><span class="entity">class_def</span><span class="main">,</span><span class="entity">axioms_def</span><span class="main">,</span><span class="entity">vars</span><span class="main">,</span><span class="entity">lthy'</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">transfer_op</span> <span class="entity">lthy</span> <span class="entity">from</span> <span class="entity">to</span> <span class="entity">var</span> <span class="main">=</span>  
<span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">convert_arg</span> <span class="main">(</span><span class="entity">T</span><span class="main">,</span><span class="entity">i</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">T</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="main">(</span>TFree <span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">from</span> $ <span class="main">(</span>Bound <span class="entity">i</span><span class="main">)</span> <span class="main">|</span>
              <span class="main">_</span> <span class="main">=&gt;</span> Bound <span class="entity">i</span>
  <span class="keyword1"><span class="keyword">fun</span></span> 
    <span class="entity">abstract</span> <span class="main">[</span><span class="main">]</span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">t</span> <span class="main">|</span>
    <span class="entity">abstract</span> <span class="main">(</span><span class="entity">x</span>::<span class="entity">xs</span><span class="main">)</span> <span class="entity">t</span> <span class="main">=</span> <span class="main">(</span>Abs <span class="main">(</span><span class="entity">x</span><span class="main">,</span> dummyT<span class="main">,</span> <span class="entity">abstract</span> <span class="entity">xs</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span>          
  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">v</span><span class="main">,</span><span class="entity">T</span><span class="main">)</span> <span class="main">=</span> dest_Free <span class="entity">var</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">binders</span><span class="main">,</span><span class="entity">body</span><span class="main">)</span> <span class="main">=</span> strip_type <span class="entity">T</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">argnames</span> <span class="main">=</span> Name.invent_names <span class="main">(</span>Variable.names_of <span class="entity">lthy</span><span class="main">)</span> <span class="inner_quoted">"x"</span> <span class="entity">binders</span> |&gt; map fst
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args_converted</span> <span class="main">=</span> map <span class="entity">convert_arg</span> <span class="main">(</span><span class="entity">binders</span> ~~ <span class="main">(</span>List.tabulate <span class="main">(</span>length <span class="entity">binders</span><span class="main">,</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">n</span> <span class="main">=&gt;</span> <span class="main">(</span>length <span class="entity">binders</span><span class="main">)</span>-<span class="main">(</span><span class="entity">n</span>+<span class="inner_numeral">1</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">op_call</span> <span class="main">=</span> list_comb <span class="main">(</span><span class="main">(</span>Free <span class="main">(</span><span class="entity">v</span><span class="main">,</span><span class="entity">T</span><span class="main">)</span><span class="main">)</span><span class="main">,</span><span class="entity">args_converted</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">op_converted</span> <span class="main">=</span> 
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">body</span> <span class="keyword2"><span class="keyword">of</span></span>
      <span class="main">(</span>TFree <span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">to</span> $ <span class="entity">op_call</span> <span class="main">|</span>
      <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">op_call</span>
<span class="keyword2"><span class="keyword">in</span></span>
  <span class="entity">abstract</span> <span class="entity">argnames</span> <span class="entity">op_converted</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove_class_transfer</span> <span class="entity">classname</span> <span class="entity">thy</span> <span class="main">=</span> 
<span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_info</span> <span class="entity">info</span> <span class="entity">thy</span> <span class="main">=</span> Class_Data.put <span class="main">(</span>Symtab.update <span class="main">(</span><span class="main">(</span><span class="main">#</span>classname <span class="entity">info</span><span class="main">)</span><span class="main">,</span><span class="entity">info</span><span class="main">)</span> <span class="main">(</span>Class_Data.get <span class="entity">thy</span><span class="main">)</span><span class="main">)</span> <span class="entity">thy</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">class</span> <span class="main">=</span> Syntax.parse_sort <span class="main">(</span>Proof_Context.init_global <span class="entity">thy</span><span class="main">)</span> <span class="entity">classname</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">classname_full</span> <span class="main">=</span> hd <span class="entity">class</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">axioms</span> <span class="main">=</span> <span class="entity">Axclass.get_info</span> <span class="entity">thy</span> <span class="entity">classname_full</span> |&gt; <span class="main">#</span>axioms
  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">class_law</span><span class="main">,</span><span class="entity">class_def</span><span class="main">,</span><span class="entity">axioms_def</span><span class="main">,</span><span class="entity">vars</span><span class="main">,</span><span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span> <span class="entity">define_class_law</span> <span class="entity">classname</span> <span class="main">(</span><span class="entity">Named_Target.theory_init</span> <span class="entity">thy</span><span class="main">)</span> 
  <span class="comment1">(* Exit so that class law is defined properly before the next step
     FIXME use begin / end block instead (?) *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy'</span> <span class="main">=</span> Local_Theory.exit_global <span class="entity">lthy</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lthy'</span> <span class="main">=</span> <span class="entity">Named_Target.theory_init</span> <span class="entity">thy'</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tfree_dt</span> <span class="main">=</span> <span class="entity">get_tvar</span> <span class="main">(</span>map <span class="main">(</span>dest_Free #&gt; snd<span class="main">)</span> <span class="entity">vars</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tfree_rep</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">n</span><span class="main">,</span><span class="entity">s</span><span class="main">)</span> <span class="main">=</span> <span class="entity">tfree_dt</span> |&gt; dest_TFree <span class="keyword2"><span class="keyword">in</span></span> Name.invent_names <span class="main">(</span>Name.make_context <span class="main">[</span><span class="entity">n</span><span class="main">]</span><span class="main">)</span> <span class="inner_quoted">"'a"</span> <span class="main">[</span><span class="entity">s</span><span class="main">]</span> <span class="keyword2"><span class="keyword">end</span></span> |&gt; hd |&gt; TFree
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">from</span> <span class="main">=</span> Free <span class="main">(</span><span class="inner_quoted">"from"</span><span class="main">,</span><span class="entity">tfree_rep</span> --&gt; <span class="entity">tfree_dt</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">to</span>   <span class="main">=</span> Free <span class="main">(</span><span class="inner_quoted">"to"</span><span class="main">,</span><span class="entity">tfree_dt</span> --&gt; <span class="entity">tfree_rep</span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">class_law_const</span> <span class="main">=</span> Thm.full_prop_of <span class="entity">class_law</span> |&gt; <span class="entity">HOLogic.dest_Trueprop</span> |&gt; <span class="entity">HOLogic.dest_eq</span> |&gt; fst |&gt; strip_comb |&gt; fst
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">class_law_const_dummy</span> <span class="main">=</span> dest_Const <span class="entity">class_law_const</span> |&gt; apsnd <span class="main">(</span>K dummyT<span class="main">)</span> |&gt; Const
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">class_law_var</span> <span class="main">=</span> <span class="main">(</span>Term.add_tvars <span class="entity">class_law_const</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> |&gt; hd |&gt; fst
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">class_law_const_dt</span> <span class="main">=</span> subst_vars <span class="main">(</span><span class="main">[</span><span class="main">(</span><span class="entity">class_law_var</span><span class="main">,</span><span class="entity">tfree_dt</span><span class="main">)</span><span class="main">]</span><span class="main">,</span><span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="entity">class_law_const</span> 
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">class_law_const_rep</span> <span class="main">=</span> subst_vars <span class="main">(</span><span class="main">[</span><span class="main">(</span><span class="entity">class_law_var</span><span class="main">,</span><span class="entity">tfree_rep</span><span class="main">)</span><span class="main">]</span><span class="main">,</span><span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="entity">class_law_const</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">assm_iso</span> <span class="main">=</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span>‹Derive.iso›</span><span class="main">,</span>dummyT<span class="main">)</span> $ <span class="entity">from</span> $ <span class="entity">to</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">assm_class</span> <span class="main">=</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span>list_comb <span class="main">(</span><span class="entity">class_law_const_dt</span><span class="main">,</span><span class="entity">vars</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">vars_transfer</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">transfer_op</span> <span class="entity">lthy'</span> <span class="entity">from</span> <span class="entity">to</span><span class="main">)</span> <span class="entity">vars</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">transfer_concl</span> <span class="main">=</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span>list_comb <span class="main">(</span><span class="entity">class_law_const_rep</span><span class="main">,</span><span class="entity">vars_transfer</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">transfer_term</span> <span class="main">=</span> Logic.mk_implies <span class="main">(</span><span class="entity">assm_iso</span><span class="main">,</span> <span class="main">(</span>Logic.mk_implies <span class="main">(</span><span class="entity">assm_class</span><span class="main">,</span> <span class="entity">transfer_concl</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">transfer_term_inf</span> <span class="main">=</span> Type_Infer_Context.infer_types <span class="entity">lthy'</span> <span class="main">[</span><span class="entity">transfer_term</span><span class="main">]</span> |&gt; hd

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">after_qed</span> <span class="entity">thms</span> <span class="entity">lthy</span> <span class="main">=</span>
    <span class="main">(</span>fold_map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">lthy</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">thm</span> <span class="main">=&gt;</span> <span class="main">(</span>Local_Theory.note <span class="main">(</span><span class="main">(</span>Binding.name <span class="main">(</span><span class="entity">classname</span> ^ <span class="inner_quoted">"_transfer"</span><span class="main">)</span><span class="main">,</span><span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="entity">thm</span><span class="main">)</span><span class="main">)</span>
                    <span class="entity">thms</span> <span class="entity">lthy</span><span class="main">)</span>    
      |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">thms</span><span class="main">,</span><span class="entity">lthy</span><span class="main">)</span> <span class="main">=&gt;</span> 
            Local_Theory.background_theory 
              <span class="main">(</span><span class="entity">add_info</span> <span class="main">{</span>classname <span class="main">=</span> <span class="entity">classname_full</span><span class="main">,</span> class <span class="main">=</span> <span class="entity">class</span><span class="main">,</span> params <span class="main">=</span> NONE<span class="main">,</span> class_law <span class="main">=</span> SOME <span class="entity">class_law</span><span class="main">,</span> class_law_const <span class="main">=</span> SOME <span class="entity">class_law_const_dummy</span><span class="main">,</span> ops <span class="main">=</span> SOME <span class="entity">vars</span><span class="main">,</span> transfer_law <span class="main">=</span> SOME <span class="entity">thms</span><span class="main">,</span> axioms <span class="main">=</span> SOME <span class="entity">axioms</span><span class="main">,</span> axioms_def <span class="main">=</span> <span class="entity">axioms_def</span><span class="main">,</span> class_def <span class="main">=</span> SOME <span class="entity">class_def</span><span class="main">,</span> equivalence_thm <span class="main">=</span> NONE<span class="main">}</span><span class="main">)</span>
              <span class="entity">lthy</span><span class="main">)</span>
      |&gt; Local_Theory.exit 
<span class="keyword2"><span class="keyword">in</span></span> 
  <span class="entity">Proof.theorem</span> NONE <span class="entity">after_qed</span> <span class="main">[</span><span class="main">[</span><span class="main">(</span><span class="entity">transfer_term_inf</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">]</span><span class="main">]</span> <span class="entity">lthy'</span> 
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.command</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">command_keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword1">derive_generic_setup</span>›</span></span> <span class="inner_quoted">"prepare a class for derivation"</span>
    <span class="main">(</span>Parse.name &gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">c</span> <span class="main">=&gt;</span>
      <span class="entity">Toplevel.theory_to_proof</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">thy</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">has_class_law</span> <span class="entity">c</span> <span class="entity">thy</span> 
                                          <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">prove_class_transfer</span> <span class="entity">c</span> <span class="entity">thy</span>
                                          <span class="keyword2"><span class="keyword">else</span></span> error <span class="main">(</span><span class="inner_quoted">"Class "</span> ^ <span class="entity">c</span> ^ <span class="inner_quoted">" has no associated laws, no need to call derive_setup"</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="files/derive.ML">
<div class="head">
<h1>File ‹derive.ML›</h1>
</div>
<pre class="source"><span class="keyword3"><span class="keyword">open</span></span> Derive_Util

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">DERIVE</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="comment1">(* Adds functions that convert to and from a product-sum representation *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> define_prod_sum_conv <span class="main">:</span> <span class="entity">type_info</span> <span class="main">-&gt;</span> bool <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">Function_Common.info</span> * <span class="entity">Function_Common.info</span> * <span class="entity">Proof.context</span><span class="main">)</span>
  <span class="comment1">(* define product-sum-representation type synonym *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> define_rep_type <span class="main">:</span> string list <span class="main">-&gt;</span> <span class="entity">ctr_info</span> <span class="main">-&gt;</span> bool <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span> <span class="entity">rep_type_info</span> * local_theory
  <span class="comment1">(* define Mu-combinator type *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> define_combinator_type <span class="main">:</span> string list <span class="main">-&gt;</span> <span class="main">(</span>typ * class list<span class="main">)</span> list <span class="main">-&gt;</span> <span class="entity">rep_type_info</span> 
                                <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span> <span class="entity">comb_type_info</span> option * local_theory
  <span class="comment1">(* instantiate a typeclass *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> generate_instance <span class="main">:</span> string <span class="main">-&gt;</span> sort <span class="main">-&gt;</span> bool <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> <span class="entity">Proof.state</span>

  <span class="keyword1"><span class="keyword">val</span></span> add_inst_info <span class="main">:</span> string <span class="main">-&gt;</span> string <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Derive</span> <span class="main">:</span> <span class="entity">DERIVE</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>      

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_type_info</span> <span class="entity">thy</span> <span class="entity">tname</span> <span class="entity">constr_names</span> <span class="main">=</span>
  Symreltab.lookup <span class="main">(</span>Type_Data.get <span class="entity">thy</span><span class="main">)</span> <span class="main">(</span><span class="entity">tname</span><span class="main">,</span> Bool.toString <span class="entity">constr_names</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_class_info</span> <span class="entity">thy</span> <span class="entity">classname</span> <span class="main">=</span> Symtab.lookup <span class="main">(</span>Class_Data.get <span class="entity">thy</span><span class="main">)</span> <span class="entity">classname</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_inst_info</span> <span class="entity">thy</span> <span class="entity">classname</span> <span class="entity">tname</span> <span class="main">=</span> Symreltab.lookup <span class="main">(</span>Instance_Data.get <span class="entity">thy</span><span class="main">)</span> <span class="main">(</span><span class="entity">classname</span><span class="main">,</span> <span class="entity">tname</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_params_cl_info</span> <span class="main">(</span><span class="entity">cl_info</span> <span class="main">:</span> <span class="entity">class_info</span><span class="main">)</span> <span class="entity">params</span> <span class="main">=</span> 
  <span class="main">{</span>classname <span class="main">=</span> <span class="main">(</span><span class="main">#</span>classname <span class="entity">cl_info</span><span class="main">)</span><span class="main">,</span> class <span class="main">=</span> <span class="main">(</span><span class="main">#</span>class <span class="entity">cl_info</span><span class="main">)</span><span class="main">,</span> params <span class="main">=</span> SOME <span class="entity">params</span><span class="main">,</span> class_law <span class="main">=</span> <span class="main">(</span><span class="main">#</span>class_law <span class="entity">cl_info</span><span class="main">)</span><span class="main">,</span> class_law_const <span class="main">=</span> <span class="main">(</span><span class="main">#</span>class_law_const <span class="entity">cl_info</span><span class="main">)</span><span class="main">,</span> ops <span class="main">=</span> <span class="main">(</span><span class="main">#</span>ops <span class="entity">cl_info</span><span class="main">)</span><span class="main">,</span> transfer_law <span class="main">=</span> <span class="main">(</span><span class="main">#</span>transfer_law <span class="entity">cl_info</span><span class="main">)</span><span class="main">,</span> axioms <span class="main">=</span> <span class="main">(</span><span class="main">#</span>axioms <span class="entity">cl_info</span><span class="main">)</span><span class="main">,</span> axioms_def <span class="main">=</span> <span class="main">(</span><span class="main">#</span>axioms_def <span class="entity">cl_info</span><span class="main">)</span><span class="main">,</span> class_def <span class="main">=</span> <span class="main">(</span><span class="main">#</span>class_def <span class="entity">cl_info</span><span class="main">)</span><span class="main">,</span> equivalence_thm <span class="main">=</span> <span class="main">(</span><span class="main">#</span>equivalence_thm <span class="entity">cl_info</span><span class="main">)</span><span class="main">}</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_inst_info</span> <span class="entity">defs</span> <span class="main">=</span> 
  <span class="main">{</span>defs <span class="main">=</span> <span class="entity">defs</span><span class="main">}</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_equivalence_cl_info</span> <span class="main">(</span><span class="entity">cl_info</span> <span class="main">:</span> <span class="entity">class_info</span><span class="main">)</span> <span class="entity">equivalence_thm</span> <span class="main">=</span> 
  <span class="main">{</span>classname <span class="main">=</span> <span class="main">(</span><span class="main">#</span>classname <span class="entity">cl_info</span><span class="main">)</span><span class="main">,</span> class <span class="main">=</span> <span class="main">(</span><span class="main">#</span>class <span class="entity">cl_info</span><span class="main">)</span><span class="main">,</span> params <span class="main">=</span> <span class="main">(</span><span class="main">#</span>params <span class="entity">cl_info</span><span class="main">)</span><span class="main">,</span> class_law <span class="main">=</span> <span class="main">(</span><span class="main">#</span>class_law <span class="entity">cl_info</span><span class="main">)</span><span class="main">,</span> class_law_const <span class="main">=</span> <span class="main">(</span><span class="main">#</span>class_law_const <span class="entity">cl_info</span><span class="main">)</span><span class="main">,</span> ops <span class="main">=</span> <span class="main">(</span><span class="main">#</span>ops <span class="entity">cl_info</span><span class="main">)</span><span class="main">,</span> transfer_law <span class="main">=</span> <span class="main">(</span><span class="main">#</span>transfer_law <span class="entity">cl_info</span><span class="main">)</span><span class="main">,</span> axioms <span class="main">=</span> <span class="main">(</span><span class="main">#</span>axioms <span class="entity">cl_info</span><span class="main">)</span><span class="main">,</span> axioms_def <span class="main">=</span> <span class="main">(</span><span class="main">#</span>axioms_def <span class="entity">cl_info</span><span class="main">)</span><span class="main">,</span> class_def <span class="main">=</span> <span class="main">(</span><span class="main">#</span>class_def <span class="entity">cl_info</span><span class="main">)</span><span class="main">,</span> equivalence_thm <span class="main">=</span> SOME <span class="entity">equivalence_thm</span><span class="main">}</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">make_rep</span> <span class="entity">T</span> <span class="entity">lthy</span> <span class="entity">conv_func</span> <span class="main">(</span><span class="entity">btype</span><span class="main">,</span><span class="entity">bname</span><span class="main">)</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span> 
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">term</span> <span class="main">=</span> 
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">btype</span> <span class="keyword2"><span class="keyword">of</span></span>
      <span class="main">(</span>TFree <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">conv_func</span> $ <span class="main">(</span>Free <span class="main">(</span><span class="entity">bname</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span> <span class="main">|</span>
      <span class="main">(</span>Type <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_polymorphic</span> <span class="entity">btype</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="entity">get_mapping_function</span> <span class="entity">lthy</span> <span class="entity">btype</span><span class="main">)</span> $ <span class="entity">conv_func</span> $ <span class="main">(</span>Free <span class="main">(</span><span class="entity">bname</span><span class="main">,</span> dummyT<span class="main">)</span><span class="main">)</span>
                                              <span class="keyword2"><span class="keyword">else</span></span> Free <span class="main">(</span><span class="entity">bname</span><span class="main">,</span> <span class="entity">btype</span><span class="main">)</span> <span class="main">|</span>
       <span class="main">_</span> <span class="main">=&gt;</span> Free <span class="main">(</span><span class="entity">bname</span><span class="main">,</span> <span class="entity">btype</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span> hd <span class="main">(</span>Type_Infer_Context.infer_types <span class="entity">lthy</span> <span class="main">[</span><span class="entity">term</span><span class="main">]</span><span class="main">)</span> 
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">from_rep</span> <span class="entity">T</span> <span class="entity">lthy</span> <span class="entity">conv_func</span> <span class="entity">inner_term</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span> 
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">term</span> <span class="main">=</span> 
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">T</span> <span class="keyword2"><span class="keyword">of</span></span>
      <span class="main">(</span>TFree <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">conv_func</span> $ <span class="entity">inner_term</span> <span class="main">|</span>
      <span class="main">(</span>Type <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_polymorphic</span> <span class="entity">T</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="entity">get_mapping_function</span> <span class="entity">lthy</span> <span class="entity">T</span><span class="main">)</span> $ <span class="entity">conv_func</span> $ <span class="entity">inner_term</span>
                                           <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">inner_term</span> <span class="main">|</span>
       <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">inner_term</span>
  <span class="keyword2"><span class="keyword">in</span></span> hd <span class="main">(</span>Type_Infer_Context.infer_types <span class="entity">lthy</span> <span class="main">[</span><span class="entity">term</span><span class="main">]</span><span class="main">)</span> 
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Generate instance for Mu-combinator type *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">instantiate_combinator_type</span> <span class="main">(</span><span class="entity">ty_info</span> <span class="main">:</span> <span class="entity">type_info</span><span class="main">)</span> <span class="main">(</span><span class="entity">cl_info</span> <span class="main">:</span> <span class="entity">class_info</span><span class="main">)</span> <span class="entity">constr_names</span> <span class="entity">lthy</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tname</span> <span class="main">=</span> <span class="main">#</span>tname <span class="entity">ty_info</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctr_type</span> <span class="main">=</span>  <span class="main">#</span>rep_type_instantiated <span class="main">(</span>the <span class="main">(</span><span class="main">#</span>comb_info <span class="entity">ty_info</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rep_type</span> <span class="main">=</span> <span class="main">#</span>rep_type <span class="main">(</span><span class="main">#</span>rep_info <span class="entity">ty_info</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">comb_type_name</span> <span class="main">=</span> <span class="main">#</span>combname <span class="main">(</span>the <span class="main">(</span><span class="main">#</span>comb_info <span class="entity">ty_info</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">comb_type_name_full</span> <span class="main">=</span> <span class="main">#</span>combname_full <span class="main">(</span>the <span class="main">(</span><span class="main">#</span>comb_info <span class="entity">ty_info</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">class</span> <span class="main">=</span> <span class="main">#</span>class <span class="entity">cl_info</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">params</span> <span class="main">=</span> the <span class="main">(</span><span class="main">#</span>params <span class="entity">cl_info</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sum_type_name</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">constr_names</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">type_name</span><span class="hidden">&gt;</span></span>‹Tagged_Prod_Sum.sum›</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">type_name</span><span class="hidden">&gt;</span></span>‹Sum_Type.sum›</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prod_type_name</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">constr_names</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">type_name</span><span class="hidden">&gt;</span></span>‹Tagged_Prod_Sum.prod›</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">type_name</span><span class="hidden">&gt;</span></span>‹Product_Type.prod›</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="main">(</span><span class="inner_quoted">"Generating instance for type "</span> ^ quote <span class="entity">comb_type_name</span><span class="main">)</span> |&gt; writeln

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">define_modular_sum_prod</span> <span class="entity">def</span> <span class="entity">vars</span> <span class="entity">opname</span> <span class="entity">opT</span> <span class="entity">opT_var</span> <span class="entity">is_sum</span> <span class="entity">lthy</span> <span class="main">=</span> 
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_tvars</span> <span class="entity">vars</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">vars</span> 
            <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">(</span>TVar <span class="main">(</span><span class="main">(</span><span class="inner_quoted">"'a"</span><span class="main">,</span><span class="inner_numeral">0</span><span class="main">)</span><span class="main">,</span><span class="entity">class</span><span class="main">)</span><span class="main">)</span><span class="main">,</span><span class="main">(</span>TVar <span class="main">(</span><span class="main">(</span><span class="inner_quoted">"'b"</span><span class="main">,</span><span class="inner_numeral">0</span><span class="main">)</span><span class="main">,</span><span class="entity">class</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
            <span class="keyword2"><span class="keyword">else</span></span> 
              <span class="keyword2"><span class="keyword">let</span></span> 
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">var</span> <span class="main">=</span> hd <span class="entity">vars</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">varTname</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_typeT</span> <span class="entity">var</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">var</span> |&gt; dest_Type |&gt; fst <span class="keyword2"><span class="keyword">else</span></span> <span class="inner_quoted">""</span>
              <span class="keyword2"><span class="keyword">in</span></span>
                <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_sum</span> <span class="keyword2"><span class="keyword">then</span></span> 
                  <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">varTname</span> <span class="main">=</span> <span class="entity">sum_type_name</span> 
                    <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">var</span> |&gt; dest_Type |&gt; snd |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">Ts</span> <span class="main">=&gt;</span> <span class="main">(</span>hd <span class="entity">Ts</span><span class="main">,</span> hd <span class="main">(</span>tl <span class="entity">Ts</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> 
                    <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">get_tvars</span> <span class="main">(</span><span class="main">(</span><span class="entity">var</span> |&gt; dest_Type |&gt; snd<span class="main">)</span>@<span class="main">(</span>tl <span class="entity">vars</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                <span class="keyword2"><span class="keyword">else</span></span>
                  <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">varTname</span> <span class="main">=</span> <span class="entity">prod_type_name</span> 
                    <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">var</span> |&gt; dest_Type |&gt; snd |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">Ts</span> <span class="main">=&gt;</span> <span class="main">(</span>hd <span class="entity">Ts</span><span class="main">,</span> hd <span class="main">(</span>tl <span class="entity">Ts</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> 
                    <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">get_tvars</span> <span class="main">(</span><span class="main">(</span><span class="entity">var</span> |&gt; dest_Type |&gt; snd<span class="main">)</span>@<span class="main">(</span>tl <span class="entity">vars</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
              <span class="keyword2"><span class="keyword">end</span></span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">replace_tfree</span> <span class="entity">tfree</span> <span class="entity">replacement</span> <span class="entity">T</span> <span class="main">=</span> 
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">tfree</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">replacement</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">T</span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">replace_op_call</span> <span class="entity">opname</span> <span class="entity">T</span> <span class="entity">replacement</span> <span class="entity">t</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">t</span> <span class="main">=</span> Const <span class="main">(</span><span class="entity">opname</span><span class="main">,</span><span class="entity">T</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">replacement</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">t</span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_TFree</span> <span class="main">(</span>TFree <span class="main">_</span><span class="main">)</span> <span class="main">=</span> true <span class="main">|</span> <span class="entity">is_TFree</span> <span class="main">_</span> <span class="main">=</span> false
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">remove_constraints</span> <span class="entity">T</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_TFree</span> <span class="entity">T</span> <span class="keyword2"><span class="keyword">then</span></span> dest_TFree <span class="entity">T</span> |&gt; apsnd <span class="main">(</span>K <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">sort</span><span class="hidden">&gt;</span></span><span class="quoted">‹type›</span></span><span class="main">)</span> |&gt; TFree <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">T</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">varTs</span> <span class="main">=</span> map <span class="main">(</span>dest_Var #&gt; snd<span class="main">)</span> <span class="entity">vars</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">left</span><span class="main">,</span><span class="entity">right</span><span class="main">)</span> <span class="main">=</span> <span class="entity">get_tvars</span> <span class="main">(</span><span class="entity">varTs</span> @ <span class="main">[</span>strip_type <span class="entity">opT_var</span> |&gt; snd<span class="main">]</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">op_tfree</span> <span class="main">=</span> Term.add_tfreesT <span class="entity">opT</span> <span class="main">[</span><span class="main">]</span> |&gt; hd |&gt; TFree
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">left_opT</span> <span class="main">=</span> map_atyps <span class="main">(</span><span class="entity">replace_tfree</span> <span class="entity">op_tfree</span> <span class="entity">left</span><span class="main">)</span> <span class="entity">opT</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">right_opT</span> <span class="main">=</span> map_atyps <span class="main">(</span><span class="entity">replace_tfree</span> <span class="entity">op_tfree</span> <span class="entity">right</span><span class="main">)</span> <span class="entity">opT</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">opname_left</span> <span class="main">=</span> <span class="main">(</span>Long_Name.base_name <span class="entity">opname</span><span class="main">)</span> ^ <span class="inner_quoted">"_left"</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">opname_right</span> <span class="main">=</span> <span class="main">(</span>Long_Name.base_name <span class="entity">opname</span><span class="main">)</span> ^ <span class="inner_quoted">"_right"</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">var_left</span> <span class="main">=</span> <span class="main">(</span>Var <span class="main">(</span><span class="main">(</span><span class="entity">opname_left</span><span class="main">,</span><span class="inner_numeral">0</span><span class="main">)</span><span class="main">,</span><span class="entity">left_opT</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">var_right</span> <span class="main">=</span> <span class="main">(</span>Var <span class="main">(</span><span class="main">(</span><span class="entity">opname_right</span><span class="main">,</span><span class="inner_numeral">0</span><span class="main">)</span><span class="main">,</span><span class="entity">right_opT</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">def_left</span> <span class="main">=</span> map_aterms <span class="main">(</span><span class="entity">replace_op_call</span> <span class="entity">opname</span> <span class="entity">left_opT</span> <span class="entity">var_left</span><span class="main">)</span> <span class="entity">def</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">def_right</span> <span class="main">=</span> map_aterms <span class="main">(</span><span class="entity">replace_op_call</span> <span class="entity">opname</span> <span class="entity">right_opT</span> <span class="entity">var_right</span><span class="main">)</span> <span class="entity">def_left</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">return_type</span> <span class="main">=</span> strip_type <span class="entity">opT_var</span> |&gt; snd 
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">def_name</span> <span class="main">=</span> <span class="main">(</span>Long_Name.base_name <span class="entity">opname</span><span class="main">)</span> ^ <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_sum</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="inner_quoted">"_sum_modular"</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="inner_quoted">"_prod_modular"</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq_head</span> <span class="main">=</span> Free <span class="main">(</span><span class="entity">def_name</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="entity">left_opT</span><span class="main">,</span><span class="entity">right_opT</span><span class="main">]</span>@<span class="entity">varTs</span><span class="main">)</span> ---&gt; <span class="entity">return_type</span><span class="main">)</span>
          |&gt; Logic.unvarify_types_global
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span> map Logic.unvarify_global <span class="main">(</span><span class="main">[</span><span class="entity">var_left</span><span class="main">,</span><span class="entity">var_right</span><span class="main">]</span> @ <span class="entity">vars</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq</span> <span class="main">=</span> <span class="entity">HOLogic.Trueprop</span> $ 
          <span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="main">(</span>list_comb <span class="main">(</span><span class="entity">eq_head</span><span class="main">,</span><span class="entity">args</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> Logic.unvarify_global <span class="entity">def_right</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq'</span> <span class="main">=</span> map_types <span class="main">(</span>map_atyps <span class="entity">remove_constraints</span><span class="main">)</span> <span class="entity">eq</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="entity">def_thm</span><span class="main">)</span><span class="main">)</span><span class="main">,</span><span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Specification.definition</span> NONE <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span><span class="main">(</span>Binding.empty<span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">eq'</span><span class="main">)</span> <span class="entity">lthy</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">left</span> <span class="main">=</span> <span class="entity">left</span> |&gt; dest_TVar |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">s</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">,</span><span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> TFree <span class="main">(</span><span class="entity">s</span><span class="main">,</span><span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">sort</span><span class="hidden">&gt;</span></span><span class="quoted">‹type›</span></span><span class="main">)</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">right</span> <span class="main">=</span> <span class="entity">right</span> |&gt; dest_TVar |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">s</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">,</span><span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> TFree <span class="main">(</span><span class="entity">s</span><span class="main">,</span><span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">sort</span><span class="hidden">&gt;</span></span><span class="quoted">‹type›</span></span><span class="main">)</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">def_const</span> <span class="main">=</span> Thm.hyps_of <span class="entity">def_thm</span> |&gt; hd |&gt; Logic.dest_equals |&gt; snd
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt_thy</span> <span class="main">=</span> Proof_Context.init_global <span class="main">(</span>Proof_Context.theory_of <span class="entity">lthy'</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">def_thm</span> <span class="main">=</span> singleton <span class="main">(</span>Proof_Context.export <span class="entity">lthy'</span> <span class="entity">ctxt_thy</span><span class="main">)</span> <span class="entity">def_thm</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="entity">left</span><span class="main">,</span><span class="entity">right</span><span class="main">,</span><span class="entity">def_const</span><span class="main">,</span><span class="entity">def_thm</span><span class="main">,</span><span class="entity">lthy'</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">op_instance</span> <span class="entity">opname</span> <span class="entity">opT</span> <span class="entity">T</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">replace_tfree</span> <span class="entity">tfree</span> <span class="entity">replacement</span> <span class="entity">T</span> <span class="main">=</span> 
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">tfree</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">replacement</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">T</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">op_tfree</span> <span class="main">=</span> Term.add_tfreesT <span class="entity">opT</span> <span class="main">[</span><span class="main">]</span> |&gt; hd |&gt; TFree
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">opT_new</span> <span class="main">=</span> map_atyps <span class="main">(</span><span class="entity">replace_tfree</span> <span class="entity">op_tfree</span> <span class="entity">T</span><span class="main">)</span> <span class="entity">opT</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        Const <span class="main">(</span><span class="entity">opname</span><span class="main">,</span><span class="entity">opT_new</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">sum_prod_instance</span> <span class="entity">term</span> <span class="entity">lvar</span> <span class="entity">rvar</span> <span class="entity">lT</span> <span class="entity">rT</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">replace_vars</span> <span class="entity">var1</span> <span class="entity">var2</span> <span class="entity">replacement1</span> <span class="entity">replacement2</span> <span class="entity">T</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">var1</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">replacement1</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">var2</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">replacement2</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">T</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        map_types <span class="main">(</span>map_atyps <span class="main">(</span><span class="entity">replace_vars</span> <span class="entity">lvar</span> <span class="entity">rvar</span> <span class="entity">lT</span> <span class="entity">rT</span><span class="main">)</span><span class="main">)</span> <span class="entity">term</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">define_modular_instance</span> <span class="entity">T</span> <span class="main">(</span><span class="entity">lvs</span><span class="main">,</span><span class="entity">rvs</span><span class="main">,</span><span class="entity">sum_term</span><span class="main">)</span> <span class="main">(</span><span class="entity">lvp</span><span class="main">,</span><span class="entity">rvp</span><span class="main">,</span><span class="entity">prod_term</span><span class="main">)</span> <span class="entity">opname</span> <span class="entity">opT</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_typeT</span> <span class="entity">T</span> 
        <span class="keyword2"><span class="keyword">then</span></span> 
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">tname</span><span class="main">,</span><span class="entity">Ts</span><span class="main">)</span> <span class="main">=</span> dest_Type <span class="entity">T</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">tname</span> <span class="main">=</span> <span class="entity">sum_type_name</span> 
              <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="entity">sum_prod_instance</span> <span class="entity">sum_term</span> <span class="entity">lvs</span> <span class="entity">rvs</span> <span class="main">(</span>hd <span class="entity">Ts</span><span class="main">)</span> <span class="main">(</span>hd <span class="main">(</span>tl <span class="entity">Ts</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> 
                 $ <span class="main">(</span><span class="entity">define_modular_instance</span> <span class="main">(</span>hd <span class="entity">Ts</span><span class="main">)</span> <span class="main">(</span><span class="entity">lvs</span><span class="main">,</span><span class="entity">rvs</span><span class="main">,</span><span class="entity">sum_term</span><span class="main">)</span> <span class="main">(</span><span class="entity">lvp</span><span class="main">,</span><span class="entity">rvp</span><span class="main">,</span><span class="entity">prod_term</span><span class="main">)</span> <span class="entity">opname</span> <span class="entity">opT</span><span class="main">)</span>
                 $ <span class="main">(</span><span class="entity">define_modular_instance</span> <span class="main">(</span>hd <span class="main">(</span>tl <span class="entity">Ts</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="entity">lvs</span><span class="main">,</span><span class="entity">rvs</span><span class="main">,</span><span class="entity">sum_term</span><span class="main">)</span> <span class="main">(</span><span class="entity">lvp</span><span class="main">,</span><span class="entity">rvp</span><span class="main">,</span><span class="entity">prod_term</span><span class="main">)</span> <span class="entity">opname</span> <span class="entity">opT</span><span class="main">)</span>
            <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">tname</span> <span class="main">=</span> <span class="entity">prod_type_name</span> 
              <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="entity">sum_prod_instance</span> <span class="entity">prod_term</span> <span class="entity">lvp</span> <span class="entity">rvp</span> <span class="main">(</span>hd <span class="entity">Ts</span><span class="main">)</span> <span class="main">(</span>hd <span class="main">(</span>tl <span class="entity">Ts</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                 $ <span class="main">(</span><span class="entity">define_modular_instance</span> <span class="main">(</span>hd <span class="entity">Ts</span><span class="main">)</span> <span class="main">(</span><span class="entity">lvs</span><span class="main">,</span><span class="entity">rvs</span><span class="main">,</span><span class="entity">sum_term</span><span class="main">)</span> <span class="main">(</span><span class="entity">lvp</span><span class="main">,</span><span class="entity">rvp</span><span class="main">,</span><span class="entity">prod_term</span><span class="main">)</span> <span class="entity">opname</span> <span class="entity">opT</span><span class="main">)</span>
                 $ <span class="main">(</span><span class="entity">define_modular_instance</span> <span class="main">(</span>hd <span class="main">(</span>tl <span class="entity">Ts</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="entity">lvs</span><span class="main">,</span><span class="entity">rvs</span><span class="main">,</span><span class="entity">sum_term</span><span class="main">)</span> <span class="main">(</span><span class="entity">lvp</span><span class="main">,</span><span class="entity">rvp</span><span class="main">,</span><span class="entity">prod_term</span><span class="main">)</span> <span class="entity">opname</span> <span class="entity">opT</span><span class="main">)</span>
            <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="entity">op_instance</span> <span class="entity">opname</span> <span class="entity">opT</span> <span class="entity">T</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>
        <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="entity">op_instance</span> <span class="entity">opname</span> <span class="entity">opT</span> <span class="entity">T</span><span class="main">)</span>
    
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">change_constraints</span> <span class="entity">constrT</span> <span class="entity">term</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">constraint</span> <span class="main">=</span> Term.add_tfreesT <span class="entity">constrT</span> <span class="main">[</span><span class="main">]</span> |&gt; hd |&gt; snd
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">unconstr_tfrees</span> <span class="main">=</span> Term.add_tfrees <span class="entity">term</span> <span class="main">[</span><span class="main">]</span> |&gt; map TFree
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">constr_names</span> <span class="main">=</span> Name.invent_names <span class="main">(</span>Variable.names_of <span class="entity">lthy</span><span class="main">)</span> <span class="inner_quoted">"a"</span> <span class="main">(</span>replicate <span class="main">(</span>length <span class="entity">unconstr_tfrees</span><span class="main">)</span> <span class="entity">constraint</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">constr_tfrees</span> <span class="main">=</span> map TFree <span class="entity">constr_names</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        subst_atomic_types <span class="main">(</span><span class="entity">unconstr_tfrees</span> ~~ <span class="entity">constr_tfrees</span><span class="main">)</span> <span class="entity">term</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">define_operation_rec</span> <span class="entity">T</span> <span class="main">(</span><span class="entity">opname</span><span class="main">,</span><span class="entity">t</span><span class="main">)</span> <span class="entity">lthy</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>    
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_comb_params</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="main">]</span> <span class="main">|</span>
            <span class="entity">get_comb_params</span> <span class="main">(</span><span class="entity">ty</span>::<span class="entity">tys</span><span class="main">)</span> <span class="main">=</span>
              <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ty</span> <span class="keyword2"><span class="keyword">of</span></span> Type <span class="main">(</span><span class="entity">n</span><span class="main">,</span><span class="entity">tys'</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">n</span> <span class="main">=</span> <span class="entity">comb_type_name_full</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">tys'</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">get_comb_params</span> <span class="main">(</span><span class="entity">tys</span>@<span class="entity">tys'</span><span class="main">)</span> <span class="main">|</span>
                          <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">get_comb_params</span> <span class="entity">tys</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">make_arg</span> <span class="entity">inConst</span> <span class="entity">ctr_type</span> <span class="entity">x</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">T</span> <span class="main">=</span> dest_Free <span class="entity">x</span> |&gt; snd
          <span class="keyword2"><span class="keyword">in</span></span> 
            <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">ctr_type</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">inConst</span> $ <span class="entity">x</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="entity">x</span> |&gt; dest_Free |&gt; apsnd <span class="main">(</span>K dummyT<span class="main">)</span> |&gt; Free<span class="main">)</span> 
          <span class="keyword2"><span class="keyword">end</span></span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">short_opname</span> <span class="main">=</span> Long_Name.base_name <span class="entity">opname</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fun_name</span> <span class="main">=</span> <span class="entity">short_opname</span> ^ <span class="inner_quoted">"_"</span> ^ <span class="entity">comb_type_name</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prod_def_name</span> <span class="main">=</span> <span class="entity">short_opname</span> ^ <span class="inner_quoted">"_prod_def"</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prod_thm</span> <span class="main">=</span> Proof_Context.get_thm <span class="entity">lthy</span> <span class="entity">prod_def_name</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prod_hd</span> <span class="main">=</span> <span class="main">(</span>Thm.full_prop_of <span class="entity">prod_thm</span><span class="main">)</span> |&gt; <span class="entity">HOLogic.dest_Trueprop</span> |&gt; <span class="entity">HOLogic.dest_eq</span> |&gt; fst  
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prod_const</span> <span class="main">=</span> <span class="entity">prod_hd</span> |&gt; <span class="entity">combs_to_list</span> |&gt; hd
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prod_opT</span> <span class="main">=</span> <span class="entity">prod_const</span> |&gt; dest_Const |&gt; snd
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prod_vars_raw</span> <span class="main">=</span> <span class="entity">prod_hd</span> |&gt; <span class="entity">combs_to_list</span> |&gt; tl
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prod_def</span> <span class="main">=</span> <span class="main">(</span>Thm.full_prop_of <span class="entity">prod_thm</span><span class="main">)</span> |&gt; <span class="entity">HOLogic.dest_Trueprop</span> |&gt; <span class="entity">HOLogic.dest_eq</span> |&gt; snd
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lvp</span><span class="main">,</span><span class="entity">rvp</span><span class="main">,</span><span class="entity">prod_def_term</span><span class="main">,</span><span class="entity">prod_def_thm</span><span class="main">,</span><span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">define_modular_sum_prod</span> <span class="entity">prod_def</span> <span class="entity">prod_vars_raw</span> <span class="entity">opname</span> <span class="entity">t</span> <span class="entity">prod_opT</span> false <span class="entity">lthy</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sum_def_name</span> <span class="main">=</span> <span class="entity">short_opname</span> ^ <span class="inner_quoted">"_sum_def"</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sum_thm</span> <span class="main">=</span> Proof_Context.get_thm <span class="entity">lthy</span> <span class="entity">sum_def_name</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sum_hd</span> <span class="main">=</span> <span class="main">(</span>Thm.full_prop_of <span class="entity">sum_thm</span><span class="main">)</span> |&gt; <span class="entity">HOLogic.dest_Trueprop</span> |&gt; <span class="entity">HOLogic.dest_eq</span> |&gt; fst
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sum_const</span> <span class="main">=</span> <span class="entity">sum_hd</span> |&gt; <span class="entity">combs_to_list</span> |&gt; hd
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sum_opT</span> <span class="main">=</span> <span class="entity">sum_const</span> |&gt; dest_Const |&gt; snd
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sum_vars_raw</span> <span class="main">=</span> <span class="entity">sum_hd</span> |&gt; <span class="entity">combs_to_list</span> |&gt; tl
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sum_def</span> <span class="main">=</span> <span class="main">(</span>Thm.full_prop_of <span class="entity">sum_thm</span><span class="main">)</span> |&gt; <span class="entity">HOLogic.dest_Trueprop</span> |&gt; <span class="entity">HOLogic.dest_eq</span> |&gt; snd
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lvs</span><span class="main">,</span><span class="entity">rvs</span><span class="main">,</span><span class="entity">sum_def_term</span><span class="main">,</span><span class="entity">sum_def_thm</span><span class="main">,</span><span class="entity">lthy''</span><span class="main">)</span>  <span class="main">=</span> <span class="entity">define_modular_sum_prod</span> <span class="entity">sum_def</span> <span class="entity">sum_vars_raw</span> <span class="entity">opname</span> <span class="entity">t</span> <span class="entity">sum_opT</span> true <span class="entity">lthy'</span>
        
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">binders</span><span class="main">,</span> <span class="entity">body</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>strip_type <span class="entity">t</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tvar</span> <span class="main">=</span> <span class="entity">get_tvar</span> <span class="main">(</span><span class="entity">body</span> :: <span class="entity">binders</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">comb_params</span> <span class="main">=</span> <span class="entity">get_comb_params</span> <span class="main">[</span><span class="entity">ctr_type</span><span class="main">]</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">T_params</span> <span class="main">=</span> dest_Type <span class="entity">T</span> |&gt; snd
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctr_type'</span> <span class="main">=</span> typ_subst_atomic <span class="main">(</span><span class="entity">comb_params</span> ~~ <span class="entity">T_params</span><span class="main">)</span> <span class="entity">ctr_type</span> 
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">body'</span> <span class="main">=</span> typ_subst_atomic <span class="main">[</span><span class="main">(</span><span class="entity">tvar</span><span class="main">,</span>dummyT<span class="main">)</span><span class="main">]</span> <span class="entity">body</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">binders'</span> <span class="main">=</span> map <span class="main">(</span>typ_subst_atomic <span class="main">[</span><span class="main">(</span><span class="entity">tvar</span><span class="main">,</span><span class="entity">ctr_type'</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="entity">binders</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">opT</span> <span class="main">=</span> <span class="main">(</span>replicate <span class="main">(</span>length <span class="entity">binders</span><span class="main">)</span> dummyT<span class="main">)</span> ---&gt; <span class="entity">body'</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">vars</span> <span class="main">=</span> <span class="main">(</span>Name.invent_names <span class="main">(</span>Variable.names_of <span class="entity">lthy</span><span class="main">)</span> <span class="inner_quoted">"x"</span> <span class="entity">binders'</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">xs</span> <span class="main">=</span> map Free <span class="entity">vars</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inConst_name</span> <span class="main">=</span> Long_Name.qualify <span class="entity">comb_type_name_full</span> <span class="inner_quoted">"In"</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inConst</span> <span class="main">=</span> Const <span class="main">(</span><span class="entity">inConst_name</span><span class="main">,</span> <span class="entity">ctr_type'</span> --&gt; dummyT<span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">xs_lhs</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">make_arg</span> <span class="entity">inConst</span> <span class="entity">ctr_type'</span><span class="main">)</span> <span class="entity">xs</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">modular_instance</span> <span class="main">=</span> <span class="entity">define_modular_instance</span> <span class="entity">rep_type</span> <span class="main">(</span><span class="entity">lvs</span><span class="main">,</span><span class="entity">rvs</span><span class="main">,</span><span class="entity">sum_def_term</span><span class="main">)</span> <span class="main">(</span><span class="entity">lvp</span><span class="main">,</span><span class="entity">rvp</span><span class="main">,</span><span class="entity">prod_def_term</span><span class="main">)</span> <span class="entity">opname</span> <span class="entity">t</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">xs_modular</span> <span class="main">=</span> map <span class="main">(</span>apsnd <span class="main">(</span>K dummyT<span class="main">)</span> #&gt; Free<span class="main">)</span> <span class="entity">vars</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">modular_folded_name</span> <span class="main">=</span> <span class="entity">short_opname</span> ^ <span class="inner_quoted">"_modular_folded"</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">modularT</span> <span class="main">=</span> typ_subst_atomic <span class="main">[</span><span class="main">(</span><span class="entity">tvar</span><span class="main">,</span><span class="entity">rep_type</span><span class="main">)</span><span class="main">]</span> <span class="entity">t</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">modular_instance_eq</span> <span class="main">=</span> <span class="entity">HOLogic.Trueprop</span> $ <span class="entity">HOLogic.mk_eq</span> <span class="main">(</span>Free <span class="main">(</span><span class="entity">modular_folded_name</span><span class="main">,</span> <span class="entity">modularT</span><span class="main">)</span><span class="main">,</span><span class="entity">modular_instance</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">modular_eq_constr</span> <span class="main">=</span> <span class="entity">change_constraints</span> <span class="entity">t</span> <span class="entity">modular_instance_eq</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="entity">modular_folded_thm</span><span class="main">)</span><span class="main">)</span><span class="main">,</span><span class="entity">lthy'''</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Specification.definition</span> NONE <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span><span class="main">(</span>Binding.empty<span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">modular_eq_constr</span><span class="main">)</span> <span class="entity">lthy''</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">modular_unfolded</span> <span class="main">=</span> Local_Defs.unfold <span class="entity">lthy'''</span> <span class="main">[</span><span class="entity">prod_def_thm</span><span class="main">,</span><span class="entity">sum_def_thm</span><span class="main">]</span> <span class="entity">modular_folded_thm</span>
                                 |&gt; Thm.full_prop_of |&gt; <span class="entity">HOLogic.dest_Trueprop</span> |&gt; <span class="entity">HOLogic.dest_eq</span> |&gt; snd |&gt; map_types <span class="main">(</span>K dummyT<span class="main">)</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs</span> <span class="main">=</span> list_comb <span class="main">(</span>Free <span class="main">(</span><span class="entity">fun_name</span><span class="main">,</span> <span class="entity">opT</span><span class="main">)</span><span class="main">,</span> <span class="entity">xs_lhs</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_polymorphic</span> <span class="entity">body</span> 
                    <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">inConst</span> $ list_comb <span class="main">(</span><span class="entity">modular_unfolded</span><span class="main">,</span><span class="entity">xs_modular</span><span class="main">)</span> 
                    <span class="keyword2"><span class="keyword">else</span></span> list_comb <span class="main">(</span><span class="entity">modular_unfolded</span><span class="main">,</span><span class="entity">xs_modular</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq</span> <span class="main">=</span> <span class="entity">HOLogic.Trueprop</span> $ <span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span> 
        <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">xs</span> <span class="main">=</span> <span class="main">[</span><span class="main">]</span> <span class="keyword2"><span class="keyword">then</span></span> 
          <span class="entity">Specification.definition</span> NONE <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span><span class="main">(</span>Binding.empty<span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">eq</span><span class="main">)</span> <span class="entity">lthy</span> |&gt; snd
        <span class="keyword2"><span class="keyword">else</span></span> 
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">constr_names</span> <span class="keyword2"><span class="keyword">then</span></span>
             <span class="entity">Function.add_function</span>
               <span class="main">[</span><span class="main">(</span>Binding.name <span class="entity">fun_name</span><span class="main">,</span> NONE<span class="main">,</span> NoSyn<span class="main">)</span><span class="main">]</span>
               <span class="main">[</span><span class="main">(</span><span class="main">(</span>Binding.empty_atts<span class="main">,</span> <span class="entity">eq</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">]</span>
               <span class="entity">Function_Fun.fun_config</span> 
               <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> <span class="entity">Pat_Completeness.pat_completeness_tac</span> <span class="entity">ctxt</span> <span class="inner_numeral">1</span> THEN <span class="entity">auto_tac</span> <span class="entity">ctxt</span><span class="main">)</span>
               <span class="entity">lthy</span> 
             |&gt; snd
             |&gt; <span class="entity">tagged_function_termination_tac</span>
             |&gt; snd
           <span class="keyword2"><span class="keyword">else</span></span>
             <span class="entity">Function_Fun.add_fun</span> 
               <span class="main">[</span><span class="main">(</span>Binding.name <span class="entity">fun_name</span><span class="main">,</span> NONE<span class="main">,</span> NoSyn<span class="main">)</span><span class="main">]</span>
               <span class="main">[</span><span class="main">(</span><span class="main">(</span>Binding.empty_atts<span class="main">,</span> <span class="entity">eq</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">]</span>
               <span class="entity">Function_Fun.fun_config</span> <span class="entity">lthy</span>
    <span class="keyword2"><span class="keyword">end</span></span>
      
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">instantiate_comb_type</span> <span class="entity">lthy</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Local_Theory.exit_global <span class="entity">lthy</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">T</span><span class="main">,</span><span class="entity">xs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Derive_Util.typ_and_vs_of_typname</span> <span class="entity">thy</span> <span class="entity">comb_type_name_full</span> <span class="entity">class</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">filtered_params</span> <span class="main">=</span> 
          <span class="entity">params</span> |&gt; filter <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span><span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> 
            <span class="entity">not_instantiated</span> <span class="entity">thy</span> <span class="entity">comb_type_name_full</span> <span class="entity">c</span> <span class="keyword1"><span class="keyword">andalso</span></span>
            <span class="entity">not_instantiated</span> <span class="entity">thy</span> <span class="entity">tname</span> <span class="entity">c</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">fun</span></span>  
          <span class="entity">define_operations_rec_aux</span> <span class="main">_</span> <span class="main">[</span><span class="main">]</span> <span class="entity">lthy</span> <span class="main">=</span> <span class="entity">lthy</span> <span class="main">|</span>
          <span class="entity">define_operations_rec_aux</span> <span class="entity">ty</span> <span class="main">(</span><span class="entity">p</span>::<span class="entity">ps</span><span class="main">)</span> <span class="entity">lthy</span> <span class="main">=</span> <span class="entity">define_operations_rec_aux</span> <span class="entity">ty</span> <span class="entity">ps</span> <span class="main">(</span><span class="entity">define_operation_rec</span> <span class="entity">ty</span> <span class="entity">p</span> <span class="entity">lthy</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="entity">Class.instantiation</span> <span class="main">(</span><span class="main">[</span><span class="entity">comb_type_name_full</span><span class="main">]</span><span class="main">,</span> <span class="entity">xs</span><span class="main">,</span> <span class="entity">class</span><span class="main">)</span> <span class="entity">thy</span>
        |&gt; <span class="main">(</span><span class="entity">define_operations_rec_aux</span> <span class="entity">T</span> <span class="main">(</span>map snd <span class="entity">filtered_params</span><span class="main">)</span><span class="main">)</span> 
      <span class="keyword2"><span class="keyword">end</span></span>
      
    <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">instantiate_comb_type</span> <span class="entity">lthy</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">define_operation</span> <span class="entity">lthy</span> <span class="entity">tname</span> <span class="entity">T</span> <span class="main">(</span><span class="entity">opname</span><span class="main">,</span><span class="entity">t</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">from_name</span> <span class="main">=</span> <span class="inner_quoted">"from_"</span> ^ Long_Name.base_name <span class="entity">tname</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">from_term</span> <span class="main">=</span> <span class="main">(</span>Proof_Context.read_const <span class="main">{</span>proper <span class="main">=</span> true<span class="main">,</span> strict <span class="main">=</span> true<span class="main">}</span> <span class="entity">lthy</span> <span class="entity">from_name</span><span class="main">)</span> 
                      |&gt; dest_Const |&gt; fst
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">from_func</span> <span class="main">=</span> Const <span class="main">(</span><span class="entity">from_term</span><span class="main">,</span> dummyT<span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">to_name</span> <span class="main">=</span> <span class="inner_quoted">"to_"</span> ^ Long_Name.base_name <span class="entity">tname</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">to_term</span> <span class="main">=</span> <span class="main">(</span>Proof_Context.read_const <span class="main">{</span>proper <span class="main">=</span> true<span class="main">,</span> strict <span class="main">=</span> true<span class="main">}</span> <span class="entity">lthy</span> <span class="entity">to_name</span><span class="main">)</span> 
                      |&gt; dest_Const |&gt; fst
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">to_func</span> <span class="main">=</span> Const <span class="main">(</span><span class="entity">to_term</span><span class="main">,</span> dummyT<span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">binders</span><span class="main">,</span> <span class="entity">body</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>strip_type <span class="entity">t</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tvar</span> <span class="main">=</span> <span class="entity">get_tvar</span> <span class="main">(</span><span class="entity">body</span> :: <span class="entity">binders</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">body'</span> <span class="main">=</span> typ_subst_atomic <span class="main">[</span><span class="main">(</span><span class="entity">tvar</span><span class="main">,</span>dummyT<span class="main">)</span><span class="main">]</span> <span class="entity">body</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">binders'</span> <span class="main">=</span> map <span class="main">(</span>typ_subst_atomic <span class="main">[</span><span class="main">(</span><span class="entity">tvar</span><span class="main">,</span><span class="entity">T</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="entity">binders</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">newT</span> <span class="main">=</span> <span class="entity">binders'</span> ---&gt; <span class="entity">body'</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">vars</span> <span class="main">=</span> <span class="main">(</span>Name.invent_names <span class="main">(</span>Variable.names_of <span class="entity">lthy</span><span class="main">)</span> <span class="inner_quoted">"x"</span> <span class="entity">binders'</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">names</span> <span class="main">=</span> map fst <span class="entity">vars</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">xs</span> <span class="main">=</span> map Free <span class="entity">vars</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs</span> <span class="main">=</span> list_comb <span class="main">(</span>Const <span class="main">(</span><span class="entity">opname</span><span class="main">,</span> <span class="entity">newT</span><span class="main">)</span><span class="main">,</span> <span class="entity">xs</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs_inner</span> <span class="main">=</span> list_comb <span class="main">(</span>Const <span class="main">(</span><span class="entity">opname</span><span class="main">,</span> dummyT<span class="main">)</span><span class="main">,</span> map <span class="main">(</span><span class="entity">make_rep</span> <span class="entity">T</span> <span class="entity">lthy</span> <span class="entity">from_func</span><span class="main">)</span> <span class="main">(</span><span class="entity">binders</span> ~~ <span class="entity">names</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span> <span class="entity">from_rep</span> <span class="entity">body</span> <span class="entity">lthy</span> <span class="entity">to_func</span> <span class="entity">rhs_inner</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq</span> <span class="main">=</span> <span class="entity">HOLogic.Trueprop</span> $ <span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="entity">thm</span><span class="main">)</span><span class="main">)</span><span class="main">,</span><span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">Specification.definition</span> NONE <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span><span class="main">(</span>Binding.empty<span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">eq</span><span class="main">)</span> <span class="entity">lthy</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span> 
    <span class="main">(</span><span class="entity">thm</span><span class="main">,</span><span class="entity">lthy'</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">define_operations</span> <span class="entity">ps</span> <span class="entity">ty</span> <span class="entity">lthy</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">let</span></span> 
  <span class="keyword1"><span class="keyword">fun</span></span> 
    <span class="entity">define_operations_aux</span> <span class="main">[</span><span class="main">]</span> <span class="main">_</span> <span class="entity">thms</span> <span class="entity">lthy</span> <span class="main">=</span> <span class="main">(</span><span class="entity">thms</span><span class="main">,</span><span class="entity">lthy</span><span class="main">)</span> <span class="main">|</span>
    <span class="entity">define_operations_aux</span> <span class="main">(</span><span class="entity">p</span>::<span class="entity">ps</span><span class="main">)</span> <span class="main">(</span><span class="entity">tname</span><span class="main">,</span><span class="entity">T</span><span class="main">)</span> <span class="entity">thms</span> <span class="entity">lthy</span> <span class="main">=</span>  
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">not_instantiated</span> <span class="main">(</span>Proof_Context.theory_of <span class="entity">lthy</span><span class="main">)</span> <span class="entity">tname</span> <span class="main">(</span>fst <span class="entity">p</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">then</span></span> 
        <span class="keyword2"><span class="keyword">let</span></span>  
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">thm</span><span class="main">,</span><span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">define_operation</span> <span class="entity">lthy</span> <span class="entity">tname</span> <span class="entity">T</span> <span class="main">(</span>snd <span class="entity">p</span><span class="main">)</span> 
        <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">define_operations_aux</span> <span class="entity">ps</span> <span class="main">(</span><span class="entity">tname</span><span class="main">,</span><span class="entity">T</span><span class="main">)</span> <span class="main">(</span><span class="entity">thm</span> :: <span class="entity">thms</span><span class="main">)</span> <span class="entity">lthy'</span>
        <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">params</span> <span class="main">=</span> <span class="main">#</span>defs <span class="main">(</span>the_default <span class="main">{</span>defs<span class="main">=</span><span class="main">[</span><span class="main">]</span><span class="main">}</span> <span class="main">(</span><span class="entity">get_inst_info</span> <span class="main">(</span>Proof_Context.theory_of <span class="entity">lthy</span><span class="main">)</span> <span class="main">(</span>fst <span class="entity">p</span><span class="main">)</span> <span class="entity">tname</span><span class="main">)</span><span class="main">)</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">names</span> <span class="main">=</span> map <span class="main">(</span>Thm.full_prop_of #&gt; <span class="entity">HOLogic.dest_Trueprop</span> #&gt; <span class="entity">HOLogic.dest_eq</span> #&gt; fst #&gt; strip_comb #&gt; fst #&gt; dest_Const #&gt; fst<span class="main">)</span> <span class="entity">params</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm</span> <span class="main">=</span> the <span class="main">(</span>AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">(</span><span class="entity">names</span> ~~ <span class="entity">params</span><span class="main">)</span> <span class="main">(</span>fst <span class="main">(</span>snd <span class="entity">p</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">define_operations_aux</span> <span class="entity">ps</span> <span class="main">(</span><span class="entity">tname</span><span class="main">,</span><span class="entity">T</span><span class="main">)</span> <span class="main">(</span><span class="entity">thm</span> :: <span class="entity">thms</span><span class="main">)</span> <span class="entity">lthy</span>
        <span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword2"><span class="keyword">in</span></span>
  <span class="entity">define_operations_aux</span> <span class="entity">ps</span> <span class="entity">ty</span> <span class="main">[</span><span class="main">]</span> <span class="entity">lthy</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">abstract_over_vars</span> <span class="entity">vars</span> <span class="entity">t</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">varnames</span> <span class="main">=</span> map dest_Free <span class="entity">vars</span> |&gt; map fst
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">varmapping</span> <span class="main">=</span> <span class="entity">varnames</span> ~~ <span class="main">(</span>List.tabulate <span class="main">(</span>length <span class="entity">vars</span><span class="main">,</span> I<span class="main">)</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">increment_bounds</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">v</span><span class="main">,</span><span class="entity">n</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">v</span><span class="main">,</span><span class="entity">n</span> + <span class="inner_numeral">1</span><span class="main">)</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">fun</span></span> 
              <span class="entity">insert_bounds</span> <span class="entity">varmapping</span> <span class="main">(</span>Free <span class="main">(</span><span class="entity">s</span><span class="main">,</span><span class="entity">T</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> 
                <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">varmapping</span> <span class="entity">s</span> <span class="keyword2"><span class="keyword">of</span></span>
                  NONE <span class="main">=&gt;</span> Free <span class="main">(</span><span class="entity">s</span><span class="main">,</span><span class="entity">T</span><span class="main">)</span> <span class="main">|</span>
                  SOME <span class="entity">i</span> <span class="main">=&gt;</span> Bound <span class="entity">i</span><span class="main">)</span> <span class="main">|</span> 
              <span class="entity">insert_bounds</span> <span class="entity">varmapping</span> <span class="main">(</span>Abs <span class="main">(</span><span class="entity">x</span><span class="main">,</span><span class="entity">T</span><span class="main">,</span><span class="entity">t</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Abs <span class="main">(</span><span class="entity">x</span><span class="main">,</span><span class="entity">T</span><span class="main">,</span><span class="entity">insert_bounds</span> <span class="main">(</span><span class="entity">increment_bounds</span> <span class="entity">varmapping</span><span class="main">)</span> <span class="entity">t</span><span class="main">)</span> <span class="main">|</span>
              <span class="entity">insert_bounds</span> <span class="entity">varmapping</span> <span class="main">(</span><span class="entity">s</span> $ <span class="entity">t</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">insert_bounds</span> <span class="entity">varmapping</span> <span class="entity">s</span><span class="main">)</span> $ <span class="main">(</span><span class="entity">insert_bounds</span> <span class="entity">varmapping</span> <span class="entity">t</span><span class="main">)</span> <span class="main">|</span>
              <span class="entity">insert_bounds</span> <span class="main">_</span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">t</span>
            <span class="keyword1"><span class="keyword">fun</span></span> 
              <span class="entity">abstract</span> <span class="main">[</span><span class="main">]</span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">insert_bounds</span> <span class="entity">varmapping</span> <span class="entity">t</span> <span class="main">|</span>
              <span class="entity">abstract</span> <span class="main">(</span><span class="entity">x</span>::<span class="entity">xs</span><span class="main">)</span> <span class="entity">t</span> <span class="main">=</span> <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span>‹Pure.all›</span><span class="main">,</span>dummyT<span class="main">)</span><span class="main">)</span> $ <span class="main">(</span>Abs <span class="main">(</span><span class="entity">x</span><span class="main">,</span> dummyT<span class="main">,</span> <span class="entity">abstract</span> <span class="entity">xs</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span>          
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">vars</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="entity">abstract</span> <span class="entity">varnames</span> <span class="entity">t</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Adds functions that convert a type to and from its product-sum representation *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">define_prod_sum_conv</span> <span class="main">(</span><span class="entity">ty_info</span> <span class="main">:</span> <span class="entity">type_info</span><span class="main">)</span> <span class="entity">constr_names</span> <span class="entity">lthy</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tnames</span> <span class="main">=</span> <span class="main">#</span>mutual_tnames <span class="entity">ty_info</span> 
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Ts</span> <span class="main">=</span> <span class="main">#</span>mutual_Ts <span class="entity">ty_info</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctrs</span> <span class="main">=</span> <span class="main">#</span>mutual_ctrs <span class="entity">ty_info</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sels</span> <span class="main">=</span> <span class="main">#</span>mutual_sels <span class="entity">ty_info</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">is_recursive</span> <span class="main">=</span> <span class="main">#</span>is_rec <span class="entity">ty_info</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">is_mutually_recursive</span> <span class="main">=</span> <span class="main">#</span>is_mutually_rec <span class="entity">ty_info</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">tyco</span> <span class="main">=&gt;</span> <span class="inner_quoted">"Generating conversions for type "</span> ^ quote <span class="entity">tyco</span><span class="main">)</span> <span class="entity">tnames</span>
      |&gt; cat_lines |&gt; writeln

    <span class="comment1">(* Functions to deal with tagged products and sums *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">str_optT</span> <span class="main">=</span> <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span><span class="quoted">‹string option›</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">none_str_opt</span> <span class="main">=</span> Const <span class="main">(</span><span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span>‹None›</span><span class="main">,</span> <span class="entity">str_optT</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">some_str</span> <span class="entity">s</span> <span class="main">=</span> Const <span class="main">(</span><span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span>‹Some›</span><span class="main">,</span> <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span><span class="quoted">‹string›</span></span> --&gt; <span class="entity">str_optT</span><span class="main">)</span> $ <span class="entity">HOLogic.mk_string</span> <span class="entity">s</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dummy_str_opt</span> <span class="main">=</span> <span class="main">(</span>Term.dummy_pattern <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span><span class="quoted">‹string option›</span></span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sum_type_name</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">constr_names</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">type_name</span><span class="hidden">&gt;</span></span>‹Tagged_Prod_Sum.sum›</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">type_name</span><span class="hidden">&gt;</span></span>‹Sum_Type.sum›</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prod_type_name</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">constr_names</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">type_name</span><span class="hidden">&gt;</span></span>‹Tagged_Prod_Sum.prod›</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">type_name</span><span class="hidden">&gt;</span></span>‹Product_Type.prod›</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prod_constr_name</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">constr_names</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span>‹Tagged_Prod_Sum.Prod›</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span>‹Product_Type.Pair›</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inl_constr_name</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">constr_names</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span>‹Tagged_Prod_Sum.Inl›</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span>‹Sum_Type.Inl›</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inr_constr_name</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">constr_names</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span>‹Tagged_Prod_Sum.Inr›</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span>‹Sum_Type.Inr›</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_tagged_prodT</span> <span class="main">(</span><span class="entity">T1</span><span class="main">,</span> <span class="entity">T2</span><span class="main">)</span> <span class="main">=</span> Type <span class="main">(</span><span class="entity">prod_type_name</span><span class="main">,</span> <span class="main">[</span><span class="entity">T1</span><span class="main">,</span> <span class="entity">T2</span><span class="main">]</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_tagged_sumT</span> <span class="entity">LT</span> <span class="entity">RT</span> <span class="main">=</span> Type <span class="main">(</span><span class="entity">sum_type_name</span><span class="main">,</span> <span class="main">[</span><span class="entity">LT</span><span class="main">,</span> <span class="entity">RT</span><span class="main">]</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tagged_pair_const</span> <span class="entity">T1</span> <span class="entity">T2</span> <span class="main">=</span> Const <span class="main">(</span><span class="entity">prod_constr_name</span><span class="main">,</span> <span class="entity">str_optT</span> --&gt; <span class="entity">str_optT</span> --&gt; <span class="entity">T1</span> --&gt; <span class="entity">T2</span> --&gt; <span class="entity">mk_tagged_prodT</span> <span class="main">(</span><span class="entity">T1</span><span class="main">,</span> <span class="entity">T2</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_tagged_prod</span> <span class="main">(</span><span class="main">(</span><span class="entity">t1</span><span class="main">,</span><span class="entity">s1</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">t2</span><span class="main">,</span><span class="entity">s2</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">T1</span> <span class="main">=</span> fastype_of <span class="entity">t1</span> 
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">T2</span> <span class="main">=</span> fastype_of <span class="entity">t2</span> 
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">S1</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">s1</span> <span class="main">=</span> <span class="inner_quoted">""</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">none_str_opt</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">some_str</span> <span class="entity">s1</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">S2</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">s2</span> <span class="main">=</span> <span class="inner_quoted">""</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">none_str_opt</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">some_str</span> <span class="entity">s2</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="entity">tagged_pair_const</span> <span class="entity">T1</span> <span class="entity">T2</span> $ <span class="entity">S1</span> $ <span class="entity">S2</span> $ <span class="entity">t1</span> $ <span class="entity">t2</span><span class="main">,</span><span class="inner_quoted">""</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_tagged_prod_dummy</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">T1</span> <span class="main">=</span> fastype_of <span class="entity">t1</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="entity">T2</span> <span class="main">=</span> fastype_of <span class="entity">t2</span> <span class="keyword2"><span class="keyword">in</span></span>
        <span class="entity">tagged_pair_const</span> <span class="entity">T1</span> <span class="entity">T2</span> $ <span class="entity">dummy_str_opt</span> $ <span class="entity">dummy_str_opt</span> $ <span class="entity">t1</span> $ <span class="entity">t2</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">Inl_const</span> <span class="entity">LT</span> <span class="entity">RT</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">constr_names</span> <span class="keyword2"><span class="keyword">then</span></span> Const <span class="main">(</span><span class="entity">inl_constr_name</span><span class="main">,</span> <span class="entity">str_optT</span> --&gt; <span class="entity">LT</span> --&gt; <span class="entity">mk_tagged_sumT</span> <span class="entity">LT</span> <span class="entity">RT</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">BNF_FP_Util.Inl_const</span> <span class="entity">LT</span> <span class="entity">RT</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_tagged_Inl</span> <span class="entity">n</span> <span class="entity">RT</span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">Inl_const</span> <span class="main">(</span>fastype_of <span class="entity">t</span><span class="main">)</span> <span class="entity">RT</span> $ <span class="entity">n</span> $ <span class="entity">t</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">Inr_const</span> <span class="entity">LT</span> <span class="entity">RT</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">constr_names</span> <span class="keyword2"><span class="keyword">then</span></span> Const <span class="main">(</span><span class="entity">inr_constr_name</span><span class="main">,</span> <span class="entity">str_optT</span> --&gt; <span class="entity">RT</span> --&gt; <span class="entity">mk_tagged_sumT</span> <span class="entity">LT</span> <span class="entity">RT</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">BNF_FP_Util.Inr_const</span> <span class="entity">LT</span> <span class="entity">RT</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_tagged_tuple</span> <span class="main">_</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> <span class="entity">HOLogic.unit</span>
      <span class="main">|</span> <span class="entity">mk_tagged_tuple</span> <span class="entity">sels</span> <span class="entity">ts</span> <span class="main">=</span> fst <span class="main">(</span>foldr1 <span class="entity">mk_tagged_prod</span> <span class="main">(</span><span class="entity">ts</span> ~~ <span class="entity">sels</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_tagged_tuple_dummy</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> <span class="entity">HOLogic.unit</span>
      <span class="main">|</span> <span class="entity">mk_tagged_tuple_dummy</span> <span class="entity">ts</span> <span class="main">=</span> foldr1 <span class="entity">mk_tagged_prod_dummy</span> <span class="entity">ts</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_dummy_patterns</span> <span class="main">(</span><span class="entity">c</span> $ <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">c</span> $ <span class="entity">dummy_str_opt</span> <span class="main">|</span>
            <span class="entity">add_dummy_patterns</span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">t</span>

    <span class="comment1">(* simple version for non-recursive types *)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">generate_conversion_eqs</span> <span class="entity">lthy</span> <span class="entity">prefix</span> <span class="main">(</span><span class="main">(</span><span class="entity">tyco</span><span class="main">,</span><span class="entity">ctrs</span><span class="main">)</span><span class="main">,</span><span class="entity">T</span><span class="main">)</span> <span class="entity">sels</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">fun</span></span> 
          <span class="entity">mk_prod_listT</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> <span class="entity">HOLogic.unitT</span> <span class="main">|</span>
          <span class="entity">mk_prod_listT</span> <span class="main">[</span><span class="entity">x</span><span class="main">]</span> <span class="main">=</span> <span class="entity">x</span> <span class="main">|</span>
          <span class="entity">mk_prod_listT</span> <span class="main">(</span><span class="entity">x</span>::<span class="entity">xs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">mk_tagged_prodT</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="main">(</span><span class="entity">mk_prod_listT</span> <span class="entity">xs</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">generate_sum_prodT</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> <span class="entity">HOLogic.unitT</span> <span class="main">|</span>
            <span class="entity">generate_sum_prodT</span> <span class="main">[</span><span class="entity">x</span><span class="main">]</span> <span class="main">=</span> <span class="entity">mk_prod_listT</span> <span class="entity">x</span> <span class="main">|</span>
            <span class="entity">generate_sum_prodT</span> <span class="main">(</span><span class="entity">x</span>::<span class="entity">xs</span><span class="main">)</span> <span class="main">=</span> 
              <span class="keyword2"><span class="keyword">let</span></span> 
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">l</span> <span class="main">=</span> <span class="entity">mk_prod_listT</span> <span class="entity">x</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">r</span> <span class="main">=</span> <span class="entity">generate_sum_prodT</span> <span class="entity">xs</span>
              <span class="keyword2"><span class="keyword">in</span></span>
                <span class="entity">mk_tagged_sumT</span> <span class="entity">l</span> <span class="entity">r</span>
              <span class="keyword2"><span class="keyword">end</span></span>
        
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">generate_conversion_eq</span> <span class="entity">lthy</span> <span class="entity">prefix</span> <span class="main">(</span><span class="entity">cN</span><span class="main">,</span> <span class="entity">Ts</span><span class="main">)</span> <span class="entity">sels</span> <span class="entity">tail_ctrs</span> <span class="main">=</span> 
          <span class="keyword2"><span class="keyword">let</span></span>           
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">c</span> <span class="main">=</span> Const <span class="main">(</span><span class="entity">cN</span><span class="main">,</span> <span class="entity">Ts</span> ---&gt; <span class="entity">T</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sels</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">sels</span> <span class="keyword2"><span class="keyword">then</span></span> replicate <span class="main">(</span>length <span class="entity">Ts</span><span class="main">)</span> <span class="inner_quoted">""</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">sels</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cN_opt</span> <span class="main">=</span> Const <span class="main">(</span><span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span>‹Some›</span><span class="main">,</span> <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span><span class="quoted">‹string›</span></span> --&gt; <span class="entity">str_optT</span><span class="main">)</span> $ <span class="entity">HOLogic.mk_string</span> <span class="main">(</span>Long_Name.base_name <span class="entity">cN</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">xs</span> <span class="main">=</span> map Free <span class="main">(</span>Name.invent_names <span class="main">(</span>Variable.names_of <span class="entity">lthy</span><span class="main">)</span> <span class="inner_quoted">"x"</span> <span class="entity">Ts</span><span class="main">)</span>
            
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">conv_inner</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">tail_ctrs</span> <span class="keyword2"><span class="keyword">of</span></span> 
                              <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">constr_names</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">mk_tagged_tuple</span> <span class="entity">sels</span> <span class="entity">xs</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">HOLogic.mk_tuple</span> <span class="entity">xs</span> <span class="main">|</span>
                              <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">constr_names</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">mk_tagged_Inl</span> <span class="entity">cN_opt</span> <span class="main">(</span><span class="entity">generate_sum_prodT</span> <span class="entity">tail_ctrs</span><span class="main">)</span> <span class="main">(</span><span class="entity">mk_tagged_tuple</span> <span class="entity">sels</span> <span class="entity">xs</span><span class="main">)</span> 
                                                   <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">BNF_FP_Util.mk_Inl</span> <span class="main">(</span><span class="entity">generate_sum_prodT</span> <span class="entity">tail_ctrs</span><span class="main">)</span> <span class="main">(</span><span class="entity">HOLogic.mk_tuple</span> <span class="entity">xs</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prefix</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">tail_ctrs</span> <span class="keyword2"><span class="keyword">of</span></span>
                          <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">constr_names</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="main">(</span>not <span class="main">(</span><span class="entity">HOLogic.is_unit</span> <span class="main">(</span>hd <span class="entity">prefix</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                                  <span class="keyword2"><span class="keyword">then</span></span> 
                                    <span class="main">(</span><span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">butlast</span><span class="main">,</span><span class="entity">last</span><span class="main">)</span> <span class="main">=</span> split_last <span class="entity">prefix</span> 
                                     <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">butlast</span> @ <span class="main">[</span><span class="entity">last</span> |&gt; dest_comb |&gt; fst |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> <span class="entity">t</span> $ <span class="entity">cN_opt</span><span class="main">)</span><span class="main">]</span>
                                     <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>
                                  <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">prefix</span> <span class="main">|</span>
                          <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">prefix</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">conv</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">HOLogic.is_unit</span> <span class="main">(</span>hd <span class="entity">prefix</span><span class="main">)</span> 
                      <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">conv_inner</span>
                      <span class="keyword2"><span class="keyword">else</span></span> Library.foldr <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> $<span class="main">)</span> <span class="main">(</span><span class="entity">prefix</span><span class="main">,</span><span class="entity">conv_inner</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">conv_dummy</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">constr_names</span> 
                               <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">conv_inner</span> <span class="main">=</span> 
                                             <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">tail_ctrs</span> <span class="keyword2"><span class="keyword">of</span></span> 
                                                <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="entity">mk_tagged_tuple</span> <span class="entity">sels</span> <span class="entity">xs</span><span class="main">|</span>
                                                <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">mk_tagged_Inl</span> <span class="main">(</span>Term.dummy_pattern <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span><span class="quoted">‹string option›</span></span><span class="main">)</span> <span class="main">(</span><span class="entity">generate_sum_prodT</span> <span class="entity">tail_ctrs</span><span class="main">)</span> <span class="main">(</span><span class="entity">mk_tagged_tuple_dummy</span> <span class="entity">xs</span><span class="main">)</span>
                                     <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">HOLogic.is_unit</span> <span class="main">(</span>hd <span class="entity">prefix</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">conv_inner</span> 
                                                                        <span class="keyword2"><span class="keyword">else</span></span> Library.foldr <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> $<span class="main">)</span> <span class="main">(</span><span class="main">(</span>map <span class="entity">add_dummy_patterns</span> <span class="entity">prefix</span><span class="main">)</span><span class="main">,</span> <span class="entity">conv_inner</span><span class="main">)</span><span class="main">)</span>
                                     <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>
                               <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">conv</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs_from</span> <span class="main">=</span> <span class="main">(</span>Free <span class="main">(</span><span class="inner_quoted">"from_"</span> ^ <span class="main">(</span>Long_Name.base_name <span class="entity">tyco</span><span class="main">)</span><span class="main">,</span> dummyT<span class="main">)</span><span class="main">)</span> $ list_comb <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">xs</span><span class="main">)</span> 
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs_to</span> <span class="main">=</span> <span class="main">(</span>Free <span class="main">(</span><span class="inner_quoted">"to_"</span> ^ <span class="main">(</span>Long_Name.base_name <span class="entity">tyco</span><span class="main">)</span><span class="main">,</span> dummyT<span class="main">)</span><span class="main">)</span> $ <span class="entity">conv_dummy</span> 
          <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">abstract_over_vars</span> <span class="entity">xs</span> <span class="main">(</span><span class="entity">HOLogic.Trueprop</span> $ <span class="main">(</span><span class="main">(</span><span class="entity">HOLogic.eq_const</span> dummyT<span class="main">)</span> $ <span class="entity">lhs_from</span> $ <span class="entity">conv</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
              <span class="entity">abstract_over_vars</span> <span class="entity">xs</span> <span class="main">(</span><span class="entity">HOLogic.Trueprop</span> $ <span class="main">(</span><span class="main">(</span><span class="entity">HOLogic.eq_const</span> dummyT<span class="main">)</span> $ <span class="entity">lhs_to</span> $ list_comb<span class="main">(</span><span class="entity">c</span><span class="main">,</span><span class="entity">xs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ctrs</span> <span class="keyword2"><span class="keyword">of</span></span> 
          <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span><span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="main">|</span>
          <span class="main">(</span><span class="entity">c</span>::<span class="entity">cs</span><span class="main">)</span> <span class="main">=&gt;</span> 
            <span class="keyword2"><span class="keyword">let</span></span> 
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">s</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">sels</span> <span class="keyword2"><span class="keyword">then</span></span> replicate <span class="main">(</span>length <span class="main">(</span>snd <span class="entity">c</span><span class="main">)</span><span class="main">)</span> <span class="inner_quoted">""</span> <span class="keyword2"><span class="keyword">else</span></span> hd <span class="entity">sels</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ss</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">sels</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span> <span class="keyword2"><span class="keyword">else</span></span> tl <span class="entity">sels</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">new_prefix</span> <span class="main">=</span> 
                  <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">HOLogic.is_unit</span> <span class="main">(</span>hd <span class="entity">prefix</span><span class="main">)</span> 
                  <span class="keyword2"><span class="keyword">then</span></span> 
                    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">constr_names</span> 
                      <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">(</span><span class="entity">Inr_const</span> <span class="main">(</span><span class="entity">generate_sum_prodT</span> <span class="main">[</span><span class="main">(</span>snd <span class="entity">c</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="main">(</span><span class="entity">generate_sum_prodT</span> <span class="main">(</span>map snd <span class="entity">cs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> $ Const <span class="main">(</span><span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span>‹None›</span><span class="main">,</span> <span class="entity">str_optT</span><span class="main">)</span><span class="main">]</span>
                      <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="main">(</span><span class="entity">BNF_FP_Util.Inr_const</span> <span class="main">(</span><span class="entity">generate_sum_prodT</span> <span class="main">[</span><span class="main">(</span>snd <span class="entity">c</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="main">(</span><span class="entity">generate_sum_prodT</span> <span class="main">(</span>map snd <span class="entity">cs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">]</span>
                  <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">prefix</span> @
                    <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">constr_names</span>
                      <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">(</span><span class="entity">Inr_const</span> <span class="main">(</span><span class="entity">generate_sum_prodT</span> <span class="main">[</span><span class="main">(</span>snd <span class="entity">c</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="main">(</span><span class="entity">generate_sum_prodT</span> <span class="main">(</span>map snd <span class="entity">cs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> $ Const <span class="main">(</span><span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span>‹None›</span><span class="main">,</span> <span class="entity">str_optT</span><span class="main">)</span><span class="main">]</span>
                      <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="main">(</span><span class="entity">BNF_FP_Util.Inr_const</span> <span class="main">(</span><span class="entity">generate_sum_prodT</span> <span class="main">[</span><span class="main">(</span>snd <span class="entity">c</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="main">(</span><span class="entity">generate_sum_prodT</span> <span class="main">(</span>map snd <span class="entity">cs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">)</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">from_eq</span><span class="main">,</span><span class="entity">to_eq</span><span class="main">)</span> <span class="main">=</span> <span class="entity">generate_conversion_eq</span> <span class="entity">lthy</span> <span class="entity">prefix</span> <span class="entity">c</span> <span class="entity">s</span> <span class="main">(</span>map snd <span class="entity">cs</span><span class="main">)</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">from_eqs</span><span class="main">,</span><span class="entity">to_eqs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">generate_conversion_eqs</span> <span class="entity">lthy</span> <span class="entity">new_prefix</span> <span class="main">(</span><span class="main">(</span><span class="entity">tyco</span><span class="main">,</span><span class="entity">cs</span><span class="main">)</span><span class="main">,</span><span class="entity">T</span><span class="main">)</span> <span class="entity">ss</span>
            <span class="keyword2"><span class="keyword">in</span></span> 
                <span class="main">(</span><span class="entity">from_eq</span> :: <span class="entity">from_eqs</span><span class="main">,</span> <span class="entity">to_eq</span> :: <span class="entity">to_eqs</span><span class="main">)</span>
            <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword2"><span class="keyword">end</span></span>  

    <span class="comment1">(* version for recursive types *)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">generate_conversion_eqs_rec</span> <span class="entity">lthy</span> <span class="entity">Ts</span> <span class="entity">comb_type</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">tyco</span><span class="main">,</span><span class="entity">ctrs</span><span class="main">)</span><span class="main">,</span><span class="entity">T</span><span class="main">)</span><span class="main">,</span><span class="entity">prefix</span><span class="main">)</span> <span class="entity">sels</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">replace_type_with_comb</span> <span class="entity">T</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">case</span></span> List.find <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span> <span class="entity">x</span> <span class="main">=</span> <span class="entity">T</span><span class="main">)</span> <span class="entity">Ts</span> <span class="keyword2"><span class="keyword">of</span></span>
            NONE <span class="main">=&gt;</span> <span class="entity">T</span> <span class="main">|</span>
            <span class="main">_</span>    <span class="main">=&gt;</span> <span class="entity">comb_type</span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_prod_listT</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> <span class="entity">HOLogic.unitT</span> <span class="main">|</span>
            <span class="entity">mk_prod_listT</span> <span class="main">[</span><span class="entity">x</span><span class="main">]</span> <span class="main">=</span> <span class="entity">replace_type_with_comb</span> <span class="entity">x</span> <span class="main">|</span>
            <span class="entity">mk_prod_listT</span> <span class="main">(</span><span class="entity">x</span>::<span class="entity">xs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">mk_tagged_prodT</span> <span class="main">(</span><span class="entity">replace_type_with_comb</span> <span class="entity">x</span><span class="main">,</span> <span class="main">(</span><span class="entity">mk_prod_listT</span> <span class="entity">xs</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">generate_sum_prodT</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> <span class="entity">HOLogic.unitT</span> <span class="main">|</span>
            <span class="entity">generate_sum_prodT</span> <span class="main">[</span><span class="entity">x</span><span class="main">]</span> <span class="main">=</span> <span class="entity">mk_prod_listT</span> <span class="entity">x</span> <span class="main">|</span>
            <span class="entity">generate_sum_prodT</span> <span class="main">(</span><span class="entity">x</span>::<span class="entity">xs</span><span class="main">)</span> <span class="main">=</span> 
              <span class="keyword2"><span class="keyword">let</span></span> 
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">l</span> <span class="main">=</span> <span class="entity">mk_prod_listT</span> <span class="entity">x</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">r</span> <span class="main">=</span> <span class="entity">generate_sum_prodT</span> <span class="entity">xs</span>
              <span class="keyword2"><span class="keyword">in</span></span>
                <span class="entity">mk_tagged_sumT</span> <span class="entity">l</span> <span class="entity">r</span>
              <span class="keyword2"><span class="keyword">end</span></span>
        
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">generate_conversion_eq</span> <span class="entity">lthy</span> <span class="entity">prefix</span> <span class="main">(</span><span class="entity">cN</span><span class="main">,</span> <span class="entity">Ts</span><span class="main">)</span> <span class="entity">sels</span> <span class="entity">tail_ctrs</span> <span class="main">=</span> 
          <span class="keyword2"><span class="keyword">let</span></span> 
            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_type_name</span> <span class="entity">T</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">T</span> <span class="keyword2"><span class="keyword">of</span></span> Type <span class="main">(</span><span class="entity">s</span><span class="main">,</span><span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">s</span> <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="inner_quoted">""</span>
            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">find_type</span> <span class="entity">T</span> <span class="entity">tycos</span> <span class="main">=</span> List.find <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span> <span class="entity">x</span> <span class="main">=</span> <span class="main">(</span><span class="entity">get_type_name</span> <span class="entity">T</span><span class="main">)</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">x</span> &lt;&gt; <span class="inner_quoted">""</span><span class="main">)</span> <span class="entity">tycos</span> 
            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_comb_type</span> <span class="entity">v</span> <span class="main">=</span> Free <span class="main">(</span><span class="entity">v</span> |&gt; dest_Free |&gt; fst<span class="main">,</span><span class="entity">comb_type</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">from_const</span> <span class="entity">tyco</span> <span class="main">=</span> Free <span class="main">(</span><span class="inner_quoted">"from_"</span> ^ <span class="main">(</span>Long_Name.base_name <span class="entity">tyco</span><span class="main">)</span><span class="main">,</span> dummyT --&gt; dummyT<span class="main">)</span>
            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">to_const</span> <span class="entity">tyco</span> <span class="main">=</span> Free <span class="main">(</span><span class="inner_quoted">"to_"</span> ^ <span class="main">(</span>Long_Name.base_name <span class="entity">tyco</span><span class="main">)</span><span class="main">,</span> dummyT --&gt; dummyT<span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">c</span> <span class="main">=</span> Const <span class="main">(</span><span class="entity">cN</span><span class="main">,</span> <span class="entity">Ts</span> ---&gt; <span class="entity">T</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cN_opt</span> <span class="main">=</span> Const <span class="main">(</span><span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span>‹Some›</span><span class="main">,</span> <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span><span class="quoted">‹string›</span></span> --&gt; <span class="entity">str_optT</span><span class="main">)</span> $ <span class="entity">HOLogic.mk_string</span> <span class="main">(</span>Long_Name.base_name <span class="entity">cN</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">xs</span> <span class="main">=</span> map Free <span class="main">(</span>Name.invent_names <span class="main">(</span>Variable.names_of <span class="entity">lthy</span><span class="main">)</span> <span class="inner_quoted">"x"</span> <span class="entity">Ts</span><span class="main">)</span>
            
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">xs_from</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">v</span><span class="main">,</span><span class="entity">t</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">find_type</span> <span class="entity">t</span> <span class="entity">tnames</span> 
                                           <span class="keyword2"><span class="keyword">of</span></span> NONE <span class="main">=&gt;</span> <span class="entity">v</span> <span class="main">|</span>
                                              <span class="main">_</span>    <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">from_const</span> <span class="main">(</span><span class="entity">get_type_name</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span> $ <span class="entity">v</span><span class="main">)</span>
                          <span class="main">(</span><span class="entity">xs</span> ~~ <span class="entity">Ts</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">xs_to</span>   <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">v</span><span class="main">,</span><span class="entity">t</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">find_type</span> <span class="entity">t</span> <span class="entity">tnames</span> 
                                           <span class="keyword2"><span class="keyword">of</span></span> NONE <span class="main">=&gt;</span> <span class="entity">v</span> <span class="main">|</span>
                                              <span class="main">_</span>    <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">to_const</span> <span class="main">(</span><span class="entity">get_type_name</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span> $ <span class="entity">mk_comb_type</span> <span class="entity">v</span><span class="main">)</span>
                          <span class="main">(</span><span class="entity">xs</span> ~~ <span class="entity">Ts</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">xs_to'</span>  <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">v</span><span class="main">,</span><span class="entity">t</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">find_type</span> <span class="entity">t</span> <span class="entity">tnames</span> 
                                           <span class="keyword2"><span class="keyword">of</span></span> NONE <span class="main">=&gt;</span> <span class="entity">v</span> <span class="main">|</span>
                                              <span class="main">_</span>    <span class="main">=&gt;</span> <span class="entity">mk_comb_type</span> <span class="entity">v</span><span class="main">)</span>
                          <span class="main">(</span><span class="entity">xs</span> ~~ <span class="entity">Ts</span><span class="main">)</span> 

            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prefix</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">tail_ctrs</span> <span class="keyword2"><span class="keyword">of</span></span>
                          <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">constr_names</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="main">(</span>not <span class="main">(</span><span class="entity">HOLogic.is_unit</span> <span class="main">(</span>hd <span class="entity">prefix</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                                  <span class="keyword2"><span class="keyword">then</span></span> 
                                    <span class="main">(</span><span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">butlast</span><span class="main">,</span><span class="entity">last</span><span class="main">)</span> <span class="main">=</span> split_last <span class="entity">prefix</span> 
                                     <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">butlast</span> @ <span class="main">[</span><span class="entity">last</span> |&gt; dest_comb |&gt; fst |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> <span class="entity">t</span> $ <span class="entity">cN_opt</span><span class="main">)</span><span class="main">]</span>
                                     <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>
                                  <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">prefix</span> <span class="main">|</span>
                          <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">prefix</span>

            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">conv_inner_from</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">tail_ctrs</span> <span class="keyword2"><span class="keyword">of</span></span> 
                              <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">constr_names</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">mk_tagged_tuple</span> <span class="entity">sels</span> <span class="entity">xs_from</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">HOLogic.mk_tuple</span> <span class="entity">xs_from</span> <span class="main">|</span>
                              <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">constr_names</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">mk_tagged_Inl</span> <span class="entity">cN_opt</span> <span class="main">(</span><span class="entity">generate_sum_prodT</span> <span class="entity">tail_ctrs</span><span class="main">)</span> <span class="main">(</span><span class="entity">mk_tagged_tuple</span> <span class="entity">sels</span> <span class="entity">xs_from</span><span class="main">)</span>
                                                   <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">BNF_FP_Util.mk_Inl</span> <span class="main">(</span><span class="entity">generate_sum_prodT</span> <span class="entity">tail_ctrs</span><span class="main">)</span> <span class="main">(</span><span class="entity">HOLogic.mk_tuple</span> <span class="entity">xs_from</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">conv_inner_to</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">tail_ctrs</span> <span class="keyword2"><span class="keyword">of</span></span> 
                              <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">constr_names</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">mk_tagged_tuple_dummy</span> <span class="entity">xs_to'</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">HOLogic.mk_tuple</span> <span class="entity">xs_to'</span> <span class="main">|</span>
                              <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">constr_names</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">mk_tagged_Inl</span> <span class="entity">dummy_str_opt</span> <span class="main">(</span><span class="entity">generate_sum_prodT</span> <span class="entity">tail_ctrs</span><span class="main">)</span> <span class="main">(</span><span class="entity">mk_tagged_tuple_dummy</span> <span class="entity">xs_to'</span><span class="main">)</span>
                                                   <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">BNF_FP_Util.mk_Inl</span> <span class="main">(</span><span class="entity">generate_sum_prodT</span> <span class="entity">tail_ctrs</span><span class="main">)</span> <span class="main">(</span><span class="entity">HOLogic.mk_tuple</span> <span class="entity">xs_to'</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">conv_from</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">HOLogic.is_unit</span> <span class="main">(</span>hd <span class="entity">prefix</span><span class="main">)</span> 
                            <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">conv_inner_from</span>
                            <span class="keyword2"><span class="keyword">else</span></span> Library.foldr <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> $<span class="main">)</span> <span class="main">(</span><span class="entity">prefix</span><span class="main">,</span><span class="entity">conv_inner_from</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">conv_to</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">HOLogic.is_unit</span> <span class="main">(</span>hd <span class="entity">prefix</span><span class="main">)</span> 
                            <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">conv_inner_to</span>
                            <span class="keyword2"><span class="keyword">else</span></span> Library.foldr <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> $<span class="main">)</span> <span class="main">(</span><span class="entity">prefix</span><span class="main">,</span><span class="entity">conv_inner_to</span><span class="main">)</span>  
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">conv_dummy</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">constr_names</span> 
                               <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">conv_inner</span> <span class="main">=</span> 
                                             <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">tail_ctrs</span> <span class="keyword2"><span class="keyword">of</span></span> 
                                               <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="entity">mk_tagged_tuple_dummy</span> <span class="entity">xs_to'</span> <span class="main">|</span>
                                               <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">mk_tagged_Inl</span> <span class="entity">dummy_str_opt</span> <span class="main">(</span><span class="entity">generate_sum_prodT</span> <span class="entity">tail_ctrs</span><span class="main">)</span> <span class="main">(</span><span class="entity">mk_tagged_tuple_dummy</span> <span class="entity">xs_to'</span><span class="main">)</span>
                                     <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">HOLogic.is_unit</span> <span class="main">(</span>hd <span class="entity">prefix</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">conv_inner</span> 
                                                                        <span class="keyword2"><span class="keyword">else</span></span> Library.foldr <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> $<span class="main">)</span> <span class="main">(</span><span class="main">(</span>map <span class="entity">add_dummy_patterns</span> <span class="entity">prefix</span><span class="main">)</span><span class="main">,</span> <span class="entity">conv_inner</span><span class="main">)</span><span class="main">)</span>
                                     <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>
                               <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">conv_to</span>
                      

            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs_from</span> <span class="main">=</span> <span class="main">(</span><span class="entity">from_const</span> <span class="entity">tyco</span><span class="main">)</span> $ list_comb <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">xs</span><span class="main">)</span> 
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs_to</span> <span class="main">=</span> <span class="main">(</span><span class="entity">to_const</span> <span class="entity">tyco</span><span class="main">)</span> $ <span class="entity">conv_dummy</span> 
          <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">abstract_over_vars</span> <span class="entity">xs</span> <span class="main">(</span><span class="entity">HOLogic.Trueprop</span> $ <span class="main">(</span><span class="main">(</span><span class="entity">HOLogic.eq_const</span> dummyT<span class="main">)</span> $ <span class="entity">lhs_from</span> $ <span class="entity">conv_from</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
              <span class="entity">abstract_over_vars</span> <span class="entity">xs</span> <span class="main">(</span><span class="entity">HOLogic.Trueprop</span> $ <span class="main">(</span><span class="main">(</span><span class="entity">HOLogic.eq_const</span> dummyT<span class="main">)</span> $ <span class="entity">lhs_to</span> $ list_comb <span class="main">(</span><span class="entity">c</span><span class="main">,</span><span class="entity">xs_to</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ctrs</span> <span class="keyword2"><span class="keyword">of</span></span> 
          <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span><span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="main">|</span>
          <span class="main">(</span><span class="entity">c</span>::<span class="entity">cs</span><span class="main">)</span> <span class="main">=&gt;</span> 
            <span class="keyword2"><span class="keyword">let</span></span>  
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">s</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">sels</span> <span class="keyword2"><span class="keyword">then</span></span> replicate <span class="main">(</span>length <span class="main">(</span>snd <span class="entity">c</span><span class="main">)</span><span class="main">)</span> <span class="inner_quoted">""</span> <span class="keyword2"><span class="keyword">else</span></span> hd <span class="entity">sels</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ss</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">sels</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span> <span class="keyword2"><span class="keyword">else</span></span> tl <span class="entity">sels</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">new_prefix</span> <span class="main">=</span> 
                  <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">HOLogic.is_unit</span> <span class="main">(</span>hd <span class="entity">prefix</span><span class="main">)</span> 
                  <span class="keyword2"><span class="keyword">then</span></span> 
                    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">constr_names</span> 
                      <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">(</span><span class="entity">Inr_const</span> <span class="main">(</span><span class="entity">generate_sum_prodT</span> <span class="main">[</span><span class="main">(</span>snd <span class="entity">c</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="main">(</span><span class="entity">generate_sum_prodT</span> <span class="main">(</span>map snd <span class="entity">cs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> $ Const <span class="main">(</span><span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span>‹None›</span><span class="main">,</span> <span class="entity">str_optT</span><span class="main">)</span><span class="main">]</span>
                      <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="main">(</span><span class="entity">BNF_FP_Util.Inr_const</span> <span class="main">(</span><span class="entity">generate_sum_prodT</span> <span class="main">[</span><span class="main">(</span>snd <span class="entity">c</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="main">(</span><span class="entity">generate_sum_prodT</span> <span class="main">(</span>map snd <span class="entity">cs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">]</span>
                  <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">prefix</span> @
                    <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">constr_names</span>
                      <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">(</span><span class="entity">Inr_const</span> <span class="main">(</span><span class="entity">generate_sum_prodT</span> <span class="main">[</span><span class="main">(</span>snd <span class="entity">c</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="main">(</span><span class="entity">generate_sum_prodT</span> <span class="main">(</span>map snd <span class="entity">cs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> $ Const <span class="main">(</span><span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span>‹None›</span><span class="main">,</span> <span class="entity">str_optT</span><span class="main">)</span><span class="main">]</span>
                      <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="main">(</span><span class="entity">BNF_FP_Util.Inr_const</span> <span class="main">(</span><span class="entity">generate_sum_prodT</span> <span class="main">[</span><span class="main">(</span>snd <span class="entity">c</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="main">(</span><span class="entity">generate_sum_prodT</span> <span class="main">(</span>map snd <span class="entity">cs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">)</span>

              <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">from_eq</span><span class="main">,</span><span class="entity">to_eq</span><span class="main">)</span> <span class="main">=</span> <span class="entity">generate_conversion_eq</span> <span class="entity">lthy</span> <span class="entity">prefix</span> <span class="entity">c</span> <span class="entity">s</span> <span class="main">(</span>map snd <span class="entity">cs</span><span class="main">)</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">from_eqs</span><span class="main">,</span><span class="entity">to_eqs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">generate_conversion_eqs_rec</span> <span class="entity">lthy</span> <span class="entity">Ts</span> <span class="entity">comb_type</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">tyco</span><span class="main">,</span><span class="entity">cs</span><span class="main">)</span><span class="main">,</span><span class="entity">T</span><span class="main">)</span><span class="main">,</span><span class="entity">new_prefix</span><span class="main">)</span> <span class="entity">ss</span>
            <span class="keyword2"><span class="keyword">in</span></span>
                <span class="main">(</span><span class="entity">from_eq</span> :: <span class="entity">from_eqs</span><span class="main">,</span> <span class="entity">to_eq</span> :: <span class="entity">to_eqs</span><span class="main">)</span>
            <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword2"><span class="keyword">end</span></span>  

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">generate_mutual_prefixes</span> <span class="entity">inConst</span> <span class="entity">Ts</span> <span class="entity">mutual_rep_types</span> <span class="main">=</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">generate_sumT</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> <span class="entity">HOLogic.unitT</span> <span class="main">|</span>
              <span class="entity">generate_sumT</span> <span class="main">[</span><span class="entity">x</span><span class="main">]</span> <span class="main">=</span> <span class="entity">x</span> <span class="main">|</span>
              <span class="entity">generate_sumT</span> <span class="main">(</span><span class="entity">x</span>::<span class="entity">xs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">mk_tagged_sumT</span> <span class="entity">x</span> <span class="main">(</span><span class="entity">generate_sumT</span> <span class="entity">xs</span><span class="main">)</span>
          <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">generate_mutual_prefix</span> <span class="entity">rep_types</span> <span class="entity">index</span> <span class="main">=</span> 
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">generate_mutual_prefix_aux</span> <span class="entity">rep_types</span> <span class="entity">index</span> <span class="main">=</span>
              <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">index</span> <span class="keyword2"><span class="keyword">of</span></span>
                <span class="inner_numeral">0</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">constr_names</span> 
                       <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">(</span><span class="entity">Inl_const</span> <span class="main">(</span>hd <span class="entity">rep_types</span><span class="main">)</span> <span class="main">(</span><span class="entity">generate_sumT</span> <span class="main">(</span>tl <span class="entity">rep_types</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> $ <span class="entity">none_str_opt</span><span class="main">]</span>
                       <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="entity">Inl_const</span> <span class="main">(</span>hd <span class="entity">rep_types</span><span class="main">)</span> <span class="main">(</span><span class="entity">generate_sumT</span> <span class="main">(</span>tl <span class="entity">rep_types</span><span class="main">)</span><span class="main">)</span><span class="main">]</span> <span class="main">|</span>
                <span class="entity">n</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">let</span></span> 
                      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inr</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">constr_names</span>
                                  <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="entity">Inr_const</span> <span class="main">(</span>hd <span class="entity">rep_types</span><span class="main">)</span> <span class="main">(</span><span class="entity">generate_sumT</span> <span class="main">(</span>tl <span class="entity">rep_types</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> $ <span class="entity">none_str_opt</span> 
                                  <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">Inr_const</span> <span class="main">(</span>hd <span class="entity">rep_types</span><span class="main">)</span> <span class="main">(</span><span class="entity">generate_sumT</span> <span class="main">(</span>tl <span class="entity">rep_types</span><span class="main">)</span><span class="main">)</span> 
                     <span class="keyword2"><span class="keyword">in</span></span>
                       <span class="keyword2"><span class="keyword">if</span></span> <span class="main">(</span>length <span class="entity">rep_types</span><span class="main">)</span> &gt; <span class="inner_numeral">2</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">inr</span> :: <span class="main">(</span><span class="entity">generate_mutual_prefix_aux</span> <span class="main">(</span>tl <span class="entity">rep_types</span><span class="main">)</span> <span class="main">(</span><span class="entity">n</span>-<span class="inner_numeral">1</span><span class="main">)</span><span class="main">)</span>
                                                 <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="entity">inr</span><span class="main">]</span>
                     <span class="keyword2"><span class="keyword">end</span></span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="entity">inConst</span> :: <span class="main">(</span><span class="entity">generate_mutual_prefix_aux</span> <span class="entity">rep_types</span> <span class="entity">index</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>

          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">indices</span> <span class="main">=</span> List.tabulate <span class="main">(</span>length <span class="entity">Ts</span><span class="main">,</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span> <span class="entity">x</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="main">(</span>map <span class="main">(</span><span class="entity">generate_mutual_prefix</span> <span class="entity">mutual_rep_types</span><span class="main">)</span> <span class="entity">indices</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">end</span></span>
        
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_functions</span> <span class="entity">lthy</span> <span class="main">=</span>
        <span class="keyword2"><span class="keyword">let</span></span> 
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eqs</span> <span class="main">=</span> 
            <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_recursive</span>
            <span class="keyword2"><span class="keyword">then</span></span>
              <span class="keyword2"><span class="keyword">let</span></span>
                <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_mutual_rep_types</span> <span class="entity">ty</span> <span class="entity">n</span> <span class="main">=</span>
                   <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">n</span> <span class="main">=</span> <span class="inner_numeral">1</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="entity">ty</span><span class="main">]</span> <span class="keyword2"><span class="keyword">else</span></span>
                     <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ty</span> <span class="keyword2"><span class="keyword">of</span></span>
                       Type <span class="main">(</span><span class="entity">tname</span><span class="main">,</span> <span class="main">[</span><span class="entity">LT</span><span class="main">,</span> <span class="entity">RT</span><span class="main">]</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">tname</span> <span class="main">=</span> <span class="entity">sum_type_name</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">LT</span> :: <span class="main">(</span><span class="entity">get_mutual_rep_types</span> <span class="entity">RT</span> <span class="main">(</span><span class="entity">n</span>-<span class="inner_numeral">1</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span>Type <span class="main">(</span><span class="entity">tname</span><span class="main">,</span> <span class="main">[</span><span class="entity">LT</span><span class="main">,</span> <span class="entity">RT</span><span class="main">]</span><span class="main">)</span><span class="main">]</span> <span class="main">|</span>
                       <span class="entity">T</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="entity">T</span><span class="main">]</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">comb_type</span> <span class="main">=</span> <span class="main">#</span>comb_type <span class="main">(</span>the <span class="main">(</span><span class="main">#</span>comb_info <span class="entity">ty_info</span><span class="main">)</span><span class="main">)</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inConst_free</span> <span class="main">=</span> <span class="main">#</span>inConst_free <span class="main">(</span>the <span class="main">(</span><span class="main">#</span>comb_info <span class="entity">ty_info</span><span class="main">)</span><span class="main">)</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rep_type_inst</span> <span class="main">=</span> <span class="main">#</span>rep_type_instantiated <span class="main">(</span>the <span class="main">(</span><span class="main">#</span>comb_info <span class="entity">ty_info</span><span class="main">)</span><span class="main">)</span>         
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mutual_rep_types</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_mutually_recursive</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">get_mutual_rep_types</span> <span class="entity">rep_type_inst</span> <span class="main">(</span>length <span class="entity">Ts</span><span class="main">)</span>
                                                                <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="entity">rep_type_inst</span><span class="main">]</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prefixes</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_mutually_recursive</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">generate_mutual_prefixes</span> <span class="entity">inConst_free</span> <span class="entity">Ts</span> <span class="entity">mutual_rep_types</span>
                                                        <span class="keyword2"><span class="keyword">else</span></span> replicate <span class="main">(</span>length <span class="entity">Ts</span><span class="main">)</span> <span class="main">[</span><span class="entity">inConst_free</span><span class="main">]</span>
              <span class="keyword2"><span class="keyword">in</span></span> 
                map2 <span class="main">(</span><span class="entity">generate_conversion_eqs_rec</span> <span class="entity">lthy</span> <span class="entity">Ts</span> <span class="entity">comb_type</span><span class="main">)</span>  <span class="main">(</span><span class="main">(</span><span class="entity">ctrs</span> ~~ <span class="entity">Ts</span><span class="main">)</span> ~~ <span class="entity">prefixes</span><span class="main">)</span> <span class="main">(</span>map snd <span class="entity">sels</span><span class="main">)</span>
              <span class="keyword2"><span class="keyword">end</span></span>
            <span class="keyword2"><span class="keyword">else</span></span>
              map2 <span class="main">(</span><span class="entity">generate_conversion_eqs</span> <span class="entity">lthy</span> <span class="main">[</span><span class="entity">HOLogic.unit</span><span class="main">]</span><span class="main">)</span> <span class="main">(</span><span class="entity">ctrs</span> ~~ <span class="entity">Ts</span><span class="main">)</span> <span class="main">(</span>map snd <span class="entity">sels</span><span class="main">)</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">from_eqs</span> <span class="main">=</span> flat <span class="main">(</span>map fst <span class="entity">eqs</span><span class="main">)</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">to_eqs</span> <span class="main">=</span> flat <span class="main">(</span>map snd <span class="entity">eqs</span><span class="main">)</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">from_info</span><span class="main">,</span><span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span> 
            <span class="entity">add_fun'</span> 
              <span class="main">(</span>map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">tname</span> <span class="main">=&gt;</span> <span class="main">(</span>Binding.name <span class="main">(</span><span class="inner_quoted">"from_"</span> ^ Long_Name.base_name <span class="entity">tname</span><span class="main">)</span><span class="main">,</span> NONE<span class="main">,</span> NoSyn<span class="main">)</span><span class="main">)</span> <span class="entity">tnames</span><span class="main">)</span> 
              <span class="main">(</span>map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">(</span>Binding.empty_atts<span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
                <span class="entity">from_eqs</span><span class="main">)</span>
              <span class="entity">Function_Fun.fun_config</span> 
              <span class="entity">lthy</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">to_info</span><span class="main">,</span><span class="entity">lthy''</span><span class="main">)</span> <span class="main">=</span>
            <span class="entity">add_fun'</span> 
              <span class="main">(</span>map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">tname</span> <span class="main">=&gt;</span> <span class="main">(</span>Binding.name <span class="main">(</span><span class="inner_quoted">"to_"</span> ^ Long_Name.base_name <span class="entity">tname</span><span class="main">)</span><span class="main">,</span> NONE<span class="main">,</span> NoSyn<span class="main">)</span><span class="main">)</span> <span class="entity">tnames</span><span class="main">)</span> 
              <span class="main">(</span>map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">(</span>Binding.empty_atts<span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
                <span class="entity">to_eqs</span><span class="main">)</span>
              <span class="entity">Function_Fun.fun_config</span>
              <span class="entity">lthy'</span>
        <span class="keyword2"><span class="keyword">in</span></span> 
          <span class="main">(</span><span class="entity">from_info</span><span class="main">,</span><span class="entity">to_info</span><span class="main">,</span><span class="entity">lthy''</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">end</span></span>
      
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">add_functions</span> <span class="entity">lthy</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">define_rep_type</span> <span class="entity">tnames</span> <span class="entity">ctrs</span> <span class="entity">constr_names</span> <span class="entity">lthy</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sum_type_name</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">constr_names</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">type_name</span><span class="hidden">&gt;</span></span>‹Tagged_Prod_Sum.sum›</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">type_name</span><span class="hidden">&gt;</span></span>‹Sum_Type.sum›</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prod_type_name</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">constr_names</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">type_name</span><span class="hidden">&gt;</span></span>‹Tagged_Prod_Sum.prod›</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">type_name</span><span class="hidden">&gt;</span></span>‹Product_Type.prod›</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">collect_tfree_names</span> <span class="entity">ctrs</span> <span class="main">=</span> 
      fold Term.add_tfree_namesT <span class="main">(</span><span class="entity">ctrs</span> |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">l</span> <span class="main">=&gt;</span> map snd <span class="main">(</span>snd <span class="entity">l</span><span class="main">)</span><span class="main">)</span> |&gt; flat |&gt; flat<span class="main">)</span> <span class="main">[</span><span class="main">]</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tFree_renaming</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">used_tfrees</span> <span class="main">=</span> <span class="entity">collect_tfree_names</span> <span class="entity">ctrs</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt</span> <span class="main">=</span> Name.make_context <span class="entity">used_tfrees</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ts</span> <span class="main">=</span> map Type <span class="main">(</span><span class="main">(</span>map fst <span class="entity">ctrs</span><span class="main">)</span> ~~ <span class="main">(</span>replicate <span class="main">(</span>length <span class="entity">ctrs</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">names</span> <span class="main">=</span> Name.invent_names <span class="entity">ctxt</span> <span class="inner_quoted">"'a"</span> <span class="entity">ts</span> |&gt; map fst
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="entity">ts</span> ~~ <span class="main">(</span>map TFree <span class="main">(</span><span class="entity">names</span> ~~ <span class="main">(</span>replicate <span class="main">(</span>length <span class="entity">names</span><span class="main">)</span> <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">sort</span><span class="hidden">&gt;</span></span><span class="quoted">‹type›</span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span> 
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">replace_types_tvars</span> <span class="entity">recTs</span> <span class="entity">T</span>  <span class="main">=</span>
      <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">T</span> <span class="keyword2"><span class="keyword">of</span></span> Type  <span class="main">(</span><span class="entity">s</span><span class="main">,</span><span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> perhaps <span class="main">(</span>AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">recTs</span><span class="main">)</span> <span class="main">(</span>Type <span class="main">(</span><span class="entity">s</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
               <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">T</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_tagged_prodT</span> <span class="main">(</span><span class="entity">T1</span><span class="main">,</span> <span class="entity">T2</span><span class="main">)</span> <span class="main">=</span> Type <span class="main">(</span><span class="entity">prod_type_name</span><span class="main">,</span> <span class="main">[</span><span class="entity">T1</span><span class="main">,</span> <span class="entity">T2</span><span class="main">]</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_tagged_sumT</span> <span class="entity">LT</span> <span class="entity">RT</span> <span class="main">=</span> Type <span class="main">(</span><span class="entity">sum_type_name</span><span class="main">,</span> <span class="main">[</span><span class="entity">LT</span><span class="main">,</span> <span class="entity">RT</span><span class="main">]</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rep_type</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span> 
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctrs'</span> <span class="main">=</span> <span class="main">(</span><span class="entity">ctrs</span> |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">l</span> <span class="main">=&gt;</span> map snd <span class="main">(</span>snd <span class="entity">l</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">fun</span></span> 
          <span class="entity">mk_prodT</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> <span class="entity">HOLogic.unitT</span> <span class="main">|</span>
          <span class="entity">mk_prodT</span> <span class="main">[</span><span class="entity">x</span><span class="main">]</span> <span class="main">=</span> <span class="entity">replace_types_tvars</span> <span class="entity">tFree_renaming</span> <span class="entity">x</span> <span class="main">|</span>
          <span class="entity">mk_prodT</span> <span class="main">(</span><span class="entity">x</span>::<span class="entity">xs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">mk_tagged_prodT</span> <span class="main">(</span><span class="entity">replace_types_tvars</span> <span class="entity">tFree_renaming</span> <span class="entity">x</span><span class="main">,</span> <span class="main">(</span><span class="entity">mk_prodT</span> <span class="entity">xs</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">fun</span></span>
          <span class="entity">mk_sumT</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> <span class="entity">HOLogic.unitT</span> <span class="main">|</span>
          <span class="entity">mk_sumT</span> <span class="main">[</span><span class="entity">x</span><span class="main">]</span> <span class="main">=</span> <span class="entity">x</span> <span class="main">|</span>
          <span class="entity">mk_sumT</span> <span class="main">(</span><span class="entity">x</span>::<span class="entity">xs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">mk_tagged_sumT</span> <span class="entity">x</span> <span class="main">(</span><span class="entity">mk_sumT</span> <span class="entity">xs</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">generate_rep_type_aux</span> <span class="main">[</span><span class="main">]</span>  <span class="main">=</span> <span class="entity">HOLogic.unitT</span> <span class="main">|</span>
            <span class="entity">generate_rep_type_aux</span> <span class="main">[</span><span class="entity">x</span><span class="main">]</span> <span class="main">=</span> <span class="entity">mk_prodT</span> <span class="entity">x</span> <span class="main">|</span>
            <span class="entity">generate_rep_type_aux</span> <span class="main">(</span><span class="entity">x</span>::<span class="entity">xs</span><span class="main">)</span> <span class="main">=</span> 
              <span class="keyword2"><span class="keyword">let</span></span> 
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">l</span> <span class="main">=</span> <span class="entity">mk_prodT</span> <span class="entity">x</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">r</span> <span class="main">=</span> <span class="entity">generate_rep_type_aux</span> <span class="entity">xs</span>
              <span class="keyword2"><span class="keyword">in</span></span>
                <span class="entity">mk_tagged_sumT</span> <span class="entity">l</span> <span class="entity">r</span>
              <span class="keyword2"><span class="keyword">end</span></span>
        <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">mk_sumT</span> <span class="main">(</span>map <span class="entity">generate_rep_type_aux</span> <span class="entity">ctrs'</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rep_type_name</span> <span class="main">=</span> fold <span class="main">(</span>curry <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> ^<span class="main">)</span><span class="main">)</span> <span class="main">(</span>map Long_Name.base_name <span class="entity">tnames</span><span class="main">)</span> <span class="inner_quoted">""</span> ^ <span class="inner_quoted">"_rep"</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tfrees</span> <span class="main">=</span> <span class="main">(</span><span class="entity">collect_tfree_names</span> <span class="entity">ctrs</span><span class="main">)</span> @ 
                 <span class="main">(</span>map <span class="main">(</span>snd #&gt; <span class="main">(</span>dest_TFree #&gt; fst<span class="main">)</span><span class="main">)</span> <span class="entity">tFree_renaming</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> writeln <span class="main">(</span><span class="inner_quoted">"Defining representation type "</span> ^ <span class="entity">rep_type_name</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">full_rep_name</span><span class="main">,</span><span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Typedecl.abbrev</span> <span class="main">(</span>Binding.name <span class="entity">rep_type_name</span><span class="main">,</span> <span class="entity">tfrees</span><span class="main">,</span> NoSyn<span class="main">)</span> <span class="entity">rep_type</span> <span class="entity">lthy</span>
  <span class="keyword2"><span class="keyword">in</span></span> 
    <span class="main">(</span><span class="main">{</span>repname <span class="main">=</span> <span class="entity">full_rep_name</span><span class="main">,</span>
      rep_type <span class="main">=</span> <span class="entity">rep_type</span><span class="main">,</span>
      tFrees_mapping <span class="main">=</span> <span class="entity">tFree_renaming</span><span class="main">,</span>
      from_info <span class="main">=</span> NONE<span class="main">,</span>
      to_info <span class="main">=</span> NONE<span class="main">}</span> <span class="main">:</span> <span class="entity">rep_type_info</span> 
    <span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_combinator_info</span> <span class="entity">comb_type_name</span> <span class="entity">ctr_type</span> <span class="entity">lthy</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inConst</span> <span class="main">=</span> Proof_Context.read_const <span class="main">{</span>proper <span class="main">=</span> true<span class="main">,</span> strict <span class="main">=</span> true<span class="main">}</span> <span class="entity">lthy</span> <span class="inner_quoted">"In"</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inConstType</span> <span class="main">=</span> <span class="entity">inConst</span> |&gt; dest_Const |&gt; snd |&gt; <span class="entity">Derive_Util.freeify_tvars</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inConst_free</span> <span class="main">=</span> Const <span class="main">(</span><span class="entity">inConst</span> |&gt; dest_Const |&gt; fst<span class="main">,</span> <span class="entity">inConstType</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">comb_type</span> <span class="main">=</span> <span class="entity">inConstType</span> |&gt; body_type
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">comb_type_name_full</span> <span class="main">=</span> <span class="entity">comb_type</span> |&gt; dest_Type |&gt; fst
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rep_type_instantiated</span> <span class="main">=</span> <span class="entity">inConstType</span> |&gt; binder_types |&gt; hd
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">{</span>combname <span class="main">=</span> <span class="entity">comb_type_name</span><span class="main">,</span>
     combname_full <span class="main">=</span> <span class="entity">comb_type_name_full</span><span class="main">,</span>
     comb_type <span class="main">=</span> <span class="entity">comb_type</span><span class="main">,</span>
     ctr_type <span class="main">=</span> <span class="entity">ctr_type</span><span class="main">,</span>
     inConst <span class="main">=</span> <span class="entity">inConst</span><span class="main">,</span>
     inConst_free <span class="main">=</span> <span class="entity">inConst_free</span><span class="main">,</span>
     inConst_type <span class="main">=</span> <span class="entity">inConstType</span><span class="main">,</span>
     rep_type_instantiated <span class="main">=</span> <span class="entity">rep_type_instantiated</span><span class="main">}</span> <span class="main">:</span> <span class="entity">comb_type_info</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">define_combinator_type</span> <span class="entity">tnames</span> <span class="entity">tfrees</span> <span class="main">(</span><span class="entity">rep_info</span> <span class="main">:</span> <span class="entity">rep_type_info</span><span class="main">)</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">comb_type_name</span> <span class="main">=</span> <span class="inner_quoted">"mu"</span> ^ <span class="main">(</span>fold <span class="main">(</span>curry <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> ^<span class="main">)</span><span class="main">)</span> <span class="main">(</span>map Long_Name.base_name <span class="entity">tnames</span><span class="main">)</span> <span class="inner_quoted">""</span><span class="main">)</span> ^ <span class="inner_quoted">"F"</span>      
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rec_tfrees</span> <span class="main">=</span> map <span class="main">(</span>dest_TFree o snd<span class="main">)</span> <span class="main">(</span><span class="main">#</span>tFrees_mapping <span class="entity">rep_info</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rec_tfree_names</span> <span class="main">=</span> map fst <span class="entity">rec_tfrees</span>        
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rep_tfree_names</span> <span class="main">=</span> <span class="main">(</span>map <span class="main">(</span>fst o dest_TFree o fst<span class="main">)</span> <span class="entity">tfrees</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">comb_type_name_tvars</span> <span class="main">=</span> <span class="entity">add_tvars</span> <span class="entity">comb_type_name</span> <span class="entity">rep_tfree_names</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rec_type</span> <span class="main">=</span> <span class="main">(</span>Type <span class="main">(</span><span class="entity">comb_type_name</span><span class="main">,</span>map fst <span class="entity">tfrees</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctr_tfree_names</span> <span class="main">=</span> <span class="entity">rep_tfree_names</span> @ <span class="main">(</span>replicate <span class="main">(</span>length <span class="entity">rec_tfree_names</span><span class="main">)</span> <span class="entity">comb_type_name_tvars</span><span class="main">)</span>    
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctr_type_name</span> <span class="main">=</span> <span class="entity">add_tvars</span> <span class="main">(</span><span class="main">#</span>repname <span class="entity">rep_info</span><span class="main">)</span> <span class="entity">ctr_tfree_names</span> 
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctr_type</span> <span class="main">=</span> map_type_tfree <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">tfree</span><span class="main">,</span><span class="entity">s</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">case</span></span> List.find <span class="main">(</span>curry <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">tfree</span><span class="main">)</span> <span class="entity">rec_tfree_names</span> <span class="keyword2"><span class="keyword">of</span></span>
                                                    SOME <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">rec_type</span> <span class="main">|</span>
                                                    NONE   <span class="main">=&gt;</span> TFree <span class="main">(</span><span class="entity">tfree</span><span class="main">,</span><span class="entity">s</span><span class="main">)</span><span class="main">)</span>
                                  <span class="main">(</span><span class="main">#</span>rep_type <span class="entity">rep_info</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctr_typarams</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span>replicate <span class="main">(</span>length <span class="entity">tfrees</span><span class="main">)</span> <span class="main">(</span>SOME Binding.empty<span class="main">)</span><span class="main">)</span> ~~ <span class="main">(</span><span class="entity">rep_tfree_names</span> ~~ <span class="main">(</span>replicate <span class="main">(</span>length <span class="entity">tfrees</span><span class="main">)</span> NONE<span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctr_specs</span> <span class="main">=</span> <span class="main">[</span><span class="main">(</span><span class="main">(</span><span class="main">(</span>Binding.empty<span class="main">,</span> Binding.name <span class="inner_quoted">"In"</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span>Binding.empty<span class="main">,</span> <span class="entity">ctr_type_name</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> NoSyn<span class="main">)</span><span class="main">]</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> writeln <span class="main">(</span><span class="inner_quoted">"Defining combinator type "</span> ^ <span class="entity">comb_type_name</span><span class="main">)</span>    
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lthy'</span> <span class="main">=</span> 
      <span class="entity">BNF_FP_Def_Sugar.co_datatype_cmd</span> <span class="entity">BNF_Util.Least_FP</span> <span class="entity">BNF_LFP.construct_lfp</span> 
        <span class="main">(</span><span class="main">(</span>K <span class="entity">Plugin_Name.default_filter</span><span class="main">,</span> false<span class="main">)</span><span class="main">,</span> 
            <span class="main">[</span><span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">ctr_typarams</span><span class="main">,</span> Binding.name <span class="entity">comb_type_name</span><span class="main">)</span><span class="main">,</span> NoSyn<span class="main">)</span><span class="main">,</span>
             <span class="entity">ctr_specs</span><span class="main">)</span>
             <span class="main">,</span><span class="main">(</span>Binding.empty<span class="main">,</span> Binding.empty<span class="main">,</span> Binding.empty<span class="main">)</span><span class="main">)</span>
            <span class="main">,</span><span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="entity">lthy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">comb_info</span> <span class="main">=</span> <span class="entity">get_combinator_info</span> <span class="entity">comb_type_name</span> <span class="entity">ctr_type</span> <span class="entity">lthy'</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span>SOME <span class="entity">comb_info</span>
    <span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">generate_type_info</span> <span class="entity">tname</span> <span class="entity">constr_names</span> <span class="entity">lthy</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">tnames</span><span class="main">,</span> <span class="entity">Ts</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Derive_Util.mutual_recursive_types</span> <span class="entity">tname</span> <span class="entity">lthy</span>
    <span class="comment1">(* get constructor and selector information from the BNF package *)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_ctrs</span> <span class="entity">t</span> <span class="main">=</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span>map <span class="main">(</span>apsnd <span class="main">(</span>map <span class="entity">Derive_Util.freeify_tvars</span> o fst o strip_type<span class="main">)</span> o dest_Const<span class="main">)</span>
                            <span class="main">(</span><span class="entity">Derive_Util.constr_terms</span> <span class="entity">lthy</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_sels</span> <span class="entity">t</span> <span class="main">=</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span><span class="entity">Ctr_Sugar.ctr_sugar_of</span> <span class="entity">lthy</span> <span class="entity">t</span> |&gt; the |&gt; <span class="main">#</span>selss 
                          |&gt; <span class="main">(</span>map <span class="main">(</span>map <span class="main">(</span>dest_Const #&gt; fst #&gt; Long_Name.base_name<span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctrs</span> <span class="main">=</span> map <span class="entity">get_ctrs</span> <span class="entity">tnames</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sels</span> <span class="main">=</span> map <span class="entity">get_sels</span> <span class="entity">tnames</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tfrees</span> <span class="main">=</span> <span class="entity">collect_tfrees</span> <span class="entity">ctrs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">is_mutually_rec</span> <span class="main">=</span> <span class="main">(</span>length <span class="entity">tnames</span><span class="main">)</span> &gt; <span class="inner_numeral">1</span>
    <span class="comment1">(* look for recursive constructor arguments *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">is_rec</span> <span class="main">=</span> <span class="entity">ctrs_arguments</span> <span class="entity">ctrs</span> |&gt; filter <span class="entity">is_typeT</span> |&gt; map <span class="main">(</span>dest_Type #&gt; fst<span class="main">)</span>
                    |&gt; List.exists <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">n</span> <span class="main">=&gt;</span> is_some <span class="main">(</span>List.find <span class="main">(</span>curry <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">n</span><span class="main">)</span> <span class="entity">tnames</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">rep_info</span><span class="main">,</span><span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">define_rep_type</span> <span class="entity">tnames</span> <span class="entity">ctrs</span> <span class="entity">constr_names</span> <span class="entity">lthy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">comb_info</span><span class="main">,</span><span class="entity">lthy''</span><span class="main">)</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_rec</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">define_combinator_type</span> <span class="entity">tnames</span> <span class="entity">tfrees</span> <span class="entity">rep_info</span> <span class="entity">lthy'</span>
                                       <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span>NONE<span class="main">,</span><span class="entity">lthy'</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="main">{</span>tname <span class="main">=</span> <span class="entity">tname</span><span class="main">,</span>
     uses_metadata <span class="main">=</span> <span class="entity">constr_names</span><span class="main">,</span>
     tfrees <span class="main">=</span> <span class="entity">tfrees</span><span class="main">,</span>
     mutual_tnames <span class="main">=</span> <span class="entity">tnames</span><span class="main">,</span>
     mutual_Ts <span class="main">=</span> <span class="entity">Ts</span><span class="main">,</span>
     mutual_ctrs <span class="main">=</span> <span class="entity">ctrs</span><span class="main">,</span>
     mutual_sels <span class="main">=</span> <span class="entity">sels</span><span class="main">,</span>
     is_rec <span class="main">=</span> <span class="entity">is_rec</span><span class="main">,</span>
     is_mutually_rec <span class="main">=</span> <span class="entity">is_mutually_rec</span><span class="main">,</span>
     rep_info <span class="main">=</span> <span class="entity">rep_info</span><span class="main">,</span>
     comb_info <span class="main">=</span> <span class="entity">comb_info</span><span class="main">,</span>
     iso_thm <span class="main">=</span> NONE<span class="main">}</span> <span class="main">:</span> <span class="entity">type_info</span>
    <span class="main">,</span> <span class="entity">lthy''</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">generate_class_info</span> <span class="entity">class</span> <span class="main">=</span> 
  <span class="main">{</span>classname <span class="main">=</span> hd <span class="entity">class</span><span class="main">,</span>
   class <span class="main">=</span> <span class="entity">class</span><span class="main">,</span>
   params <span class="main">=</span> NONE<span class="main">,</span>
   class_law <span class="main">=</span> NONE<span class="main">,</span>
   class_law_const <span class="main">=</span> NONE<span class="main">,</span>
   ops <span class="main">=</span> NONE<span class="main">,</span>
   transfer_law <span class="main">=</span> NONE<span class="main">,</span>
   axioms <span class="main">=</span> NONE<span class="main">,</span>
   axioms_def <span class="main">=</span> NONE<span class="main">,</span>
   class_def <span class="main">=</span> NONE<span class="main">,</span>
   equivalence_thm <span class="main">=</span> NONE<span class="main">}</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">record_type_class_info</span> <span class="entity">ty_info</span> <span class="entity">cl_info</span> <span class="entity">inst_info</span> <span class="entity">thy</span> <span class="main">=</span>  
  <span class="keyword2"><span class="keyword">let</span></span> 
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_info</span> <span class="entity">info</span> <span class="entity">thy</span> <span class="main">=</span>
      Type_Data.put <span class="main">(</span>Symreltab.update <span class="main">(</span><span class="main">(</span><span class="main">#</span>tname <span class="entity">info</span><span class="main">,</span> Bool.toString <span class="main">(</span><span class="main">#</span>uses_metadata <span class="entity">info</span><span class="main">)</span><span class="main">)</span><span class="main">,</span><span class="entity">info</span><span class="main">)</span> <span class="main">(</span>Type_Data.get <span class="entity">thy</span><span class="main">)</span><span class="main">)</span> <span class="entity">thy</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_inst_info</span> <span class="entity">classname</span> <span class="entity">tname</span> <span class="entity">thy</span> <span class="main">=</span>
      Instance_Data.put <span class="main">(</span>Symreltab.update <span class="main">(</span><span class="main">(</span><span class="entity">classname</span><span class="main">,</span> <span class="entity">tname</span><span class="main">)</span><span class="main">,</span> <span class="entity">inst_info</span><span class="main">)</span> <span class="main">(</span>Instance_Data.get <span class="entity">thy</span><span class="main">)</span><span class="main">)</span> <span class="entity">thy</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">update_tname</span> <span class="main">(</span><span class="main">{</span>tname <span class="main">=</span> <span class="main">_</span><span class="main">,</span> uses_metadata <span class="main">=</span> <span class="entity">uses_metadata</span><span class="main">,</span> tfrees <span class="main">=</span> <span class="entity">tfrees</span><span class="main">,</span> mutual_tnames <span class="main">=</span> <span class="entity">mutual_tnames</span><span class="main">,</span>
                     mutual_Ts <span class="main">=</span> <span class="entity">mutual_Ts</span><span class="main">,</span> mutual_ctrs <span class="main">=</span> <span class="entity">mutual_ctrs</span><span class="main">,</span> mutual_sels <span class="main">=</span> <span class="entity">mutual_sels</span><span class="main">,</span> is_rec <span class="main">=</span> <span class="entity">is_rec</span><span class="main">,</span>
                     is_mutually_rec <span class="main">=</span> <span class="entity">is_mutually_rec</span><span class="main">,</span> rep_info <span class="main">=</span> <span class="entity">rep_info</span><span class="main">,</span> comb_info <span class="main">=</span> <span class="entity">comb_info</span><span class="main">,</span> iso_thm <span class="main">=</span> <span class="entity">iso_thm</span><span class="main">}</span> <span class="main">:</span> <span class="entity">type_info</span><span class="main">)</span>
                     <span class="entity">tname</span> <span class="main">=</span> 
      <span class="main">{</span>tname <span class="main">=</span> <span class="entity">tname</span><span class="main">,</span> uses_metadata <span class="main">=</span> <span class="entity">uses_metadata</span><span class="main">,</span> tfrees <span class="main">=</span> <span class="entity">tfrees</span><span class="main">,</span> mutual_tnames <span class="main">=</span> <span class="entity">mutual_tnames</span><span class="main">,</span>
                     mutual_Ts <span class="main">=</span> <span class="entity">mutual_Ts</span><span class="main">,</span> mutual_ctrs <span class="main">=</span> <span class="entity">mutual_ctrs</span><span class="main">,</span> mutual_sels <span class="main">=</span> <span class="entity">mutual_sels</span><span class="main">,</span> is_rec <span class="main">=</span> <span class="entity">is_rec</span><span class="main">,</span>
                     is_mutually_rec <span class="main">=</span> <span class="entity">is_mutually_rec</span><span class="main">,</span> rep_info <span class="main">=</span> <span class="entity">rep_info</span><span class="main">,</span> comb_info <span class="main">=</span> <span class="entity">comb_info</span><span class="main">,</span> iso_thm <span class="main">=</span> <span class="entity">iso_thm</span><span class="main">}</span> <span class="main">:</span> <span class="entity">type_info</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">infos</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">update_tname</span> <span class="entity">ty_info</span><span class="main">)</span> <span class="main">(</span><span class="main">#</span>mutual_tnames <span class="entity">ty_info</span><span class="main">)</span>                    
  <span class="keyword2"><span class="keyword">in</span></span>
    fold <span class="entity">add_info</span> <span class="entity">infos</span> <span class="entity">thy</span> 
  |&gt; Class_Data.put <span class="main">(</span>Symtab.update <span class="main">(</span><span class="main">(</span><span class="main">#</span>classname <span class="entity">cl_info</span><span class="main">)</span><span class="main">,</span><span class="entity">cl_info</span><span class="main">)</span> <span class="main">(</span>Class_Data.get <span class="entity">thy</span><span class="main">)</span><span class="main">)</span>
  |&gt; fold <span class="main">(</span><span class="entity">add_inst_info</span> <span class="main">(</span><span class="main">#</span>classname <span class="entity">cl_info</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">#</span>mutual_tnames <span class="entity">ty_info</span><span class="main">)</span> 
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">generate_instance</span> <span class="entity">tname</span> <span class="entity">class</span> <span class="entity">constr_names</span> <span class="entity">thy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">T</span><span class="main">,</span><span class="entity">xs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Derive_Util.typ_and_vs_of_typname</span> <span class="entity">thy</span> <span class="entity">tname</span> <span class="entity">class</span> 
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">has_law</span> <span class="main">=</span> <span class="entity">has_class_law</span> <span class="main">(</span>hd <span class="entity">class</span><span class="main">)</span> <span class="entity">thy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cl_info</span> <span class="main">=</span> 
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">get_class_info</span> <span class="entity">thy</span> <span class="main">(</span>hd <span class="entity">class</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
        NONE <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">has_law</span> <span class="keyword2"><span class="keyword">then</span></span> error <span class="main">(</span><span class="inner_quoted">"Class "</span> ^ <span class="main">(</span>hd <span class="entity">class</span><span class="main">)</span> ^ <span class="inner_quoted">"not set up for derivation, call derive_setup first"</span><span class="main">)</span>
                                            <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">generate_class_info</span> <span class="entity">class</span> <span class="main">|</span>
        SOME <span class="entity">info</span> <span class="main">=&gt;</span> <span class="entity">info</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw_params</span> <span class="main">=</span> map snd <span class="main">(</span><span class="entity">Class.these_params</span> <span class="entity">thy</span> <span class="entity">class</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cl_info'</span> <span class="main">=</span> <span class="entity">add_params_cl_info</span> <span class="entity">cl_info</span> <span class="entity">raw_params</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy'</span> <span class="main">=</span> Class_Data.put <span class="main">(</span>Symtab.update <span class="main">(</span><span class="main">(</span><span class="main">#</span>classname <span class="entity">cl_info'</span><span class="main">)</span><span class="main">,</span><span class="entity">cl_info'</span><span class="main">)</span> <span class="main">(</span>Class_Data.get <span class="entity">thy</span><span class="main">)</span><span class="main">)</span> <span class="entity">thy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lthy</span> <span class="main">=</span> <span class="entity">Named_Target.theory_init</span> <span class="entity">thy'</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">ty_info</span><span class="main">,</span><span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span> 
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">get_type_info</span> <span class="entity">thy</span> <span class="entity">tname</span> <span class="entity">constr_names</span> <span class="keyword2"><span class="keyword">of</span></span>
        SOME <span class="entity">info</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">let</span></span>
                       <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> writeln <span class="main">(</span><span class="inner_quoted">"Using existing type information for "</span> ^ <span class="entity">tname</span><span class="main">)</span>
                     <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">info</span><span class="main">,</span><span class="entity">lthy</span><span class="main">)</span> 
                     <span class="keyword2"><span class="keyword">end</span></span> <span class="main">|</span>
        NONE <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">let</span></span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">t_info</span><span class="main">,</span><span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span> <span class="entity">generate_type_info</span> <span class="entity">tname</span> <span class="entity">constr_names</span> <span class="entity">lthy</span> 
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">from_info</span><span class="main">,</span><span class="entity">to_info</span><span class="main">,</span><span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">define_prod_sum_conv</span> <span class="entity">t_info</span> <span class="entity">constr_names</span> <span class="entity">lthy</span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t_info'</span> <span class="main">=</span> <span class="entity">add_conversion_info</span> <span class="entity">from_info</span> <span class="entity">to_info</span> <span class="entity">t_info</span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">iso_thm</span><span class="main">,</span><span class="entity">lthy''</span><span class="main">)</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">has_law</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">Derive_Laws.prove_isomorphism</span> <span class="entity">t_info'</span> <span class="entity">lthy'</span>
                                                    <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span>NONE<span class="main">,</span><span class="entity">lthy'</span><span class="main">)</span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t_info''</span> <span class="main">=</span> <span class="entity">add_iso_info</span> <span class="entity">iso_thm</span> <span class="entity">t_info'</span>                        
                <span class="keyword2"><span class="keyword">in</span></span>
                  <span class="main">(</span><span class="entity">t_info''</span><span class="main">,</span><span class="entity">lthy''</span><span class="main">)</span>
                <span class="keyword2"><span class="keyword">end</span></span>
                                    
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tnames</span> <span class="main">=</span> <span class="main">#</span>mutual_tnames <span class="entity">ty_info</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Ts</span> <span class="main">=</span> <span class="main">(</span>map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">tn</span> <span class="main">=&gt;</span> <span class="entity">Derive_Util.typ_and_vs_of_typname</span> <span class="entity">thy</span> <span class="entity">tn</span> <span class="entity">class</span><span class="main">)</span> <span class="entity">tnames</span><span class="main">)</span> |&gt; map fst
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">define_operations_all_Ts</span> <span class="main">_</span> <span class="entity">lthy</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span> 
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">thms</span><span class="main">,</span><span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span> fold_map <span class="main">(</span><span class="entity">define_operations</span> <span class="entity">raw_params</span><span class="main">)</span> <span class="main">(</span><span class="entity">tnames</span> ~~ <span class="entity">Ts</span><span class="main">)</span> <span class="entity">lthy</span> |&gt; apfst flat
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt_thy</span> <span class="main">=</span> Proof_Context.init_global <span class="main">(</span>Proof_Context.theory_of <span class="entity">lthy'</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thms_export</span> <span class="main">=</span> Proof_Context.export <span class="entity">lthy'</span> <span class="entity">ctxt_thy</span> <span class="entity">thms</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inst_info</span> <span class="main">=</span> <span class="entity">mk_inst_info</span> <span class="entity">thms_export</span>
      <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">inst_info</span><span class="main">,</span><span class="entity">lthy'</span><span class="main">)</span> 
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">instantiate_and_prove</span> <span class="main">_</span> <span class="entity">lthy</span> <span class="main">=</span>
      Local_Theory.exit_global <span class="entity">lthy</span>
      |&gt; <span class="main">(</span><span class="entity">Class.instantiation</span> <span class="main">(</span><span class="entity">tnames</span><span class="main">,</span> <span class="entity">xs</span><span class="main">,</span> <span class="entity">class</span><span class="main">)</span><span class="main">)</span>
      |&gt; <span class="entity">define_operations_all_Ts</span> <span class="entity">cl_info'</span>
      |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">inst_info</span><span class="main">,</span><span class="entity">lthy</span><span class="main">)</span> <span class="main">=&gt;</span> 
          <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">has_law</span> 
            <span class="keyword2"><span class="keyword">then</span></span>
              <span class="keyword2"><span class="keyword">let</span></span> 
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">equivalence_thm</span> <span class="main">=</span> <span class="main">(</span><span class="entity">Derive_Laws.prove_equivalence_law</span> <span class="entity">cl_info</span> <span class="entity">inst_info</span> <span class="entity">lthy</span><span class="main">)</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cl_info''</span> <span class="main">=</span> <span class="entity">add_equivalence_cl_info</span> <span class="entity">cl_info'</span> <span class="entity">equivalence_thm</span>
              <span class="keyword2"><span class="keyword">in</span></span>                                              
                <span class="main">(</span><span class="entity">Class.prove_instantiation_exit</span> <span class="main">(</span><span class="entity">Derive_Laws.prove_instance_tac</span> <span class="entity">T</span> <span class="entity">cl_info''</span> <span class="entity">inst_info</span> <span class="entity">ty_info</span><span class="main">)</span> <span class="entity">lthy</span><span class="main">)</span> |&gt; pair <span class="entity">cl_info''</span> |&gt; pair <span class="entity">inst_info</span>
              <span class="keyword2"><span class="keyword">end</span></span>
            <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="entity">Class.prove_instantiation_exit</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> <span class="entity">Class.intro_classes_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="entity">lthy</span><span class="main">)</span> |&gt; pair <span class="entity">cl_info</span> |&gt; pair <span class="entity">inst_info</span><span class="main">)</span><span class="main">)</span>
      |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">inst_info</span><span class="main">,</span><span class="main">(</span><span class="entity">cl_info</span><span class="main">,</span><span class="entity">thy</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">record_type_class_info</span> <span class="entity">ty_info</span> <span class="entity">cl_info</span> <span class="entity">inst_info</span> <span class="entity">thy</span><span class="main">)</span>
      |&gt; Proof_Context.init_global

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">empty_goal</span> <span class="main">=</span> <span class="main">[</span><span class="main">[</span><span class="main">]</span><span class="main">]</span>
      
    <span class="comment1">(* Generate instance for Mu-combinator type if there is recursion *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy'</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="main">(</span><span class="main">#</span>is_rec <span class="entity">ty_info</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="entity">instantiate_combinator_type</span> <span class="entity">ty_info</span> <span class="entity">cl_info'</span> <span class="entity">constr_names</span> <span class="entity">lthy'</span> 
                                      |&gt; <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> is_some <span class="main">(</span><span class="main">#</span>class_law <span class="entity">cl_info'</span><span class="main">)</span> 
                                            <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">Derive_Laws.prove_combinator_instance</span> <span class="entity">instantiate_and_prove</span>
                                            <span class="keyword2"><span class="keyword">else</span></span>
                                                <span class="entity">Class.prove_instantiation_exit</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> <span class="entity">Class.intro_classes_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
                                                #&gt; <span class="entity">Named_Target.theory_init</span>
                                                #&gt; <span class="entity">Proof.theorem</span> NONE <span class="entity">instantiate_and_prove</span> <span class="entity">empty_goal</span><span class="main">)</span><span class="main">)</span>
                                    <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">Proof.theorem</span> NONE <span class="entity">instantiate_and_prove</span> <span class="entity">empty_goal</span> <span class="entity">lthy'</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">thy'</span> 
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">generate_instance_cmd</span> <span class="entity">classname</span> <span class="entity">tyco</span> <span class="entity">constr_names</span> <span class="entity">thy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lthy</span> <span class="main">=</span> Proof_Context.init_global <span class="entity">thy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">T</span> <span class="main">=</span> Syntax.parse_typ <span class="entity">lthy</span> <span class="entity">tyco</span> |&gt; dest_Type |&gt; fst
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">class</span> <span class="main">=</span> Syntax.parse_sort <span class="main">(</span>Proof_Context.init_global <span class="entity">thy</span><span class="main">)</span> <span class="entity">classname</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">generate_instance</span> <span class="entity">T</span> <span class="entity">class</span> <span class="entity">constr_names</span> <span class="entity">thy</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parse_cmd</span> <span class="main">=</span>
      Scan.optional <span class="main">(</span>Args.parens <span class="main">(</span>Parse.reserved <span class="inner_quoted">"metadata"</span><span class="main">)</span><span class="main">)</span> <span class="inner_quoted">""</span>  --
      Parse.name --
      Parse.type_const

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.command</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">command_keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword1">derive_generic</span>›</span></span> <span class="inner_quoted">"derives some sort"</span>
    <span class="main">(</span><span class="entity">parse_cmd</span> &gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">s</span><span class="main">,</span><span class="entity">c</span><span class="main">)</span><span class="main">,</span><span class="entity">t</span><span class="main">)</span> <span class="main">=&gt;</span>
      <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">meta</span> <span class="main">=</span> <span class="entity">s</span> <span class="main">=</span> <span class="inner_quoted">"metadata"</span> <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">Toplevel.theory_to_proof</span> <span class="main">(</span><span class="entity">generate_instance_cmd</span> <span class="entity">c</span> <span class="entity">t</span> <span class="entity">meta</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span> <span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_inst_info</span> <span class="entity">classname</span> <span class="entity">tname</span> <span class="entity">thms</span> <span class="entity">thy</span> <span class="main">=</span> 
  Instance_Data.put <span class="main">(</span>Symreltab.update <span class="main">(</span><span class="main">(</span><span class="entity">classname</span><span class="main">,</span> <span class="entity">tname</span><span class="main">)</span> <span class="main">,</span><span class="main">{</span>defs <span class="main">=</span> <span class="entity">thms</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span>Instance_Data.get <span class="entity">thy</span><span class="main">)</span><span class="main">)</span> <span class="entity">thy</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Derive_Datatypes">
<div class="head">
<h1>Theory Derive_Datatypes</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">chapter</span></span> <span class="quoted"><span class="plain_text">"Examples"</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">"Example Datatypes"</span></span>

<span class="keyword1"><span class="command">theory</span></span> Derive_Datatypes
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(* Simple type without recursion or parameters *)</span>
<span class="keyword1"><span class="command">datatype</span></span> simple <span class="main">=</span> A <span class="main">(</span><span class="free"><span class="entity">num</span></span><span class="main">:</span> <span class="quoted">nat</span><span class="main">)</span> <span class="main">|</span> B <span class="main">(</span><span class="free"><span class="entity">left</span></span><span class="main">:</span><span class="quoted">nat</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="entity">right</span></span><span class="main">:</span><span class="quoted">nat</span><span class="main">)</span> <span class="main">|</span> C 
  
<span class="comment1">(* type with parameters *)</span>  
<span class="keyword1"><span class="command">datatype</span></span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> either <span class="main">=</span> L <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="main">|</span> R <span class="tfree"><span class="quoted"><span class="tfree">'b</span></span></span>
  
<span class="comment1">(* recursive type *)</span>
<span class="keyword1"><span class="command">datatype</span></span> <span class="tfree">'a</span> tree <span class="main">=</span> Leaf <span class="main">|</span> Node <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> tree"</span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> tree"</span></span>     
  
<span class="comment1">(* mutually recursive types *)</span>
  
<span class="keyword1"><span class="command">datatype</span></span> even_nat <span class="main">=</span> Even_Zero <span class="main">|</span> Even_Succ <span class="quoted">odd_nat</span>
   <span class="keyword2"><span class="keyword">and</span></span>   odd_nat  <span class="main">=</span> Odd_Succ <span class="quoted">even_nat</span>  
   
<span class="keyword1"><span class="command">datatype</span></span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> exp <span class="main">=</span> Term <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> trm"</span></span> <span class="main">|</span> Sum <span class="main">(</span><span class="free"><span class="entity">left</span></span><span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> trm"</span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="entity">right</span></span><span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> exp"</span></span><span class="main">)</span>
<span class="keyword2"><span class="keyword">and</span></span>      <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> trm <span class="main">=</span> Factor <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> fct "</span></span> <span class="main">|</span> Prod <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> fct "</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> trm "</span></span>
<span class="keyword2"><span class="keyword">and</span></span>      <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> fct <span class="main">=</span> Const <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="main">|</span> Var <span class="main">(</span><span class="free"><span class="entity">v</span></span><span class="main">:</span><span class="tfree"><span class="quoted"><span class="tfree">'b</span></span></span><span class="main">)</span> <span class="main">|</span> Expr <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> exp"</span></span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="Derive_Eq">
<div class="head">
<h1>Theory Derive_Eq</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">"Equality"</span></span>

<span class="keyword1"><span class="command">theory</span></span> Derive_Eq
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a> <span class="quoted">"<a href="Derive.html">../Derive</a>"</span> <a href="Derive_Datatypes.html">Derive_Datatypes</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">class</span></span> eq <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free"><span class="free"><span class="free">eq</span></span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span>

<span class="comment1">(* Manual instances for nat, unit, prod, and sum *)</span>
<span class="keyword1"><span class="command">instantiation</span></span> nat <span class="keyword2"><span class="keyword">and</span></span> unit<span class="main">::</span> <span class="quoted"><span class="quoted">eq</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> eq_nat <span class="main">:</span> <span class="quoted"><span class="quoted">"eq <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">::</span>nat<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> eq_unit_def<span class="main">:</span> <span class="quoted"><span class="quoted">"eq <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">::</span>unit<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">⟷</span> True"</span></span>
  <span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> prod <span class="keyword2"><span class="keyword">and</span></span> sum <span class="main">::</span> <span class="main">(</span><span class="quoted"><span class="quoted">eq</span></span><span class="main">,</span> <span class="quoted"><span class="quoted">eq</span></span><span class="main">)</span> <span class="quoted"><span class="quoted">eq</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> eq_prod_def<span class="main">:</span> <span class="quoted"><span class="quoted">"eq <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">⟷</span> <span class="main">(</span>eq <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span>eq <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> eq_sum_def<span class="main">:</span> <span class="quoted"><span class="quoted">"eq <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">of</span> Inl <span class="bound">a</span> <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="keyword1">of</span> Inl <span class="bound">b</span> <span class="main">⇒</span> eq <span class="bound">a</span> <span class="bound">b</span> <span class="main">|</span> Inr <span class="bound">b</span> <span class="main">⇒</span> False<span class="main">)</span>
                                            <span class="main">|</span> Inr <span class="bound">a</span> <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="keyword1">of</span> Inl <span class="bound">b</span> <span class="main">⇒</span> False <span class="main">|</span> Inr <span class="bound">b</span> <span class="main">⇒</span> eq <span class="bound">a</span> <span class="bound">b</span><span class="main">)</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>  

<span class="comment1">(* nonrecursive test *)</span>

<span class="keyword1"><span class="command">derive_generic</span></span> eq <span class="quoted">simple</span> <span class="keyword1"><span class="command">.</span></span>

<span class="comment1">(* some tests *)</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"eq <span class="main">(</span>A <span class="numeral">4</span><span class="main">)</span> <span class="main">(</span>A <span class="numeral">4</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"eq <span class="main">(</span>A <span class="numeral">6</span><span class="main">)</span> <span class="main">(</span>A <span class="numeral">4</span><span class="main">)</span> <span class="main">⟷</span> False"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"eq C C"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"eq <span class="main">(</span>B <span class="numeral">4</span> <span class="numeral">5</span><span class="main">)</span> <span class="main">(</span>B <span class="numeral">4</span> <span class="numeral">5</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"eq <span class="main">(</span>B <span class="numeral">4</span> <span class="numeral">4</span><span class="main">)</span> <span class="main">(</span>A <span class="numeral">3</span><span class="main">)</span> <span class="main">⟷</span> False"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"eq C <span class="main">(</span>A <span class="numeral">4</span><span class="main">)</span> <span class="main">⟷</span> False"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>

<span class="comment1">(* type with parameter *)</span>

<span class="keyword1"><span class="command">derive_generic</span></span> eq <span class="quoted">either</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"eq <span class="main">(</span>L <span class="main">(</span><span class="numeral">3</span><span class="main">::</span>nat<span class="main">)</span><span class="main">)</span> <span class="main">(</span>R <span class="numeral">3</span><span class="main">)</span> <span class="main">⟷</span> False"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">code_simp</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"eq <span class="main">(</span>L <span class="main">(</span><span class="numeral">3</span><span class="main">::</span>nat<span class="main">)</span><span class="main">)</span> <span class="main">(</span>L <span class="numeral">3</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">code_simp</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"eq <span class="main">(</span>L <span class="main">(</span><span class="numeral">3</span><span class="main">::</span>nat<span class="main">)</span><span class="main">)</span> <span class="main">(</span>L <span class="numeral">4</span><span class="main">)</span> <span class="main">⟷</span> False"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">code_simp</span>

<span class="comment1">(* recursive types *)</span>
<span class="keyword1"><span class="command">derive_generic</span></span> eq <span class="quoted">list</span> <span class="keyword1"><span class="command">.</span></span>


<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"eq <span class="main">(</span><span class="main">[]</span><span class="main">::</span><span class="main">(</span>nat list<span class="main">)</span><span class="main">)</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"eq <span class="main">(</span><span class="main">[</span><span class="main">1</span><span class="main">,</span><span class="numeral">2</span><span class="main">,</span><span class="numeral">3</span><span class="main">]</span><span class="main">::</span> <span class="main">(</span>nat list<span class="main">)</span><span class="main">)</span> <span class="main">[</span><span class="main">1</span><span class="main">,</span><span class="numeral">2</span><span class="main">,</span><span class="numeral">3</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"eq <span class="main">[</span><span class="main">(</span><span class="main">1</span><span class="main">::</span>nat<span class="main">)</span><span class="main">]</span> <span class="main">[</span><span class="main">1</span><span class="main">,</span><span class="numeral">2</span><span class="main">]</span> <span class="main">⟷</span> False"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>

<span class="keyword1"><span class="command">derive_generic</span></span> eq <span class="quoted">tree</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"eq Leaf Leaf"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">code_simp</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"eq <span class="main">(</span>Node <span class="main">(</span><span class="main">1</span><span class="main">::</span>nat<span class="main">)</span> Leaf Leaf<span class="main">)</span> Leaf <span class="main">⟷</span> False"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"eq <span class="main">(</span>Node <span class="main">(</span><span class="main">1</span><span class="main">::</span>nat<span class="main">)</span> Leaf Leaf<span class="main">)</span> <span class="main">(</span>Node <span class="main">(</span><span class="main">1</span><span class="main">::</span>nat<span class="main">)</span> Leaf Leaf<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"eq <span class="main">(</span>Node <span class="main">(</span><span class="main">1</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">(</span>Node <span class="numeral">2</span> Leaf Leaf<span class="main">)</span> <span class="main">(</span>Node <span class="numeral">3</span> Leaf Leaf<span class="main">)</span><span class="main">)</span> <span class="main">(</span>Node <span class="main">(</span><span class="main">1</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">(</span>Node <span class="numeral">2</span> Leaf Leaf<span class="main">)</span> <span class="main">(</span>Node <span class="numeral">4</span> Leaf Leaf<span class="main">)</span><span class="main">)</span> 
    <span class="main">⟷</span> False"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>

<span class="comment1">(* mutually recursive types *)</span>

<span class="keyword1"><span class="command">derive_generic</span></span> eq <span class="quoted">even_nat</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">derive_generic</span></span> eq <span class="quoted">exp</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"eq Even_Zero Even_Zero"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"eq Even_Zero <span class="main">(</span>Even_Succ <span class="main">(</span>Odd_Succ Even_Zero<span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> False"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"eq <span class="main">(</span>Odd_Succ <span class="main">(</span>Even_Succ <span class="main">(</span>Odd_Succ Even_Zero<span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Odd_Succ <span class="main">(</span>Even_Succ <span class="main">(</span>Odd_Succ Even_Zero<span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"eq <span class="main">(</span>Odd_Succ <span class="main">(</span>Even_Succ <span class="main">(</span>Odd_Succ Even_Zero<span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Odd_Succ <span class="main">(</span>Even_Succ <span class="main">(</span>Odd_Succ <span class="main">(</span>Even_Succ <span class="main">(</span>Odd_Succ Even_Zero<span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="main">⟷</span> False"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"eq <span class="main">(</span>Const <span class="main">(</span><span class="main">1</span><span class="main">::</span>nat<span class="main">)</span><span class="main">)</span> <span class="main">(</span>Const <span class="main">(</span><span class="main">1</span><span class="main">::</span>nat<span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">code_simp</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"eq <span class="main">(</span>Const <span class="main">(</span><span class="main">1</span><span class="main">::</span>nat<span class="main">)</span><span class="main">)</span> <span class="main">(</span>Var <span class="main">(</span><span class="main">1</span><span class="main">::</span>nat<span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> False"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"eq <span class="main">(</span>Term <span class="main">(</span>Prod <span class="main">(</span>Const <span class="main">(</span><span class="main">1</span><span class="main">::</span>nat<span class="main">)</span><span class="main">)</span> <span class="main">(</span>Factor <span class="main">(</span>Const <span class="main">(</span><span class="numeral">2</span><span class="main">::</span>nat<span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Term <span class="main">(</span>Prod <span class="main">(</span>Const <span class="main">(</span><span class="main">1</span><span class="main">::</span>nat<span class="main">)</span><span class="main">)</span> <span class="main">(</span>Factor <span class="main">(</span>Const <span class="main">(</span><span class="numeral">2</span><span class="main">::</span>nat<span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">code_simp</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"eq <span class="main">(</span>Term <span class="main">(</span>Prod <span class="main">(</span>Const <span class="main">(</span><span class="main">1</span><span class="main">::</span>nat<span class="main">)</span><span class="main">)</span> <span class="main">(</span>Factor <span class="main">(</span>Const <span class="main">(</span><span class="numeral">2</span><span class="main">::</span>nat<span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Term <span class="main">(</span>Prod <span class="main">(</span>Const <span class="main">(</span><span class="main">1</span><span class="main">::</span>nat<span class="main">)</span><span class="main">)</span> <span class="main">(</span>Factor <span class="main">(</span>Const <span class="main">(</span><span class="numeral">3</span><span class="main">::</span>nat<span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="main">⟷</span> False"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">code_simp</span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="Derive_Encode">
<div class="head">
<h1>Theory Derive_Encode</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">"Encoding"</span></span>

<span class="keyword1"><span class="command">theory</span></span> Derive_Encode
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a> <span class="quoted">"<a href="Derive.html">../Derive</a>"</span> <a href="Derive_Datatypes.html">Derive_Datatypes</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">class</span></span> encodeable <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free"><span class="free"><span class="free">encode</span></span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> bool list"</span></span>

<span class="comment1">(* Manual instances for nat, unit, prod, and sum *)</span>    
<span class="keyword1"><span class="command">instantiation</span></span> nat <span class="keyword2"><span class="keyword">and</span></span> unit<span class="main">::</span> <span class="quoted"><span class="quoted">encodeable</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>  
  <span class="keyword1"><span class="command">fun</span></span> <span class="entity"><span class="class_parameter">encode_nat</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> bool list"</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">encode_nat</span> <span class="main">0</span> <span class="main">=</span> <span class="main">[]</span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">encode_nat</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> True <span class="main">#</span> <span class="main">(</span>encode <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span>"</span></span>
  
  <span class="keyword1"><span class="command">definition</span></span> encode_unit<span class="main">:</span> <span class="quoted"><span class="quoted">"encode <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">::</span>unit<span class="main">)</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
  <span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span> 

<span class="keyword1"><span class="command">instantiation</span></span> prod <span class="keyword2"><span class="keyword">and</span></span> sum <span class="main">::</span> <span class="main">(</span><span class="quoted"><span class="quoted">encodeable</span></span><span class="main">,</span> <span class="quoted"><span class="quoted">encodeable</span></span><span class="main">)</span> <span class="quoted"><span class="quoted">encodeable</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> encode_prod_def<span class="main">:</span> <span class="quoted"><span class="quoted">"encode <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> append <span class="main">(</span>encode <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>encode <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> encode_sum_def<span class="main">:</span>  <span class="quoted"><span class="quoted">"encode <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">of</span> Inl <span class="bound">a</span> <span class="main">⇒</span> False <span class="main">#</span> encode <span class="bound">a</span>
                                                   <span class="main">|</span> Inr <span class="bound">a</span> <span class="main">⇒</span> True <span class="main">#</span> encode <span class="bound">a</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">derive_generic</span></span> encodeable <span class="quoted">simple</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">derive_generic</span></span> encodeable <span class="quoted">either</span> <span class="keyword1"><span class="command">.</span></span>
  
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"encode <span class="main">(</span>B <span class="numeral">3</span> <span class="numeral">4</span><span class="main">)</span> <span class="main">=</span> <span class="main">[</span>True<span class="main">,</span> False<span class="main">,</span> True<span class="main">,</span> True<span class="main">,</span> True<span class="main">,</span> True<span class="main">,</span> True<span class="main">,</span> True<span class="main">,</span> True<span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"encode C <span class="main">=</span> <span class="main">[</span>True<span class="main">,</span> True<span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span> 
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"encode <span class="main">(</span>R <span class="main">(</span><span class="numeral">3</span><span class="main">::</span>nat<span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">[</span>True<span class="main">,</span> True<span class="main">,</span> True<span class="main">,</span> True<span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">code_simp</span>
  
<span class="comment1">(* recursive types *)</span> 
  
<span class="keyword1"><span class="command">derive_generic</span></span> encodeable <span class="quoted">list</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">derive_generic</span></span> encodeable <span class="quoted">tree</span> <span class="keyword1"><span class="command">.</span></span>
  
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"encode <span class="main">[</span><span class="main">1</span><span class="main">,</span><span class="numeral">2</span><span class="main">,</span><span class="numeral">3</span><span class="main">,</span><span class="numeral">4</span><span class="main">::</span>nat<span class="main">]</span> 
  <span class="main">=</span> <span class="main">[</span>True<span class="main">,</span> True<span class="main">,</span> True<span class="main">,</span> True<span class="main">,</span> True<span class="main">,</span> True<span class="main">,</span> True<span class="main">,</span> True<span class="main">,</span> True<span class="main">,</span> True<span class="main">,</span> True<span class="main">,</span> True<span class="main">,</span> True<span class="main">,</span> True<span class="main">,</span> False<span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"encode <span class="main">(</span>Node <span class="main">(</span><span class="numeral">3</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">(</span>Node <span class="main">1</span> Leaf Leaf<span class="main">)</span> <span class="main">(</span>Node <span class="numeral">2</span> Leaf Leaf<span class="main">)</span><span class="main">)</span> 
  <span class="main">=</span> <span class="main">[</span>True<span class="main">,</span> True<span class="main">,</span> True<span class="main">,</span> True<span class="main">,</span> True<span class="main">,</span> True<span class="main">,</span> False<span class="main">,</span> False<span class="main">,</span> True<span class="main">,</span> True<span class="main">,</span> True<span class="main">,</span> False<span class="main">,</span> False<span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>

<span class="comment1">(* mutually recursive types *)</span>

<span class="keyword1"><span class="command">derive_generic</span></span> encodeable <span class="quoted">even_nat</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">derive_generic</span></span> encodeable <span class="quoted">exp</span> <span class="keyword1"><span class="command">.</span></span>
   
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"encode <span class="main">(</span>Odd_Succ <span class="main">(</span>Even_Succ <span class="main">(</span>Odd_Succ Even_Zero<span class="main">)</span><span class="main">)</span><span class="main">)</span> 
  <span class="main">=</span> <span class="main">[</span>True<span class="main">,</span> False<span class="main">,</span> True<span class="main">,</span> True<span class="main">,</span> False<span class="main">,</span> False<span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span> 
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"encode <span class="main">(</span>Term <span class="main">(</span>Prod <span class="main">(</span>Const <span class="main">(</span><span class="main">1</span><span class="main">::</span>nat<span class="main">)</span><span class="main">)</span> <span class="main">(</span>Factor <span class="main">(</span>Const <span class="main">(</span><span class="numeral">2</span><span class="main">::</span>nat<span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
  <span class="main">=</span> <span class="main">[</span>False<span class="main">,</span> False<span class="main">,</span> True<span class="main">,</span> False<span class="main">,</span> True<span class="main">,</span> True<span class="main">,</span> True<span class="main">,</span> False<span class="main">,</span> True<span class="main">,</span> True<span class="main">,</span> False<span class="main">,</span> False<span class="main">,</span> True<span class="main">,</span> True<span class="main">,</span> False<span class="main">,</span> True<span class="main">,</span> True<span class="main">]</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">code_simp</span>    

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="Derive_Algebra">
<div class="head">
<h1>Theory Derive_Algebra</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">"Algebraic Classes"</span></span>

<span class="keyword1"><span class="command">theory</span></span> Derive_Algebra
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a> <span class="quoted">"<a href="Derive.html">../Derive</a>"</span> <a href="Derive_Datatypes.html">Derive_Datatypes</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">class</span></span> semigroup <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free"><span class="free"><span class="free">mult</span></span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1"><span class="keyword1"><span class="keyword1">⊗</span></span></span>"</span> 70<span class="main">)</span>
<span class="comment1">(*  assumes assoc: "(x ⊗ y) ⊗ z = x ⊗ (y ⊗ z)" *)</span>
    
<span class="keyword1"><span class="command">class</span></span> monoidl <span class="main">=</span> semigroup <span class="main">+</span>
<span class="keyword2"><span class="keyword">fixes</span></span> <span class="free"><span class="free"><span class="free">neutral</span></span></span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1"><span class="keyword1"><span class="keyword1">𝟭</span></span></span>"</span><span class="main">)</span>
<span class="comment1">(* assumes neutl : "𝟭 ⊗ x = x" *)</span>    
  
<span class="keyword1"><span class="command">class</span></span> group <span class="main">=</span> monoidl <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free"><span class="free"><span class="free">inverse</span></span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
<span class="comment1">(* assumes invl: "x÷ ⊗ x = 𝟭" *)</span>
    
<span class="comment1">(* Manual instances for nat, unit, prod, and sum *)</span>    
<span class="keyword1"><span class="command">instantiation</span></span> nat <span class="keyword2"><span class="keyword">and</span></span> unit<span class="main">::</span> <span class="quoted"><span class="quoted">semigroup</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>  
  <span class="keyword1"><span class="command">definition</span></span> mult_nat <span class="main">:</span> <span class="quoted"><span class="quoted">"mult <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">::</span>nat<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">+</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> mult_unit_def<span class="main">:</span> <span class="quoted"><span class="quoted">"mult <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">::</span>unit<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>
  <span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span> 
<span class="keyword1"><span class="command">instantiation</span></span> nat <span class="keyword2"><span class="keyword">and</span></span> unit<span class="main">::</span> <span class="quoted"><span class="quoted">monoidl</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>  
  <span class="keyword1"><span class="command">definition</span></span> neutral_nat <span class="main">:</span> <span class="quoted"><span class="quoted">"neutral <span class="main">=</span> <span class="main">(</span><span class="main">0</span><span class="main">::</span>nat<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> neutral_unit_def<span class="main">:</span> <span class="quoted"><span class="quoted">"neutral <span class="main">=</span> <span class="main">()</span>"</span></span>
  <span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>   
  
<span class="keyword1"><span class="command">instantiation</span></span> nat <span class="keyword2"><span class="keyword">and</span></span> unit<span class="main">::</span> <span class="quoted"><span class="quoted">group</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>  
  <span class="keyword1"><span class="command">definition</span></span> inverse_nat <span class="main">:</span> <span class="quoted"><span class="quoted">"inverse <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">::</span>nat<span class="main">)</span> <span class="main">=</span> <span class="main">𝟭</span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> inverse_unit_def<span class="main">:</span> <span class="quoted"><span class="quoted">"inverse <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">=</span> <span class="main">()</span>"</span></span>
  <span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>   

<span class="keyword1"><span class="command">instantiation</span></span> prod <span class="keyword2"><span class="keyword">and</span></span> sum <span class="main">::</span> <span class="main">(</span><span class="quoted"><span class="quoted">semigroup</span></span><span class="main">,</span> <span class="quoted"><span class="quoted">semigroup</span></span><span class="main">)</span> <span class="quoted"><span class="quoted">semigroup</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> mult_prod_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">⊗</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">⊗</span> fst <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">,</span> snd <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">⊗</span> snd <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> mult_sum_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">⊗</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">of</span> Inl <span class="bound">a</span> <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="keyword1">of</span> Inl <span class="bound">b</span> <span class="main">⇒</span> Inl <span class="main">(</span><span class="bound">a</span> <span class="main">⊗</span> <span class="bound">b</span><span class="main">)</span> <span class="main">|</span> Inr <span class="bound">b</span> <span class="main">⇒</span> Inl <span class="bound">a</span><span class="main">)</span>
                                             <span class="main">|</span> Inr <span class="bound">a</span> <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="keyword1">of</span> Inl <span class="bound">b</span> <span class="main">⇒</span> Inr <span class="bound">a</span> <span class="main">|</span> Inr <span class="bound">b</span> <span class="main">⇒</span> Inr <span class="main">(</span><span class="bound">a</span> <span class="main">⊗</span> <span class="bound">b</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>
  
<span class="keyword1"><span class="command">instantiation</span></span> prod <span class="keyword2"><span class="keyword">and</span></span> sum <span class="main">::</span> <span class="main">(</span><span class="quoted"><span class="quoted">monoidl</span></span><span class="main">,</span> <span class="quoted"><span class="quoted">monoidl</span></span><span class="main">)</span> <span class="quoted"><span class="quoted">monoidl</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> neutral_prod_def<span class="main">:</span> <span class="quoted"><span class="quoted">"neutral <span class="main">=</span> <span class="main">(</span>neutral<span class="main">,</span>neutral<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> neutral_sum_def<span class="main">:</span> <span class="quoted"><span class="quoted">"neutral <span class="main">=</span> Inl neutral"</span></span>
  <span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span> 
  
<span class="keyword1"><span class="command">instantiation</span></span> prod <span class="keyword2"><span class="keyword">and</span></span> sum <span class="main">::</span> <span class="main">(</span><span class="quoted"><span class="quoted">group</span></span><span class="main">,</span> <span class="quoted"><span class="quoted">group</span></span><span class="main">)</span> <span class="quoted"><span class="quoted">group</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> inverse_prod_def<span class="main">:</span> <span class="quoted"><span class="quoted">"inverse <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span>inverse <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span><span class="main">,</span> inverse <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> inverse_sum_def<span class="main">:</span> <span class="quoted"><span class="quoted">"inverse <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">of</span> Inl <span class="bound">a</span> <span class="main">⇒</span> <span class="main">(</span>Inl <span class="main">(</span>inverse <span class="bound">a</span><span class="main">)</span><span class="main">)</span> 
                                                    <span class="main">|</span> Inr <span class="bound">b</span> <span class="main">⇒</span> Inr <span class="main">(</span>inverse <span class="bound">b</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>    
    
<span class="comment1">(* Simple test *)</span>  
  
<span class="keyword1"><span class="command">derive_generic</span></span> semigroup <span class="quoted">simple</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">derive_generic</span></span> monoidl <span class="quoted">simple</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">derive_generic</span></span> group <span class="quoted">simple</span> <span class="keyword1"><span class="command">.</span></span>
  
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>B <span class="main">𝟭</span> <span class="numeral">6</span><span class="main">)</span> <span class="main">⊗</span> <span class="main">(</span>B <span class="numeral">4</span> <span class="numeral">5</span><span class="main">)</span> <span class="main">=</span> B <span class="numeral">4</span> <span class="numeral">11</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>A <span class="numeral">2</span><span class="main">)</span> <span class="main">⊗</span> <span class="main">(</span>A <span class="numeral">3</span><span class="main">)</span> <span class="main">=</span> A <span class="numeral">5</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>B <span class="main">𝟭</span> <span class="numeral">6</span><span class="main">)</span> <span class="main">⊗</span> <span class="main">𝟭</span> <span class="main">=</span> B <span class="main">0</span> <span class="numeral">6</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
  
<span class="comment1">(* type with parameter *)</span>
  
<span class="keyword1"><span class="command">derive_generic</span></span> group <span class="quoted">either</span> <span class="keyword1"><span class="command">.</span></span>  

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>L <span class="numeral">3</span><span class="main">)</span> <span class="main">⊗</span> <span class="main">(</span><span class="main">(</span>L <span class="numeral">4</span><span class="main">)</span><span class="main">::</span><span class="main">(</span>nat<span class="main">,</span>nat<span class="main">)</span> either<span class="main">)</span> <span class="main">=</span> L <span class="numeral">7</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>R <span class="main">(</span><span class="numeral">2</span><span class="main">::</span>nat<span class="main">)</span><span class="main">)</span> <span class="main">⊗</span> <span class="main">(</span>L <span class="main">(</span><span class="numeral">3</span><span class="main">::</span>nat<span class="main">)</span><span class="main">)</span> <span class="main">=</span> R <span class="numeral">2</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
  
<span class="comment1">(* recursive types *)</span> 

<span class="keyword1"><span class="command">derive_generic</span></span> semigroup <span class="quoted">list</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">derive_generic</span></span> monoidl <span class="quoted">list</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">derive_generic</span></span> group <span class="quoted">list</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">derive_generic</span></span> semigroup <span class="quoted">tree</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">derive_generic</span></span> monoidl <span class="quoted">tree</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">derive_generic</span></span> group <span class="quoted">tree</span> <span class="keyword1"><span class="command">.</span></span>
  
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">1</span><span class="main">,</span><span class="numeral">2</span><span class="main">,</span><span class="numeral">3</span><span class="main">,</span><span class="numeral">4</span><span class="main">::</span>nat<span class="main">]</span> <span class="main">⊗</span> <span class="main">[</span><span class="main">1</span><span class="main">,</span><span class="numeral">2</span><span class="main">,</span><span class="numeral">3</span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="numeral">2</span><span class="main">,</span><span class="numeral">4</span><span class="main">,</span><span class="numeral">6</span><span class="main">,</span><span class="numeral">4</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"inverse <span class="main">[</span><span class="main">1</span><span class="main">,</span><span class="numeral">2</span><span class="main">,</span><span class="numeral">3</span><span class="main">::</span>nat<span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="main">0</span><span class="main">,</span><span class="main">0</span><span class="main">,</span><span class="main">0</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>

<span class="comment1">(* mutually recursive types *)</span>

<span class="keyword1"><span class="command">derive_generic</span></span> semigroup <span class="quoted">even_nat</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">derive_generic</span></span> monoidl <span class="quoted">even_nat</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">derive_generic</span></span> group <span class="quoted">even_nat</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">derive_generic</span></span> semigroup <span class="quoted">exp</span> <span class="keyword1"><span class="command">.</span></span>

<span class="comment1">(* instantiate monoidl manually *)</span>  
<span class="keyword1"><span class="command">instantiation</span></span> exp <span class="keyword2"><span class="keyword">and</span></span> trm <span class="keyword2"><span class="keyword">and</span></span> fct  <span class="main">::</span> <span class="main">(</span><span class="quoted"><span class="quoted"><span class="quoted">monoidl</span></span></span><span class="main">,</span><span class="quoted"><span class="quoted"><span class="quoted">monoidl</span></span></span><span class="main">)</span> <span class="quoted"><span class="quoted"><span class="quoted">monoidl</span></span></span> 
<span class="keyword2"><span class="keyword">begin</span></span>  
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity"><span class="class_parameter">neutral_fct</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">neutral_fct</span> <span class="main">=</span> Const neutral"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity"><span class="class_parameter">neutral_trm</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">neutral_trm</span> <span class="main">=</span> Factor neutral"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity"><span class="class_parameter">neutral_exp</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">neutral_exp</span> <span class="main">=</span> Term neutral"</span></span>
  <span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>     

<span class="comment1">(* Manually defined instances need to be added to the theory context *)</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹
<span class="main">(</span><span class="entity">Derive.add_inst_info</span> <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">class</span><span class="hidden">&gt;</span></span>‹monoidl›</span> <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">type_name</span><span class="hidden">&gt;</span></span>‹fct›</span> <span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> neutral_fct_def<span class="antiquote">}</span></span></span><span class="main">]</span><span class="main">)</span> #&gt;
<span class="main">(</span><span class="entity">Derive.add_inst_info</span> <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">class</span><span class="hidden">&gt;</span></span>‹monoidl›</span> <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">type_name</span><span class="hidden">&gt;</span></span>‹trm›</span> <span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> neutral_trm_def<span class="antiquote">}</span></span></span><span class="main">]</span><span class="main">)</span> #&gt;
<span class="main">(</span><span class="entity">Derive.add_inst_info</span> <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">class</span><span class="hidden">&gt;</span></span>‹monoidl›</span> <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">type_name</span><span class="hidden">&gt;</span></span>‹exp›</span> <span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> neutral_exp_def<span class="antiquote">}</span></span></span><span class="main">]</span><span class="main">)</span>
›</span>

<span class="keyword1"><span class="command">derive_generic</span></span> group <span class="quoted">exp</span> <span class="keyword1"><span class="command">.</span></span>
   
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Odd_Succ <span class="main">(</span>Even_Succ <span class="main">(</span>Odd_Succ Even_Zero<span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">⊗</span> <span class="main">(</span>Odd_Succ Even_Zero<span class="main">)</span> 
       <span class="main">=</span> Odd_Succ <span class="main">(</span>Even_Succ <span class="main">(</span>Odd_Succ Even_Zero<span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"inverse <span class="main">(</span>Odd_Succ Even_Zero<span class="main">)</span> <span class="main">=</span> Odd_Succ Even_Zero"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Term <span class="main">(</span>Prod <span class="main">(</span><span class="main">(</span>Const <span class="main">1</span><span class="main">)</span><span class="main">::</span><span class="main">(</span>nat<span class="main">,</span> nat<span class="main">)</span> fct<span class="main">)</span> <span class="main">(</span>Factor <span class="main">(</span>Const <span class="main">(</span><span class="numeral">2</span><span class="main">::</span>nat<span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> 
    <span class="main">⊗</span> <span class="main">(</span>Term <span class="main">(</span>Prod <span class="main">(</span>Const <span class="main">(</span><span class="numeral">2</span><span class="main">::</span>nat<span class="main">)</span><span class="main">)</span> <span class="main">(</span>Factor <span class="main">(</span><span class="main">(</span>Const <span class="numeral">2</span><span class="main">)</span><span class="main">::</span><span class="main">(</span>nat<span class="main">,</span> nat<span class="main">)</span> fct<span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="main">=</span> Term <span class="main">(</span>Prod <span class="main">(</span>Const <span class="numeral">3</span><span class="main">)</span> <span class="main">(</span>Factor <span class="main">(</span>Const <span class="numeral">4</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>   


<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="Derive_Show">
<div class="head">
<h1>Theory Derive_Show</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">"Show"</span></span>

<span class="keyword1"><span class="command">theory</span></span> Derive_Show
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a> <span class="quoted">"<a href="Derive.html">../Derive</a>"</span> <a href="Derive_Datatypes.html">Derive_Datatypes</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">class</span></span> showable <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free"><span class="free"><span class="free">print</span></span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> string"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">string_of_nat</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> string"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">string_of_nat</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">&lt;</span> <span class="numeral">10</span> <span class="keyword1">then</span> <span class="main">[</span><span class="main">(</span>char_of <span class="main">::</span> nat <span class="main">⇒</span> char<span class="main">)</span> <span class="main">(</span><span class="numeral">48</span> <span class="main">+</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span><span class="main">]</span> <span class="keyword1">else</span>
     <span class="free">string_of_nat</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">div</span> <span class="numeral">10</span><span class="main">)</span> <span class="main">@</span> <span class="main">[</span><span class="main">(</span>char_of <span class="main">::</span> nat <span class="main">⇒</span> char<span class="main">)</span> <span class="main">(</span><span class="numeral">48</span> <span class="main">+</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">mod</span> <span class="numeral">10</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">)</span>"</span></span>

<span class="comment1">(* Manual instances for nat, unit, prod, and sum *)</span>
<span class="keyword1"><span class="command">instantiation</span></span> nat <span class="keyword2"><span class="keyword">and</span></span> unit<span class="main">::</span> <span class="quoted"><span class="quoted">showable</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> print_nat<span class="main">:</span> <span class="quoted"><span class="quoted">"print <span class="main">(</span><span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">::</span>nat<span class="main">)</span> <span class="main">=</span> string_of_nat <span class="free"><span class="bound"><span class="entity">n</span></span></span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> print_unit<span class="main">:</span> <span class="quoted"><span class="quoted">"print <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">::</span>unit<span class="main">)</span> <span class="main">=</span> <span class="inner_quoted">''''</span>"</span></span>
  <span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> Tagged_Prod_Sum.prod <span class="keyword2"><span class="keyword">and</span></span> Tagged_Prod_Sum.sum <span class="main">::</span> <span class="main">(</span><span class="quoted"><span class="quoted">showable</span></span><span class="main">,</span> <span class="quoted"><span class="quoted">showable</span></span><span class="main">)</span> <span class="quoted"><span class="quoted">showable</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> print_prod_def<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"print <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">::</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> Tagged_Prod_Sum.prod<span class="main">)</span> <span class="main">=</span> 
    <span class="main">(</span><span class="keyword1">case</span> Tagged_Prod_Sum.sel_name_fst <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">of</span> 
        None <span class="main">⇒</span> <span class="main">(</span>print <span class="main">(</span>Tagged_Prod_Sum.fst <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">)</span> 
      <span class="main">|</span> Some <span class="bound">s</span> <span class="main">⇒</span> <span class="inner_quoted">''(''</span> <span class="main">@</span> <span class="bound">s</span> <span class="main">@</span> <span class="inner_quoted">'': ''</span> <span class="main">@</span> <span class="main">(</span>print <span class="main">(</span>Tagged_Prod_Sum.fst <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">@</span> <span class="inner_quoted">'')''</span><span class="main">)</span>
    <span class="main">@</span>
    <span class="inner_quoted">'' ''</span> 
    <span class="main">@</span>
    <span class="main">(</span><span class="keyword1">case</span> Tagged_Prod_Sum.sel_name_snd <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">of</span> 
        None <span class="main">⇒</span> <span class="main">(</span>print <span class="main">(</span>Tagged_Prod_Sum.snd <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">)</span> 
      <span class="main">|</span> Some <span class="bound">s</span> <span class="main">⇒</span> <span class="inner_quoted">''(''</span> <span class="main">@</span> <span class="bound">s</span> <span class="main">@</span> <span class="inner_quoted">'': ''</span> <span class="main">@</span> <span class="main">(</span>print <span class="main">(</span>Tagged_Prod_Sum.snd <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">@</span> <span class="inner_quoted">'')''</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> print_sum_def<span class="main">:</span>  <span class="quoted"><span class="quoted">"print <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">::</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> Tagged_Prod_Sum.sum<span class="main">)</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">of</span> <span class="main">(</span>Tagged_Prod_Sum.Inl <span class="bound">s</span> <span class="bound">a</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> <span class="bound">s</span> <span class="keyword1">of</span> None <span class="main">⇒</span> print <span class="bound">a</span> <span class="main">|</span> Some <span class="bound">c</span> <span class="main">⇒</span> <span class="inner_quoted">''(''</span> <span class="main">@</span> <span class="bound">c</span> <span class="main">@</span> <span class="inner_quoted">'' ''</span> <span class="main">@</span> <span class="main">(</span>print <span class="bound">a</span><span class="main">)</span> <span class="main">@</span> <span class="inner_quoted">'')''</span><span class="main">)</span>
           <span class="main">|</span> <span class="main">(</span>Tagged_Prod_Sum.Inr <span class="bound">s</span> <span class="bound">b</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> <span class="bound">s</span> <span class="keyword1">of</span> None <span class="main">⇒</span> print <span class="bound">b</span> <span class="main">|</span> Some <span class="bound">c</span> <span class="main">⇒</span> <span class="inner_quoted">''(''</span> <span class="main">@</span> <span class="bound">c</span> <span class="main">@</span> <span class="inner_quoted">'' ''</span> <span class="main">@</span> <span class="main">(</span>print <span class="bound">b</span><span class="main">)</span> <span class="main">@</span> <span class="inner_quoted">'')''</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* simple types *)</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">ML_print_depth</span><span class="main"><span class="main">=</span></span>30<span class="main">]</span><span class="main">]</span>

<span class="keyword1"><span class="command">derive_generic</span></span> <span class="main">(</span>metadata<span class="main">)</span> showable <span class="quoted">simple</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">derive_generic</span></span> <span class="main">(</span>metadata<span class="main">)</span> showable <span class="quoted">either</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"print <span class="main">(</span>A <span class="numeral">3</span><span class="main">)</span>"</span></span> 
<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"print <span class="main">(</span>B <span class="main">1</span> <span class="numeral">2</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">value</span></span> <span class="main">[</span>simp<span class="main">]</span> <span class="quoted"><span class="quoted">"print <span class="main">(</span>L <span class="main">(</span><span class="numeral">2</span><span class="main">::</span>nat<span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"print C"</span></span>

<span class="comment1">(* recursive types *)</span>

<span class="keyword1"><span class="command">derive_generic</span></span> <span class="main">(</span>metadata<span class="main">)</span> showable <span class="quoted">list</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">derive_generic</span></span> <span class="main">(</span>metadata<span class="main">)</span> showable <span class="quoted">tree</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"print <span class="main">[</span><span class="main">1</span><span class="main">,</span><span class="numeral">2</span><span class="main">::</span>nat<span class="main">]</span>"</span></span>
<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"print <span class="main">(</span>Node <span class="main">(</span><span class="numeral">3</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">(</span>Node <span class="main">1</span> Leaf Leaf<span class="main">)</span> <span class="main">(</span>Node <span class="numeral">2</span> Leaf Leaf<span class="main">)</span><span class="main">)</span>"</span></span>

<span class="comment1">(* mutually recursive types *)</span>

<span class="keyword1"><span class="command">derive_generic</span></span> <span class="main">(</span>metadata<span class="main">)</span> showable <span class="quoted">even_nat</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">derive_generic</span></span> <span class="main">(</span>metadata<span class="main">)</span> showable <span class="quoted">exp</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"print <span class="main">(</span>Odd_Succ <span class="main">(</span>Even_Succ <span class="main">(</span>Odd_Succ Even_Zero<span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">value</span></span> <span class="main">[</span>simp<span class="main">]</span> <span class="quoted"><span class="quoted">"print <span class="main">(</span>Sum <span class="main">(</span>Factor <span class="main">(</span>Const <span class="main">(</span><span class="main">0</span><span class="main">::</span>nat<span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Term <span class="main">(</span>Prod <span class="main">(</span>Const <span class="main">(</span><span class="main">1</span><span class="main">::</span>nat<span class="main">)</span><span class="main">)</span> <span class="main">(</span>Factor <span class="main">(</span>Const <span class="main">(</span><span class="numeral">2</span><span class="main">::</span>nat<span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="Derive_Eq_Laws">
<div class="head">
<h1>Theory Derive_Eq_Laws</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">"Classes with Laws"</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Equality"</span></span>

<span class="keyword1"><span class="command">theory</span></span> Derive_Eq_Laws
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a> <span class="quoted">"<a href="Derive.html">../Derive</a>"</span> <a href="Derive_Datatypes.html">Derive_Datatypes</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">class</span></span> eq <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free"><span class="free"><span class="free">eq</span></span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> refl<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">eq</span> <span class="free">x</span> <span class="free">x</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
          sym<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">eq</span> <span class="free">x</span> <span class="free">y</span> <span class="main">⟹</span> <span class="free">eq</span> <span class="free">y</span> <span class="free">x</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
          trans<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">eq</span> <span class="free">x</span> <span class="free">y</span> <span class="main">⟹</span> <span class="free">eq</span> <span class="free">y</span> <span class="free">z</span> <span class="main">⟹</span> <span class="free">eq</span> <span class="free">x</span> <span class="free">z</span>"</span></span>

<span class="keyword1"><span class="command">derive_generic_setup</span></span> eq
  <span class="keyword1"><span class="command">unfolding</span></span> eq_class_law_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="Derive_Eq_Laws-eq_law_eq"><span class="command">lemma</span></span> eq_law_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"eq_class_law eq"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> eq_class_law_def
  <span class="keyword1"><span class="command">using</span></span> eq_class.axioms <span class="keyword1"><span class="command">unfolding</span></span> class.eq_def <span class="keyword1"><span class="command">.</span></span>

<span class="comment1">(* Manual instances for nat, unit, prod, and sum *)</span>
<span class="keyword1"><span class="command">instantiation</span></span> nat <span class="keyword2"><span class="keyword">and</span></span> unit <span class="main">::</span> <span class="quoted"><span class="quoted">eq</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> eq_nat_def <span class="main">:</span> <span class="quoted"><span class="quoted">"eq <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">::</span>nat<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> eq_unit_def<span class="main">:</span> <span class="quoted"><span class="quoted">"eq <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">::</span>unit<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">⟷</span> True"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="skolem">z</span> <span class="main">::</span> <span class="quoted">nat</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"eq <span class="skolem">x</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> eq_nat_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"eq <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">⟹</span> eq <span class="skolem">y</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> eq_nat_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"eq <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">⟹</span> eq <span class="skolem">y</span> <span class="skolem">z</span> <span class="main">⟹</span> eq <span class="skolem">x</span> <span class="skolem">z</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> eq_nat_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="skolem">z</span> <span class="main">::</span> <span class="quoted">unit</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"eq <span class="skolem">x</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> eq_unit_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"eq <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">⟹</span> eq <span class="skolem">y</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> eq_unit_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"eq <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">⟹</span> eq <span class="skolem">y</span> <span class="skolem">z</span> <span class="main">⟹</span> eq <span class="skolem">x</span> <span class="skolem">z</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> eq_unit_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> prod <span class="keyword2"><span class="keyword">and</span></span> sum <span class="main">::</span> <span class="main">(</span><span class="quoted"><span class="quoted">eq</span></span><span class="main">,</span> <span class="quoted"><span class="quoted">eq</span></span><span class="main">)</span> <span class="quoted"><span class="quoted">eq</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> eq_prod_def<span class="main">:</span> <span class="quoted"><span class="quoted">"eq <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">⟷</span> <span class="main">(</span>eq <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span>eq <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> eq_sum_def<span class="main">:</span> <span class="quoted"><span class="quoted">"eq <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">of</span> Inl <span class="bound">a</span> <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="keyword1">of</span> Inl <span class="bound">b</span> <span class="main">⇒</span> eq <span class="bound">a</span> <span class="bound">b</span> <span class="main">|</span> Inr <span class="bound">b</span> <span class="main">⇒</span> False<span class="main">)</span>
                                            <span class="main">|</span> Inr <span class="bound">a</span> <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="keyword1">of</span> Inl <span class="bound">b</span> <span class="main">⇒</span> False <span class="main">|</span> Inr <span class="bound">b</span> <span class="main">⇒</span> eq <span class="bound">a</span> <span class="bound">b</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="skolem">z</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>eq<span class="main">)</span> <span class="main">×</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">::</span>eq<span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"eq <span class="skolem">x</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> eq_prod_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq_class.refl<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"eq <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">⟹</span> eq <span class="skolem">y</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> eq_prod_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq_class.sym<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"eq <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">⟹</span> eq <span class="skolem">y</span> <span class="skolem">z</span> <span class="main">⟹</span> eq <span class="skolem">x</span> <span class="skolem">z</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> eq_prod_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> eq_class.trans<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="skolem">z</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>eq<span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">::</span>eq<span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"eq <span class="skolem">x</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> eq_sum_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sum.case_eq_if eq_class.refl<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"eq <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">⟹</span> eq <span class="skolem">y</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> eq_sum_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> eq_class.sym sum.case_eq_if<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"eq <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">⟹</span> eq <span class="skolem">y</span> <span class="skolem">z</span> <span class="main">⟹</span> eq <span class="skolem">x</span> <span class="skolem">z</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> eq_sum_def 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> sum.case_eq_if<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"isl <span class="skolem">x</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="quoted">"isl <span class="skolem">y</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="quoted">"isl <span class="skolem">z</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq_class.trans<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* nonrecursive test *)</span>
<span class="keyword1"><span class="command">derive_generic</span></span> eq <span class="quoted">simple</span> <span class="keyword1"><span class="command">.</span></span>

<span class="comment1">(* some tests *)</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"eq <span class="main">(</span>A <span class="numeral">4</span><span class="main">)</span> <span class="main">(</span>A <span class="numeral">4</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"eq <span class="main">(</span>A <span class="numeral">6</span><span class="main">)</span> <span class="main">(</span>A <span class="numeral">4</span><span class="main">)</span> <span class="main">⟷</span> False"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"eq C C"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"eq <span class="main">(</span>B <span class="numeral">4</span> <span class="numeral">5</span><span class="main">)</span> <span class="main">(</span>B <span class="numeral">4</span> <span class="numeral">5</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"eq <span class="main">(</span>B <span class="numeral">4</span> <span class="numeral">4</span><span class="main">)</span> <span class="main">(</span>A <span class="numeral">3</span><span class="main">)</span> <span class="main">⟷</span> False"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"eq C <span class="main">(</span>A <span class="numeral">4</span><span class="main">)</span> <span class="main">⟷</span> False"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>

<span class="comment1">(* type with parameter *)</span>

<span class="keyword1"><span class="command">derive_generic</span></span> eq <span class="quoted">either</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"eq <span class="main">(</span>L <span class="main">(</span><span class="numeral">3</span><span class="main">::</span>nat<span class="main">)</span><span class="main">)</span> <span class="main">(</span>R <span class="numeral">3</span><span class="main">)</span> <span class="main">⟷</span> False"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">code_simp</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"eq <span class="main">(</span>L <span class="main">(</span><span class="numeral">3</span><span class="main">::</span>nat<span class="main">)</span><span class="main">)</span> <span class="main">(</span>L <span class="numeral">3</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">code_simp</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"eq <span class="main">(</span>L <span class="main">(</span><span class="numeral">3</span><span class="main">::</span>nat<span class="main">)</span><span class="main">)</span> <span class="main">(</span>L <span class="numeral">4</span><span class="main">)</span> <span class="main">⟷</span> False"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">code_simp</span>

<span class="comment1">(* recursive types *)</span>
<span class="keyword1"><span class="command">derive_generic</span></span> eq <span class="quoted">list</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">goal_cases</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">x</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>In <span class="skolem">y</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">y</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Derive_Eq_Laws.eq_mulistF.simps eq_unit_def eq_class.refl<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>2 <span class="skolem">x</span> <span class="skolem">y</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">y</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">x</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>In <span class="skolem">y</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">y</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">hypsubst_thin</span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Derive_Eq_Laws.eq_mulistF.simps sum.case_eq_if eq_unit_def<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">metis</span> old.sum.simps<span class="main"><span class="main">(</span></span>5<span class="main"><span class="main">)</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">unfolding</span></span> sum_set_defs prod_set_defs
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Derive_Eq_Laws.eq_mulistF.simps sum.case_eq_if<span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> eq_class.sym <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>      
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>3 <span class="skolem">x</span> <span class="skolem">y</span> <span class="skolem">z</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">x</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">y</span></span> <span class="quoted"><span class="skolem">z</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>In <span class="skolem">x'</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x'</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">y</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">z</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">hypsubst_thin</span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Derive_Eq_Laws.eq_mulistF.simps sum.case_eq_if eq_unit_def<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> sum.case_eq_if<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">y</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">z</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">hypsubst_thin</span><span class="main">)</span>
      <span class="keyword1"><span class="command">unfolding</span></span> sum_set_defs prod_set_defs
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Derive_Eq_Laws.eq_mulistF.simps eq_unit_def snds.intros<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> sum.case_eq_if<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> eq_class.trans<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"eq <span class="main">(</span><span class="main">[]</span><span class="main">::</span><span class="main">(</span>nat list<span class="main">)</span><span class="main">)</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"eq <span class="main">(</span><span class="main">[</span><span class="main">1</span><span class="main">,</span><span class="numeral">2</span><span class="main">,</span><span class="numeral">3</span><span class="main">]</span><span class="main">::</span> <span class="main">(</span>nat list<span class="main">)</span><span class="main">)</span> <span class="main">[</span><span class="main">1</span><span class="main">,</span><span class="numeral">2</span><span class="main">,</span><span class="numeral">3</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"eq <span class="main">[</span><span class="main">(</span><span class="main">1</span><span class="main">::</span>nat<span class="main">)</span><span class="main">]</span> <span class="main">[</span><span class="main">1</span><span class="main">,</span><span class="numeral">2</span><span class="main">]</span> <span class="main">⟷</span> False"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>

<span class="keyword1"><span class="command">derive_generic</span></span> eq <span class="quoted">tree</span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">goal_cases</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">x</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>In <span class="skolem">y</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">y</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Derive_Eq_Laws.eq_mutreeF.simps eq_unit_def eq_class.refl<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>2 <span class="skolem">x</span> <span class="skolem">y</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">y</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">x</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>In <span class="skolem">y</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">y</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">hypsubst_thin</span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Derive_Eq_Laws.eq_mutreeF.simps sum.case_eq_if eq_unit_def<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">metis</span> old.sum.simps<span class="main"><span class="main">(</span></span>5<span class="main"><span class="main">)</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">unfolding</span></span> sum_set_defs prod_set_defs
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Derive_Eq_Laws.eq_mutreeF.simps sum.case_eq_if<span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> eq_class.sym <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>      
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>3 <span class="skolem">x</span> <span class="skolem">y</span> <span class="skolem">z</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">x</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">y</span></span> <span class="quoted"><span class="skolem">z</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>In <span class="skolem">x'</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x'</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">y</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">z</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">hypsubst_thin</span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Derive_Eq_Laws.eq_mutreeF.simps sum.case_eq_if eq_unit_def<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> sum.case_eq_if<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">y</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">z</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">hypsubst_thin</span><span class="main">)</span>
      <span class="keyword1"><span class="command">unfolding</span></span> sum_set_defs prod_set_defs
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Derive_Eq_Laws.eq_mutreeF.simps eq_unit_def snds.intros<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> sum.case_eq_if<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> eq_class.trans<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"eq Leaf Leaf"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">code_simp</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"eq <span class="main">(</span>Node <span class="main">(</span><span class="main">1</span><span class="main">::</span>nat<span class="main">)</span> Leaf Leaf<span class="main">)</span> Leaf <span class="main">⟷</span> False"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"eq <span class="main">(</span>Node <span class="main">(</span><span class="main">1</span><span class="main">::</span>nat<span class="main">)</span> Leaf Leaf<span class="main">)</span> <span class="main">(</span>Node <span class="main">(</span><span class="main">1</span><span class="main">::</span>nat<span class="main">)</span> Leaf Leaf<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"eq <span class="main">(</span>Node <span class="main">(</span><span class="main">1</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">(</span>Node <span class="numeral">2</span> Leaf Leaf<span class="main">)</span> <span class="main">(</span>Node <span class="numeral">3</span> Leaf Leaf<span class="main">)</span><span class="main">)</span> <span class="main">(</span>Node <span class="main">(</span><span class="main">1</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">(</span>Node <span class="numeral">2</span> Leaf Leaf<span class="main">)</span> <span class="main">(</span>Node <span class="numeral">4</span> Leaf Leaf<span class="main">)</span><span class="main">)</span> 
    <span class="main">⟷</span> False"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="Derive_Algebra_Laws">
<div class="head">
<h1>Theory Derive_Algebra_Laws</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Algebraic Classes"</span></span>

<span class="keyword1"><span class="command">theory</span></span> Derive_Algebra_Laws
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a> <span class="quoted">"<a href="Derive.html">../Derive</a>"</span> <a href="Derive_Datatypes.html">Derive_Datatypes</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">datatype</span></span> simple_int <span class="main">=</span> A <span class="quoted">int</span> <span class="main">|</span> B <span class="quoted">int</span> <span class="quoted">int</span> <span class="main">|</span> C 

<span class="keyword1"><span class="command">class</span></span> semigroup <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free"><span class="free"><span class="free">mult</span></span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1"><span class="keyword1"><span class="keyword1">⊗</span></span></span>"</span> 70<span class="main">)</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> assoc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main"><span class="free">⊗</span></span> <span class="free">y</span><span class="main">)</span> <span class="main"><span class="free">⊗</span></span> <span class="free">z</span> <span class="main">=</span> <span class="free">x</span> <span class="main"><span class="free">⊗</span></span> <span class="main">(</span><span class="free">y</span> <span class="main"><span class="free">⊗</span></span> <span class="free">z</span><span class="main">)</span>"</span></span> 

<span class="keyword1"><span class="command">class</span></span> monoidl <span class="main">=</span> semigroup <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free"><span class="free"><span class="free">neutral</span></span></span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1"><span class="keyword1"><span class="keyword1">𝟭</span></span></span>"</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> neutl <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main"><span class="free">𝟭</span></span> <span class="main">⊗</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span>   
  
<span class="keyword1"><span class="command">class</span></span> group <span class="main">=</span> monoidl <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free"><span class="free"><span class="free">inverse</span></span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> invl<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">inverse</span> <span class="free">x</span><span class="main">)</span> <span class="main">⊗</span> <span class="free">x</span> <span class="main">=</span> <span class="main">𝟭</span>"</span></span> 

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">semigroup_law</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">semigroup_law</span> <span class="free"><span class="bound"><span class="entity">MULT</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">x</span> <span class="bound">y</span> <span class="bound">z</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">MULT</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">MULT</span></span></span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span> <span class="bound">z</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">MULT</span></span></span> <span class="bound">x</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">MULT</span></span></span> <span class="bound">y</span> <span class="bound">z</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">monoidl_law</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">monoidl_law</span> <span class="free"><span class="bound"><span class="entity">NEUTRAL</span></span></span> <span class="free"><span class="bound"><span class="entity">MULT</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="main">∀</span> <span class="bound">x</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">MULT</span></span></span> <span class="free"><span class="bound"><span class="entity">NEUTRAL</span></span></span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">x</span><span class="main">)</span> <span class="main">∧</span> semigroup_law <span class="free"><span class="bound"><span class="entity">MULT</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">group_law</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">group_law</span> <span class="free"><span class="bound"><span class="entity">INVERSE</span></span></span> <span class="free"><span class="bound"><span class="entity">NEUTRAL</span></span></span> <span class="free"><span class="bound"><span class="entity">MULT</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="main">∀</span> <span class="bound">x</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">MULT</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">INVERSE</span></span></span> <span class="bound">x</span><span class="main">)</span> <span class="bound">x</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">NEUTRAL</span></span></span><span class="main">)</span> <span class="main">∧</span> monoidl_law <span class="free"><span class="bound"><span class="entity">NEUTRAL</span></span></span> <span class="free"><span class="bound"><span class="entity">MULT</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Derive_Algebra_Laws-transfer_semigroup"><span class="command">lemma</span></span> transfer_semigroup<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Derive.iso <span class="free">f</span> <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"semigroup_law <span class="free">MULT</span> <span class="main">⟹</span> semigroup_law <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">g</span> <span class="main">(</span><span class="free">MULT</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">f</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> semigroup_law_def
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> Derive.iso_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Derive_Algebra_Laws-transfer_monoidl"><span class="command">lemma</span></span> transfer_monoidl<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Derive.iso <span class="free">f</span> <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monoidl_law <span class="free">NEUTRAL</span> <span class="free">MULT</span> <span class="main">⟹</span> monoidl_law <span class="main">(</span><span class="free">g</span> <span class="free">NEUTRAL</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">g</span> <span class="main">(</span><span class="free">MULT</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">f</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> monoidl_law_def semigroup_law_def 
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> Derive.iso_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Derive_Algebra_Laws-transfer_group"><span class="command">lemma</span></span> transfer_group<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Derive.iso <span class="free">f</span> <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"group_law <span class="free">INVERSE</span> <span class="free">NEUTRAL</span> <span class="free">MULT</span> <span class="main">⟹</span> group_law <span class="main">(</span><span class="main">λ</span> <span class="bound">x</span><span class="main">.</span> <span class="free">g</span> <span class="main">(</span><span class="free">INVERSE</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free">g</span> <span class="free">NEUTRAL</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">g</span> <span class="main">(</span><span class="free">MULT</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">f</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> group_law_def monoidl_law_def semigroup_law_def
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> Derive.iso_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Derive_Algebra_Laws-semigroup_law_semigroup"><span class="command">lemma</span></span> semigroup_law_semigroup<span class="main">:</span> <span class="quoted"><span class="quoted">"semigroup_law mult"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> semigroup_law_def
  <span class="keyword1"><span class="command">using</span></span> semigroup_class.axioms <span class="keyword1"><span class="command">unfolding</span></span> class.semigroup_def <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1" id="Derive_Algebra_Laws-monoidl_law_monoidl"><span class="command">lemma</span></span> monoidl_law_monoidl<span class="main">:</span> <span class="quoted"><span class="quoted">"monoidl_law neutral mult"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> monoidl_law_def
  <span class="keyword1"><span class="command">using</span></span> monoidl_class.axioms semigroup_law_semigroup 
  <span class="keyword1"><span class="command">unfolding</span></span> class.monoidl_axioms_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Derive_Algebra_Laws-group_law_group"><span class="command">lemma</span></span> group_law_group<span class="main">:</span> <span class="quoted"><span class="quoted">"group_law inverse neutral mult"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> group_law_def
  <span class="keyword1"><span class="command">using</span></span> group_class.axioms monoidl_law_monoidl 
  <span class="keyword1"><span class="command">unfolding</span></span> class.group_axioms_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">derive_generic_setup</span></span> semigroup
  <span class="keyword1"><span class="command">unfolding</span></span> semigroup_class_law_def
  Derive.iso_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">derive_generic_setup</span></span> monoidl
  <span class="keyword1"><span class="command">unfolding</span></span> monoidl_class_law_def semigroup_class_law_def Derive.iso_def 
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">derive_generic_setup</span></span> group
  <span class="keyword1"><span class="command">unfolding</span></span> group_class_law_def monoidl_class_law_def semigroup_class_law_def Derive.iso_def 
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="comment1">(* Manual instances for int, unit, prod, and sum *)</span>    
<span class="keyword1"><span class="command">instantiation</span></span> int <span class="keyword2"><span class="keyword">and</span></span> unit<span class="main">::</span> <span class="quoted"><span class="quoted">semigroup</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>  
  <span class="keyword1"><span class="command">definition</span></span> mult_int_def <span class="main">:</span> <span class="quoted"><span class="quoted">"mult <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">::</span>int<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">+</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> mult_unit_def<span class="main">:</span> <span class="quoted"><span class="quoted">"mult <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">::</span>unit<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="skolem">z</span> <span class="main">::</span> <span class="quoted">int</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">⊗</span> <span class="skolem">y</span> <span class="main">⊗</span> <span class="skolem">z</span> <span class="main">=</span> <span class="skolem">x</span> <span class="main">⊗</span> <span class="main">(</span><span class="skolem">y</span> <span class="main">⊗</span> <span class="skolem">z</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> mult_int_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="skolem">z</span> <span class="main">::</span> <span class="quoted">unit</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">⊗</span> <span class="skolem">y</span> <span class="main">⊗</span> <span class="skolem">z</span> <span class="main">=</span> <span class="skolem">x</span> <span class="main">⊗</span> <span class="main">(</span><span class="skolem">y</span> <span class="main">⊗</span> <span class="skolem">z</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> mult_unit_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>
<span class="keyword2"><span class="keyword">end</span></span> 
<span class="keyword1"><span class="command">instantiation</span></span> int <span class="keyword2"><span class="keyword">and</span></span> unit<span class="main">::</span> <span class="quoted"><span class="quoted">monoidl</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>  
  <span class="keyword1"><span class="command">definition</span></span> neutral_int_def <span class="main">:</span> <span class="quoted"><span class="quoted">"neutral <span class="main">=</span> <span class="main">(</span><span class="main">0</span><span class="main">::</span>int<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> neutral_unit_def<span class="main">:</span> <span class="quoted"><span class="quoted">"neutral <span class="main">=</span> <span class="main">()</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted">int</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">𝟭</span> <span class="main">⊗</span> <span class="skolem">x</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> neutral_int_def mult_int_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted">unit</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">𝟭</span> <span class="main">⊗</span> <span class="skolem">x</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> neutral_unit_def mult_unit_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>
<span class="keyword2"><span class="keyword">end</span></span>   
  
<span class="keyword1"><span class="command">instantiation</span></span> int <span class="keyword2"><span class="keyword">and</span></span> unit<span class="main">::</span> <span class="quoted"><span class="quoted">group</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>  
  <span class="keyword1"><span class="command">definition</span></span> inverse_int_def <span class="main">:</span> <span class="quoted"><span class="quoted">"inverse <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">::</span>int<span class="main">)</span> <span class="main">=</span> <span class="main">𝟭</span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> inverse_unit_def<span class="main">:</span> <span class="quoted"><span class="quoted">"inverse <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">=</span> <span class="main">()</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted">int</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"inverse <span class="skolem">x</span> <span class="main">⊗</span> <span class="skolem">x</span> <span class="main">=</span> <span class="main">𝟭</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> inverse_int_def mult_int_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted">unit</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"inverse <span class="skolem">x</span> <span class="main">⊗</span> <span class="skolem">x</span> <span class="main">=</span> <span class="main">𝟭</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> inverse_unit_def mult_unit_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>
<span class="keyword2"><span class="keyword">end</span></span>   

<span class="keyword1"><span class="command">instantiation</span></span> prod <span class="keyword2"><span class="keyword">and</span></span> sum <span class="main">::</span> <span class="main">(</span><span class="quoted"><span class="quoted">semigroup</span></span><span class="main">,</span> <span class="quoted"><span class="quoted">semigroup</span></span><span class="main">)</span> <span class="quoted"><span class="quoted">semigroup</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> mult_prod_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">⊗</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">⊗</span> fst <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">,</span> snd <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">⊗</span> snd <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> mult_sum_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">⊗</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">of</span> Inl <span class="bound">a</span> <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="keyword1">of</span> Inl <span class="bound">b</span> <span class="main">⇒</span> Inl <span class="main">(</span><span class="bound">a</span> <span class="main">⊗</span> <span class="bound">b</span><span class="main">)</span> <span class="main">|</span> Inr <span class="bound">b</span> <span class="main">⇒</span> Inr <span class="bound">b</span><span class="main">)</span>
                                             <span class="main">|</span> Inr <span class="bound">a</span> <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="keyword1">of</span> Inl <span class="bound">b</span> <span class="main">⇒</span> Inr <span class="bound">a</span> <span class="main">|</span> Inr <span class="bound">b</span> <span class="main">⇒</span> Inr <span class="main">(</span><span class="bound">a</span> <span class="main">⊗</span> <span class="bound">b</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="skolem">z</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>semigroup<span class="main">)</span> <span class="main">×</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">::</span>semigroup<span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">⊗</span> <span class="skolem">y</span> <span class="main">⊗</span> <span class="skolem">z</span> <span class="main">=</span> <span class="skolem">x</span> <span class="main">⊗</span> <span class="main">(</span><span class="skolem">y</span> <span class="main">⊗</span> <span class="skolem">z</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> mult_prod_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assoc<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="skolem">z</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>semigroup<span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">::</span>semigroup<span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">⊗</span> <span class="skolem">y</span> <span class="main">⊗</span> <span class="skolem">z</span> <span class="main">=</span> <span class="skolem">x</span> <span class="main">⊗</span> <span class="main">(</span><span class="skolem">y</span> <span class="main">⊗</span> <span class="skolem">z</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> mult_sum_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assoc sum.case_eq_if<span class="main">)</span> 
<span class="keyword1"><span class="command">qed</span></span>
<span class="keyword2"><span class="keyword">end</span></span>
  
<span class="keyword1"><span class="command">instantiation</span></span> prod <span class="keyword2"><span class="keyword">and</span></span> sum <span class="main">::</span> <span class="main">(</span><span class="quoted"><span class="quoted">monoidl</span></span><span class="main">,</span> <span class="quoted"><span class="quoted">monoidl</span></span><span class="main">)</span> <span class="quoted"><span class="quoted">monoidl</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> neutral_prod_def<span class="main">:</span> <span class="quoted"><span class="quoted">"neutral <span class="main">=</span> <span class="main">(</span>neutral<span class="main">,</span>neutral<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> neutral_sum_def<span class="main">:</span> <span class="quoted"><span class="quoted">"neutral <span class="main">=</span> Inl neutral"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>monoidl<span class="main">)</span> <span class="main">×</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">::</span>monoidl<span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">𝟭</span> <span class="main">⊗</span> <span class="skolem">x</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> neutral_prod_def mult_prod_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> neutl<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>monoidl<span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">::</span>monoidl<span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">𝟭</span> <span class="main">⊗</span> <span class="skolem">x</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> neutral_sum_def mult_sum_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> neutl sum.case_eq_if sum.exhaust_sel<span class="main">)</span> 
<span class="keyword1"><span class="command">qed</span></span>
<span class="keyword2"><span class="keyword">end</span></span> 
  
<span class="keyword1"><span class="command">instantiation</span></span> prod <span class="main">::</span> <span class="main">(</span><span class="quoted">group</span><span class="main">,</span> <span class="quoted">group</span><span class="main">)</span> <span class="quoted">group</span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> inverse_prod_def<span class="main">:</span> <span class="quoted"><span class="quoted">"inverse <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span>inverse <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span><span class="main">,</span> inverse <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>group<span class="main">)</span> <span class="main">×</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">::</span>group<span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"inverse <span class="skolem">x</span> <span class="main">⊗</span> <span class="skolem">x</span> <span class="main">=</span> <span class="main">𝟭</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> inverse_prod_def mult_prod_def neutral_prod_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> invl<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>
<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">derive_generic</span></span> semigroup <span class="quoted">simple_int</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">derive_generic</span></span> monoidl <span class="quoted">simple_int</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">derive_generic</span></span> semigroup <span class="quoted">either</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">derive_generic</span></span> monoidl <span class="quoted">either</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>B <span class="main">𝟭</span> <span class="numeral">6</span><span class="main">)</span> <span class="main">⊗</span> <span class="main">(</span>B <span class="numeral">4</span> <span class="numeral">5</span><span class="main">)</span> <span class="main">=</span> B <span class="numeral">4</span> <span class="numeral">11</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>A <span class="numeral">2</span><span class="main">)</span> <span class="main">⊗</span> <span class="main">(</span>A <span class="numeral">3</span><span class="main">)</span> <span class="main">=</span> A <span class="numeral">5</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>B <span class="main">𝟭</span> <span class="numeral">6</span><span class="main">)</span> <span class="main">⊗</span> <span class="main">𝟭</span> <span class="main">=</span> B <span class="main">0</span> <span class="numeral">6</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>L <span class="numeral">3</span><span class="main">)</span> <span class="main">⊗</span> <span class="main">(</span><span class="main">(</span>L <span class="numeral">4</span><span class="main">)</span><span class="main">::</span><span class="main">(</span>int<span class="main">,</span>int<span class="main">)</span> either<span class="main">)</span> <span class="main">=</span> L <span class="numeral">7</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>R <span class="main">(</span><span class="numeral">2</span><span class="main">::</span>int<span class="main">)</span><span class="main">)</span> <span class="main">⊗</span> <span class="main">(</span>L <span class="main">(</span><span class="numeral">3</span><span class="main">::</span>int<span class="main">)</span><span class="main">)</span> <span class="main">=</span> R <span class="numeral">2</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>

<span class="keyword1"><span class="command">derive_generic</span></span> semigroup <span class="quoted">list</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">goal_cases</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">x</span> <span class="skolem">y</span> <span class="skolem">z</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">x</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">y</span></span> <span class="quoted"><span class="skolem">z</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>In <span class="skolem">x'</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x'</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">y</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">z</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">hypsubst_thin</span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Derive_Algebra_Laws.mult_mulistF.simps sum.case_eq_if mult_unit_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">y</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">z</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">hypsubst_thin</span><span class="main">)</span>
      <span class="keyword1"><span class="command">unfolding</span></span> sum_set_defs prod_set_defs
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Derive_Algebra_Laws.mult_mulistF.simps mult_unit_def<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sum.case_eq_if assoc<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>    

<span class="keyword1"><span class="command">derive_generic</span></span> semigroup <span class="quoted">tree</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">goal_cases</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">x</span> <span class="skolem">y</span> <span class="skolem">z</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">x</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">y</span></span> <span class="quoted"><span class="skolem">z</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>In <span class="skolem">x'</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x'</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">y</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">z</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">hypsubst_thin</span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Derive_Algebra_Laws.mult_mutreeF.simps sum.case_eq_if mult_unit_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">y</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">z</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">hypsubst_thin</span><span class="main">)</span>
      <span class="keyword1"><span class="command">unfolding</span></span> sum_set_defs prod_set_defs
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Derive_Algebra_Laws.mult_mutreeF.simps mult_unit_def<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> semigroup_class.assoc sum.case_eq_if<span class="main">)</span> 
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">derive_generic</span></span> monoidl <span class="quoted">list</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">goal_cases</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">x</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>In <span class="skolem">x'</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x'</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Derive_Algebra_Laws.neutral_mulistF_def sum.case_eq_if neutral_unit_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">derive_generic</span></span> monoidl <span class="quoted">tree</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">goal_cases</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">x</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>In <span class="skolem">x'</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x'</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Derive_Algebra_Laws.neutral_mutreeF_def sum.case_eq_if neutral_unit_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">1</span><span class="main">,</span><span class="numeral">2</span><span class="main">,</span><span class="numeral">3</span><span class="main">,</span><span class="numeral">4</span><span class="main">::</span>int<span class="main">]</span> <span class="main">⊗</span> <span class="main">[</span><span class="main">1</span><span class="main">,</span><span class="numeral">2</span><span class="main">,</span><span class="numeral">3</span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="numeral">2</span><span class="main">,</span><span class="numeral">4</span><span class="main">,</span><span class="numeral">6</span><span class="main">,</span><span class="numeral">4</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Node <span class="main">(</span><span class="numeral">3</span><span class="main">::</span>int<span class="main">)</span> Leaf Leaf<span class="main">)</span> <span class="main">⊗</span> <span class="main">(</span>Node <span class="main">(</span><span class="main">1</span><span class="main">::</span>int<span class="main">)</span> Leaf Leaf<span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Node <span class="numeral">4</span> Leaf Leaf<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div>