<div id="Banach_Steinhaus_Missing">
<div class="head"><h1>Theory Banach_Steinhaus_Missing</h1>
<span class="command">theory</span> <span class="name">Banach_Steinhaus_Missing</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL-Analysis/Infinite_Set_Sum.html"><span class="name">Infinite_Set_Sum</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  File:   Banach_Steinhaus_Missing.thy
  Author: Dominique Unruh, University of Tartu
  Author: Jose Manuel Rodriguez Caballero, University of Tartu
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Missing results for the proof of Banach-Steinhaus theorem›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Banach_Steinhaus_Missing</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"HOL-Analysis.Infinite_Set_Sum"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Results missing for the proof of Banach-Steinhaus theorem›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  The results proved here are preliminaries for the proof of Banach-Steinhaus theorem using Sokal's 
  approach, but they do not explicitly appear in Sokal's paper ~\cite{sokal2011reall}.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Notation for the norm›</span></span></span><span>
</span><span class="keyword1"><span class="command">bundle</span></span><span> </span><span>notation_norm</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>norm</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"∥_∥"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">bundle</span></span><span> </span><span>no_notation_norm</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>norm</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"∥_∥"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">unbundle</span></span><span> </span><span>notation_norm</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Notation for apply bilinear function›</span></span></span><span>
</span><span class="keyword1"><span class="command">bundle</span></span><span> </span><span>notation_blinfun_apply</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>blinfun_apply</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"*<span class="hidden">⇩</span><sub>v</sub>"</span></span></span><span> </span><span>70</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">bundle</span></span><span> </span><span>no_notation_blinfun_apply</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>blinfun_apply</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"*<span class="hidden">⇩</span><sub>v</sub>"</span></span></span><span> </span><span>70</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">unbundle</span></span><span> </span><span>notation_blinfun_apply</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bdd_above_plus</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span class="delimiter">::</span><span class="cartouche"><span class="delete"><span class="delete">‹'a ⇒ real›</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹bdd_above (f ` S)›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹bdd_above (g ` S)›</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹bdd_above ((λ x. f x + g x) ` S)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Explanation: If the images of two real-valued functions \&lt;^term&gt;‹f›,\&lt;^term&gt;‹g› are bounded above on a 
  set \&lt;^term&gt;‹S›, then the image of their sum is bounded on \&lt;^term&gt;‹S›.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀ x. x∈S ⟹ f x ≤ M›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹bdd_above (f ` S)›</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bdd_above_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>N</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀ x. x∈S ⟹ g x ≤ N›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹bdd_above (g ` S)›</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bdd_above_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀ x. x∈S ⟹ f x + g x ≤ M + N›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀x. x ∈ S ⟹ f x ≤ M›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀x. x ∈ S ⟹ g x ≤ N›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bdd_above_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The maximum of two functions›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>pointwise_max</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b::ord) ⇒ ('a ⇒ 'b) ⇒ ('a ⇒ 'b)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹pointwise_max f g = (λx. max (f x) (g x))›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>max_Sup_absorb_left</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span> </span><span>g</span><span class="delimiter">::</span><span class="cartouche"><span class="delete"><span class="delete">‹'a ⇒ real›</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹X ≠ {}›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹bdd_above (f ` X)›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹bdd_above (g ` X)›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sup (f ` X) ≥ Sup (g ` X)›</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sup ((pointwise_max f g) ` X) = Sup (f ` X)›</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Explanation: For real-valued functions \&lt;^term&gt;‹f› and \&lt;^term&gt;‹g›, if the supremum of \&lt;^term&gt;‹f› is 
    greater-equal the supremum of \&lt;^term&gt;‹g›, then the supremum of \&lt;^term&gt;‹max f g› equals the supremum of
    \&lt;^term&gt;‹f›. (Under some technical conditions.)›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>y_Sup</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y ∈ ((λ x. max (f x) (g x)) ` X) ⟹ y ≤ Sup (f ` X)›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>y</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y ∈ ((λ x. max (f x) (g x)) ` X)›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y = max (f x) (g x)›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ∈ X›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f x ≤ Sup (f ` X)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹x ∈ X›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹bdd_above (f ` X)›</span></span></span><span> </span><span>cSUP_upper</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹g x ≤ Sup (g ` X)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹x ∈ X›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹bdd_above (g ` X)›</span></span></span><span> </span><span>cSUP_upper</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹max (f x) (g x) ≤ Sup (f ` X)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹Sup (f ` X) ≥ Sup (g ` X)›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y = max (f x) (g x)›</span></span></span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>y_f_X</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y ∈ f ` X ⟹ y ≤ Sup ((λ x. max (f x) (g x)) ` X)›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>y</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y ∈ f ` X›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ∈ X›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y = f x›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹bdd_above ((λ ξ. max (f ξ) (g ξ)) ` X)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹bdd_above (f ` X)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹bdd_above (g ` X)›</span></span></span><span> </span><span>bdd_above_image_sup</span><span> </span><span>sup_max</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e &gt; 0 ⟹ ∃ k ∈ (λ ξ. max (f ξ) (g ξ)) ` X. y ≤ k + e›</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>e</span><span class="delimiter">::</span><span>real</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sup (f ` X) ≥ Sup (g ` X)›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ∈ X›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y = f x›</span></span></span><span> </span><span>image_eqI</span><span class="delimiter">)</span><span>        
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ∈ X›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y = f x›</span></span></span><span> </span><span>cSUP_upper</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sup ((λ x. max (f x) (g x)) ` X) ≤ Sup (f ` X)›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>y_Sup</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹X ≠ {}›</span></span></span><span> </span><span>cSup_least</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sup ((λ x. max (f x) (g x)) ` X) ≥ Sup (f ` X)›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>y_f_X</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">)</span><span> </span><span>cSup_least</span><span> </span><span>calculation</span><span> </span><span>empty_is_image</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pointwise_max_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>max_Sup_absorb_right</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span> </span><span>g</span><span class="delimiter">::</span><span class="cartouche"><span class="delete"><span class="delete">‹'a ⇒ real›</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹X ≠ {}›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹bdd_above (f ` X)›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹bdd_above (g ` X)›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sup (f ` X) ≤ Sup (g ` X)›</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sup ((pointwise_max f g) ` X) = Sup (g ` X)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Explanation: For real-valued functions \&lt;^term&gt;‹f› and \&lt;^term&gt;‹g› and a nonempty set \&lt;^term&gt;‹X›, such that 
  the \&lt;^term&gt;‹f› and \&lt;^term&gt;‹g› are bounded above on \&lt;^term&gt;‹X›, if the supremum of \&lt;^term&gt;‹f› on \&lt;^term&gt;‹X› is 
  lower-equal the supremum of \&lt;^term&gt;‹g› on \&lt;^term&gt;‹X›, then the supremum of \&lt;^term&gt;‹pointwise_max f g› on \&lt;^term&gt;‹X›
  equals the supremum of \&lt;^term&gt;‹g›. This is the right analog of @{text max_Sup_absorb_left}.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sup ((pointwise_max g f) ` X) = Sup (g ` X)›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>max_Sup_absorb_left</span><span class="delimiter">)</span><span>     
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹pointwise_max g f = pointwise_max f g›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pointwise_max_def</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>max_Sup</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span> </span><span>g</span><span class="delimiter">::</span><span class="cartouche"><span class="delete"><span class="delete">‹'a ⇒ real›</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹X ≠ {}›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹bdd_above (f ` X)›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹bdd_above (g ` X)›</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sup ((pointwise_max f g) ` X) = max (Sup (f ` X)) (Sup (g ` X))›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Explanation: Let \&lt;^term&gt;‹X› be a nonempty set. Two supremum over \&lt;^term&gt;‹X› of the maximum of two 
  real-value functions is equal to the maximum of their suprema over \&lt;^term&gt;‹X›, provided that the
  functions are bounded above on \&lt;^term&gt;‹X›.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sup (f ` X) ≥ Sup (g ` X)›</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>max_Sup_absorb_left</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ 0 ≤ Sup (f ` X) + - 1 * Sup (g ` X)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Sup (Banach_Steinhaus_Missing.pointwise_max f g ` X) = Sup (g ` X)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>max_Sup_absorb_right</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>identity_telescopic</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹_ ⇒ 'a::real_normed_vector›</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ⇢ l›</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(λ N. sum (λ k. x (Suc k) - x k) {n..N}) ⇢ l - x n›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹
  Expression of a limit as a telescopic series.
  Explanation: If \&lt;^term&gt;‹x› converges to \&lt;^term&gt;‹l› then the sum \&lt;^term&gt;‹sum (λ k. x (Suc k) - x k) {n..N}›
  converges to \&lt;^term&gt;‹l - x n› as \&lt;^term&gt;‹N› goes to infinity.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(λ p. x (p + Suc n)) ⇢ l›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ⇢ l›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>LIMSEQ_ignore_initial_segment</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(λ p. x (Suc n + p)) ⇢ l›</span></span></span><span>   
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add.commute</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(λ p. x (Suc (n + p))) ⇢ l›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(λ t. (- (x n)) + (λ p.  x (Suc (n + p))) t ) ⇢ (- (x n))  + l›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tendsto_add_const_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(λ p. x (Suc (n + p)) - x n)⇢ l - x n›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sum (λ k. x (Suc k) - x k) {n..n+p} = x (Suc (n+p)) - x n›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>p</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sum_Suc_diff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(λ N. sum (λ k. x (Suc k) - x k) {n..N}) (n + t) 
               = (λ p. sum (λ k. x (Suc k) - x k) {n..n+p}) t›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>t</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹(λ p. (λ N. sum (λ k. x (Suc k) - x k) {n..N}) (n + p)) ⇢ l - x n›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(λ p. (λ N. sum (λ k. x (Suc k) - x k) {n..N}) (p + n)) ⇢ l - x n›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add.commute</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹(λ p. (λ N. sum (λ k. x (Suc k) - x k) {n..N}) p) ⇢ l - x n›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Topological_Spaces.LIMSEQ_offset</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(λ N. sum (λ k. x (Suc k) - x k) {n..N})"</span></span></span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"l - x n"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>k</span><span> </span><span class="delimiter">=</span><span> </span><span>n</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹(λ M. (λ N. sum (λ k. x (Suc k) - x k) {n..N}) M) ⇢ l - x n›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bound_Cauchy_to_lim</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y ⇢ x›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀n. ∥y (Suc n) - y n∥ ≤ c^n›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y 0 = 0›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹c &lt; 1›</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∥x - y (Suc n)∥ ≤ (c / (1 - c)) * c ^ n›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹
  Inequality about a sequence of approximations assuming that the sequence of differences is bounded
  by a geometric progression.
  Explanation: Let \&lt;^term&gt;‹y› be a sequence converging to \&lt;^term&gt;‹x›.
  If \&lt;^term&gt;‹y› satisfies the inequality ‹∥y (Suc n) - y n∥ ≤ c ^ n› for some \&lt;^term&gt;‹c &lt; 1› and 
  assuming \&lt;^term&gt;‹y 0 = 0› then the inequality ‹∥x - y (Suc n)∥ ≤ (c / (1 - c)) * c ^ n› holds.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹c ≥ 0›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀ n. ∥y (Suc n) - y n∥ ≤ c^n›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>norm_imp_pos_and_ge</span><span> </span><span>power_Suc0_right</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>norm_1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹norm (∑k = Suc n..N. y (Suc k) - y k) ≤ (c ^ Suc n)/(1 - c)›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>N</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹N &lt; Suc n›</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∥sum (λk. y (Suc k) - y k) {Suc n .. N}∥ = 0›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹c ≥ 0›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹c &lt; 1›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>       
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹N ≥ Suc n›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹c^(Suc N) ≥ 0›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹c ≥ 0›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹1 - c &gt; 0›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹c &lt; 1›</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(1 - c)/(1 - c) = 1›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∥sum (λk. y (Suc k) - y k) {Suc n .. N}∥ ≤ (sum (λk. ∥y (Suc k) - y k∥) {Suc n .. N})›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sum_norm_le</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∥sum (λk. y (Suc k) - y k) {Suc n .. N}∥ ≤ (sum (power c) {Suc n .. N})›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>sum_norm_le</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(1 - c) * ∥sum (λk. y (Suc k) - y k) {Suc n .. N}∥
                   ≤ (1 - c) * (sum (power c) {Suc n .. N})›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹0 &lt; 1 - c›</span></span></span><span> </span><span>real_mult_le_cancel_iff2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹… = c^(Suc n) - c^(Suc N)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Set_Interval.sum_gp_multiplied</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Suc n ≤ N›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹… ≤ c^(Suc n)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹c^(Suc N) ≥ 0›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(1 - c) * ∥∑k = Suc n..N. y (Suc k) - y k∥ ≤ c ^ Suc n›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹((1 - c) * ∥∑k = Suc n..N. y (Suc k) - y k∥)/(1 - c)
                   ≤ (c ^ Suc n)/(1 - c)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹0 &lt; 1 - c›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>divide_right_mono</span><span class="delimiter">)</span><span>      
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∥∑k = Suc n..N. y (Suc k) - y k∥ ≤ (c ^ Suc n)/(1 - c)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹0 &lt; 1 - c›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(λ N. (sum (λk. y (Suc k) - y k) {Suc n .. N})) ⇢ x - y (Suc n)›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y ⇢ x›</span></span></span><span> </span><span>identity_telescopic</span><span class="delimiter">)</span><span>     
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(λ N. ∥sum (λk. y (Suc k) - y k) {Suc n .. N}∥) ⇢ ∥x - y (Suc n)∥›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tendsto_norm</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∥x - y (Suc n)∥ ≤ (c ^ Suc n)/(1 - c)›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>norm_1</span><span> </span><span>Lim_bounded</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹∥x - y (Suc n)∥ ≤ (c ^ Suc n)/(1 - c)›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(c ^ Suc n)/(1 - c) = (c / (1 - c)) * (c ^ n)›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>divide_inverse_commute</span><span class="delimiter">)</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∥x - y (Suc n)∥ ≤ (c / (1 - c)) * (c ^ n)›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>onorm_open_ball</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>notation_norm</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∥f∥ = Sup { ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ | x. ∥x∥ &lt; 1 }›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Explanation: Let \&lt;^term&gt;‹f› be a bounded linear operator. The operator norm of \&lt;^term&gt;‹f› is the
  supremum of \&lt;^term&gt;‹norm (f x)› for \&lt;^term&gt;‹x› such that \&lt;^term&gt;‹norm x &lt; 1›.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(UNIV::'a set) = 0›</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x = 0›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span class="delimiter">::</span><span class="tfree">'a</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f *<span class="hidden">⇩</span><sub>v</sub> x = 0›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>blinfun.zero_right</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∥f∥ = 0›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>blinfun_eqI</span><span> </span><span>zero_blinfun.rep_eq</span><span class="delimiter">)</span><span>      
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹{ ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ | x. ∥x∥ &lt; 1} = {0}›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>Collect_cong</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀x. f *<span class="hidden">⇩</span><sub>v</sub> x = 0›</span></span></span><span> </span><span>norm_zero</span><span> </span><span>singleton_conv</span><span class="delimiter">)</span><span>      
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sup { ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ | x. ∥x∥ &lt; 1} = 0›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>    
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∥f∥ = 0›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>      
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(UNIV::'a set) ≠ 0›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nonnegative</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ ≥ 0›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃ x::'a. x ≠ 0›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹UNIV ≠ 0›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span class="delimiter">::</span><span class="tfree">'a</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ≠ 0›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∥x∥ ≠ 0›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y = x /<span class="hidden">⇩</span><sub>R</sub> ∥x∥›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹norm y = ∥ x /<span class="hidden">⇩</span><sub>R</sub> ∥x∥ ∥›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>y_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹… = ∥x∥ /<span class="hidden">⇩</span><sub>R</sub> ∥x∥›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹… = 1›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∥x∥ ≠ 0›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∥y∥ = 1›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>norm_1_non_empty</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹{ ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ | x. ∥x∥ = 1} ≠ {}›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>norm_1_bounded</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹bdd_above { ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ | x. ∥x∥ = 1}›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bdd_above_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>norm_blinfun</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>norm_less_1_non_empty</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹{∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ | x. ∥x∥ &lt; 1} ≠ {}›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Collect_empty_eq_bot</span><span> </span><span>bot_empty_eq</span><span> </span><span>empty_iff</span><span> </span><span>norm_zero</span><span> 
</span><span>        </span><span>zero_less_one</span><span class="delimiter">)</span><span>   
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>norm_less_1_bounded</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹bdd_above {∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ | x. ∥x∥ &lt; 1}›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃r. ∥a r∥ &lt; 1 ⟶ ∥f *<span class="hidden">⇩</span><sub>v</sub> (a r)∥ ≤ r›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"real ⇒ 'a"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>r</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒<span class="hidden">⇩</span><sub>L</sub> 'b) ⇒ real"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"⋀f x. 0 ≤ r f ∧ (bounded_linear f ⟶ ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ ≤ ∥x∥ * r f)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bounded_linear.nonneg_bounded</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>moura</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹¬ ∥f∥ &lt; 0›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>          
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃r. ∥f∥ * ∥a r∥ ≤ r) ∨ (∃r. ∥a r∥ &lt; 1 ⟶ ∥f *<span class="hidden">⇩</span><sub>v</sub> a r∥ ≤ r)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>less_eq_real_def</span><span> </span><span>mult_le_cancel_left2</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dual_order.trans</span><span> </span><span>norm_blinfun</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃ M. ∀ x. ∥x∥ &lt; 1 ⟶ ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ ≤ M›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Sup_non_neg</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sup {∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ |x. ∥x∥ = 1} ≥ 0›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>Collect_empty_eq</span><span> </span><span>cSup_upper</span><span> </span><span>mem_Collect_eq</span><span> </span><span>nonnegative</span><span> </span><span>norm_1_bounded</span><span> </span><span>norm_1_non_empty</span><span class="delimiter">)</span><span>      
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹{0::real} ≠ {}›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹bdd_above {0::real}›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∥f∥ = Sup {∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ | x. ∥x∥ &lt; 1}›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀x. f *<span class="hidden">⇩</span><sub>v</sub> x = 0›</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ = 0›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>True</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹{∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ | x. ∥x∥ &lt; 1 } ⊆ {0}›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>        
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹{∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ | x. ∥x∥ &lt; 1 } ⊇ {0}›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>calculation</span><span> </span><span>norm_less_1_non_empty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>                        
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹{∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ | x. ∥x∥ &lt; 1 } = {0}›</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>Sup1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sup {∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ | x. ∥x∥ &lt; 1 } = 0›</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∥f∥ = 0›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>True</span><span> </span><span>blinfun_eqI</span><span class="delimiter">)</span><span>        
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sup {∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ | x. ∥x∥ &lt; 1} = 0›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Sup1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>norm_f_eq_leq</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y ∈ {∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ | x. ∥x∥ = 1} ⟹ 
                         y ≤ Sup {∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ | x. ∥x∥ &lt; 1}›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>y</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y ∈ {∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ | x. ∥x∥ = 1}›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃ x. y = ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ ∧ ∥x∥ = 1›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y = ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∥x∥ = 1›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>y'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y' n = (1 - (inverse (real (Suc n)))) *<span class="hidden">⇩</span><sub>R</sub> y›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y' n ∈ {∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ | x. ∥x∥ &lt; 1}›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y' n = (1 - (inverse (real (Suc n)))) *<span class="hidden">⇩</span><sub>R</sub> ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥›</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>y'_def</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y = ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹... = ¦(1 - (inverse (real (Suc n))))¦ *<span class="hidden">⇩</span><sub>R</sub> ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥›</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>hide_lams</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y = ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥›</span></span></span><span> </span><span>abs_1</span><span> </span><span>abs_le_self_iff</span><span> </span><span>abs_of_nat</span><span> 
</span><span>              </span><span>abs_of_nonneg</span><span> </span><span>add_diff_cancel_left'</span><span> </span><span>add_eq_if</span><span> </span><span>cancel_comm_monoid_add_class.diff_cancel</span><span>
</span><span>              </span><span>diff_ge_0_iff_ge</span><span> </span><span>eq_iff_diff_eq_0</span><span> </span><span>inverse_1</span><span> </span><span>inverse_le_iff_le</span><span> </span><span>nat.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>of_nat_0</span><span>
</span><span>              </span><span>of_nat_Suc</span><span> </span><span>of_nat_le_0_iff</span><span> </span><span>zero_less_abs_iff</span><span> </span><span>zero_neq_one</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹... = ∥f *<span class="hidden">⇩</span><sub>v</sub> ((1 - (inverse (real (Suc n)))) *<span class="hidden">⇩</span><sub>R</sub>  x)∥›</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>blinfun.scaleR_right</span><span class="delimiter">)</span><span>            
</span><span>        </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>y'_1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y' n = ∥f *<span class="hidden">⇩</span><sub>v</sub> ( (1 - (inverse (real (Suc n)))) *<span class="hidden">⇩</span><sub>R</sub> x)∥›</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∥(1 - (inverse (Suc n))) *<span class="hidden">⇩</span><sub>R</sub> x∥ = (1 - (inverse (real (Suc n)))) * ∥x∥›</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>linordered_field_class.inverse_le_1_iff</span><span class="delimiter">)</span><span>                
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∥(1 - (inverse (Suc n))) *<span class="hidden">⇩</span><sub>R</sub> x∥ &lt; 1›</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∥x∥ = 1›</span></span></span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>y'_1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(λn. (1 - (inverse (real (Suc n)))) ) ⇢ 1›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Limits.LIMSEQ_inverse_real_of_nat_add_minus</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(λn. (1 - (inverse (real (Suc n)))) *<span class="hidden">⇩</span><sub>R</sub> y) ⇢ 1 *<span class="hidden">⇩</span><sub>R</sub> y›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Limits.tendsto_scaleR</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(λn. (1 - (inverse (real (Suc n)))) *<span class="hidden">⇩</span><sub>R</sub> y) ⇢ y›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(λn. y' n) ⇢ y›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>y'_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y' ⇢ y›</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y' n ≤ Sup {∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ | x. ∥x∥ &lt; 1}›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cSup_upper</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀n. y' n ∈ {∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ |x. ∥x∥ &lt; 1}›</span></span></span><span> </span><span>norm_less_1_bounded</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y ≤ Sup {∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ | x. ∥x∥ &lt; 1}›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y' ⇢ y›</span></span></span><span> </span><span>Topological_Spaces.Sup_lim</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>LIMSEQ_le_const2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sup {∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ | x. ∥x∥ = 1} ≤ Sup {∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ | x. ∥x∥ &lt; 1}›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>lifting</span><span class="delimiter">)</span><span> </span><span>cSup_least</span><span> </span><span>norm_1_non_empty</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y ∈ {∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ | x. ∥x∥ &lt; 1} ⟹ y ≤ Sup {∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ | x. ∥x∥ = 1}›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>y</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y = 0›</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Sup_non_neg</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y ≠ 0›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y ∈ {∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ | x. ∥x∥ &lt; 1}›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃ x. y = ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ ∧ ∥x∥ &lt; 1›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y = ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∥x∥ &lt; 1›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(1/∥x∥) * y = (1/∥x∥) * ∥f x∥›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y = ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥›</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹... = ¦1/∥x∥¦ * ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹... = ∥(1/∥x∥) *<span class="hidden">⇩</span><sub>R</sub> (f *<span class="hidden">⇩</span><sub>v</sub> x)∥›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹... = ∥f *<span class="hidden">⇩</span><sub>v</sub> ((1/∥x∥) *<span class="hidden">⇩</span><sub>R</sub> x)∥›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>blinfun.scaleR_right</span><span class="delimiter">)</span><span>          
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(1/∥x∥) * y  = ∥f *<span class="hidden">⇩</span><sub>v</sub> ((1/∥x∥) *<span class="hidden">⇩</span><sub>R</sub> x)∥›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ≠ 0›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹y ≠ 0›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y = ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥›</span></span></span><span> </span><span>blinfun.zero_right</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∥ (1/∥x∥) *<span class="hidden">⇩</span><sub>R</sub> x ∥ = ¦ (1/∥x∥) ¦ * ∥x∥›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹... = (1/∥x∥) * ∥x∥›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹∥(1/∥x∥) *<span class="hidden">⇩</span><sub>R</sub> x∥ = 1›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ≠ 0›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(1/∥x∥) * y ∈ { ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ | x. ∥x∥ = 1}›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹1 / ∥x∥ * y = ∥f *<span class="hidden">⇩</span><sub>v</sub> (1 / ∥x∥) *<span class="hidden">⇩</span><sub>R</sub> x∥›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(1/∥x∥) * y ≤ Sup { ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ | x. ∥x∥ = 1}›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cSup_upper</span><span> </span><span>norm_1_bounded</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y ≤ (1/∥x∥) * y›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∥x∥ &lt; 1›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y = ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥›</span></span></span><span> </span><span>mult_le_cancel_right1</span><span> </span><span>norm_not_less_zero</span><span> 
</span><span>            </span><span>order.strict_implies_order</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ≠ 0›</span></span></span><span> </span><span>less_divide_eq_1_pos</span><span> </span><span>zero_less_norm_iff</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sup { ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ | x. ∥x∥ &lt; 1} ≤ Sup { ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ | x. ∥x∥ = 1}›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>cSup_least</span><span> </span><span>norm_less_1_non_empty</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sup { ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ | x. ∥x∥ = 1} = Sup { ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ | x. ∥x∥ &lt; 1}›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sup {∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ |x. norm x = 1} ≤ Sup { ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ |x. ∥x∥ &lt; 1}›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(SUP x. ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ / ∥x∥) = Sup { ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ / ∥x∥ | x. True}›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>full_SetCompr_eq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y ∈ { ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ / ∥x∥ |x. True} ⟹ y ∈ { ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ |x. ∥x∥ = 1} ∪ {0}›</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>y</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y ∈ { ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ / ∥x∥ |x. True}›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y = 0›</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃ x. y = ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ / ∥x∥›</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y ∈ { ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ / ∥x∥ |x. True}›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y = ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ / ∥x∥›</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y = ¦(1/∥x∥)¦ * ∥ f *<span class="hidden">⇩</span><sub>v</sub> x ∥›</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y = ∥(1/∥x∥) *<span class="hidden">⇩</span><sub>R</sub> (f *<span class="hidden">⇩</span><sub>v</sub> x)∥›</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y = ∥f ((1/∥x∥) *<span class="hidden">⇩</span><sub>R</sub> x)∥›</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>blinfun.scaleR_right</span><span class="delimiter">)</span><span>            
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∥ (1/∥x∥) *<span class="hidden">⇩</span><sub>R</sub> x ∥ = 1›</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>False</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y = ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ / ∥x∥›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y ∈ {∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ |x. ∥x∥ = 1}›</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y ∈ {∥f x∥ |x. ∥x∥ = 1} ∪ {0} ⟹ y ∈ {∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ / ∥x∥ |x. True}›</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>y</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y = 0›</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y ∉ {0}›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y ∈ {∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ |x. ∥x∥ = 1} ∪ {0}›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y ∈ {∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ |x. ∥x∥ = 1}›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∥x∥ = 1›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y = ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y = ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ / ∥x∥›</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹∥x∥ = 1›</span></span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹y = ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹{∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ / ∥x∥ |x. True} = {∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ |x. ∥x∥ = 1} ∪ {0}›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sup {∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ / ∥x∥ |x. True} = Sup ({∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ |x. ∥x∥ = 1} ∪ {0})›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀r s. ¬ (r::real) ≤ s ∨ sup r s = s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>lifting</span><span class="delimiter">)</span><span> </span><span>sup.absorb_iff1</span><span> </span><span>sup_commute</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sup ({∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ |x. ∥x∥ = 1} ∪ {(0::real)})
             = max (Sup {∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ |x. ∥x∥ = 1}) (Sup {0::real})›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹0 ≤ Sup {∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ |x. ∥x∥ = 1}›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹bdd_above {0}›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹{0} ≠ {}›</span></span></span><span> </span><span>cSup_singleton</span><span> 
</span><span>        </span><span>cSup_union_distrib</span><span> </span><span>max.absorb_iff1</span><span> </span><span>sup_commute</span><span> </span><span>norm_1_bounded</span><span> </span><span>norm_1_non_empty</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sup {(0::real)} = (0::real)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>          
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sup ({∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ |x. ∥x∥ = 1} ∪ {0}) = Sup {∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ |x. ∥x∥ = 1}›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Sup_non_neg</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sup ( {∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ |x. ∥x∥ = 1} ∪ {0}) 
                    = max (Sup {∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ |x. ∥x∥ = 1}) (Sup {0}) ›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Sup_non_neg</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹Sup ({∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ |x. ∥x∥ = 1} ∪ {0}) 
        = max (Sup {∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ |x. ∥x∥ = 1}) (Sup {0})›</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>           
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sup {∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ / ∥x∥ | x. True} = Sup {∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ | x. ∥x∥ = 1}›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sup {∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ / ∥x∥ |x. True} = Sup ({∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ |x. ∥x∥ = 1} ∪ {0})›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(SUP x. ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ / ∥x∥) = Sup {∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ | x. ∥x∥ = 1}›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span>f2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(SUP x. ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ / ∥x∥) = Sup {∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ | x. ∥x∥ &lt; 1 }›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sup {∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ |x. ∥x∥ = 1} = Sup {∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ |x. ∥x∥ &lt; 1}›</span></span></span><span class="delimiter">)</span><span>        
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>onorm_def</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>      
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>onorm_r</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>notation_norm</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹r &gt; 0›</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∥f∥ = Sup ((λx. ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥) ` (ball 0 r)) / r›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Explanation: The norm of \&lt;^term&gt;‹f› is \&lt;^term&gt;‹1/r› of the supremum of the norm of \&lt;^term&gt;‹f *<span class="hidden">⇩</span><sub>v</sub> x› for
  \&lt;^term&gt;‹x› in the ball of radius \&lt;^term&gt;‹r› centered at the origin.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∥f∥ = Sup {∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ |x. ∥x∥ &lt; 1}›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>onorm_open_ball</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹{∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ |x. ∥x∥ &lt; 1} = (λx. ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥) ` (ball 0 1)›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ball_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>onorm_f</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∥f∥ = Sup ((λx. ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥) ` (ball 0 1))›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ∈ (λt. r *<span class="hidden">⇩</span><sub>R</sub> ∥f *<span class="hidden">⇩</span><sub>v</sub> t∥) ` ball 0 1 ⟹ x ≤ r * Sup ((λt. ∥f *<span class="hidden">⇩</span><sub>v</sub> t∥) ` ball 0 1)›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ∈ (λt. r *<span class="hidden">⇩</span><sub>R</sub> ∥f *<span class="hidden">⇩</span><sub>v</sub> t∥) ` ball 0 1›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃ t. x = r *<span class="hidden">⇩</span><sub>R</sub> ∥f *<span class="hidden">⇩</span><sub>v</sub> t∥ ∧ ∥t∥ &lt; 1›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x = r *<span class="hidden">⇩</span><sub>R</sub> ∥f *<span class="hidden">⇩</span><sub>v</sub> t∥›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∥t∥ &lt; 1›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y = x /<span class="hidden">⇩</span><sub>R</sub> r›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x = r * (inverse r * x)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x = r *<span class="hidden">⇩</span><sub>R</sub> norm (f t)›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x - (r * (inverse r * x)) ≤ 0›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ≤ r * (x /<span class="hidden">⇩</span><sub>R</sub> r)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y ∈ (λk. ∥f *<span class="hidden">⇩</span><sub>v</sub> k∥) ` ball 0 1›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>y_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ∈ (λt. r *<span class="hidden">⇩</span><sub>R</sub> ∥f *<span class="hidden">⇩</span><sub>v</sub> t∥) ` ball 0 1›</span></span></span><span> </span><span>assms</span><span> </span><span>image_iff</span><span> 
</span><span>          </span><span>inverse_inverse_eq</span><span> </span><span>pos_le_divideR_eq</span><span> </span><span>positive_imp_inverse_positive</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ≤ r * y›</span></span></span><span>          
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ≤ r * (x /<span class="hidden">⇩</span><sub>R</sub> r)›</span></span></span><span> </span><span>y_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>y_norm_f</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y ∈ (λt. ∥f *<span class="hidden">⇩</span><sub>v</sub> t∥) ` ball 0 1 ∧ x ≤ r * y›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(λt. ∥f *<span class="hidden">⇩</span><sub>v</sub> t∥) ` ball 0 1 ≠ {}›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>        
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹bdd_above ((λt. ∥f *<span class="hidden">⇩</span><sub>v</sub> t∥) ` ball 0 1)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bounded_linear_image</span><span> </span><span>blinfun.bounded_linear_right</span><span> </span><span>bounded_imp_bdd_above</span><span> 
</span><span>          </span><span>bounded_norm_comp</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃ y. y ∈ (λt. ∥f *<span class="hidden">⇩</span><sub>v</sub> t∥) ` ball 0 1 ∧ x ≤ r * y›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>y_norm_f</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹0 &lt; r›</span></span></span><span> </span><span>cSup_upper</span><span> </span><span>ordered_comm_semiring_class.comm_mult_left_mono</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s3</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(⋀x. x ∈ (λt. r * ∥f *<span class="hidden">⇩</span><sub>v</sub> t∥) ` ball 0 1 ⟹ x ≤ y) ⟹
         r * Sup ((λt. ∥f *<span class="hidden">⇩</span><sub>v</sub> t∥) ` ball 0 1) ≤ y›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>y</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀x. x ∈ (λt. r * ∥f *<span class="hidden">⇩</span><sub>v</sub> t∥) ` ball 0 1 ⟹ x ≤ y›</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x_leq</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ∈ (λt. ∥f *<span class="hidden">⇩</span><sub>v</sub> t∥) ` ball 0 1 ⟹ x ≤ y / r›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ∈ (λt. ∥f *<span class="hidden">⇩</span><sub>v</sub> t∥) ` ball 0 1›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t ∈ ball (0::'a) 1›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x = ∥f *<span class="hidden">⇩</span><sub>v</sub> t∥›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>x'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x' = r *<span class="hidden">⇩</span><sub>R</sub> x›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x' = r * ∥f *<span class="hidden">⇩</span><sub>v</sub> t∥›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x = ∥f *<span class="hidden">⇩</span><sub>v</sub> t∥›</span></span></span><span> </span><span>x'_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x' ∈ (λt. r * ∥f *<span class="hidden">⇩</span><sub>v</sub> t∥) ` ball 0 1›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t ∈ ball (0::'a) 1›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x' ≤ y›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀x. x ∈ (λt. r * ∥f *<span class="hidden">⇩</span><sub>v</sub> t∥) ` ball 0 1 ⟹ x ≤ y›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>        
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ≤ y / r›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>x'_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹r &gt; 0›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mult.commute</span><span> </span><span>pos_le_divide_eq</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(λt. ∥f *<span class="hidden">⇩</span><sub>v</sub> t∥) ` ball 0 1 ≠ {}›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>        
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹bdd_above ((λt. ∥f *<span class="hidden">⇩</span><sub>v</sub> t∥) ` ball 0 1)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bounded_linear_image</span><span> </span><span>blinfun.bounded_linear_right</span><span> </span><span>bounded_imp_bdd_above</span><span> 
</span><span>          </span><span>bounded_norm_comp</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sup ((λt. ∥f *<span class="hidden">⇩</span><sub>v</sub> t∥) ` ball 0 1) ≤ y/r›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x_leq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹bdd_above ((λt. ∥f *<span class="hidden">⇩</span><sub>v</sub> t∥) ` ball 0 1)›</span></span></span><span> </span><span>cSup_least</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹r &gt; 0›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>divide_strict_right_mono</span><span> </span><span>nonzero_mult_div_cancel_left</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>norm_scaleR</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹norm ∘ ((*<span class="hidden">⇩</span><sub>R</sub>) r) = ((*<span class="hidden">⇩</span><sub>R</sub>) ¦r¦) ∘ (norm::'a ⇒ real)›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f_x1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f (r *<span class="hidden">⇩</span><sub>R</sub> x) = r *<span class="hidden">⇩</span><sub>R</sub> f x›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>blinfun.scaleR_right</span><span class="delimiter">)</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ball (0::'a) r = ((*<span class="hidden">⇩</span><sub>R</sub>) r) ` (ball 0 1)›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>assms</span><span> </span><span>ball_scale</span><span> </span><span>nonzero_mult_div_cancel_left</span><span> </span><span>right_inverse_eq</span><span> </span><span>scale_zero_right</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sup ((λt. ∥f *<span class="hidden">⇩</span><sub>v</sub> t∥) ` (ball 0 r)) = Sup ((λt. ∥f *<span class="hidden">⇩</span><sub>v</sub> t∥) ` (((*<span class="hidden">⇩</span><sub>R</sub>) r) ` (ball 0 1)))›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹… = Sup (((λt. ∥f *<span class="hidden">⇩</span><sub>v</sub> t∥) ∘ ((*<span class="hidden">⇩</span><sub>R</sub>) r)) ` (ball 0 1))›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Sup.SUP_image</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹… = Sup ((λt. ∥f *<span class="hidden">⇩</span><sub>v</sub> (r *<span class="hidden">⇩</span><sub>R</sub> t)∥) ` (ball 0 1))›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_x1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>comp_assoc</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹… = Sup ((λt. ¦r¦ *<span class="hidden">⇩</span><sub>R</sub> ∥f *<span class="hidden">⇩</span><sub>v</sub> t∥) ` (ball 0 1))›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>norm_scaleR</span><span> </span><span>f_x1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹… = Sup ((λt. r *<span class="hidden">⇩</span><sub>R</sub> ∥f *<span class="hidden">⇩</span><sub>v</sub> t∥) ` (ball 0 1))›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹r &gt; 0›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹… = r * Sup ((λt. ∥f *<span class="hidden">⇩</span><sub>v</sub> t∥) ` (ball 0 1))›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cSup_eq_non_empty</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s2</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹… = r * ∥f∥›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>onorm_f</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sup ((λt. ∥f *<span class="hidden">⇩</span><sub>v</sub> t∥) ` ball 0 r) = r * ∥f∥›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>    
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∥f∥ = Sup ((λx. ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥) ` (ball 0 r)) / r›</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹r &gt; 0›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Pointwise convergence›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>pointwise_convergent_to</span><span> </span><span class="delimiter">::</span><span> 
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹( nat ⇒ ('a ⇒ 'b::topological_space) ) ⇒ ('a ⇒ 'b) ⇒ bool›</span></span></span><span> 
</span><span>  </span><span class="delimiter">(</span><span class="cartouche"><span class="delete"><span class="delete">‹((_)/ ─pointwise→ (_))›</span></span></span><span> </span><span class="delimiter">[</span><span>60</span><span class="delimiter">,</span><span> </span><span>60</span><span class="delimiter">]</span><span> </span><span>60</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹pointwise_convergent_to x l = (∀ t::'a. (λ n. (x n) t) ⇢ l t)›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>linear_limit_linear</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹_ ⇒ ('a::real_vector ⇒ 'b::real_normed_vector)›</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀n. linear (f n)›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f ─pointwise→ F›</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹linear F›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹
  Explanation: If a family of linear operators converges pointwise, then the limit is also a linear
  operator.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F (x + y) = F x + F y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀a. F a = lim (λn. f n a)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f ─pointwise→ F›</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pointwise_convergent_to_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>limI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀f b c g. (lim (λn. g n + f n) = (b::'b) + c ∨ ¬ f ⇢ c) ∨ ¬ g ⇢ b"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>limI</span><span> </span><span>tendsto_add</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀a. (λn. f n a) ⇢ F a"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>pointwise_convergent_to_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>      </span><span>lim_sum</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹lim (λ n. (f n) x + (f n) y) = lim (λ n. (f n) x) + lim (λ n. (f n) y)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(f n) (x + y) = (f n) x + (f n) y›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀ n.  linear (f n)›</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>linear_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Real_Vector_Spaces.linear_iff</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹lim (λ n. (f n) (x + y)) = lim (λ n. (f n) x + (f n) y)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹lim (λ n. (f n) (x + y)) = lim (λ n. (f n) x) + lim (λ n. (f n) y)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lim_sum</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(λ n. (f n) (x + y)) ⇢ F (x + y)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f ─pointwise→ F›</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pointwise_convergent_to_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(λ n. (f n) x) ⇢ F x›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f ─pointwise→ F›</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pointwise_convergent_to_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(λ n. (f n) y) ⇢ F y›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f ─pointwise→ F›</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pointwise_convergent_to_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>limI</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F (r *<span class="hidden">⇩</span><sub>R</sub> x) = r *<span class="hidden">⇩</span><sub>R</sub> F x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>r</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(f n) (r *<span class="hidden">⇩</span><sub>R</sub> x) = r *<span class="hidden">⇩</span><sub>R</sub> (f n) x›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀ n.  linear (f n)›</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Real_Vector_Spaces.linear_def</span><span> </span><span>real_vector.linear_scale</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹lim (λ n. (f n) (r *<span class="hidden">⇩</span><sub>R</sub> x)) = lim (λ n. r *<span class="hidden">⇩</span><sub>R</sub> (f n) x)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹convergent (λ n. (f n) x)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>convergentI</span><span> </span><span>pointwise_convergent_to_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹isCont (λ t::'b. r *<span class="hidden">⇩</span><sub>R</sub> t) tt›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>tt</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bounded_linear_scaleR_right</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹lim (λ n. r *<span class="hidden">⇩</span><sub>R</sub> ((f n) x)) =  r *<span class="hidden">⇩</span><sub>R</sub> lim (λ n. (f n) x)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f ─pointwise→ F›</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pointwise_convergent_to_def</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">)</span><span> </span><span>isCont_tendsto_compose</span><span> </span><span>limI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹lim (λ n.  (f n) (r *<span class="hidden">⇩</span><sub>R</sub> x)) = r *<span class="hidden">⇩</span><sub>R</sub> lim (λ n. (f n) x)›</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹lim (λ n. (f n) (r *<span class="hidden">⇩</span><sub>R</sub> x)) = lim (λ n. r *<span class="hidden">⇩</span><sub>R</sub> (f n) x)›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(λ n. (f n) x) ⇢ F x›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f ─pointwise→ F›</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pointwise_convergent_to_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(λ n.  (f n) (r *<span class="hidden">⇩</span><sub>R</sub> x)) ⇢ F (r *<span class="hidden">⇩</span><sub>R</sub> x)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f ─pointwise→ F›</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pointwise_convergent_to_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>limI</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>non_Cauchy_unbounded</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>a</span><span> </span><span class="delimiter">::</span><span class="cartouche"><span class="delete"><span class="delete">‹_ ⇒ real›</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀n. a n ≥ 0›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e &gt; 0›</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀M. ∃m. ∃n. m ≥ M ∧ n ≥ M ∧ m &gt; n ∧ sum a {Suc n..m} ≥ e›</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(λn. (sum a  {0..n})) ⇢ ∞›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹
  Explanation: If the sequence of partial sums of nonnegative terms is not Cauchy, then it converges
  to infinite.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>S</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"ereal set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹S = range (λn. sum a  {0..n})›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃s∈S.  k*e ≤ s›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>k</span><span class="delimiter">::</span><span>nat</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>k</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀M. ∃m. ∃n. m ≥ M ∧ n ≥ M ∧ m &gt; n ∧ sum a {Suc n..m} ≥ e›</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>m</span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m ≥ 0›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n ≥ 0›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m &gt; n›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sum a {Suc n..m} ≥ e›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n &lt; Suc n›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹{0..n} ∪ {Suc n..m} = {0..m}›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Set_Interval.ivl_disj_un</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n &lt; m›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹finite {0..n}›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹finite {Suc n..m}›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹{0..n} ∩ {Suc n..m} = {}›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sum a {0..n} + sum a {Suc n..m} = sum a {0..m}›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>sum.union_disjoint</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sum a {Suc n..m} &gt; 0›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e &gt; 0›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sum a {Suc n..m} ≥ e›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sum a {0..n} ≥ 0›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>sum_nonneg</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sum a {0..m} &gt; 0›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sum a {0..m} ∈ S›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃s∈S. 0 ≤ s›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ereal_less_eq</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>    
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>zero_ereal_def</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>k</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃s∈S. k*e ≤ s›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s∈S›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ereal (k * e) ≤ s›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃N. s = sum a {0..N}›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s∈S›</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>N</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s = sum a {0..N}›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀M. ∃m. ∃n. m ≥ M ∧ n ≥ M ∧ m &gt; n ∧ sum a {Suc n..m} ≥ e›</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>m</span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m ≥ Suc N›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n ≥ Suc N›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m &gt; n›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sum a {Suc n..m} ≥ e›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹finite {Suc N..n}›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹finite {Suc n..m}›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹{Suc N..n} ∪ {Suc n..m} = {Suc N..m}›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Set_Interval.ivl_disj_un</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Suc N ≤ n›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n &lt; m›</span></span></span><span> </span><span>atLeastSucAtMost_greaterThanAtMost</span><span> </span><span>less_imp_le_nat</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹{} = {Suc N..n} ∩ {Suc n..m}›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sum a {Suc N..m} = sum a {Suc N..n} + sum a {Suc n..m}›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>sum.union_disjoint</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sum a {Suc N..n} ≥ 0›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀n. a n ≥ 0›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sum_nonneg</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sum a {Suc N..m} ≥ e›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e ≤ sum a {Suc n..m}›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹finite {0..N}›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹finite {Suc N..m}›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹{0..N} ∪ {Suc N..m} = {0..m}›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Set_Interval.ivl_disj_un</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Suc N ≤ m›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>          
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹{0..N} ∩ {Suc N..m} = {}›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sum a {0..N} + sum a {Suc N..m} =  sum a {0..m}›</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹finite {0..N}›</span></span></span><span> </span><span>sum.union_disjoint</span><span class="delimiter">)</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e + k * e ≤ sum a {0..m}›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ereal (real k * e) ≤ s›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s = ereal (sum a {0..N})›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e ≤ sum a {Suc N..m}›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e + k * e = (Suc k) * e›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>semiring_normalization_rules</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(Suc k) * e ≤ sum a {0..m}›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ereal ((Suc k) * e) ≤ sum a {0..m}›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sum a {0..m}∈S›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃s∈S. (real n) ≤ s›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>ereal_le_le</span><span> </span><span>ex_less_of_nat_mult</span><span> </span><span>less_le_not_le</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹Sup S = ∞›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Sup_le_iff</span><span> </span><span>Sup_subset_mono</span><span> </span><span>dual_order.strict_trans1</span><span> </span><span>leD</span><span> </span><span>less_PInf_Ex_of_nat</span><span> </span><span>subsetI</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>Sup</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sup ((range (λ n. (sum a  {0..n})))::ereal set) = ∞›</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹incseq (λn. (sum a  {..&lt;n}))›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀n. a n ≥ 0›</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Extended_Real.incseq_sumI</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹incseq (λn. (sum a  {..&lt; Suc n}))›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>incseq_Suc_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹incseq (λn. (sum a  {0..n})::ereal)›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>incseq_ereal</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>atLeast0AtMost</span><span> </span><span>lessThan_Suc_atMost</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(λn. sum a  {0..n}) ⇢ Sup (range (λn. (sum a  {0..n})::ereal))›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LIMSEQ_SUP</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Sup</span><span> </span><span>PInfty_neq_ereal</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sum_Cauchy_positive</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>a</span><span> </span><span class="delimiter">::</span><span class="cartouche"><span class="delete"><span class="delete">‹_ ⇒ real›</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀n. a n ≥ 0›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃K. ∀n. (sum a  {0..n}) ≤ K›</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Cauchy (λn. sum a {0..n})›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹
  Explanation: If a series of nonnegative reals is bounded, then the series is 
  Cauchy.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>Cauchy_altdef2</span><span class="delimiter">,</span><span> </span><span>rule</span><span class="delimiter">,</span><span> </span><span>rule</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>e</span><span class="delimiter">::</span><span>real</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e&gt;0›</span></span></span><span>       
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃M. ∀m≥M. ∀n≥M. m &gt; n ⟶ sum a {Suc n..m} &lt; e›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>classical</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹¬(∃M. ∀m≥M. ∀n≥M. m &gt; n ⟶ sum a {Suc n..m} &lt; e)›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀M. ∃m. ∃n. m ≥ M ∧ n ≥ M ∧ m &gt; n ∧ ¬(sum a {Suc n..m} &lt; e)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀M. ∃m. ∃n. m ≥ M ∧ n ≥ M ∧ m &gt; n ∧ sum a {Suc n..m} ≥ e›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(λn. (sum a  {0..n}) ) ⇢ ∞›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>non_Cauchy_unbounded</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹0 &lt; e›</span></span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹∃K. ∀n. sum a  {0..n} ≤ K›</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>K</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹∀n. sum a {0..n} ≤ K›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹(λn. sum a {0..n})  ⇢ ∞›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀B. ∃N. ∀n≥N. (λ n. (sum a  {0..n}) ) n ≥ B›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Lim_PInfty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹∃n. (sum a {0..n}) ≥ K+1›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ereal_less_eq</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>        
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹∀n. (sum a  {0..n}) ≤ K›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>smt</span><span>       
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sum a {Suc n..m} = sum a {0..m} - sum a {0..n}›</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m &gt; n"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>m</span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>that</span><span> </span><span>atLeast0AtMost</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sum_up_index_split</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>less_imp_add_positive</span><span> </span><span>that</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃M. ∀m≥M. ∀n≥M. m &gt; n ⟶ sum a {0..m} - sum a {0..n} &lt; e›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃M. ∀m≥M. ∀n≥M. m &gt; n ⟶ sum a {Suc n..m} &lt; e›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>smt</span><span>     
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃M. ∀m≥M. ∀n≥M. m &gt; n ⟶ sum a {0..m} - sum a {0..n} &lt; e›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀m≥M. ∀n≥M. m &gt; n ⟶ sum a {0..m} - sum a {0..n} &lt; e›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m &gt; n ⟹ sum a {0..m} ≥ sum a {0..n}›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>m</span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀ n. a n ≥ 0›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sum_mono2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃M. ∀m≥M. ∀n≥M. m &gt; n ⟶ ¦sum a {0..m} - sum a {0..n}¦ &lt; e›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃M. ∀m≥M. ∀n≥M. m ≥ n ⟶ ¦sum a {0..m} - sum a {0..n}¦ &lt; e›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹0 &lt; e›</span></span></span><span> </span><span>abs_zero</span><span> </span><span>cancel_comm_monoid_add_class.diff_cancel</span><span> </span><span>diff_is_0_eq'</span><span> 
</span><span>        </span><span>less_irrefl_nat</span><span> </span><span>linorder_neqE_nat</span><span> </span><span>zero_less_diff</span><span class="delimiter">)</span><span>      
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃M. ∀m≥M. ∀n≥M. ¦sum a {0..m} - sum a {0..n}¦ &lt; e›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>abs_minus_commute</span><span> </span><span>nat_le_linear</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃M. ∀m≥M. ∀n≥M. dist (sum a {0..m}) (sum a {0..n}) &lt; e›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>dist_real_def</span><span class="delimiter">)</span><span>      
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃M. ∀m≥M. ∀n≥M. dist (sum a {0..m}) (sum a {0..n}) &lt; e›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃N. ∀n≥N. dist (sum a {0..n}) (sum a {0..N}) &lt; e›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>convergent_series_Cauchy</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>a</span><span class="delimiter">::</span><span class="cartouche"><span class="delete"><span class="delete">‹nat ⇒ real›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>φ</span><span class="delimiter">::</span><span class="cartouche"><span class="delete"><span class="delete">‹nat ⇒ 'a::metric_space›</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃M. ∀n. sum a {0..n} ≤ M›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀n. dist (φ (Suc n)) (φ n) ≤ a n›</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Cauchy φ›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹
  Explanation: Let \&lt;^term&gt;‹a› be a real-valued sequence and let \&lt;^term&gt;‹φ› be sequence in a metric space.
  If the partial sums of \&lt;^term&gt;‹a› are uniformly bounded and the distance between consecutive terms of \&lt;^term&gt;‹φ›
  are bounded by the sequence \&lt;^term&gt;‹a›, then \&lt;^term&gt;‹φ› is Cauchy.›</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>Cauchy_altdef2</span><span class="delimiter">,</span><span> </span><span>rule</span><span class="delimiter">,</span><span> </span><span>rule</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>e</span><span class="delimiter">::</span><span>real</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e &gt; 0›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀k. a k ≥ 0›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀n. dist (φ (Suc n)) (φ n) ≤ a n›</span></span></span><span> </span><span>dual_order.trans</span><span> </span><span>zero_le_dist</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Cauchy (λk. sum a {0..k})›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹∃M. ∀n. sum a {0..n} ≤ M›</span></span></span><span> </span><span>sum_Cauchy_positive</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃M. ∀m≥M. ∀n≥M. dist (sum a {0..m}) (sum a {0..n}) &lt; e›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cauchy_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e &gt; 0›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃M. ∀m≥M. ∀n≥M. m &gt; n ⟶ dist (sum a {0..m}) (sum a {0..n}) &lt; e›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹dist (sum a {0..m}) (sum a {0..n}) = sum a {Suc n..m}›</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n&lt;m›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>m</span><span> </span><span>n</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n &lt; Suc n›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹finite {0..n}›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹finite {Suc n..m}›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹{0..n} ∪ {Suc n..m} = {0..m}›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n &lt; Suc n›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n &lt; m›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹{0..n} ∩ {Suc n..m} = {}›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sum_plus</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(sum a {0..n}) + sum a {Suc n..m} = (sum a {0..m})›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>sum.union_disjoint</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹dist (sum a {0..m}) (sum a {0..n}) = ¦(sum a {0..m}) - (sum a {0..n})¦›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dist_real_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(sum a {0..m}) - (sum a {0..n}) = sum a {Suc n..m}›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sum_plus</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀k. 0 ≤ a k›</span></span></span><span> </span><span>sum_nonneg</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>sum_a</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃M. ∀m≥M. ∀n≥M. m &gt; n ⟶ sum a {Suc n..m} &lt; e›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃M. ∀m≥M. ∀n≥M. dist (sum a {0..m}) (sum a {0..n}) &lt; e›</span></span></span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀m≥M. ∀n≥M. m &gt; n ⟶ sum a {Suc n..m} &lt; e›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sum_a</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e &gt; 0›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹∀m. ∀n. Suc m ≥ Suc M ∧ Suc n ≥ Suc M ∧ Suc m &gt; Suc n ⟶ sum a {Suc n..Suc m - 1} &lt; e›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹∀m≥1. ∀n≥1. m ≥ Suc M ∧ n ≥ Suc M ∧ m &gt; n ⟶ sum a {n..m - 1} &lt; e›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_le_D</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>sum_a2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃M. ∀m≥M. ∀n≥M. m &gt; n ⟶ sum a {n..m-1} &lt; e›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>add_leE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹dist (φ (n+p+1)) (φ n) ≤ sum a {n..n+p}›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>p</span><span> </span><span>n</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>p</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>p</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>Suc_eq_plus1</span><span> </span><span>add_Suc_right</span><span> </span><span>add_less_same_cancel1</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>dist_self</span><span> </span><span>dist_triangle2</span><span> 
</span><span>          </span><span>gr_implies_not0</span><span> </span><span>sum.cl_ivl_Suc</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m &gt; n ⟹ dist (φ m) (φ n) ≤ sum a {n..m-1}›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>m</span><span> </span><span>n</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_eq_plus1</span><span> </span><span>Suc_le_D</span><span> </span><span>diff_Suc_1</span><span>  </span><span>gr0_implies_Suc</span><span> </span><span>less_eq_Suc_le</span><span> </span><span>less_imp_Suc_add</span><span> 
</span><span>        </span><span>zero_less_Suc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃M. ∀m≥M. ∀n≥M. m &gt; n ⟶ dist (φ m) (φ n) &lt; e›</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sum_a2</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e &gt; 0›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>smt</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃N. ∀n≥N. dist (φ n) (φ N) &lt; e"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹0 &lt; e›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">unbundle</span></span><span> </span><span>notation_blinfun_apply</span><span>
</span><span>
</span><span class="keyword1"><span class="command">unbundle</span></span><span> </span><span>no_notation_norm</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Banach_Steinhaus">
<div class="head"><h1>Theory Banach_Steinhaus</h1>
<span class="command">theory</span> <span class="name">Banach_Steinhaus</span><br/>
<span class="keyword">imports</span> <a href="Banach_Steinhaus_Missing.html"><span class="name">Banach_Steinhaus_Missing</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  File:   Banach_Steinhaus.thy
  Author: Dominique Unruh, University of Tartu
  Author: Jose Manuel Rodriguez Caballero, University of Tartu
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Banach-Steinhaus theorem›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Banach_Steinhaus</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Banach_Steinhaus_Missing</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  We formalize Banach-Steinhaus theorem as theorem @{text banach_steinhaus}. This theorem was 
  originally proved in Banach-Steinhaus's paper~\cite{banach1927principe}. For the proof, we follow
  Sokal's approach~\cite{sokal2011really}. Furthermore, we prove as a corollary a result about
  pointwise convergent sequences of bounded operators whose domain is a Banach space.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Preliminaries for Sokal's proof of Banach-Steinhaus theorem›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>linear_plus_norm</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>notation_norm</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹linear f›</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∥f ξ∥ ≤ max ∥f (x + ξ)∥ ∥f (x - ξ)∥›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Explanation: For arbitrary \&lt;^term&gt;‹x› and a linear operator \&lt;^term&gt;‹f›,
  \&lt;^term&gt;‹norm (f ξ)› is upper bounded by the maximum of the norms
  of the shifts of \&lt;^term&gt;‹f› (i.e., \&lt;^term&gt;‹f (x + ξ)› and \&lt;^term&gt;‹f (x - ξ)›).
›</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹norm (f ξ) = norm ( (inverse (of_nat 2)) *<span class="hidden">⇩</span><sub>R</sub> (f (x + ξ) - f (x - ξ)) )›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>add_diff_cancel_left'</span><span> </span><span>assms</span><span> </span><span>diff_add_cancel</span><span> </span><span>diff_diff_add</span><span> </span><span>linear_diff</span><span> </span><span>midpoint_def</span><span> 
</span><span>        </span><span>midpoint_plus_self</span><span> </span><span>of_nat_1</span><span> </span><span>of_nat_add</span><span> </span><span>one_add_one</span><span> </span><span>scaleR_half_double</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹… = inverse (of_nat 2) * norm (f (x + ξ) - f (x - ξ))›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Real_Vector_Spaces.real_normed_vector_class.norm_scaleR</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹… ≤ inverse (of_nat 2) * (norm (f (x + ξ)) + norm (f (x - ξ)))›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>norm_triangle_ineq4</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹… ≤  max (norm (f (x + ξ))) (norm (f (x - ξ)))›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>onorm_Sup_on_ball</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>notation_norm</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹r &gt; 0›</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∥f∥ ≤ Sup ( (λx. ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥) ` (ball x r) ) / r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Explanation: Let \&lt;^term&gt;‹f› be a bounded operator and let \&lt;^term&gt;‹x› be a point. For any \&lt;^term&gt;‹r &gt; 0›, 
  the operator norm of \&lt;^term&gt;‹f› is bounded above by the supremum of $f$ applied to the open ball of 
  radius \&lt;^term&gt;‹r› around \&lt;^term&gt;‹x›, divided by \&lt;^term&gt;‹r›.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bdd_above_3</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹bdd_above ((λx. ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥) ` (ball 0 r))›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀ ξ.  ∥f *<span class="hidden">⇩</span><sub>v</sub> ξ∥ ≤ M * norm ξ›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹M ≥ 0›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>norm_blinfun</span><span> </span><span>norm_ge_zero</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀ ξ. ξ ∈ ball 0 r ⟹ ∥f *<span class="hidden">⇩</span><sub>v</sub> ξ∥ ≤ M * r›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹r &gt; 0›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>mem_ball_0</span><span> </span><span>mult_left_mono</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>bdd_aboveI2</span><span class="delimiter">)</span><span>     
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bdd_above_2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹bdd_above ((λ ξ. ∥f *<span class="hidden">⇩</span><sub>v</sub> (x + ξ)∥) ` (ball 0 r))›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹bdd_above ((λ ξ. ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥) ` (ball 0 r))›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>          
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹bdd_above ((λ ξ. ∥f *<span class="hidden">⇩</span><sub>v</sub> ξ∥) ` (ball 0 r))›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bdd_above_3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹bdd_above ((λ ξ. ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ + ∥f *<span class="hidden">⇩</span><sub>v</sub> ξ∥) ` (ball 0 r))›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>bdd_above_plus</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀ ξ. ξ ∈ ball 0 r ⟹ ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ + ∥f *<span class="hidden">⇩</span><sub>v</sub> ξ∥ ≤ M›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bdd_above_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>image_eqI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∥f *<span class="hidden">⇩</span><sub>v</sub> (x + ξ)∥ ≤ ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥ + ∥f *<span class="hidden">⇩</span><sub>v</sub> ξ∥›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>ξ</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>blinfun.add_right</span><span> </span><span>norm_triangle_ineq</span><span class="delimiter">)</span><span>                
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀ ξ. ξ ∈ ball 0 r ⟹ ∥f *<span class="hidden">⇩</span><sub>v</sub> (x + ξ)∥ ≤ M›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>blinfun.add_right</span><span> </span><span>norm_triangle_le</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>bdd_aboveI2</span><span class="delimiter">)</span><span>                          
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bdd_above_4</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹bdd_above ((λ ξ. ∥f *<span class="hidden">⇩</span><sub>v</sub> (x - ξ)∥) ` (ball 0 r))›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>K</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>K_def</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀ ξ. ξ ∈ ball 0 r ⟹ ∥f *<span class="hidden">⇩</span><sub>v</sub> (x + ξ)∥ ≤ K›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹bdd_above ((λ ξ. norm (f (x + ξ))) ` (ball 0 r))›</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bdd_above_def</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>image_eqI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ξ ∈ ball (0::'a) r ⟹ -ξ ∈ ball 0 r›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>ξ</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>K_def</span><span> </span><span>ab_group_add_class.ab_diff_conv_add_uminus</span><span> </span><span>bdd_aboveI2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bdd_above_1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹bdd_above ((λ ξ. max ∥f *<span class="hidden">⇩</span><sub>v</sub> (x + ξ)∥  ∥f *<span class="hidden">⇩</span><sub>v</sub> (x - ξ)∥) ` (ball 0 r))›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹bdd_above ((λ ξ. ∥f *<span class="hidden">⇩</span><sub>v</sub> (x + ξ)∥) ` (ball 0 r))›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bdd_above_2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹bdd_above ((λ ξ.  ∥f *<span class="hidden">⇩</span><sub>v</sub> (x - ξ)∥) ` (ball 0 r))›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bdd_above_4</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>max_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>bdd_above_Int1</span><span> </span><span>bdd_above_mono</span><span> </span><span>image_Int_subset</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>bdd_above_Int1</span><span> </span><span>bdd_above_mono</span><span> </span><span>image_Int_subset</span><span class="delimiter">)</span><span>   
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bdd_above_6</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹bdd_above ((λt. ∥f *<span class="hidden">⇩</span><sub>v</sub> t∥) ` ball x r)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹bounded (ball x r)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>            
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹bounded ((λt. ∥f *<span class="hidden">⇩</span><sub>v</sub> t∥) ` ball x r)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>add.left_neutral</span><span> </span><span>bdd_above_2</span><span> </span><span>bdd_above_norm</span><span> </span><span>bounded_norm_comp</span><span> 
</span><span>          </span><span>image_add_ball</span><span> </span><span>image_image</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bounded_imp_bdd_above</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>norm_1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(λξ. ∥f *<span class="hidden">⇩</span><sub>v</sub> (x + ξ)∥) ` ball 0 r = (λt. ∥f *<span class="hidden">⇩</span><sub>v</sub> t∥) ` ball x r›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add.right_neutral</span><span> </span><span>ball_translation</span><span> </span><span>image_image</span><span class="delimiter">)</span><span>   
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bdd_above_5</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹bdd_above ((λξ. norm (f (x + ξ))) ` ball 0 r)›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bdd_above_2</span><span class="delimiter">)</span><span>   
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>norm_2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∥ξ∥ &lt; r ⟹ ∥f *<span class="hidden">⇩</span><sub>v</sub> (x - ξ)∥ ∈ (λξ. ∥f *<span class="hidden">⇩</span><sub>v</sub> (x + ξ)∥) ` ball 0 r›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>ξ</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∥ξ∥ &lt; r›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ξ ∈ ball (0::'a) r›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹-ξ ∈ ball (0::'a) r›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>ab_group_add_class.ab_diff_conv_add_uminus</span><span> </span><span>image_iff</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>norm_2'</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∥ξ∥ &lt; r ⟹ ∥f *<span class="hidden">⇩</span><sub>v</sub> (x + ξ)∥ ∈ (λξ. ∥f *<span class="hidden">⇩</span><sub>v</sub> (x - ξ)∥) ` ball 0 r›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>ξ</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹norm ξ &lt; r›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ξ ∈ ball (0::'a) r›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹-ξ ∈ ball (0::'a) r›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>diff_minus_eq_add</span><span> </span><span>image_iff</span><span class="delimiter">)</span><span>          
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bdd_above_6</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹bdd_above ((λξ. ∥f *<span class="hidden">⇩</span><sub>v</sub> (x - ξ)∥) ` ball 0 r)›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bdd_above_4</span><span class="delimiter">)</span><span>   
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Sup_2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(SUP ξ∈ball 0 r. max ∥f *<span class="hidden">⇩</span><sub>v</sub> (x + ξ)∥ ∥f *<span class="hidden">⇩</span><sub>v</sub> (x - ξ)∥) =
                 max (SUP ξ∈ball 0 r. ∥f *<span class="hidden">⇩</span><sub>v</sub> (x + ξ)∥) (SUP ξ∈ball 0 r. ∥f *<span class="hidden">⇩</span><sub>v</sub> (x - ξ)∥)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ball (0::'a) r ≠ {}›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹r &gt; 0›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹bdd_above ((λξ. ∥f *<span class="hidden">⇩</span><sub>v</sub> (x + ξ)∥) ` ball 0 r)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bdd_above_5</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹bdd_above ((λξ. ∥f *<span class="hidden">⇩</span><sub>v</sub> (x - ξ)∥) ` ball 0 r)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bdd_above_6</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>max_Sup</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Banach_Steinhaus_Missing.pointwise_max_def</span><span> </span><span>image_cong</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Sup_3'</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∥ξ∥ &lt; r ⟹ ∥f *<span class="hidden">⇩</span><sub>v</sub> (x + ξ)∥ ∈ (λξ. ∥f *<span class="hidden">⇩</span><sub>v</sub> (x - ξ)∥) ` ball 0 r›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>ξ</span><span class="delimiter">::</span><span class="tfree">'a</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>norm_2'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Sup_3''</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∥ξ∥ &lt; r ⟹ ∥f *<span class="hidden">⇩</span><sub>v</sub> (x - ξ)∥ ∈ (λξ. ∥f *<span class="hidden">⇩</span><sub>v</sub> (x + ξ)∥) ` ball 0 r›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>ξ</span><span class="delimiter">::</span><span class="tfree">'a</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>norm_2</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Sup_3</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹max (SUP ξ∈ball 0 r. ∥f *<span class="hidden">⇩</span><sub>v</sub> (x + ξ)∥) (SUP ξ∈ball 0 r.  ∥f *<span class="hidden">⇩</span><sub>v</sub> (x - ξ)∥) =
        (SUP ξ∈ball 0 r. ∥f *<span class="hidden">⇩</span><sub>v</sub> (x + ξ)∥)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(λξ. ∥f *<span class="hidden">⇩</span><sub>v</sub> (x + ξ)∥) ` (ball 0 r) = (λξ. ∥f *<span class="hidden">⇩</span><sub>v</sub> (x - ξ)∥) ` (ball 0 r)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Sup_3'</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Sup_3''</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sup ((λξ. ∥f *<span class="hidden">⇩</span><sub>v</sub> (x + ξ)∥) ` (ball 0 r))=Sup ((λξ. ∥f *<span class="hidden">⇩</span><sub>v</sub> (x - ξ)∥) ` (ball 0 r))›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Sup_1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sup ((λt. ∥f *<span class="hidden">⇩</span><sub>v</sub> t∥) ` (ball 0 r)) ≤ Sup ( (λξ. ∥f *<span class="hidden">⇩</span><sub>v</sub> ξ∥) ` (ball x r) )›</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(λt. ∥f *<span class="hidden">⇩</span><sub>v</sub> t∥) ξ ≤ max ∥f *<span class="hidden">⇩</span><sub>v</sub> (x + ξ)∥ ∥f *<span class="hidden">⇩</span><sub>v</sub> (x - ξ)∥›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>ξ</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>linear_plus_norm</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>bounded_linear.linear</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>blinfun.bounded_linear_right</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹bdd_above ((λ ξ. max ∥f *<span class="hidden">⇩</span><sub>v</sub> (x + ξ)∥  ∥f *<span class="hidden">⇩</span><sub>v</sub> (x - ξ)∥) ` (ball 0 r))›</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bdd_above_1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ball (0::'a) r ≠ {}›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹r &gt; 0›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sup ((λt. ∥f *<span class="hidden">⇩</span><sub>v</sub> t∥) ` (ball 0 r)) ≤
                     Sup ((λξ. max ∥f *<span class="hidden">⇩</span><sub>v</sub> (x + ξ)∥ ∥f *<span class="hidden">⇩</span><sub>v</sub> (x - ξ)∥) ` (ball 0 r))›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cSUP_mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>smt</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹… = max (Sup ((λξ.  ∥f *<span class="hidden">⇩</span><sub>v</sub> (x + ξ)∥) ` (ball 0 r)))
                        (Sup ((λξ. ∥f *<span class="hidden">⇩</span><sub>v</sub> (x - ξ)∥) ` (ball 0 r)))›</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Sup_2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹… = Sup ((λξ. ∥f *<span class="hidden">⇩</span><sub>v</sub> (x + ξ)∥) ` (ball 0 r))›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Sup_3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹… = Sup ((λξ. ∥f *<span class="hidden">⇩</span><sub>v</sub> ξ∥) ` (ball x r))›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span>  </span><span>add.right_neutral</span><span> </span><span>ball_translation</span><span> </span><span>image_image</span><span class="delimiter">)</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∥f∥ = (SUP x∈ball 0 r. ∥f *<span class="hidden">⇩</span><sub>v</sub> x∥) / r›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹0 &lt; r›</span></span></span><span> </span><span>onorm_r</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sup ((λt. ∥f *<span class="hidden">⇩</span><sub>v</sub> t∥) ` (ball 0 r)) / r ≤ Sup ((λξ. ∥f *<span class="hidden">⇩</span><sub>v</sub> ξ∥) ` (ball x r)) / r›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Sup_1</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹0 &lt; r›</span></span></span><span> </span><span>divide_right_mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∥f∥ ≤ Sup ((λt. ∥f *<span class="hidden">⇩</span><sub>v</sub> t∥) ` ball x r) / r›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>    
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>onorm_Sup_on_ball'</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>notation_norm</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹r &gt; 0›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹τ &lt; 1›</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃ξ∈ball x r.  τ * r * ∥f∥ ≤ ∥f *<span class="hidden">⇩</span><sub>v</sub> ξ∥›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹                 
  In the proof of Banach-Steinhaus theorem, we will use this variation of the 
  lemma @{text onorm_Sup_on_ball}.

  Explanation: Let \&lt;^term&gt;‹f› be a bounded operator, let \&lt;^term&gt;‹x› be a point and let \&lt;^term&gt;‹r› be a 
  positive real number. For any real number \&lt;^term&gt;‹τ &lt; 1›, there is a point \&lt;^term&gt;‹ξ› in the open ball 
  of radius \&lt;^term&gt;‹r› around \&lt;^term&gt;‹x› such that \&lt;^term&gt;‹τ * r * ∥f∥ ≤ ∥f *<span class="hidden">⇩</span><sub>v</sub> ξ∥›.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹f = 0›</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>centre_in_ball</span><span> </span><span>mult_zero_right</span><span> </span><span>norm_zero</span><span> </span><span>order_refl</span><span> 
</span><span>        </span><span>zero_blinfun.rep_eq</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bdd_above_1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹bdd_above ((λt. ∥(*<span class="hidden">⇩</span><sub>v</sub>) f t∥) ` ball x r)›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>f</span><span class="delimiter">::</span><span class="cartouche"><span class="delete"><span class="delete">‹'a ⇒<span class="hidden">⇩</span><sub>L</sub> 'b›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>bounded_linear_image</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bounded_linear_image</span><span> 
</span><span>        </span><span>blinfun.bounded_linear_right</span><span> </span><span>bounded_imp_bdd_above</span><span> </span><span>bounded_norm_comp</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹norm f &gt; 0›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f ≠ 0›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹norm f ≤  Sup ( (λξ.  ∥(*<span class="hidden">⇩</span><sub>v</sub>) f ξ∥) ` (ball x r) ) / r›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹r &gt; 0›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>onorm_Sup_on_ball</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹r * norm f ≤  Sup ( (λξ.  ∥(*<span class="hidden">⇩</span><sub>v</sub>) f ξ∥) ` (ball x r) )›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹0 &lt; r›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>divide_strict_right_mono</span><span> </span><span>nonzero_mult_div_cancel_left</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹τ * r * norm f &lt; r * norm f›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹τ &lt; 1›</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹0 &lt; norm f›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹0 &lt; r›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹τ * r * norm f &lt; Sup ( (norm ∘ ((*<span class="hidden">⇩</span><sub>v</sub>) f)) ` (ball x r) )›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(norm ∘ ( (*<span class="hidden">⇩</span><sub>v</sub>) f)) ` (ball x r) ≠ {}›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹0 &lt; r›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹bdd_above ((norm ∘ ( (*<span class="hidden">⇩</span><sub>v</sub>) f)) ` (ball x r))›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bdd_above_1</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃t ∈ (norm ∘ ( (*<span class="hidden">⇩</span><sub>v</sub>) f)) ` (ball x r). τ * r * norm f &lt; t›</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>less_cSup_iff</span><span class="delimiter">)</span><span>    
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>comp_def</span><span> </span><span>image_iff</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Banach-Steinhaus theorem›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>banach_steinhaus</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span class="delimiter">::</span><span class="cartouche"><span class="delete"><span class="delete">‹'c ⇒ ('a::banach ⇒<span class="hidden">⇩</span><sub>L</sub> 'b::real_normed_vector)›</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀x. bounded (range (λn. (f n) *<span class="hidden">⇩</span><sub>v</sub> x))›</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹bounded (range f)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹
  This is Banach-Steinhaus Theorem.

  Explanation: If a family of bounded operators on a Banach space
  is pointwise bounded, then it is uniformly bounded.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>classical</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹¬(bounded (range f))›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sum_1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃K. ∀n. sum (λk. inverse (real_of_nat 3^k)) {0..n} ≤ K›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹summable (λn. (inverse (real_of_nat 3))^n)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Series.summable_geometric_iff</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>c</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"inverse (real_of_nat 3)"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(inverse (real_of_nat 3))^n = inverse (real_of_nat 3^n)›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span class="delimiter">::</span><span>nat</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>power_inverse</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>        
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹summable (λn. inverse (real_of_nat 3^n))›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹bounded (range (λn. sum (λ k. inverse (real 3 ^ k)) {0..&lt;n}))›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>summable_imp_sums_bounded</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(λn. inverse (real_of_nat 3^n))"</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span>lessThan_atLeast0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃M. ∀h∈(range (λn. sum (λ k. inverse (real 3 ^ k)) {0..&lt;n})). norm h ≤ M›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bounded_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹h∈range (λn. sum (λ k. inverse (real 3 ^ k)) {0..&lt;n}) ⟹ norm h ≤ M›</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>h</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sum_2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sum (λk. inverse (real_of_nat 3^k)) {0..n} ≤ M›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹norm (sum (λ k. inverse (real 3 ^ k)) {0..&lt; Suc n}) ≤ M›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀h. h∈(range (λn. sum (λ k. inverse (real 3 ^ k)) {0..&lt;n})) ⟹ norm h ≤ M›</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹norm (sum (λ k. inverse (real 3 ^ k)) {0..n}) ≤ M›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>atLeastLessThanSuc_atLeastAtMost</span><span class="delimiter">)</span><span>        
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹(sum (λ k. inverse (real 3 ^ k)) {0..n}) ≤ M›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sum (λk. inverse (real_of_nat 3^k)) {0..n} ≤ M›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sum_2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹of_rat 2/3 &lt; (1::real)›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀g::'a ⇒<span class="hidden">⇩</span><sub>L</sub> 'b. ∀x. ∀r. ∃ξ. g ≠ 0 ∧ r &gt; 0
               ⟶ (ξ∈ball x r ∧ (of_rat 2/3) * r * norm g ≤ norm ((*<span class="hidden">⇩</span><sub>v</sub>) g ξ))›</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>onorm_Sup_on_ball'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃ξ. ∀g::'a ⇒<span class="hidden">⇩</span><sub>L</sub> 'b. ∀x. ∀r. g ≠ 0 ∧ r &gt; 0
           ⟶ ((ξ g x r)∈ball x r ∧ (of_rat 2/3) * r * norm g ≤ norm ((*<span class="hidden">⇩</span><sub>v</sub>) g (ξ g x r)))›</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ξ</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⟦g ≠ 0; r &gt; 0⟧ ⟹ 
        ξ g x r ∈ ball x r ∧  (of_rat 2/3) * r * norm g ≤ norm ((*<span class="hidden">⇩</span><sub>v</sub>) g (ξ g x r))›</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>g</span><span class="delimiter">::</span><span class="cartouche"><span class="delete"><span class="delete">‹'a ⇒<span class="hidden">⇩</span><sub>L</sub> 'b›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>r</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀n. ∃k. norm (f k) ≥ 4^n›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹¬(bounded (range f))›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>hide_lams</span><span class="delimiter">)</span><span> </span><span>boundedI</span><span> </span><span>image_iff</span><span> </span><span>linear</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹∃k. ∀n. norm (f (k n)) ≥ 4^n›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹∃k. ∀n. norm ((f ∘ k) n) ≥ 4^n›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>k</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹norm ((f ∘ k) n) ≥ 4^n›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>T</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹T = f ∘ k›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹T n ∈ range f›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>T_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>        
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹norm (T n) ≥ of_nat (4^n)›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>T_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀ n. norm ((f ∘ k) n) ≥ 4^n›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹T n ≠ 0›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>T_def</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀n. 4 ^ n ≤ norm ((f ∘ k) n)›</span></span></span><span> </span><span>norm_zero</span><span> </span><span>power_not_zero</span><span> </span><span>zero_le_power</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹inverse (of_nat 3^n) &gt; (0::real)›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>y</span><span class="delimiter">::</span><span class="cartouche"><span class="delete"><span class="delete">‹nat ⇒ 'a›</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y = rec_nat 0 (λn x. ξ (T n) x (inverse (of_nat 3^n)))›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y (Suc n) ∈ ball (y n) (inverse (of_nat 3^n))›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀ n. T n ≠ 0›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀ n. inverse (of_nat 3^n) &gt; 0›</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>y_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹norm (y (Suc n) - y n) ≤ inverse (of_nat 3^n)›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ball_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dist_norm</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>norm_minus_commute</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃K. ∀n. sum (λk. inverse (real_of_nat 3^k)) {0..n} ≤ K›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sum_1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Cauchy y›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>convergent_series_Cauchy</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>a</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λn. inverse (of_nat 3^n)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>φ</span><span> </span><span class="delimiter">=</span><span> </span><span>y</span><span class="delimiter">]</span><span> </span><span>dist_norm</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>calculation</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>calculation</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃ x. y ⇢ x›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>convergent_eq_Cauchy</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y ⇢ x›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>norm_2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹norm (x - y (Suc n)) ≤ (inverse (of_nat 2))*(inverse (of_nat 3^n))›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹inverse (real_of_nat 3) &lt; 1›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>        
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y 0 = 0›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>y_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹norm (x - y (Suc n)) 
    ≤ (inverse (of_nat 3)) * inverse (1 - (inverse (of_nat 3))) * ((inverse (of_nat 3)) ^ n)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bound_Cauchy_to_lim</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>c</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"inverse (of_nat 3)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span> </span><span class="delimiter">=</span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>x</span><span class="delimiter">]</span><span>
</span><span>        </span><span>power_inverse</span><span> </span><span>semiring_norm</span><span class="delimiter">(</span><span>77</span><span class="delimiter">)</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹y ⇢ x›</span></span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀ n. norm (y (Suc n) - y n) ≤ inverse (of_nat 3^n)›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>divide_inverse</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹inverse (real_of_nat 3) * inverse (1 - (inverse (of_nat 3)))
                   = inverse (of_nat 2)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>power_inverse</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹norm (x - y (Suc n)) ≤ (inverse (of_nat 2))*(inverse (of_nat 3^n))›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>norm_2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃ M. ∀ n. norm ((*<span class="hidden">⇩</span><sub>v</sub>) (T n) x) ≤ M›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>T_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀x. bounded (range (λn. (*<span class="hidden">⇩</span><sub>v</sub>) (f n) x))›</span></span></span><span> </span><span>bounded_iff</span><span> </span><span>rangeI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹norm ((*<span class="hidden">⇩</span><sub>v</sub>) (T n) x) ≤ M›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>norm_1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹norm (T n) * norm (y (Suc n) - x) + norm ((*<span class="hidden">⇩</span><sub>v</sub>) (T n) x)
       ≤ inverse (real 2) * inverse (real 3 ^ n) * norm (T n) + norm ((*<span class="hidden">⇩</span><sub>v</sub>) (T n) x)›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>   
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹norm (y (Suc n) - x) ≤ (inverse (of_nat 2))*(inverse (of_nat 3^n))›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹norm (x - y (Suc n)) ≤ (inverse (of_nat 2))*(inverse (of_nat 3^n))›</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>norm_minus_commute</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹norm (T n) ≥ 0›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹norm (T n) * norm (y (Suc n) - x) 
                     ≤ (inverse (of_nat 2))*(inverse (of_nat 3^n))*norm (T n)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀n. T n ≠ 0›</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>      
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inverse_2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(inverse (of_nat 6)) * inverse (real 3 ^ n) * norm (T n) 
                  ≤ norm ((*<span class="hidden">⇩</span><sub>v</sub>) (T n) x)›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(of_rat 2/3)*(inverse (of_nat 3^n))*norm (T n) ≤ norm ((*<span class="hidden">⇩</span><sub>v</sub>) (T n) (y (Suc n)))›</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀ n. T n ≠ 0›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀ n. inverse (of_nat 3^n) &gt; 0›</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>y_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹… = norm ((*<span class="hidden">⇩</span><sub>v</sub>) (T n) ((y (Suc n) - x) + x))›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹… = norm ((*<span class="hidden">⇩</span><sub>v</sub>) (T n) (y (Suc n) - x) + (*<span class="hidden">⇩</span><sub>v</sub>) (T n) x)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>diff_add_cancel</span><span> </span><span>linear_simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹… ≤ norm ((*<span class="hidden">⇩</span><sub>v</sub>) (T n) (y (Suc n) - x)) + norm ((*<span class="hidden">⇩</span><sub>v</sub>) (T n) x)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>norm_triangle_ineq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹… ≤ norm (T n) * norm (y (Suc n) - x) + norm ((*<span class="hidden">⇩</span><sub>v</sub>) (T n) x)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>onorm</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹… ≤ (inverse (of_nat 2))*(inverse (of_nat 3^n))*norm (T n) 
                + norm ((*<span class="hidden">⇩</span><sub>v</sub>) (T n) x)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>norm_1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(of_rat 2/3) * inverse (real 3 ^ n) * norm (T n)
                ≤ inverse (real 2) * inverse (real 3 ^ n) * norm (T n) 
                + norm ((*<span class="hidden">⇩</span><sub>v</sub>) (T n) x)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(of_rat 2/3) * inverse (real 3 ^ n) * norm (T n) 
             - inverse (real 2) * inverse (real 3 ^ n) * norm (T n) ≤ norm ((*<span class="hidden">⇩</span><sub>v</sub>) (T n) x)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(of_rat 2/3) * inverse (real 3 ^ n) * norm (T n) 
             - inverse (real 2) * inverse (real 3 ^ n) * norm (T n)
             = (inverse (of_nat 6)) * inverse (real 3 ^ n) * norm (T n)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(inverse (of_nat 6)) * inverse (real 3 ^ n) * norm (T n) ≤ norm ((*<span class="hidden">⇩</span><sub>v</sub>) (T n) x)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>      
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inverse_3</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(inverse (of_nat 6)) * (of_rat (4/3)^n) 
                    ≤ (inverse (of_nat 6)) * inverse (real 3 ^ n) * norm (T n)›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹of_rat (4/3)^n = inverse (real 3 ^ n) * (of_nat 4^n)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>divide_inverse_commute</span><span> </span><span>of_rat_divide</span><span> </span><span>power_divide</span><span> </span><span>of_rat_numeral_eq</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹… ≤  inverse (real 3 ^ n) * norm (T n)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀n. norm (T n) ≥ of_nat (4^n)›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹of_rat (4/3)^n ≤ inverse (real 3 ^ n) * norm (T n)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹inverse (of_nat 6) &gt; (0::real)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inverse_1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(inverse (of_nat 6)) * (of_rat (4/3)^n) ≤ M›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(inverse (of_nat 6)) * (of_rat (4/3)^n) 
          ≤ (inverse (of_nat 6)) * inverse (real 3 ^ n) * norm (T n)›</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inverse_3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹… ≤ norm ((*<span class="hidden">⇩</span><sub>v</sub>) (T n) x)›</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inverse_2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(inverse (of_nat 6)) * (of_rat (4/3)^n) ≤ norm ((*<span class="hidden">⇩</span><sub>v</sub>) (T n) x)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀ n. norm ((*<span class="hidden">⇩</span><sub>v</sub>) (T n) x) ≤ M›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>smt</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃n. M &lt; (inverse (of_nat 6)) * (of_rat (4/3)^n)›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Real.real_arch_pow</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(inverse (of_nat 6)) * (of_rat (4/3)^n) ≤ M›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inverse_1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>                      
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>smt</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A consequence of Banach-Steinhaus theorem›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>bounded_linear_limit_bounded_linear</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span class="delimiter">::</span><span class="cartouche"><span class="delete"><span class="delete">‹nat ⇒ ('a::banach ⇒<span class="hidden">⇩</span><sub>L</sub> 'b::real_normed_vector)›</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀x. convergent (λn. (f n) *<span class="hidden">⇩</span><sub>v</sub> x)›</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹∃g. (λn. (*<span class="hidden">⇩</span><sub>v</sub>) (f n)) ─pointwise→ (*<span class="hidden">⇩</span><sub>v</sub>) g›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹
  Explanation: If a sequence of bounded operators on a Banach space converges
  pointwise, then the limit is also a bounded operator.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃l. (λn. (*<span class="hidden">⇩</span><sub>v</sub>) (f n) x) ⇢ l›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀x. convergent (λn. (*<span class="hidden">⇩</span><sub>v</sub>) (f n) x)›</span></span></span><span> </span><span>convergentD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃F. (λn. (*<span class="hidden">⇩</span><sub>v</sub>) (f n)) ─pointwise→ F›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pointwise_convergent_to_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>F</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(λn. (*<span class="hidden">⇩</span><sub>v</sub>) (f n)) ─pointwise→ F›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃F. (λn. (*<span class="hidden">⇩</span><sub>v</sub>) (f n)) ─pointwise→ F›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀x. (λ n. (*<span class="hidden">⇩</span><sub>v</sub>) (f n) x) ⇢ F x›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(λn. (*<span class="hidden">⇩</span><sub>v</sub>) (f n)) ─pointwise→ F›</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pointwise_convergent_to_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹bounded (range f)›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀x. convergent (λn. (*<span class="hidden">⇩</span><sub>v</sub>) (f n) x)›</span></span></span><span> </span><span>banach_steinhaus</span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀x. ∃l. (λn. (*<span class="hidden">⇩</span><sub>v</sub>) (f n) x) ⇢ l›</span></span></span><span> </span><span>convergent_imp_bounded</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>norm_f_n</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃ M. ∀ n. norm (f n) ≤ M›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bounded_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>UNIV_I</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹bounded (range f)›</span></span></span><span> </span><span>bounded_iff</span><span> </span><span>image_eqI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹isCont (λ t::'b. norm t) y›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>y</span><span class="delimiter">::</span><span class="tfree">'b</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Limits.isCont_norm</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(λ n. norm ((*<span class="hidden">⇩</span><sub>v</sub>) (f n) x)) ⇢ (norm (F x))›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀ x::'a. (λ n. (*<span class="hidden">⇩</span><sub>v</sub>) (f n) x) ⇢ F x›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>tendsto_norm</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>norm_f_n_x</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃ M. ∀ n. norm ((*<span class="hidden">⇩</span><sub>v</sub>) (f n) x) ≤ M›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Elementary_Metric_Spaces.convergent_imp_bounded</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>UNIV_I</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀ x::'a. (λ n. (*<span class="hidden">⇩</span><sub>v</sub>) (f n) x) ⇢ F x›</span></span></span><span> </span><span>bounded_iff</span><span> </span><span>image_eqI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>norm_f</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃K. ∀n. ∀x. norm ((*<span class="hidden">⇩</span><sub>v</sub>) (f n) x) ≤ norm x * K›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃ M. ∀ n. norm ((*<span class="hidden">⇩</span><sub>v</sub>) (f n) x) ≤ M›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>norm_f_n_x</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀x. (λn. (*<span class="hidden">⇩</span><sub>v</sub>) (f n) x) ⇢ F x›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃ M. ∀ n. norm (f n) ≤ M›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>norm_f_n</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M</span><span class="delimiter">::</span><span>real</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃ M. ∀ n. norm (f n) ≤ M›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀ n. ∀x. norm ((*<span class="hidden">⇩</span><sub>v</sub>) (f n) x) ≤ norm x * norm (f n)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mult.commute</span><span> </span><span>onorm</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span>  </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃ M. ∀ n. norm (f n) ≤ M›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>hide_lams</span><span class="delimiter">)</span><span> </span><span>dual_order.trans</span><span> </span><span>norm_eq_zero</span><span> </span><span>order_refl</span><span> 
</span><span>          </span><span>real_mult_le_cancel_iff2</span><span> </span><span>vector_space_over_itself.scale_zero_left</span><span> </span><span>zero_less_norm_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>norm_F_x</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃K. ∀x. norm (F x) ≤ norm x * K›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃K. ∀n. ∀x. norm ((*<span class="hidden">⇩</span><sub>v</sub>) (f n) x) ≤ norm x * K"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>norm_f</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀x. (λn. (*<span class="hidden">⇩</span><sub>v</sub>) (f n) x) ⇢ F x›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀ x::'a. (λ n. (*<span class="hidden">⇩</span><sub>v</sub>) (f n)  x) ⇢ F x›</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Lim_bounded</span><span> </span><span>tendsto_norm</span><span class="delimiter">)</span><span>   
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹linear F›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>linear_limit_linear</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹linear ((*<span class="hidden">⇩</span><sub>v</sub>) (f n))›</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bounded_linear.linear</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f ─pointwise→ F›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(λn. (*<span class="hidden">⇩</span><sub>v</sub>) (f n)) ─pointwise→ F›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹bounded_linear_axioms F›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>norm_F_x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀x. (λn. (*<span class="hidden">⇩</span><sub>v</sub>) (f n) x) ⇢ F x›</span></span></span><span> </span><span>bounded_linear_axioms_def</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹bounded_linear F›</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bounded_linear_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃g. (*<span class="hidden">⇩</span><sub>v</sub>) g = F›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bounded_linear_Blinfun_apply</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(λn. (*<span class="hidden">⇩</span><sub>v</sub>) (f n)) ─pointwise→ F›</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div>