<div id="Lifting_Definition_Option_Examples">
<div class="head">
<h1>Theory Lifting_Definition_Option_Examples</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Lifting Definition Option
    Author:      René Thiemann       &lt;rene.thiemann@uibk.ac.at&gt;
    Maintainer:  René Thiemann
    License:     LGPL
*)</span>

<span class="comment1">(*
Copyright 2014 René Thiemann

This file is part of IsaFoR/CeTA.

IsaFoR/CeTA is free software: you can redistribute it and/or modify it under the
terms of the GNU Lesser General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

IsaFoR/CeTA is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along
with IsaFoR/CeTA. If not, see &lt;http://www.gnu.org/licenses/&gt;.
*)</span>
<span class="keyword1"><span class="command">theory</span></span> Lifting_Definition_Option_Examples
<span class="keyword2"><span class="keyword">imports</span></span>  
  <a href="../../HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Examples›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹A simple restricted type without type-parameters›</span></span>

<span class="keyword1"><span class="command">typedef</span></span> <span class="quoted">"restricted"</span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span> <span class="bound">i</span> <span class="main">::</span> int<span class="main">.</span> <span class="bound">i</span> <span class="keyword1">mod</span> <span class="numeral">2</span> <span class="main">=</span> <span class="main">0</span><span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">morphisms</span></span> base <span class="quoted">"restricted"</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> exI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="numeral"><span class="quoted"><span class="numeral"><span class="quoted"><span class="numeral">4</span></span></span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">setup_lifting</span></span> type_definition_restricted

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Let us start with just using a sufficient criterion for testing for even numbers,
  without actually generating them, i.e., where the generator is just the identity function.›</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span><span class="main">(</span>code_dt<span class="main">)</span> restricted_of_simple <span class="main">::</span> <span class="quoted"><span class="quoted">"int <span class="main">⇒</span> restricted option"</span></span> <span class="keyword2"><span class="keyword">is</span></span> 
  <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">x</span> <span class="main">::</span> int<span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">∈</span> <span class="main">{</span><span class="main">0</span><span class="main">,</span> <span class="numeral">2</span><span class="main">,</span> <span class="numeral">4</span><span class="main">,</span> <span class="numeral">6</span><span class="main">}</span> <span class="keyword1">then</span> Some <span class="bound">x</span> <span class="keyword1">else</span> None"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We can also take several input arguments for the test, and generate a more complex value.›</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span><span class="main">(</span>code_dt<span class="main">)</span> restricted_of_many_args <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> int <span class="main">⇒</span> bool <span class="main">⇒</span> restricted option"</span></span> <span class="keyword2"><span class="keyword">is</span></span> 
  <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">(</span><span class="bound">b</span> <span class="main">::</span> bool<span class="main">)</span><span class="main">.</span> <span class="keyword1">if</span> int <span class="bound">x</span> <span class="main">+</span> <span class="bound">y</span> <span class="main">=</span> <span class="numeral">5</span> <span class="keyword1">then</span> Some <span class="main">(</span><span class="main">(</span>int <span class="bound">x</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span><span class="bound">y</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">else</span> None"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="operator">presburger</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹No problem to use type parameters.›</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span><span class="main">(</span>code_dt<span class="main">)</span> restricted_of_poly <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> list <span class="main">⇒</span> restricted option"</span></span> <span class="keyword2"><span class="keyword">is</span></span> 
  <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">xs</span> <span class="main">::</span> <span class="tfree">'b</span> list<span class="main">.</span> <span class="keyword1">if</span> length <span class="bound">xs</span> <span class="main">=</span> <span class="numeral">2</span> <span class="keyword1">then</span> Some <span class="main">(</span>int <span class="main">(</span>length <span class="main">(</span><span class="bound">xs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">else</span> None"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Examples with type-parameters in the restricted type.›</span></span>

<span class="keyword1"><span class="command">typedef</span></span> <span class="tfree">'f</span> restrictedf <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span> <span class="bound">xs</span> <span class="main">::</span> <span class="tfree">'f</span> list<span class="main">.</span> length <span class="bound">xs</span> <span class="main">&lt;</span> <span class="numeral">3</span><span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">morphisms</span></span> basef restrictedf 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> exI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted"><span class="quoted">Nil</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">setup_lifting</span></span> type_definition_restrictedf

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹It does not matter, if we take the same or different type-parameters in the lift-definition.›</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span><span class="main">(</span>code_dt<span class="main">)</span> test1 <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'g</span> <span class="main">⇒</span> nat <span class="main">⇒</span> <span class="tfree">'g</span> restrictedf option"</span></span> <span class="keyword2"><span class="keyword">is</span></span> 
  <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="main">(</span><span class="bound">e</span> <span class="main">::</span> <span class="tfree">'g</span><span class="main">)</span> <span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="numeral">2</span> <span class="keyword1">then</span> Some <span class="main">(</span>replicate <span class="bound">x</span> <span class="bound">e</span><span class="main">)</span> <span class="keyword1">else</span> None"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lift_definition</span></span><span class="main">(</span>code_dt<span class="main">)</span> test2 <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'f</span> <span class="main">⇒</span> nat <span class="main">⇒</span> <span class="tfree">'f</span> restrictedf option"</span></span> <span class="keyword2"><span class="keyword">is</span></span> 
  <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="main">(</span><span class="bound">e</span> <span class="main">::</span> <span class="tfree">'f</span><span class="main">)</span> <span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="numeral">2</span> <span class="keyword1">then</span> Some <span class="main">(</span>replicate <span class="bound">x</span> <span class="bound">e</span><span class="main">)</span> <span class="keyword1">else</span> None"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Tests with multiple type-parameters.›</span></span>
 
<span class="keyword1"><span class="command">typedef</span></span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'f</span><span class="main">)</span> restr <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span> <span class="main">(</span><span class="bound">xs</span> <span class="main">::</span> <span class="tfree">'a</span> list<span class="main">,</span><span class="bound">ys</span> <span class="main">::</span> <span class="tfree">'f</span> list<span class="main">)</span> <span class="main">.</span> length <span class="bound">xs</span> <span class="main">=</span> length <span class="bound">ys</span><span class="main">}</span>"</span></span> 
  <span class="keyword2"><span class="keyword">morphisms</span></span> base' restr
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> exI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">(</span></span></span><span class="main"><span class="main"><span class="main">[]</span></span></span><span class="main"><span class="main"><span class="main">,</span></span></span> <span class="main"><span class="main"><span class="main">[]</span></span></span><span class="main"><span class="main"><span class="main">)</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> 
<span class="keyword1"><span class="command">setup_lifting</span></span> type_definition_restr

<span class="keyword1"><span class="command">lift_definition</span></span><span class="main">(</span>code_dt<span class="main">)</span> restr_of_pair <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'g</span> <span class="main">⇒</span> <span class="tfree">'e</span> list <span class="main">⇒</span> nat <span class="main">⇒</span> nat <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'e</span><span class="main">,</span>nat<span class="main">)</span> restr option"</span></span> <span class="keyword2"><span class="keyword">is</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="main">(</span><span class="bound">z</span> <span class="main">::</span> <span class="tfree">'g</span><span class="main">)</span> <span class="main">(</span><span class="bound">xs</span> <span class="main">::</span> <span class="tfree">'e</span> list<span class="main">)</span> <span class="main">(</span><span class="bound">y</span> <span class="main">::</span> nat<span class="main">)</span> <span class="bound">n</span><span class="main">.</span> <span class="keyword1">if</span> length <span class="bound">xs</span> <span class="main">=</span> <span class="bound">n</span> <span class="keyword1">then</span> Some <span class="main">(</span><span class="bound">xs</span><span class="main">,</span>replicate <span class="bound">n</span> <span class="bound">y</span><span class="main">)</span> <span class="keyword1">else</span> None"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Example from \isafor/\ceta›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹An argument filter is a mapping <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">π</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> from n-ary function symbols into 
lists of positions, i.e., where each position is between 0 and n-1. In \isafor,
(Isabelle's Formalization of Rewriting) and \ceta 
\cite{DBLP:conf/tphol/ThiemannS09}, the corresponding certifier for 
term rewriting related properties,
this is modelled as follows, where a partial argument filter in a map is extended to a full one 
by means of an default filter.›</span></span>

<span class="keyword1"><span class="command">typedef</span></span> <span class="tfree">'f</span> af <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span> <span class="main">(</span><span class="bound">π</span> <span class="main">::</span> <span class="tfree">'f</span> <span class="main">×</span> nat <span class="main">⇒</span> nat list<span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">f</span> <span class="bound">n</span><span class="main">.</span> set <span class="main">(</span><span class="bound">π</span> <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">n</span><span class="main">)</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span> <span class="main">..&lt;</span> <span class="bound">n</span><span class="main">}</span><span class="main">)</span><span class="main">}</span>"</span></span> 
  <span class="keyword2"><span class="keyword">morphisms</span></span> af Abs_af <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> exI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">λ</span></span></span> <span class="main"><span class="bound"><span class="main"><span class="bound"><span class="main"><span class="bound">_</span></span></span></span></span></span><span class="main"><span class="main"><span class="main">.</span></span></span> <span class="main"><span class="main"><span class="main">[]</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">setup_lifting</span></span> type_definition_af

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'f</span> af_impl <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="tfree">'f</span> <span class="main">×</span> nat<span class="main">)</span> <span class="main">×</span> nat list<span class="main">)</span>list"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">fun_of_map_fun</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> option<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">fun_of_map_fun</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="keyword1">of</span> Some <span class="bound">b</span> <span class="main">⇒</span> <span class="bound">b</span> <span class="main">|</span> None <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span><span class="main">(</span>code_dt<span class="main">)</span> af_of <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'f</span> af_impl <span class="main">⇒</span> <span class="tfree">'f</span> af option"</span></span> <span class="keyword2"><span class="keyword">is</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">s</span> <span class="main">::</span> <span class="tfree">'f</span> af_impl<span class="main">.</span> <span class="keyword1">if</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">fidx</span> <span class="main">∈</span> set <span class="bound">s</span><span class="main">.</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">i</span> <span class="main">∈</span> set <span class="main">(</span>snd <span class="bound">fidx</span><span class="main">)</span><span class="main">.</span> <span class="bound">i</span> <span class="main">&lt;</span> snd <span class="main">(</span>fst <span class="bound">fidx</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
     <span class="keyword1">then</span> Some <span class="main">(</span>fun_of_map_fun <span class="main">(</span>map_of <span class="bound">s</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span> <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">n</span><span class="main">)</span><span class="main">.</span> <span class="main">[</span><span class="main">0</span> <span class="main">..&lt;</span> <span class="bound">n</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">else</span> None"</span></span>
<span class="keyword1"><span class="command">using</span></span> map_of_SomeD <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Code generation tests and derived theorems›</span></span>
<span class="keyword1"><span class="command">export_code</span></span> 
  <span class="quoted"><span class="quoted">restricted_of_many_args</span></span>
  <span class="quoted"><span class="quoted">restricted_of_simple</span></span>
  <span class="quoted"><span class="quoted">restricted_of_poly</span></span>
  <span class="quoted"><span class="quoted">test1</span></span>
  <span class="quoted"><span class="quoted">test2</span></span>
  <span class="quoted"><span class="quoted">restr_of_pair</span></span>
  <span class="quoted"><span class="quoted">af_of</span></span>
<span class="keyword2"><span class="keyword">in</span></span> Haskell

<span class="keyword1"><span class="command">lemma</span></span> restricted_of_simple_Some<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"restricted_of_simple <span class="free">x</span> <span class="main">=</span> Some <span class="free">r</span> <span class="main">⟹</span> base <span class="free">r</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> restricted_of_simple.rep_eq<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">x</span></span><span class="main">]</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">split</span> if_splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> option.map option.inject option.simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div>