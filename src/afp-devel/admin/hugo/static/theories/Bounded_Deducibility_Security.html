<div id="Trivia">
<div class="head"><h1>Theory Trivia</h1>
<span class="command">theory</span> <span class="name">Trivia</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Trivia›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Trivia</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>measure_induct2</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>meas</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'b ⇒ nat"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x1 x2. (⋀y1 y2. meas y1 y2 &lt; meas x1 x2 ⟹ S y1 y2) ⟹ S x1 x2"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S x1 x2"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?m</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ x1x2. meas (fst x1x2) (snd x1x2)"</span></span></span><span> </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?S</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ x1x2. S (fst x1x2) (snd x1x2)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?S (x1,x2)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>measure_induct</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?m</span><span> </span><span class="var">?S</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fst_conv</span><span> </span><span>snd_conv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Right cons:›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>Rcons</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"##"</span></span></span><span> </span><span>70</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs ## x ≡ xs @ [x]"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>two_singl_Rcons</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"[a,b] = [a] ## b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div><div id="IO_Automaton">
<div class="head"><h1>Theory IO_Automaton</h1>
<span class="command">theory</span> <span class="name">IO_Automaton</span><br/>
<span class="keyword">imports</span> <a href="Trivia.html"><span class="name">Trivia</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹IO Automaton›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>IO_Automaton</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Trivia</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Preliminaries›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Transitions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'state</span><span class="delimiter">,</span><span class="tfree">'act</span><span class="delimiter">,</span><span class="tfree">'out</span><span class="delimiter">)</span><span> </span><span>trans</span><span> </span><span class="delimiter">=</span><span>
</span><span>Trans</span><span> </span><span class="delimiter">(</span><span>srcOf</span><span class="delimiter">:</span><span> </span><span class="tfree">'state</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>actOf</span><span class="delimiter">:</span><span> </span><span class="tfree">'act</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>outOf</span><span class="delimiter">:</span><span> </span><span class="tfree">'out</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>tgtOf</span><span class="delimiter">:</span><span> </span><span class="tfree">'state</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'state</span><span class="delimiter">,</span><span class="tfree">'act</span><span class="delimiter">,</span><span class="tfree">'out</span><span class="delimiter">)</span><span> </span><span>trace</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('state,'act,'out) trans list"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>IO_Automaton</span><span> </span><span class="delimiter">=</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>istate</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'state"</span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* initial step *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>step</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'state ⇒ 'act ⇒ 'out * 'state"</span></span></span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* transition function *)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Reachability and invariance›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Reachable states: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>reach</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'state ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>Istate</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reach istate"</span></span></span><span>
</span><span class="delimiter">|</span><span>
</span><span>Step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reach s ⟹ reach (snd (step s a))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reach_PairI</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reach s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"step s a = (ou, s')"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reach s'"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Step</span><span> </span><span>assms</span><span> </span><span>assms</span><span> </span><span>snd_eqD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* holds at the initial state: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>holdsIstate</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('state ⇒ bool) ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"holdsIstate φ ≡ φ istate"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* is invariant: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>invar</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('state ⇒ bool) ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"invar φ ≡ ∀ s a. reach s ∧ φ s ⟶ φ (snd (step s a))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>holdsIstate_invar</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>h</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"holdsIstate φ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar φ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reach s"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ s"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>reach.induct</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>h</span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>holdsIstate_def</span><span> </span><span>invar_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹System traces›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* The output and effect of an action on a state: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>out</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'state ⇒ 'act ⇒ 'out"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"out s a ≡ fst (step s a)"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>eff</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'state ⇒ 'act ⇒ 'state"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eff s a ≡ snd (step s a)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>validTrans</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('state,'act,'out) trans ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"validTrans (Trans s a ou s') = (step s a = (ou, s'))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>validTrans</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"validTrans trn =
 (step (srcOf trn) (actOf trn) = (outOf trn, tgtOf trn))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>trn</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Traces allowed by the system (starting in any given state) *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Two alternative definitions: growing from the left and growing from the right: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>valid</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('state,'act,'out) trace ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>Singl</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"validTrans trn
 ⟹
 valid [trn]"</span></span></span><span>
</span><span class="delimiter">|</span><span>
</span><span>Cons</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦validTrans trn; tgtOf trn = srcOf (hd tr); valid tr⟧
 ⟹
 valid (trn # tr)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>valid_SinglE</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid [trn]"</span></span></span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>valid_ConsE</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid (trn # tr)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>valid2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('state,'act,'out) trace ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>Singl</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"validTrans trn
 ⟹
 valid2 [trn]"</span></span></span><span>
</span><span class="delimiter">|</span><span>
</span><span>Rcons</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦valid2 tr; tgtOf (last tr) = srcOf trn; validTrans trn⟧
 ⟹
 valid2 (tr ## trn)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>valid2_SinglE</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid2 [trn]"</span></span></span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>valid2_RconsE</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid2 (tr ## trn)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Nil_not_valid</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ valid []"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>valid.simps</span><span> </span><span>neq_Nil_conv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Nil_not_valid2</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ valid2 []"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>valid2.cases</span><span> </span><span>append_Nil</span><span> </span><span>butlast.simps</span><span> </span><span>butlast_snoc</span><span> </span><span>not_Cons_self2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_Rcons</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid tr"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tgtOf (last tr) = srcOf trn"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"validTrans trn"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid (tr ## trn)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>trn</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>trn</span><span> </span><span>tr</span><span> </span><span>trna</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>tr</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>valid.Cons</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>valid.intros</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_hd_Rcons</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid tr"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hd (tr ## tran) = hd tr"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Nil_not_valid</span><span> </span><span>assms</span><span> </span><span>hd_append</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid2_hd_Rcons</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid2 tr"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hd (tr ## tran) = hd tr"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Nil_not_valid2</span><span> </span><span>assms</span><span> </span><span>hd_append</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid2_last_Cons</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid2 tr"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"last (tran # tr) = last tr"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Nil_not_valid2</span><span> </span><span>assms</span><span> </span><span>last.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid2_Cons</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid2 tr"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tgtOf trn = srcOf (hd tr)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"validTrans trn"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid2 (trn # tr)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>trn</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Singl</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>two_singl_Rcons</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Singl</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>valid2.Rcons</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>valid2.Singl</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Rcons</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>append.append_Cons</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Rcons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>valid2.Rcons</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_valid2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid = valid2"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">,</span><span> </span><span>safe</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>tr</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid tr"</span></span></span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid2 tr"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>valid2.Singl</span><span> </span><span>valid2_Cons</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>tr</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid2 tr"</span></span></span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid tr"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>valid.Singl</span><span> </span><span>valid_Rcons</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>valid2_valid</span><span> </span><span class="delimiter">=</span><span> </span><span>valid_valid2</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>validFrom</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'state ⇒ ('state,'act,'out) trace ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"validFrom s tr ≡ tr = [] ∨ (valid tr ∧ srcOf (hd tr) = s)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>validFrom_Nil</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"validFrom s []"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>validFrom_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>validFrom_valid</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid tr ∧ srcOf (hd tr) = s ⟹ validFrom s tr"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>validFrom_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>validFrom_validTrans</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"validTrans (Trans s a ou s')"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"validFrom s' tr"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"validFrom s (Trans s a ou s' # tr)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>validFrom_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Traces versus reachability›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_reach_src_tgt</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid tr"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reach (srcOf (hd tr))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reach (tgtOf (last tr))"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>induct</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>reach_PairI</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>validTrans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_init_reach</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid tr"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"srcOf (hd tr) = istate"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reach (tgtOf (last tr))"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valid_reach_src_tgt</span><span> </span><span>assms</span><span> </span><span>reach.Istate</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Trans_fst_sndI</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"valid [Trans s a (fst (step s a)) (snd (step s a))]"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>valid.Singl</span><span> </span><span>surjective_pairing</span><span> </span><span>validTrans.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reach_init_valid</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reach s"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"s = istate
 ∨
 (∃ tr. valid tr ∧ srcOf (hd tr) = istate ∧ tgtOf (last tr) = s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>induction</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Step</span><span> </span><span>s</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span> </span><span>exE</span><span> </span><span>conjE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s = istate"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?ou</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (step s a)"</span></span></span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s'</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (step s a)"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>disjI2</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"[Trans s a ?ou ?s']"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>tr</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>v</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid tr"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"srcOf (hd tr) = istate"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tgtOf (last tr) = s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?ou</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (step s a)"</span></span></span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s'</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (step s a)"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>v</span><span> </span><span>t</span><span> </span><span>s</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>disjI2</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"tr ## Trans s a ?ou ?s'"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>valid_Rcons</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reach_validFrom</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reach s'"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ s tr. s = istate ∧ (s = s' ∨ (validFrom s tr ∧ tgtOf (last tr) = s'))"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>reach_init_valid</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>validFrom_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* locale IO_Automaton *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div><div id="BD_Security">
<div class="head"><h1>Theory BD_Security</h1>
<span class="command">theory</span> <span class="name">BD_Security</span><br/>
<span class="keyword">imports</span> <a href="IO_Automaton.html"><span class="name">IO_Automaton</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹BD Security›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>BD_Security</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>IO_Automaton</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Definition›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>Let_def</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>relcomp</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"O"</span></span></span><span> </span><span>75</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>never</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ bool) ⇒ 'a list ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"never U ≡ list_all (λ a. ¬ U a)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">function</span></span><span> </span><span>filtermap</span><span> </span><span class="delimiter">::</span><span>
</span><span class="string"><span class="delete"><span class="delete">"(('state,'act,'out) trans ⇒ bool) ⇒ (('state,'act,'out) trans ⇒ 'a) ⇒ ('state,'act,'out) trace ⇒ 'a list"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"filtermap pred func [] = []"</span></span></span><span>
</span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"¬ pred trn ⟹ filtermap pred func (trn # tr) = filtermap pred func tr"</span></span></span><span>
</span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"pred trn ⟹ filtermap pred func (trn # tr) = func trn # filtermap pred func tr"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>list.exhaust</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">termination</span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>BD_Security</span><span> </span><span class="delimiter">=</span><span> </span><span>IO_Automaton</span><span> </span><span>istate</span><span> </span><span>step</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>istate</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'state</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>step</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'state ⇒ 'act ⇒ 'out × 'state"</span></span></span><span>
</span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* value filtering and production:  *)</span></span></span></span></span><span>
</span><span>   </span><span>φ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('state,'act,'out) trans =&gt; bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('state,'act,'out) trans ⇒ 'value"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* observation filtering and production: *)</span></span></span></span></span><span>
</span><span>   </span><span>γ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('state,'act,'out) trans =&gt; bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>g</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('state,'act,'out) trans ⇒ 'obs"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* declassification trigger:  *)</span></span></span></span></span><span>
</span><span>   </span><span>T</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('state,'act,'out) trans ⇒ bool"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* declassification bound: *)</span></span></span></span></span><span>
</span><span>   </span><span>B</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'value list ⇒ 'value list ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* The value function: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>V</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('state,'act,'out) trace ⇒ 'value list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ≡ filtermap φ f"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* The observation function: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>O</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('state,'act,'out) trace ⇒ 'obs list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"O ≡ filtermap γ g"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>V_simps</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"V [] = []"</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"¬ φ trn ⟹ V (trn # tr) = V tr"</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"φ trn ⟹ V (trn # tr) = f trn # V tr"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>V_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>O_simps</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"O [] = []"</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"¬ γ trn ⟹ O (trn # tr) = O tr"</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"γ trn ⟹ O (trn # tr) = g trn # O tr"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>O_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Reachable states by transitions satisfying T: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>reachNT</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'state ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>Istate</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reachNT istate"</span></span></span><span>
</span><span class="delimiter">|</span><span>
</span><span>Step</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦reachNT (srcOf trn); step (srcOf trn) (actOf trn) = (outOf trn, tgtOf trn); ¬ T trn⟧
 ⟹ reachNT (tgtOf trn)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reachNT_PairI</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reachNT s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"step s a = (ou, s')"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ T (Trans s a ou s')"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reachNT s'"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>BD_Security.reachNT.simps</span><span> </span><span>assms</span><span> </span><span>trans.sel</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reachNT_reach</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reachNT s"</span></span></span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reach s"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>induct</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>reach.intros</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span>reach.Step</span><span> </span><span>snd_conv</span><span> </span><span>validTrans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reachNT_stateO_aux</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reachNT s"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s = istate ∨ (∃sh a ou. reach sh ∧ step sh a = (ou,s) ∧ ¬T (Trans sh a ou s))"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>induct</span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span>BD_Security.reachNT_reach</span><span> </span><span>trans.exhaust_sel</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reachNT_state_cases</span><span class="delimiter">[</span><span>cases</span><span> </span><span>set</span><span class="delimiter">,</span><span>consumes</span><span> </span><span>1</span><span class="delimiter">,</span><span> </span><span>case_names</span><span> </span><span>init</span><span> </span><span>step</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reachNT s"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s = istate"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>sh</span><span> </span><span>a</span><span> </span><span>ou</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reach sh"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"step sh a = (ou,s)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬T (Trans sh a ou s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>reachNT_stateO_aux</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* This is assumed to be an invariant only modulo non T  *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>invarNT</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"invarNT Inv ≡ ∀ s a ou s'. reachNT s ∧ Inv s ∧ ¬ T (Trans s a ou s') ∧ step s a = (ou,s') ⟶ Inv s'"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>invarNT_disj</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invarNT Inv1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invarNT Inv2"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invarNT (λ s. Inv1 s ∨ Inv2 s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>invarNT_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>invarNT_conj</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invarNT Inv1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invarNT Inv2"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invarNT (λ s. Inv1 s ∧ Inv2 s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>invarNT_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>holdsIstate_invarNT</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>h</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"holdsIstate Inv"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invarNT Inv"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reachNT s"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Inv s"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>h</span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>holdsIstate_def</span><span> </span><span>invarNT_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>reachNT.induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>i</span><span> </span><span>invarNT_def</span><span> </span><span>trans.exhaust_sel</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* BD security: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>secure</span><span> </span><span class="delimiter">::</span><span> </span><span>bool</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"secure ≡
 ∀ tr vl vl1.
   validFrom istate tr ∧ never T tr ∧ B vl vl1 ∧ V tr = vl ⟶
   (∃ tr1. validFrom istate tr1 ∧ O tr1 = O tr ∧ V tr1 = vl1)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>V_iff_non_φ</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"V (trn # tr) = V tr ⟷ ¬ φ trn"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ trn"</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>V_imp_φ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"V (trn # tr) = v # V tr ⟹ φ trn"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ trn"</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>V_imp_Nil</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"V (trn # tr) = [] ⟹ V tr = []"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>V_simps</span><span> </span><span>list.distinct</span><span> </span><span>trans.exhaust</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>V_iff_Nil</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"V (trn # tr) = [] ⟷ ¬ φ trn ∧ V tr = []"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>V_iff_non_φ</span><span> </span><span>V_imp_Nil</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* context BD_Security *)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Unwinding proof method›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>BD_Security</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>consume</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('state,'act,'out) trans ⇒ 'value list ⇒ 'value list ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"consume trn vl vl' ≡
 if φ trn then vl ≠ [] ∧ f trn = hd vl ∧ vl' = tl vl
 else vl' = vl"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>length_consume</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"consume trn vl vl' ⟹ length vl' &lt; Suc (length vl)"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>consume_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ex_consume_φ</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ φ trn"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>vl'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"consume trn vl vl'"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>consume_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ex_consume_NO</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vl ≠ []"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f trn = hd vl"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>vl'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"consume trn vl vl'"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>consume_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ trn"</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* independent action: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>iaction</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"iaction Δ s vl s1 vl1 ≡
 ∃ a1 ou1 s1' vl1'.
   let trn1 = Trans s1 a1 ou1 s1' in
   validTrans trn1 ∧
   φ trn1 ∧ consume trn1 vl1 vl1' ∧
   ¬ γ trn1
   ∧
   Δ s vl s1' vl1'"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>iactionI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">?</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"step s1 a1 = (ou1, s1')"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ (Trans s1 a1 ou1 s1')"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"consume (Trans s1 a1 ou1 s1') vl1 vl1'"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ γ (Trans s1 a1 ou1 s1')"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Δ s vl s1' vl1'"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"iaction Δ s vl s1 vl1"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>iaction_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>match</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"match Δ s s1 vl1 a ou s' vl' ≡
 ∃ a1 ou1 s1' vl1'.
    let trn = Trans s a ou s'; trn1 = Trans s1 a1 ou1 s1' in
    validTrans trn1 ∧
    consume trn1 vl1 vl1' ∧
    γ trn = γ trn1 ∧ (γ trn ⟶ g trn = g trn1) ∧
    Δ s' vl' s1' vl1'"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>matchI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">?</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"validTrans (Trans s1 a1 ou1 s1')"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"consume (Trans s1 a1 ou1 s1') vl1 vl1'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"γ (Trans s a ou s') = γ (Trans s1 a1 ou1 s1')"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"γ (Trans s a ou s') ⟹ g (Trans s a ou s') = g (Trans s1 a1 ou1 s1')"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Δ s' vl' s1' vl1'"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"match Δ s s1 vl1 a ou s' vl'"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>match_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ignore</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"ignore Δ s s1 vl1 a ou s' vl' ≡
 ¬ γ (Trans s a ou s') ∧
 Δ s' vl' s1 vl1"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ignoreI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">?</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ γ (Trans s a ou s')"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Δ s' vl' s1 vl1"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ignore Δ s s1 vl1 a ou s' vl'"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ignore_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* reaction: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>reaction</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"reaction Δ s vl s1 vl1 ≡
 ∀ a ou s' vl'.
   let trn = Trans s a ou s' in
   validTrans trn ∧ ¬ T trn ∧
   consume trn vl vl'
   ⟶
   match Δ s s1 vl1 a ou s' vl'
   ∨
   ignore Δ s s1 vl1 a ou s' vl'"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reactionI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">?</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"⋀a ou s' vl'.
   ⟦step s a = (ou, s'); ¬ T (Trans s a ou s');
    consume (Trans s a ou s') vl vl'⟧
   ⟹
   match Δ s s1 vl1 a ou s' vl' ∨ ignore Δ s s1 vl1 a ou s' vl'"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reaction Δ s vl s1 vl1"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>reaction_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exit"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'state ⇒ 'value ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"exit s v ≡ ∀ tr trn. validFrom s (tr ## trn) ∧ never T (tr ## trn) ∧ φ trn ⟶ f trn ≠ v"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exit_coind</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>K</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"K s"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>I</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ trn. ⟦K (srcOf trn); validTrans trn; ¬ T trn⟧
        ⟹ (φ trn ⟶ f trn ≠ v) ∧ K (tgtOf trn)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exit s v"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>K</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>exit_def</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>tr</span><span> </span><span>trn</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"K s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"validFrom s (tr ## trn) ∧ never T (tr ## trn) ∧ φ trn"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f trn ≠ v"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>I</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>validFrom_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>tr</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>s</span><span> </span><span>trn</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span>neq_Nil_conv</span><span> </span><span>rotate1.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>rotate1_is_Nil_conv</span><span> </span><span>valid_ConsE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>noVal</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"noVal K v ≡
 ∀ s a ou s'. reachNT s ∧ K s ∧ step s a = (ou,s') ∧ φ (Trans s a ou s') ⟶ f (Trans s a ou s') ≠ v"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>noVal_disj</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"noVal Inv1 v"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"noVal Inv2 v"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"noVal (λ s. Inv1 s ∨ Inv2 s) v"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>noVal_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>noVal_conj</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"noVal Inv1 v"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"noVal Inv2 v"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"noVal (λ s. Inv1 s ∧ Inv2 s) v"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>noVal_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Often encountered sufficient criterion for noVal: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>noφ</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"noφ K ≡ ∀ s a ou s'. reachNT s ∧ K s ∧ step s a = (ou,s') ⟶ ¬ φ (Trans s a ou s')"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>noφ_noVal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"noφ K ⟹ noVal K v"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>noφ_def</span><span> </span><span>noVal_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* intro rule for quick inline checks: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exitI</span><span class="delimiter">[</span><span>consumes</span><span> </span><span>2</span><span class="delimiter">,</span><span> </span><span>induct</span><span> </span><span>pred</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"exit"</span></span></span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>rs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reachNT s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>K</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"K s"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>I</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⋀ s a ou s'.
   ⟦reach s; reachNT s; step s a = (ou,s'); K s⟧
   ⟹ (φ (Trans s a ou s') ⟶ f (Trans s a ou s') ≠ v) ∧ K s'"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exit s v"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?K</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ s. reachNT s ∧ K s"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exit_coind</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?K</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="delimiter">(</span><span>metis</span><span> </span><span>BD_Security.reachNT_reach</span><span> </span><span>IO_Automaton.validTrans</span><span> </span><span>reachNT.Step</span><span> </span><span>trans.exhaust_sel</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* intro rule for more elaborate checks: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exitI2</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>rs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reachNT s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>K</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"K s"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invarNT K"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"noVal K v"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exit s v"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?K</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ s. reachNT s ∧ K s"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>invarNT_def</span><span> </span><span>noVal_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>exit_coind</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?K</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>IO_Automaton.validTrans</span><span> </span><span>reachNT.Step</span><span> </span><span>trans.exhaust_sel</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Binary version of the invariant: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>noVal2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"noVal2 K v ≡
 ∀ s a ou s'. reachNT s ∧ K s v ∧ step s a = (ou,s') ∧ φ (Trans s a ou s') ⟶ f (Trans s a ou s') ≠ v"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>noVal2_disj</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"noVal2 Inv1 v"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"noVal2 Inv2 v"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"noVal2 (λ s v. Inv1 s v ∨ Inv2 s v) v"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>noVal2_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>noVal2_conj</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"noVal2 Inv1 v"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"noVal2 Inv2 v"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"noVal2 (λ s v. Inv1 s v ∧ Inv2 s v) v"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>noVal2_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>noVal_noVal2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"noVal K v ⟹ noVal2 (λ s v. K s) v"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>noVal_def</span><span> </span><span>noVal2_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exitI_noVal2</span><span class="delimiter">[</span><span>consumes</span><span> </span><span>2</span><span class="delimiter">,</span><span> </span><span>induct</span><span> </span><span>pred</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"exit"</span></span></span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>rs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reachNT s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>K</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"K s v"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>I</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⋀ s a ou s'.
   ⟦reach s; reachNT s; step s a = (ou,s'); K s v⟧
   ⟹ (φ (Trans s a ou s') ⟶ f (Trans s a ou s') ≠ v) ∧ K s' v"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exit s v"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?K</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ s. reachNT s ∧ K s v"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exit_coind</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?K</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="delimiter">(</span><span>metis</span><span> </span><span>BD_Security.reachNT_reach</span><span> </span><span>IO_Automaton.validTrans</span><span> </span><span>reachNT.Step</span><span> </span><span>trans.exhaust_sel</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exitI2_noVal2</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>rs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reachNT s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>K</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"K s v"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invarNT (λ s. K s v)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"noVal2 K v"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exit s v"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?K</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ s. reachNT s ∧ K s v"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>invarNT_def</span><span> </span><span>noVal2_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exit_coind</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?K</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>IO_Automaton.validTrans</span><span> </span><span>reachNT.Step</span><span> </span><span>trans.exhaust_sel</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* end binary version *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exit_validFrom</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>vl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vl ≠ []"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"exit s (hd vl)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>v</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"validFrom s tr"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>V</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"V tr = vl"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>T</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"never T tr"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>False</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i</span><span> </span><span>v</span><span> </span><span>V</span><span> </span><span>T</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>tr</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>V_simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>vl</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>trn</span><span> </span><span>tr</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ trn"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f trn = hd vl"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>V_simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>hd_Cons_tl</span><span> </span><span>list.inject</span><span> </span><span>vl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"validFrom s [trn]"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹validFrom s (trn # tr)›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>validFrom_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>exit_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>allE</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V tr = vl"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"never T tr"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Cons.prems</span><span> </span><span>list_all_simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹validFrom s (trn # tr)›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"validFrom (tgtOf trn) tr"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s = srcOf trn"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>list.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>validFrom_def</span><span> </span><span>valid_ConsE</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> 
</span><span>              </span><span>IO_Automaton.validFrom_def</span><span> </span><span>list.discI</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">+</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exit (tgtOf trn) (hd vl)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹exit s (hd vl)›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>exit_def</span><span> </span><span>s</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>append_Cons</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>           </span><span>list.distinct</span><span> </span><span>list_all_simps</span><span> </span><span>valid.Cons</span><span> </span><span>validFrom_def</span><span> </span><span>valid_ConsE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>unwind</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"unwind Δ ≡
 ∀ s vl s1 vl1.
   reachNT s ∧ reach s1 ∧ Δ s vl s1 vl1
   ⟶
   (vl ≠ [] ∧ exit s (hd vl))
   ∨
   iaction Δ s vl s1 vl1
   ∨
   ((vl ≠ [] ∨ vl1 = []) ∧ reaction Δ s vl s1 vl1)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unwindI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">?</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"⋀ s vl s1 vl1.
   ⟦reachNT s; reach s1; Δ s vl s1 vl1⟧
   ⟹
   (vl ≠ [] ∧ exit s (hd vl))
   ∨
   iaction Δ s vl s1 vl1
   ∨
   ((vl ≠ [] ∨ vl1 = []) ∧ reaction Δ s vl s1 vl1)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"unwind Δ"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unwind_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unwind_trace</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>unwind</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"unwind Δ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reachNT s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reach s1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Δ s vl s1 vl1"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"validFrom s tr"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"never T tr"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V tr = vl"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃tr1. validFrom s1 tr1 ∧ O tr1 = O tr ∧ V tr1 = vl1"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?S</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ tr vl1.
  ∀ s vl s1. reachNT s ∧ reach s1 ∧ Δ s vl s1 vl1 ∧ validFrom s tr ∧ never T tr ∧ V tr = vl ⟶
          (∃tr1. validFrom s1 tr1 ∧ O tr1 = O tr ∧ V tr1 = vl1)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?f</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ tr vl1. length tr + length vl1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?S tr vl1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>measure_induct2</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?f</span><span> </span><span class="var">?S</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>tr</span><span> </span><span>vl1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">,</span><span> </span><span>elim</span><span> </span><span>conjE</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> </span><span>vl</span><span> </span><span>s1</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>rs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reachNT s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>rs1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reach s1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Δ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Δ s vl s1 vl1"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>v</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"validFrom s tr"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>NT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"never T tr"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>V</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"V tr = vl"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(vl ≠ [] ∧ exit s (hd vl)) ∨
             iaction Δ s vl s1 vl1 ∨
             (reaction Δ s vl s1 vl1 ∧ ¬ iaction Δ s vl s1 vl1)"</span></span></span><span>
</span><span>      </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?exit ∨ ?iact ∨ ?react ∧ _"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>unwind</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unwind_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃tr1. validFrom s1 tr1 ∧ O tr1 = O tr ∧ V tr1 = vl1"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>safe</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vl ≠ []"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exit s (hd vl)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>v</span><span> </span><span>V</span><span> </span><span>exit_validFrom</span><span> </span><span>NT</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?iact</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>iaction_def</span><span> </span><span>Let_def</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>safe</span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a1</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'act</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ou1</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'out</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s1'</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'state</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>vl1'</span><span>
</span><span>          </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?trn1</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Trans s1 a1 ou1 s1'"</span></span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>vtrans1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"validTrans ?trn1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>φ1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ?trn1"</span></span></span><span>
</span><span>          </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"consume ?trn1 vl1 vl1'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>γ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ γ ?trn1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Δ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Δ s vl s1' vl1'"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>φ1</span><span> </span><span>c</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>v1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>vl1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vl1 = v1 # vl1'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f ?trn1 = v1"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>consume_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>vl1</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>rs1'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reach s1'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rs1</span><span> </span><span>vtrans1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>reach_PairI</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>tr1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>v1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"validFrom s1' tr1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>O</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"O tr1 = O tr"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>V</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"V tr1 = vl1'"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span class="delimiter">[</span><span>of</span><span> </span><span>tr</span><span> </span><span>vl1'</span><span class="delimiter">]</span><span> </span><span>rs</span><span> </span><span>rs1'</span><span> </span><span>Δ</span><span> </span><span>v</span><span> </span><span>NT</span><span> </span><span>V</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vl1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vtrans1</span><span> </span><span>v1</span><span> </span><span>O</span><span> </span><span>γ</span><span> </span><span>V</span><span> </span><span>φ1</span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vl1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"?trn1 # tr1"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>react</span><span class="delimiter">:</span><span> </span><span class="var">?react</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>iact</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ?iact"</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>tr</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>tr</span><span> </span><span class="delimiter">=</span><span> </span><span>Nil</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>vl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vl = []"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>V</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>vl1</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>vl1</span><span> </span><span class="delimiter">=</span><span> </span><span>Nil</span><span>
</span><span>            </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span class="delimiter">[</span><span>of</span><span> </span><span>tr</span><span> </span><span>vl1</span><span class="delimiter">]</span><span> </span><span>Δ</span><span> </span><span>V</span><span> </span><span>NT</span><span> </span><span>V</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tr</span><span> </span><span>vl1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Cons</span><span>
</span><span>            </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vl</span><span> </span><span>unwind</span><span> </span><span>rs</span><span> </span><span>rs1</span><span> </span><span>Δ</span><span> </span><span>iact</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unwind_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>trn</span><span> </span><span>tr'</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>tr</span><span> </span><span class="delimiter">=</span><span> </span><span>Cons</span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>trn</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Trans</span><span> </span><span>ss</span><span> </span><span>a</span><span> </span><span>ou</span><span> </span><span>s'</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>trn</span><span> </span><span class="delimiter">=</span><span> </span><span>Trans</span><span> </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?trn</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Trans s a ou s'"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ss</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ss = s"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>trn</span><span> </span><span>v</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tr</span><span> </span><span>validFrom_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Ta</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ T ?trn"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s = srcOf trn"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>vtrans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"validTrans ?trn"</span></span></span><span>
</span><span>            </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>v'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"validFrom s' tr'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>NT'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"never T tr'"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>v</span><span> </span><span>NT</span><span> </span><span>V</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tr</span><span> </span><span>validFrom_def</span><span> </span><span>trn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>rs'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reachNT s'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rs</span><span> </span><span>vtrans</span><span> </span><span>Ta</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>reachNT_PairI</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ?trn"</span></span></span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vl ≠ [] ∧ f ?trn = hd vl"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>V</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tr</span><span> </span><span>trn</span><span> </span><span>ss</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>vl'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"consume ?trn vl vl'"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ex_consume_φ</span><span> </span><span>ex_consume_NO</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>V'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"V tr' = vl'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>V</span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tr</span><span> </span><span>trn</span><span> </span><span>ss</span><span> </span><span>consume_def</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ?trn"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>2</span><span>-</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"match Δ s s1 vl1 a ou s' vl' ∨ ignore Δ s s1 vl1 a ou s' vl'"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?match ∨ ?ignore"</span></span></span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>react</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>reaction_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vtrans</span><span> </span><span>Ta</span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>safe</span><span>
</span><span>              </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?match</span><span>
</span><span>              </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>match_def</span><span> </span><span>Let_def</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>exE</span><span> </span><span>conjE</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a1</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'act</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ou1</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'out</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s1'</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'state</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>vl1'</span><span>
</span><span>                </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?trn1</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Trans s1 a1 ou1 s1'"</span></span></span><span>
</span><span>                </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>Δ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Δ s' vl' s1' vl1'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>vtrans1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"validTrans ?trn1"</span></span></span><span>
</span><span>                </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>c1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"consume ?trn1 vl1 vl1'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>γ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"γ ?trn = γ ?trn1"</span></span></span><span>
</span><span>                </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>g</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"γ ?trn ⟶ g ?trn = g ?trn1"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>rs1'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reach s1'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rs</span><span> </span><span>rs1</span><span> </span><span>vtrans</span><span> </span><span>vtrans1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>reach_PairI</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>tr1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>v1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"validFrom s1' tr1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>O</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"O tr1 = O tr'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>V</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"V tr1 = vl1'"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span class="delimiter">[</span><span>of</span><span> </span><span>tr'</span><span> </span><span>vl1'</span><span class="delimiter">]</span><span> </span><span>rs'</span><span> </span><span>rs1'</span><span> </span><span>Δ</span><span> </span><span>v'</span><span> </span><span>NT'</span><span> </span><span>V'</span><span> </span><span>c1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tr</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V (?trn1 # tr1) = vl1"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c1</span><span> </span><span>V</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>consume_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ?trn1"</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>                </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>                </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"Trans s1 a1 ou1 s1' # tr1"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vtrans1</span><span> </span><span>v1</span><span> </span><span>O</span><span> </span><span>γ</span><span> </span><span>g</span><span> </span><span>V</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tr</span><span> </span><span>trn</span><span> </span><span>ss</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?ignore</span><span>
</span><span>              </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ignore_def</span><span> </span><span>Let_def</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>exE</span><span> </span><span>conjE</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>γ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ γ ?trn"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Δ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Δ s' vl' s1 vl1"</span></span></span><span>
</span><span>                </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>tr1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>v1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"validFrom s1 tr1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>O</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"O tr1 = O tr'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>V</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"V tr1 = vl1"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span class="delimiter">[</span><span>of</span><span> </span><span>tr'</span><span> </span><span>vl1</span><span class="delimiter">]</span><span> </span><span>rs'</span><span> </span><span>rs1</span><span> </span><span>Δ</span><span> </span><span>v'</span><span> </span><span>NT'</span><span> </span><span>V'</span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tr</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>                </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>tr1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>v1</span><span> </span><span>O</span><span> </span><span>V</span><span> </span><span>γ</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tr</span><span> </span><span>trn</span><span> </span><span>ss</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>unwind_secure</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>init</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ vl vl1. B vl vl1 ⟹ Δ istate vl istate vl1"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>unwind</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"unwind Δ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>secure</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>unwind_trace</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>secure_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>reach.Istate</span><span> </span><span>reachNT.Istate</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* locale BD_Security *)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div><div id="Compositional_Reasoning">
<div class="head"><h1>Theory Compositional_Reasoning</h1>
<span class="command">theory</span> <span class="name">Compositional_Reasoning</span><br/>
<span class="keyword">imports</span> <a href="BD_Security.html"><span class="name">BD_Security</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Compositional Reasoning›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Compositional_Reasoning</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>BD_Security</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>BD_Security</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Preliminaries›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"disjAll Δs s vl s1 vl1 ≡ (∃Δ ∈ Δs. Δ s vl s1 vl1)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>disjAll_simps</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"disjAll {} ≡ λ_ _ _ _. False"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"disjAll (insert Δ Δs) ≡ λs vl s1 vl1. Δ s vl s1 vl1 ∨ disjAll Δs s vl s1 vl1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>disjAll_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>iaction_mono</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"iaction Δ s vl s1 vl1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ s vl s1 vl1. Δ s vl s1 vl1 ⟹ Δ' s vl s1 vl1"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"iaction Δ' s vl s1 vl1"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a1</span><span> </span><span>ou1</span><span> </span><span>s1'</span><span> </span><span>vl1'</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"step s1 a1 = (ou1, s1')"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ (Trans s1 a1 ou1 s1')"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"consume (Trans s1 a1 ou1 s1') vl1 vl1'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ γ (Trans s1 a1 ou1 s1')"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Δ s vl s1' vl1'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>iaction_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>iaction_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>a1</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>ou1</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>s1'</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>vl1'</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>match_mono</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"match Δ s s1 vl1 a ou s' vl'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ s vl s1 vl1. Δ s vl s1 vl1 ⟹ Δ' s vl s1 vl1"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"match Δ' s s1 vl1 a ou s' vl'"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a1</span><span> </span><span>ou1</span><span> </span><span>s1'</span><span> </span><span>vl1'</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Δ s' vl' s1' vl1'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"step s1 a1 = (ou1, s1')"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"consume (Trans s1 a1 ou1 s1') vl1 vl1'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"γ (Trans s a ou s') = γ (Trans s1 a1 ou1 s1')"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(γ (Trans s a ou s') ⟶ g (Trans s a ou s') = g (Trans s1 a1 ou1 s1'))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>match_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>match_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>a1</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>ou1</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>s1'</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>vl1'</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ignore_mono</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ignore Δ s s1 vl1 a ou s' vl'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ s vl s1 vl1. Δ s vl s1 vl1 ⟹ Δ' s vl s1 vl1"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ignore Δ' s s1 vl1 a ou s' vl'"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ignore_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reaction_mono</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reaction Δ s vl s1 vl1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ s vl s1 vl1. Δ s vl s1 vl1 ⟹ Δ' s vl s1 vl1"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reaction Δ' s vl s1 vl1"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>ou</span><span> </span><span>s'</span><span> </span><span>vl'</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"step s a = (ou, s')"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ T (Trans s a ou s')"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"consume (Trans s a ou s') vl vl'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"match Δ s s1 vl1 a ou s' vl' ∨ ignore Δ s s1 vl1 a ou s' vl'"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?m ∨ ?i"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>reaction_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"match Δ' s s1 vl1 a ou s' vl' ∨ ignore Δ' s s1 vl1 a ou s' vl'"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?m' ∨ ?i'"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?m</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>match_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span> </span><span>2</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?i</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ignore_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span> </span><span>2</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Decomposition into an arbitrary network of components›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Unwind not to itself, but to a disjunction of other relations: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>unwind_to</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"unwind_to Δ Δs ≡
 ∀ s vl s1 vl1.
   reachNT s ∧ reach s1 ∧ Δ s vl s1 vl1
   ⟶
   vl ≠ [] ∧ exit s (hd vl)
   ∨
   iaction (disjAll Δs) s vl s1 vl1
   ∨
   (vl ≠ [] ∨ vl1 = []) ∧ reaction (disjAll Δs) s vl s1 vl1"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unwind_toI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">?</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"⋀ s vl s1 vl1.
   ⟦reachNT s; reach s1; Δ s vl s1 vl1⟧
   ⟹
   vl ≠ [] ∧ exit s (hd vl)
   ∨
   iaction (disjAll Δs) s vl s1 vl1
   ∨
   (vl ≠ [] ∨ vl1 = []) ∧ reaction (disjAll Δs) s vl s1 vl1"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"unwind_to Δ Δs"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unwind_to_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Decomposition: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unwind_dec</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>ne</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ Δ. Δ ∈ Δs ⟹ next Δ ⊆ Δs ∧ unwind_to Δ (next Δ)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"unwind (disjAll Δs)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"unwind ?Δ"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> </span><span>s1</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'state</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>vl</span><span> </span><span>vl1</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'value list"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reachNT s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reach s1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Δ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?Δ s vl s1 vl1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Δ</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Δ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Δ ∈ Δs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Δ s vl s1 vl1"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>disjAll_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?Δs'</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"next Δ"</span></span></span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?Δ'</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"disjAll ?Δs'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(vl ≠ [] ∧ exit s (hd vl)) ∨
        iaction ?Δ' s vl s1 vl1 ∨
        ((vl ≠ [] ∨ vl1 = []) ∧ reaction ?Δ' s vl s1 vl1)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span> </span><span>Δ</span><span> </span><span>ne</span><span> </span><span>r</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unwind_to_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ s vl s1 vl1. ?Δ' s vl s1 vl1 ⟹ ?Δ s vl s1 vl1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ne</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Δ</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>disjAll_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">"(vl ≠ [] ∧ exit s (hd vl)) ∨
        iaction ?Δ s vl s1 vl1 ∨
        ((vl ≠ [] ∨ vl1 = []) ∧ reaction ?Δ s vl s1 vl1)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>iaction_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?Δ'</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="var">?Δ</span><span class="delimiter">]</span><span> </span><span>reaction_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?Δ'</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="var">?Δ</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>init_dec</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>Δ0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Δ0 ∈ Δs"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ vl vl1. B vl vl1 ⟹ Δ0 istate vl istate vl1"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ vl vl1. B vl vl1 ⟶ disjAll Δs istate vl istate vl1"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>disjAll_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>unwind_dec_secure</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>Δ0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Δ0 ∈ Δs"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ vl vl1. B vl vl1 ⟹ Δ0 istate vl istate vl1"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ne</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ Δ. Δ ∈ Δs ⟹ next Δ ⊆ Δs ∧ unwind_to Δ (next Δ)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>secure</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>init_dec</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Δ0</span><span> </span><span>i</span><span class="delimiter">]</span><span> </span><span>unwind_dec</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ne</span><span class="delimiter">]</span><span> </span><span>unwind_secure</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹A customization for linear modular reasoning›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* The customization assumes that each component unwinds only into itself,
its successor or an exit component.  *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>unwind_cont</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"unwind_cont Δ Δs ≡
 ∀ s vl s1 vl1.
   reachNT s ∧ reach s1 ∧ Δ s vl s1 vl1
   ⟶
   iaction (disjAll Δs) s vl s1 vl1
   ∨
   ((vl ≠ [] ∨ vl1 = []) ∧ reaction (disjAll Δs) s vl s1 vl1)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unwind_contI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">?</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"⋀ s vl s1 vl1.
   ⟦reachNT s; reach s1; Δ s vl s1 vl1⟧
   ⟹
   iaction (disjAll Δs) s vl s1 vl1
   ∨
   ((vl ≠ [] ∨ vl1 = []) ∧ reaction (disjAll Δs) s vl s1 vl1)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"unwind_cont Δ Δs"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unwind_cont_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>unwind_exit</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"unwind_exit Δe ≡
 ∀ s vl s1 vl1.
   reachNT s ∧ reach s1 ∧ Δe s vl s1 vl1
   ⟶
   vl ≠ [] ∧ exit s (hd vl)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unwind_exitI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">?</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"⋀ s vl s1 vl1.
   ⟦reachNT s; reach s1; Δe s vl s1 vl1⟧
   ⟹
   vl ≠ [] ∧ exit s (hd vl)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"unwind_exit Δe"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unwind_exit_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>allConsec</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list ⇒ ('a * 'a) set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"allConsec [] = {}"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"allConsec [a] = {}"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"allConsec (a # b # as) = insert (a,b) (allConsec (b#as))"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_allConsec</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Δ ∈ set Δs'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Δs = Δs' ## Δ1"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ Δ2. (Δ,Δ2) ∈ allConsec Δs"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>Δs'</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>Δs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>Δ3</span><span> </span><span>Δs'</span><span> </span><span>Δs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"Δ = Δ3"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>Δs'</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Δs = (Δ3 # Δs') ## Δ1›</span></span></span><span> </span><span>Nil</span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>Δ1</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>Δ4</span><span> </span><span>Δs''</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Δs = (Δ3 # Δs') ## Δ1›</span></span></span><span> </span><span>Cons</span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>Δ4</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Δ ∈ set Δs'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Δ2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(Δ, Δ2) ∈ allConsec (Δs' ## Δ1)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Δs = (Δ3 # Δs') ## Δ1›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>Δ2</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>Δs'</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>allConsec_set</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(Δ1,Δ2) ∈ allConsec Δs"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Δ1 ∈ set Δs ∧ Δ2 ∈ set Δs"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>Δs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>allConsec.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Liniar decomposition: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>unwind_decomp_secure</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>n</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Δs ≠ []"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ vl vl1. B vl vl1 ⟹ hd Δs istate vl istate vl1"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ Δ1 Δ2. (Δ1,Δ2) ∈ allConsec Δs ⟹ unwind_cont Δ1 {Δ1, Δ2, Δe}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"unwind_cont (last Δs) {last Δs, Δe}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>e</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"unwind_exit Δe"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>secure</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?Δ0</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"hd Δs"</span></span></span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?Δs</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"insert Δe (set Δs)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"next"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"next Δ1 =
    (if Δ1 = Δe then {}
     else if Δ1 = last Δs then {Δ1,Δe}
     else {Δ1,SOME Δ2. (Δ1,Δ2) ∈ allConsec Δs,Δe})"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>Δ1</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>unwind_dec_secure</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?Δ0 ∈ ?Δs"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>vl</span><span> </span><span>vl1</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B vl vl1"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?Δ0 istate vl istate vl1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>Δ</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Δ ∈ ?Δs"</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"next Δ ⊆ ?Δs ∧ unwind_to Δ (next Δ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Δ = Δe"</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>e</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>next_def</span><span> </span><span>unwind_exit_def</span><span> </span><span>unwind_to_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Δ = last Δs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Δ ≠ Δe"</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n</span><span> </span><span>l</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>next_def</span><span> </span><span>unwind_cont_def</span><span> </span><span>unwind_to_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Δ ∈ set Δs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Δ ≠ last Δs"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Δ ≠ Δe"</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Δ'</span><span> </span><span>Δs'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Δs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Δs = Δs' ## Δ'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Δ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Δ ∈ set Δs'"</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>append_Cons</span><span> </span><span>append_assoc</span><span> </span><span>in_set_conv_decomp</span><span> </span><span>last_snoc</span><span> </span><span>rev_exhaust</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ Δ2. (Δ, Δ2) ∈ allConsec Δs"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>set_allConsec</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Δ</span><span> </span><span>Δs</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(Δ, SOME Δ2. (Δ, Δ2) ∈ allConsec Δs) ∈ allConsec Δs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>lifting</span><span class="delimiter">)</span><span> </span><span>someI_ex</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>next_def</span><span> </span><span>unwind_cont_def</span><span> </span><span>unwind_to_def</span><span>
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>allConsec_set</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Instances›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>unwind_decomp3_secure</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ vl vl1. B vl vl1 ⟹ Δ1 istate vl istate vl1"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>c1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"unwind_cont Δ1 {Δ1, Δ2, Δe}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>c2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"unwind_cont Δ2 {Δ2, Δ3, Δe}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"unwind_cont Δ3 {Δ3, Δe}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>e</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"unwind_exit Δe"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>secure</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>unwind_decomp_secure</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"[Δ1, Δ2, Δ3]"</span></span></span><span> </span><span>Δe</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>unwind_decomp4_secure</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ vl vl1. B vl vl1 ⟹ Δ1 istate vl istate vl1"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>c1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"unwind_cont Δ1 {Δ1, Δ2, Δe}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>c2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"unwind_cont Δ2 {Δ2, Δ3, Δe}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>c3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"unwind_cont Δ3 {Δ3, Δ4, Δe}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"unwind_cont Δ4 {Δ4, Δe}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>e</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"unwind_exit Δe"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>secure</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>unwind_decomp_secure</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"[Δ1, Δ2, Δ3, Δ4]"</span></span></span><span> </span><span>Δe</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>unwind_decomp5_secure</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ vl vl1. B vl vl1 ⟹ Δ1 istate vl istate vl1"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>c1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"unwind_cont Δ1 {Δ1, Δ2, Δe}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>c2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"unwind_cont Δ2 {Δ2, Δ3, Δe}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>c3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"unwind_cont Δ3 {Δ3, Δ4, Δe}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>c4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"unwind_cont Δ4 {Δ4, Δ5, Δe}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"unwind_cont Δ5 {Δ5, Δe}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>e</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"unwind_exit Δe"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>secure</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>unwind_decomp_secure</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"[Δ1, Δ2, Δ3, Δ4, Δ5]"</span></span></span><span> </span><span>Δe</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* context BD_Security *)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div><div id="Bounded_Deducibility_Security">
<div class="head"><h1>Theory Bounded_Deducibility_Security</h1>
<span class="command">theory</span> <span class="name">Bounded_Deducibility_Security</span><br/>
<span class="keyword">imports</span> <a href="Compositional_Reasoning.html"><span class="name">Compositional_Reasoning</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Bounded_Deducibility_Security</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Compositional_Reasoning</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div>