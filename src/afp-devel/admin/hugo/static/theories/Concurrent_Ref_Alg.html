<div id="Refinement_Lattice">
<div class="head"><h1>Theory Refinement_Lattice</h1>
<span class="command">theory</span> <span class="name">Refinement_Lattice</span><br/>
<span class="keyword">imports</span> <a href="Lattice_Syntax.html"><span class="name">Lattice_Syntax</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Refinement Lattice \label{S:lattice}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Refinement_Lattice</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Main</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Lattice_Syntax"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  The underlying lattice of commands is complete and distributive.
  We follow the refinement calculus tradition so that $\nondet$ 
  is non-deterministic choice and $c \refsto d$ means $c$ is refined 
  (or implemented) by $d$.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>show_sorts</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Remove existing notation for quotient as it interferes with the rely quotient›</span></span></span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>Equiv_Relations.quotient</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"'/'/"</span></span></span><span> </span><span>90</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>refinement_lattice</span><span> </span><span class="delimiter">=</span><span> </span><span>complete_distrib_lattice</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The refinement lattice infimum corresponds to non-deterministic choice for commands.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>refine</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊑"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"c ⊑ d ≡ less_eq c d"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>refine_strict</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊏"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"c ⊏ d ≡ less c d"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Non-deterministic choice is monotonic in both arguments›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inf_mono_left</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ⊑ b ⟹ a ⊓ c ⊑ b ⊓ c"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inf_mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inf_mono_right</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c ⊑ d ⟹ a ⊓ c ⊑ a ⊓ d"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inf_mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Binary choice is a special case of choice over a set.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Inf2_inf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⨅{ f x | x. x ∈ {c, d}} = f c ⊓ f d"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{ f x | x. x ∈ {c, d}} = {f c, f d}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⨅{ f x | x. x ∈ {c, d}} = ⨅{f c, f d}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = f c ⊓ f d"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Helper lemma for choice over indexed set.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>INF_Inf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⨅x∈X. f x) = (⨅{f x |x. x ∈ X})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Setcompr_eq_image</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>INF_absorb_args</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⨅i j. (f::nat ⇒ 'c::complete_lattice) (i + j)) = (⨅k. f k)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_class.order.antisym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⨅k. f k) ≤ (⨅i j. f (i + j))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>complete_lattice_class.INF_lower</span><span> </span><span>complete_lattice_class.le_INF_iff</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀k. ∃i j. f (i + j) ≤ f k"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add.left_neutral</span><span> </span><span>order_class.eq_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀k. ∃i. (⨅j. f (i + j)) ≤ f k"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>UNIV_I</span><span> </span><span>complete_lattice_class.INF_lower2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⨅i j. f (i + j)) ≤ (⨅k. f k)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>complete_lattice_class.INF_mono</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>nested_Collect</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{f y |y. y ∈ {g x |x. x ∈ X}} = {f (g x) |x. x ∈ X}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A transition lemma for INF distributivity properties, going from Inf to INF,
  qualified version followed by a straightforward one.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Inf_distrib_INF_qual</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ 'a"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>qual</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P {d x |x. x ∈ X}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>f_Inf_distrib</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀c D. P D ⟹ f c (⨅ D) = ⨅ {f c d | d . d ∈ D }"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f c (⨅x∈X. d x) = (⨅x∈X. f c (d x))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f c (⨅x∈X. d x) = f c (⨅{d x |x. x ∈ X})"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>INF_Inf</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (⨅{f c dx |dx. dx ∈ {d x | x. x ∈ X}})"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>qual</span><span> </span><span>f_Inf_distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (⨅{f c (d x) |x. x ∈ X})"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>nested_Collect</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (⨅x∈X. f c (d x))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>INF_Inf</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Inf_distrib_INF</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ 'a"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>f_Inf_distrib</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀c D. f c (⨅ D) = ⨅ {f c d | d . d ∈ D }"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f c (⨅x∈X. d x) = (⨅x∈X. f c (d x))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Setcompr_eq_image</span><span> </span><span>f_Inf_distrib</span><span> </span><span>image_comp</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>refine_trans</span><span> </span><span class="delimiter">=</span><span> </span><span>order.trans</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹More transitivity rules to make calculational reasoning smoother›</span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>ord_eq_le_trans</span><span class="delimiter">[</span><span>trans</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>ord_le_eq_trans</span><span class="delimiter">[</span><span>trans</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>dual_order.trans</span><span class="delimiter">[</span><span>trans</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>dist_over_sup</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::refinement_lattice ⇒ 'a) ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"dist_over_sup F ≡ (∀ X . F (⨆ X) = (⨆x∈X. F (x)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>dist_over_inf</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::refinement_lattice ⇒ 'a) ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"dist_over_inf F ≡ (∀ X . F (⨅ X) = (⨅x∈X. F (x)))"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Sequential">
<div class="head"><h1>Theory Sequential</h1>
<span class="command">theory</span> <span class="name">Sequential</span><br/>
<span class="keyword">imports</span> <a href="Refinement_Lattice.html"><span class="name">Refinement_Lattice</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sequential Operator \label{S:sequential}›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Sequential</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Refinement_Lattice</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Basic sequential›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  The sequential composition operator ``$;$'' is associative and 
  has identity nil but it is not commutative. 
  It has $\bot$ as a left annihilator.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>seq</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>seq</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::refinement_lattice ⇒ 'a ⇒ 'a"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">";"</span></span></span><span> </span><span>90</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>seq_bot</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⊥ ; c = ⊥"</span></span></span><span>   </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* 35 *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>nil</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>nil</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::refinement_lattice"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"nil"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  The monoid axioms imply ``;'' is associative and has identity nil.
  Abort is a left annihilator of sequential composition.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>sequential</span><span> </span><span class="delimiter">=</span><span> </span><span>seq</span><span> </span><span class="delimiter">+</span><span> </span><span>nil</span><span> </span><span class="delimiter">+</span><span> </span><span>seq</span><span class="delimiter">:</span><span> </span><span>monoid</span><span> </span><span>seq</span><span> </span><span>nil</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>seq.assoc</span><span> </span><span class="delimiter">[</span><span>algebra_simps</span><span class="delimiter">,</span><span> </span><span>field_simps</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>seq_assoc</span><span> </span><span class="delimiter">=</span><span> </span><span>seq.assoc</span><span>             </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* 30 *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>seq_nil_right</span><span> </span><span class="delimiter">=</span><span> </span><span>seq.right_neutral</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* 31 *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>seq_nil_left</span><span> </span><span class="delimiter">=</span><span> </span><span>seq.left_neutral</span><span>   </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* 32 *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Distributed sequential›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Sequential composition distributes across arbitrary infima 
  from the right but only across the binary (finite) infima from the left
  and hence it is monotonic in both arguments. 
  We consider left distribution first.
  Note that Section \ref{S:conjunctive-sequential} considers the
  case in which the weak-seq-inf-distrib axiom is strengthened to
  an equality.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>seq_distrib_left</span><span> </span><span class="delimiter">=</span><span> </span><span>sequential</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>weak_seq_inf_distrib</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(c::'a::refinement_lattice);(d<span class="hidden">⇩</span><sub>0</sub> ⊓ d<span class="hidden">⇩</span><sub>1</sub>) ⊑ (c;d<span class="hidden">⇩</span><sub>0</sub> ⊓ c;d<span class="hidden">⇩</span><sub>1</sub>)"</span></span></span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* 33 *)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Left distribution implies sequential composition is monotonic is its right argument›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>seq_mono_right</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇩</span><sub>0</sub> ⊑ c<span class="hidden">⇩</span><sub>1</sub> ⟹ d ; c<span class="hidden">⇩</span><sub>0</sub> ⊑ d ; c<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inf.absorb_iff2</span><span> </span><span>le_inf_iff</span><span> </span><span>weak_seq_inf_distrib</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Nec? *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>seq_bot_right</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c;⊥ ⊑ c"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>bot.extremum</span><span> </span><span>seq.right_neutral</span><span> </span><span>seq_mono_right</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>seq_distrib_right</span><span> </span><span class="delimiter">=</span><span> </span><span>sequential</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>Inf_seq_distrib</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(⨅ C) ; d = (⨅(c::'a::refinement_lattice)∈C. c ; d)"</span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* 34 *)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>INF_seq_distrib</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⨅c∈C. f c) ; d = (⨅c∈C. f c ; d)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Inf_seq_distrib</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>image_comp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inf_seq_distrib</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(c<span class="hidden">⇩</span><sub>0</sub> ⊓ c<span class="hidden">⇩</span><sub>1</sub>) ; d = (c<span class="hidden">⇩</span><sub>0</sub> ; d ⊓ c<span class="hidden">⇩</span><sub>1</sub> ; d)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(c<span class="hidden">⇩</span><sub>0</sub> ⊓ c<span class="hidden">⇩</span><sub>1</sub>) ; d = (⨅ {c<span class="hidden">⇩</span><sub>0</sub>, c<span class="hidden">⇩</span><sub>1</sub>}) ; d"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (⨅c∈{c<span class="hidden">⇩</span><sub>0</sub>, c<span class="hidden">⇩</span><sub>1</sub>}. c ; d)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fact</span><span> </span><span>Inf_seq_distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (c<span class="hidden">⇩</span><sub>0</sub> ; d) ⊓ (c<span class="hidden">⇩</span><sub>1</sub> ; d)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>seq_mono_left</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇩</span><sub>0</sub> ⊑ c<span class="hidden">⇩</span><sub>1</sub> ⟹ c<span class="hidden">⇩</span><sub>0</sub> ; d ⊑ c<span class="hidden">⇩</span><sub>1</sub> ; d"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inf.absorb_iff2</span><span> </span><span>inf_seq_distrib</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>seq_top</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⊤ ; c = ⊤"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊤ ; c = (⨅a∈{}. a ; c)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Inf_empty</span><span> </span><span>Inf_seq_distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>seq_power</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ nat ⇒ 'a"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"<span class="hidden">⇧</span><sup>;</sup>^"</span></span></span><span> </span><span>80</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>seq_power_0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a <span class="hidden">⇧</span><sup>;</sup>^ 0 = nil"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>seq_power_Suc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a <span class="hidden">⇧</span><sup>;</sup>^ Suc n = a ; (a <span class="hidden">⇧</span><sup>;</sup>^ n)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span class="delimiter">(</span><span>latex</span><span> </span><span class="keyword2"><span class="keyword">output</span></span><span class="delimiter">)</span><span>
</span><span>  </span><span>seq_power</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(_<span class="hidden">⇗</span><sup>_<span class="hidden">⇖</span></sup>)"</span></span></span><span> </span><span class="delimiter">[</span><span>1000</span><span class="delimiter">]</span><span> </span><span>1000</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span class="delimiter">(</span><span>HTML</span><span> </span><span class="keyword2"><span class="keyword">output</span></span><span class="delimiter">)</span><span>
</span><span>  </span><span>seq_power</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(_<span class="hidden">⇗</span><sup>_<span class="hidden">⇖</span></sup>)"</span></span></span><span> </span><span class="delimiter">[</span><span>1000</span><span class="delimiter">]</span><span> </span><span>1000</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>seq_power_front</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a <span class="hidden">⇧</span><sup>;</sup>^ n) ; a = a ; (a <span class="hidden">⇧</span><sup>;</sup>^ n)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>n</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>seq_assoc</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>seq_power_split_less</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; j ⟹ (b <span class="hidden">⇧</span><sup>;</sup>^ j) = (b <span class="hidden">⇧</span><sup>;</sup>^ i) ; (b <span class="hidden">⇧</span><sup>;</sup>^ (j - i))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>j</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>i</span><span> </span><span>type</span><span class="delimiter">:</span><span> </span><span>nat</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>j</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b <span class="hidden">⇧</span><sup>;</sup>^ Suc j = b ; (b <span class="hidden">⇧</span><sup>;</sup>^ i) ; (b <span class="hidden">⇧</span><sup>;</sup>^ (j - i))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc.hyps</span><span> </span><span>Suc.prems</span><span> </span><span>less_Suc_eq</span><span> </span><span>seq_assoc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (b <span class="hidden">⇧</span><sup>;</sup>^ i) ; b ; (b <span class="hidden">⇧</span><sup>;</sup>^ (j - i))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>seq_power_front</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (b <span class="hidden">⇧</span><sup>;</sup>^ i) ; (b <span class="hidden">⇧</span><sup>;</sup>^ (Suc j - i))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc.prems</span><span> </span><span>Suc_diff_le</span><span> </span><span>seq_assoc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>seq_distrib</span><span> </span><span class="delimiter">=</span><span> </span><span>seq_distrib_right</span><span> </span><span class="delimiter">+</span><span> </span><span>seq_distrib_left</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>seq_mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇩</span><sub>1</sub> ⊑ d<span class="hidden">⇩</span><sub>1</sub> ⟹ c<span class="hidden">⇩</span><sub>2</sub> ⊑ d<span class="hidden">⇩</span><sub>2</sub> ⟹ c<span class="hidden">⇩</span><sub>1</sub>;c<span class="hidden">⇩</span><sub>2</sub> ⊑ d<span class="hidden">⇩</span><sub>1</sub>;d<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq_mono_left</span><span> </span><span>seq_mono_right</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inf.orderE</span><span> </span><span>le_infI2</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Parallel">
<div class="head"><h1>Theory Parallel</h1>
<span class="command">theory</span> <span class="name">Parallel</span><br/>
<span class="keyword">imports</span> <a href="Refinement_Lattice.html"><span class="name">Refinement_Lattice</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Parallel Operator \label{S:parallel}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Parallel</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Refinement_Lattice</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Basic parallel operator›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  The parallel operator is associative, commutative and has unit skip
  and has as an annihilator the lattice bottom. 
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>skip</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>skip</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::refinement_lattice"</span></span></span><span>  </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"skip"</span></span></span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>par</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>par</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::refinement_lattice ⇒ 'a ⇒ 'a"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∥"</span></span></span><span> </span><span>75</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>abort_par</span><span class="delimiter">:</span><span>   </span><span class="string"><span class="delete"><span class="delete">"⊥ ∥ c = ⊥"</span></span></span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* ++ *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>parallel</span><span> </span><span class="delimiter">=</span><span> </span><span>par</span><span> </span><span class="delimiter">+</span><span> </span><span>skip</span><span> </span><span class="delimiter">+</span><span> </span><span>par</span><span class="delimiter">:</span><span> </span><span>comm_monoid</span><span> </span><span>par</span><span> </span><span>skip</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>algebra_simps</span><span class="delimiter">,</span><span> </span><span>field_simps</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>par.assoc</span><span>
</span><span>  </span><span>par.commute</span><span>
</span><span>  </span><span>par.left_commute</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>par_assoc</span><span> </span><span class="delimiter">=</span><span> </span><span>par.assoc</span><span>            </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* 36 *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>par_commute</span><span> </span><span class="delimiter">=</span><span> </span><span>par.commute</span><span>        </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* 37 *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>par_skip</span><span> </span><span class="delimiter">=</span><span> </span><span>par.right_neutral</span><span>     </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* 38 *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>par_skip_left</span><span> </span><span class="delimiter">=</span><span> </span><span>par.left_neutral</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* 38 + 37 *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Distributed parallel›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  The parallel operator distributes across arbitrary non-empty infima.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>par_distrib</span><span> </span><span class="delimiter">=</span><span> </span><span>parallel</span><span> </span><span class="delimiter">+</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>par_Inf_distrib</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"D ≠ {} ⟹ c ∥ (⨅ D) = (⨅d∈D. c ∥ d)"</span></span></span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* 39+ *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Inf_par_distrib</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"D ≠ {} ⟹ (⨅ D) ∥ c = (⨅d∈D. d ∥ c)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>par_Inf_distrib</span><span> </span><span>par_commute</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>par_INF_distrib</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X ≠ {} ⟹ c ∥ (⨅x∈X. d x) = (⨅x∈X. c ∥ d x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>par_Inf_distrib</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>image_comp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>INF_par_distrib</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X ≠ {} ⟹ (⨅x∈X. d x) ∥ c = (⨅x∈X. d x ∥ c)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>par_INF_distrib</span><span> </span><span>par_commute</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>INF_cong</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>INF_INF_par_distrib</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"X ≠ {} ⟹ Y ≠ {} ⟹ (⨅x∈X. c x) ∥ (⨅y∈Y. d y) = (⨅x∈X. ⨅y∈Y. c x ∥ d y)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>nonempty_X</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X ≠ {}"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>nonempty_Y</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Y ≠ {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⨅x∈X. c x) ∥ (⨅y∈Y. d y) = (⨅x∈X. c x ∥ (⨅y∈Y. d y))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>INF_par_distrib</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>nonempty_X</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = (⨅x∈X. ⨅y∈Y. c x ∥ d y)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>par_INF_distrib</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>nonempty_Y</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>calculation</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inf_par_distrib</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(c<span class="hidden">⇩</span><sub>0</sub> ⊓ c<span class="hidden">⇩</span><sub>1</sub>) ∥ d = (c<span class="hidden">⇩</span><sub>0</sub> ∥ d) ⊓ (c<span class="hidden">⇩</span><sub>1</sub> ∥ d)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(c<span class="hidden">⇩</span><sub>0</sub> ⊓ c<span class="hidden">⇩</span><sub>1</sub>) ∥ d = (⨅ {c<span class="hidden">⇩</span><sub>0</sub>, c<span class="hidden">⇩</span><sub>1</sub>}) ∥ d"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (⨅c ∈ {c<span class="hidden">⇩</span><sub>0</sub>, c<span class="hidden">⇩</span><sub>1</sub>}. c ∥ d)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Inf_par_distrib</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>insert_not_empty</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = c<span class="hidden">⇩</span><sub>0</sub> ∥ d ⊓ c<span class="hidden">⇩</span><sub>1</sub> ∥ d"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inf_par_distrib2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d ∥ (c<span class="hidden">⇩</span><sub>0</sub> ⊓ c<span class="hidden">⇩</span><sub>1</sub>) = (d ∥ c<span class="hidden">⇩</span><sub>0</sub>) ⊓ (d ∥ c<span class="hidden">⇩</span><sub>1</sub>)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inf_par_distrib</span><span> </span><span>par_commute</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inf_par_product</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a ⊓ b) ∥ (c ⊓ d) = (a ∥ c) ⊓ (a ∥ d) ⊓ (b ∥ c) ⊓ (b ∥ d)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inf_commute</span><span> </span><span>inf_par_distrib</span><span> </span><span>inf_par_distrib2</span><span> </span><span>inf_sup_aci</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>par_mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇩</span><sub>1</sub> ⊑ d<span class="hidden">⇩</span><sub>1</sub> ⟹ c<span class="hidden">⇩</span><sub>2</sub> ⊑ d<span class="hidden">⇩</span><sub>2</sub> ⟹ c<span class="hidden">⇩</span><sub>1</sub> ∥ c<span class="hidden">⇩</span><sub>2</sub> ⊑ d<span class="hidden">⇩</span><sub>1</sub> ∥ d<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inf.orderE</span><span> </span><span>le_inf_iff</span><span> </span><span>order_refl</span><span> </span><span>inf_par_distrib</span><span> </span><span>par_commute</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Conjunction">
<div class="head"><h1>Theory Conjunction</h1>
<span class="command">theory</span> <span class="name">Conjunction</span><br/>
<span class="keyword">imports</span> <a href="Refinement_Lattice.html"><span class="name">Refinement_Lattice</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Weak Conjunction Operator \label{S:conjunction}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Conjunction</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Refinement_Lattice</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  The weak conjunction operator $\doublecap$ is similar to
  least upper bound ($\sqcup$) 
  but is abort strict,
  i.e.\ the lattice bottom is an annihilator: $c \doublecap \bot = \bot$. 
  It has identity the command chaos that allows any non-aborting behaviour.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>chaos</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>chaos</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::refinement_lattice"</span></span></span><span>    </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"chaos"</span></span></span><span class="delimiter">)</span><span> 
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
The weak conjunction operator uses a special symbol: double intersection.
To see this symbol in your Isabelle PIDE, install DejaVu Sans fonts
(available freely online at http://dejavu-fonts.org/wiki/Download)
and add the following line to ~/.isabelle/Isabelle2015/etc/symbols
(create the file if it does not exist):

\&lt;iinter&gt;               code: 0x0022d2  group: operator  font: DejaVuSans

Note: if the symbol is rendering correctly, you do not need to do anything.
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>conj</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>conj</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::refinement_lattice ⇒ 'a ⇒ 'a"</span></span></span><span>   </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"\&lt;iinter&gt;"</span></span></span><span> </span><span>80</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>conj_bot_right</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c \&lt;iinter&gt; ⊥ = ⊥"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Conjunction forms an idempotent, commutative monoid
  (i.e. a semi-lattice), with identity chaos.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>conjunction</span><span> </span><span class="delimiter">=</span><span> </span><span>conj</span><span> </span><span class="delimiter">+</span><span> </span><span>chaos</span><span> </span><span class="delimiter">+</span><span> </span><span>conj</span><span class="delimiter">:</span><span> </span><span>semilattice_neutr</span><span> </span><span>conj</span><span> </span><span>chaos</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>algebra_simps</span><span class="delimiter">,</span><span> </span><span>field_simps</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>conj.assoc</span><span>
</span><span>  </span><span>conj.commute</span><span>
</span><span>  </span><span>conj.left_commute</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>conj_assoc</span><span> </span><span class="delimiter">=</span><span> </span><span>conj.assoc</span><span>             </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* 42 *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>conj_commute</span><span> </span><span class="delimiter">=</span><span> </span><span>conj.commute</span><span>         </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* 43 *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>conj_idem</span><span> </span><span class="delimiter">=</span><span> </span><span>conj.idem</span><span>               </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* 44 *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>conj_chaos</span><span> </span><span class="delimiter">=</span><span> </span><span>conj.right_neutral</span><span>     </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* 45 *)</span></span></span></span></span><span>            
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>conj_chaos_left</span><span> </span><span class="delimiter">=</span><span> </span><span>conj.left_neutral</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* 45 + 43 *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conj_bot_left</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⊥ \&lt;iinter&gt; c = ⊥"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conj_bot_right</span><span> </span><span>local.conj_commute</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conj_not_bot</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a \&lt;iinter&gt; b ≠ ⊥ ⟹ a ≠ ⊥ ∧ b ≠ ⊥"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conj_bot_right</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conj_distrib1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c \&lt;iinter&gt; (d<span class="hidden">⇩</span><sub>0</sub> \&lt;iinter&gt; d<span class="hidden">⇩</span><sub>1</sub>) = (c \&lt;iinter&gt; d<span class="hidden">⇩</span><sub>0</sub>) \&lt;iinter&gt; (c \&lt;iinter&gt; d<span class="hidden">⇩</span><sub>1</sub>)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>conj_assoc</span><span> </span><span>conj_commute</span><span> </span><span>conj_idem</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Distributed weak conjunction›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  The weak conjunction operator distributes across arbitrary non-empty infima.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>conj_distrib</span><span> </span><span class="delimiter">=</span><span> </span><span>conjunction</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>Inf_conj_distrib</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"D ≠ {} ⟹ (⨅ D) \&lt;iinter&gt; c = (⨅d∈D. d \&lt;iinter&gt; c)"</span></span></span><span>   </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* 48 *)</span></span></span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* and sup_conj_distrib: "(c<span class="hidden">⇩</span><sub>0</sub> ⊔ c<span class="hidden">⇩</span><sub>1</sub>) \&lt;iinter&gt; d = (c<span class="hidden">⇩</span><sub>0</sub> \&lt;iinter&gt; d) ⊔ (c<span class="hidden">⇩</span><sub>1</sub> \&lt;iinter&gt; d)"  *)</span></span></span></span></span><span>       </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* 49+ *)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conj_Inf_distrib</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"D ≠ {} ⟹ c \&lt;iinter&gt; (⨅ D) = (⨅d∈D. c \&lt;iinter&gt; d)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Inf_conj_distrib</span><span> </span><span>conj_commute</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inf_conj_distrib</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(c<span class="hidden">⇩</span><sub>0</sub> ⊓ c<span class="hidden">⇩</span><sub>1</sub>) \&lt;iinter&gt; d = (c<span class="hidden">⇩</span><sub>0</sub> \&lt;iinter&gt; d) ⊓ (c<span class="hidden">⇩</span><sub>1</sub> \&lt;iinter&gt; d)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(c<span class="hidden">⇩</span><sub>0</sub> ⊓ c<span class="hidden">⇩</span><sub>1</sub>) \&lt;iinter&gt; d = (⨅ {c<span class="hidden">⇩</span><sub>0</sub>, c<span class="hidden">⇩</span><sub>1</sub>}) \&lt;iinter&gt; d"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (⨅c ∈ {c<span class="hidden">⇩</span><sub>0</sub>, c<span class="hidden">⇩</span><sub>1</sub>}. c \&lt;iinter&gt; d)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Inf_conj_distrib</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (c<span class="hidden">⇩</span><sub>0</sub> \&lt;iinter&gt; d) ⊓ (c<span class="hidden">⇩</span><sub>1</sub> \&lt;iinter&gt; d)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inf_conj_product</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a ⊓ b) \&lt;iinter&gt; (c ⊓ d) = (a \&lt;iinter&gt; c) ⊓ (a \&lt;iinter&gt; d) ⊓ (b \&lt;iinter&gt; c) ⊓ (b \&lt;iinter&gt; d)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inf_conj_distrib</span><span> </span><span>conj_commute</span><span> </span><span>inf_assoc</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conj_mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇩</span><sub>0</sub> ⊑ d<span class="hidden">⇩</span><sub>0</sub> ⟹ c<span class="hidden">⇩</span><sub>1</sub> ⊑ d<span class="hidden">⇩</span><sub>1</sub> ⟹ c<span class="hidden">⇩</span><sub>0</sub> \&lt;iinter&gt; c<span class="hidden">⇩</span><sub>1</sub> ⊑ d<span class="hidden">⇩</span><sub>0</sub> \&lt;iinter&gt; d<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inf.absorb_iff1</span><span> </span><span>inf_conj_product</span><span> </span><span>inf_right_idem</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conj_mono_left</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇩</span><sub>0</sub> ⊑ c<span class="hidden">⇩</span><sub>1</sub> ⟹ c<span class="hidden">⇩</span><sub>0</sub> \&lt;iinter&gt; d ⊑ c<span class="hidden">⇩</span><sub>1</sub> \&lt;iinter&gt; d"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>conj_mono</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conj_mono_right</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇩</span><sub>0</sub> ⊑ c<span class="hidden">⇩</span><sub>1</sub> ⟹ d \&lt;iinter&gt; c<span class="hidden">⇩</span><sub>0</sub> ⊑ d \&lt;iinter&gt; c<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>conj_mono</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conj_refine</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇩</span><sub>0</sub> ⊑ d ⟹ c<span class="hidden">⇩</span><sub>1</sub> ⊑ d ⟹ c<span class="hidden">⇩</span><sub>0</sub> \&lt;iinter&gt; c<span class="hidden">⇩</span><sub>1</sub> ⊑ d"</span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* law 'refine-conjunction' *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>conj_idem</span><span> </span><span>conj_mono</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>refine_to_conj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c ⊑ d<span class="hidden">⇩</span><sub>0</sub> ⟹ c ⊑ d<span class="hidden">⇩</span><sub>1</sub> ⟹ c ⊑ d<span class="hidden">⇩</span><sub>0</sub> \&lt;iinter&gt; d<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>conj_idem</span><span> </span><span>conj_mono</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conjoin_non_aborting</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chaos ⊑ c ⟹ d ⊑ d \&lt;iinter&gt; c"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>conj_mono</span><span> </span><span>order.refl</span><span> </span><span>conj_chaos</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conjunction_sup</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c \&lt;iinter&gt; d ⊑ c ⊔ d"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>conj_refine</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conjunction_sup_nonaborting</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chaos ⊑ c"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chaos ⊑ d"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c \&lt;iinter&gt; d = c ⊔ d"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>antisym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ⊔ d ⊑ c \&lt;iinter&gt; d"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>conjoin_non_aborting</span><span> </span><span>local.conj_commute</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c \&lt;iinter&gt; d ⊑ c ⊔ d"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>conjunction_sup</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conjoin_top</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chaos ⊑ c ⟹ c \&lt;iinter&gt; ⊤ = ⊤"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>conjunction_sup_nonaborting</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="CRA">
<div class="head"><h1>Theory CRA</h1>
<span class="command">theory</span> <span class="name">CRA</span><br/>
<span class="keyword">imports</span> <a href="Sequential.html"><span class="name">Sequential</span></a> <a href="Conjunction.html"><span class="name">Conjunction</span></a> <a href="Parallel.html"><span class="name">Parallel</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Concurrent Refinement Algebra \label{S:CRA}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  This theory brings together the three main operators:
  sequential composition,
  parallel composition and
  conjunction,
  as well as the iteration operators. 
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>CRA</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> 
</span><span>  </span><span>Sequential</span><span>
</span><span>  </span><span>Conjunction</span><span>
</span><span>  </span><span>Parallel</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Locale sequential-parallel brings together the sequential and parallel
  operators and relates their identities.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>sequential_parallel</span><span> </span><span class="delimiter">=</span><span> </span><span>seq_distrib</span><span> </span><span class="delimiter">+</span><span> </span><span>par_distrib</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>nil_par_nil</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nil ∥ nil ⊑ nil"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>skip_nil</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"skip ⊑ nil"</span></span></span><span>           </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* 41 *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>skip_skip</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"skip ⊑ skip;skip"</span></span></span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* 40 *)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nil_absorb</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nil ∥ nil = nil"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nil_par_nil</span><span> </span><span>skip_nil</span><span> </span><span>par_skip</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inf.absorb_iff2</span><span> </span><span>inf.orderE</span><span> </span><span>inf_par_distrib2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>skip_absorb</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"skip;skip = skip"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>antisym</span><span> </span><span>seq_mono_right</span><span> </span><span>seq_nil_right</span><span> </span><span>skip_skip</span><span> </span><span>skip_nil</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Locale conjunction-parallel brings together the weak conjunction and
  parallel operators and relates their identities.
  It also introduces the interchange axiom for conjunction and parallel.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>conjunction_parallel</span><span> </span><span class="delimiter">=</span><span> </span><span>conj_distrib</span><span> </span><span class="delimiter">+</span><span> </span><span>par_distrib</span><span> </span><span class="delimiter">+</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>chaos_par_top</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⊤ ⊑ chaos ∥ ⊤"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>chaos_par_chaos</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chaos ⊑ chaos ∥ chaos"</span></span></span><span>     </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* 47 *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>parallel_interchange</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(c<span class="hidden">⇩</span><sub>0</sub> ∥ c<span class="hidden">⇩</span><sub>1</sub>) \&lt;iinter&gt; (d<span class="hidden">⇩</span><sub>0</sub> ∥ d<span class="hidden">⇩</span><sub>1</sub>) ⊑ (c<span class="hidden">⇩</span><sub>0</sub> \&lt;iinter&gt; d<span class="hidden">⇩</span><sub>0</sub>) ∥ (c<span class="hidden">⇩</span><sub>1</sub> \&lt;iinter&gt; d<span class="hidden">⇩</span><sub>1</sub>)"</span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* 50 *)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>chaos_skip</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chaos ⊑ skip"</span></span></span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* 46 *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chaos = (chaos ∥ skip) \&lt;iinter&gt; (skip ∥ chaos)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ⊑ (chaos \&lt;iinter&gt; skip) ∥ (skip \&lt;iinter&gt; chaos)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>parallel_interchange</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>chaos_par_chaos_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chaos = chaos ∥ chaos"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>antisym</span><span> </span><span>chaos_par_chaos</span><span> </span><span>chaos_skip</span><span> </span><span>order_refl</span><span> </span><span>par_mono</span><span> </span><span>par_skip</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nonabort_par_top</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chaos ⊑ c ⟹ c ∥ ⊤ = ⊤"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>chaos_par_top</span><span> </span><span>par_mono</span><span> </span><span>top.extremum_uniqueI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>skip_conj_top</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"skip \&lt;iinter&gt; ⊤ = ⊤"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>chaos_skip</span><span> </span><span>conjoin_top</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conj_distrib2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c ⊑ c ∥ c ⟹ c \&lt;iinter&gt; (d<span class="hidden">⇩</span><sub>0</sub> ∥ d<span class="hidden">⇩</span><sub>1</sub>) ⊑ (c \&lt;iinter&gt; d<span class="hidden">⇩</span><sub>0</sub>) ∥ (c \&lt;iinter&gt; d<span class="hidden">⇩</span><sub>1</sub>)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ⊑ c ∥ c"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c \&lt;iinter&gt; (d<span class="hidden">⇩</span><sub>0</sub> ∥ d<span class="hidden">⇩</span><sub>1</sub>) ⊑ (c ∥ c) \&lt;iinter&gt; (d<span class="hidden">⇩</span><sub>0</sub> ∥ d<span class="hidden">⇩</span><sub>1</sub>)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>conj_mono</span><span> </span><span>order.refl</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>parallel_interchange</span><span> </span><span>refine_trans</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Locale conjunction-sequential brings together the weak conjunction and
  sequential operators.
  It also introduces the interchange axiom for conjunction and sequential.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>conjunction_sequential</span><span> </span><span class="delimiter">=</span><span> </span><span>conj_distrib</span><span> </span><span class="delimiter">+</span><span> </span><span>seq_distrib</span><span> </span><span class="delimiter">+</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* iteration + *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>chaos_seq_chaos</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chaos ⊑ chaos;chaos"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>sequential_interchange</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(c<span class="hidden">⇩</span><sub>0</sub>;c<span class="hidden">⇩</span><sub>1</sub>) \&lt;iinter&gt; (d<span class="hidden">⇩</span><sub>0</sub>;d<span class="hidden">⇩</span><sub>1</sub>) ⊑ (c<span class="hidden">⇩</span><sub>0</sub> \&lt;iinter&gt; d<span class="hidden">⇩</span><sub>0</sub>);(c<span class="hidden">⇩</span><sub>1</sub> \&lt;iinter&gt; d<span class="hidden">⇩</span><sub>1</sub>)"</span></span></span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* 51 *)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>chaos_nil</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chaos ⊑ nil"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>conj_chaos</span><span> </span><span>local.conj_commute</span><span> </span><span>seq_nil_left</span><span> </span><span>seq_nil_right</span><span>
</span><span>       </span><span>sequential_interchange</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>chaos_seq_absorb</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chaos = chaos;chaos"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>antisym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chaos ⊑ chaos;chaos"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>chaos_seq_chaos</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chaos;chaos ⊑ chaos"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>chaos_nil</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq_mono_left</span><span> </span><span>seq_nil_left</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>seq_bot_conj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c;⊥ \&lt;iinter&gt; d ⊑ (c \&lt;iinter&gt; d);⊥"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>conj_bot_left</span><span> </span><span>seq_nil_right</span><span> </span><span>sequential_interchange</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conj_seq_bot_right</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c;⊥ \&lt;iinter&gt; c =  c;⊥"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>antisym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>lr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c;⊥ \&lt;iinter&gt; c ⊑  c;⊥"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>seq_bot_conj</span><span> </span><span>conj_idem</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>rl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c;⊥ ⊑ c;⊥ \&lt;iinter&gt; c"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>conj_idem</span><span> </span><span>conj_mono_right</span><span> </span><span>seq_bot_right</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conj_distrib3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c ⊑ c;c ⟹ c \&lt;iinter&gt; (d<span class="hidden">⇩</span><sub>0</sub> ; d<span class="hidden">⇩</span><sub>1</sub>) ⊑ (c \&lt;iinter&gt; d<span class="hidden">⇩</span><sub>0</sub>);(c \&lt;iinter&gt; d<span class="hidden">⇩</span><sub>1</sub>)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ⊑ c;c"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c \&lt;iinter&gt; (d<span class="hidden">⇩</span><sub>0</sub>;d<span class="hidden">⇩</span><sub>1</sub>) ⊑ (c;c) \&lt;iinter&gt; (d<span class="hidden">⇩</span><sub>0</sub>;d<span class="hidden">⇩</span><sub>1</sub>)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>conj_mono</span><span> </span><span>order.refl</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>sequential_interchange</span><span> </span><span>refine_trans</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
lemma iter_conj_distrib:
  assumes nil: "c ⊑ nil"
    and repeat: "c ⊑ c ; c"
  shows "c \&lt;iinter&gt; d<span class="hidden">⇧</span><sup>ω</sup> ⊑ (c \&lt;iinter&gt; d)<span class="hidden">⇧</span><sup>ω</sup>"
proof (unfold iter_def)
  def F ≡ "(λ x. c \&lt;iinter&gt; x)"
  def G ≡ "(λ x. nil ⊓ d;x)"
  def H ≡ "(λ x. nil ⊓ ((c \&lt;iinter&gt; d);x))"

  have FG: "F ∘ G = (λ x. c \&lt;iinter&gt; (nil ⊓ d;x))"  by (metis comp_def F_def G_def) 
  have HF: "H ∘ F = (λ x. (nil ⊓ (c \&lt;iinter&gt; d);(c \&lt;iinter&gt; x)))" by (metis comp_def H_def F_def) 

  have "F (lfp G) ⊑ lfp H"
  proof (rule fusion_lfp_leq)
    show "mono H" by (simp add: H_def iter_step_mono)
  next
    show "dist_over_sup F" by (simp add: F_def conj_Sup_distrib)
  next
    fix x
    have "c \&lt;iinter&gt; (nil ⊓ d;x) = (c \&lt;iinter&gt; nil) ⊓ (c \&lt;iinter&gt; d;x)" by (metis inf_conj_distrib conj_commute)
    also have "... ⊑ nil ⊓ (c \&lt;iinter&gt; d;x)" by (metis conjunction_sup inf_mono_left le_iff_sup nil)
    also have "... ⊑ nil ⊓ (c;c \&lt;iinter&gt; d;x)" by (metis inf_conj_distrib inf.absorb_iff2 inf_mono_right repeat)
    also have "... ⊑ nil ⊓ (c \&lt;iinter&gt; d);(c \&lt;iinter&gt; x)" by (meson inf_mono_right sequential_interchange)
    finally show "(F ∘ G) x ⊑ (H ∘ F) x" by (simp add: FG HF)
  qed

  then show "c \&lt;iinter&gt; lfp(λx. nil ⊓ d ; x) ⊑ lfp (λx. nil ⊓ (c \&lt;iinter&gt; d) ; x)" using F_def G_def H_def by simp
qed

lemma iter_conj_distrib1: "c<span class="hidden">⇧</span><sup>ω</sup> \&lt;iinter&gt; d<span class="hidden">⇧</span><sup>ω</sup> ⊑ (c<span class="hidden">⇧</span><sup>ω</sup> \&lt;iinter&gt; d)<span class="hidden">⇧</span><sup>ω</sup>"
  by (simp add: iter0 iter_conj_distrib)

lemma iter_conj_distrib2: "c<span class="hidden">⇧</span><sup>ω</sup> \&lt;iinter&gt; d<span class="hidden">⇧</span><sup>ω</sup> ⊑ (c \&lt;iinter&gt; d)<span class="hidden">⇧</span><sup>ω</sup>"
proof -
  have a: "c<span class="hidden">⇧</span><sup>ω</sup> ⊑ c" by (metis iter1)
  have b: "c<span class="hidden">⇧</span><sup>ω</sup> \&lt;iinter&gt; d<span class="hidden">⇧</span><sup>ω</sup> ⊑ (c<span class="hidden">⇧</span><sup>ω</sup> \&lt;iinter&gt; d)<span class="hidden">⇧</span><sup>ω</sup>" by (metis iter_conj_distrib1)
  have "c<span class="hidden">⇧</span><sup>ω</sup> \&lt;iinter&gt; d ⊑ c \&lt;iinter&gt; d" by (metis a conj_mono order.refl) 
  thus ?thesis using a b by (metis refine_trans iter_mono) 
qed
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Locale cra brings together sequential, parallel and weak conjunction.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>cra</span><span> </span><span class="delimiter">=</span><span> </span><span>sequential_parallel</span><span> </span><span class="delimiter">+</span><span> </span><span>conjunction_parallel</span><span> </span><span class="delimiter">+</span><span> </span><span>conjunction_sequential</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Galois_Connections">
<div class="head"><h1>Theory Galois_Connections</h1>
<span class="command">theory</span> <span class="name">Galois_Connections</span><br/>
<span class="keyword">imports</span> <a href="Refinement_Lattice.html"><span class="name">Refinement_Lattice</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Galois Connections and Fusion Theorems \label{S:galois}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Galois_Connections</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Refinement_Lattice</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  The concept of Galois connections is introduced here to prove the fixed-point fusion lemmas. 
  The definition of Galois connections used is quite simple but encodes a lot of 
  information.
  The material in this section is largely based on the work of the Eindhoven
  Mathematics of Program Construction Group \cite{fixedpointcalculus1995}
  and the reader is referred to their work for a full explanation of this section.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Lower Galois connections›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* auxiliary lemma to prefer 2-element sets rather than disjunction *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Collect_2set</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"{F x |x. x = a ∨ x = b} = {F a, F b}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>lower_galois_connections</span><span>  
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>l_adjoint</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::refinement_lattice ⇒ 'a) ⇒ ('a ⇒ 'a)"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_<span class="hidden">⇧</span><sup>♭</sup>"</span></span></span><span> </span><span class="delimiter">[</span><span>201</span><span class="delimiter">]</span><span> </span><span>200</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(F<span class="hidden">⇧</span><sup>♭</sup>) x ≡ ⨅{y. x ⊑ F y}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dist_inf_mono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>distF</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dist_over_inf F"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mono F"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'a</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'a</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊑ y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F x = F (x ⊓ y)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>le_iff_inf</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = F x ⊓ F y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>distF</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F (⨅{x, y}) = ⨅{F x, F y}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"{x, y}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F (x ⊓ y) = F x ⊓ F y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F x ⊑ F y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>le_iff_inf</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>l_cancellation</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dist_over_inf F ⟹ x ⊑ (F ∘ F<span class="hidden">⇧</span><sup>♭</sup>) x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dist_over_inf F"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>Y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Y = {F y | y. x ⊑ F y}"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>X</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X = {x}"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀ y ∈ Y. (∃ x ∈ X. x ⊑ y))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>X_def</span><span> </span><span>Y_def</span><span> </span><span>CollectD</span><span> </span><span>singletonI</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⨅ X ⊑ ⨅ Y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Inf_mono</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊑ ⨅{F y | y. x ⊑ F y}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>X_def</span><span> </span><span>Y_def</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊑ F (⨅{y. x ⊑ F y})"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>dist</span><span> </span><span>le_INF_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>comp_def</span><span> </span><span>l_adjoint_def</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>l_galois_connection</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dist_over_inf F ⟹ ((F<span class="hidden">⇧</span><sup>♭</sup>) x ⊑ y) ⟷ (x ⊑ F y)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊑ F y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⨅{y. x ⊑ F y} ⊑ y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Inf_lower</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(F<span class="hidden">⇧</span><sup>♭</sup>) x ⊑ y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>l_adjoint_def</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dist_over_inf F"</span></span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>monoF</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mono F"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>dist_inf_mono</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(F<span class="hidden">⇧</span><sup>♭</sup>) x ⊑ y"</span></span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"F ((F<span class="hidden">⇧</span><sup>♭</sup>) x) ⊑ F y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>monoD</span><span> </span><span>monoF</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊑ F ((F<span class="hidden">⇧</span><sup>♭</sup>) x)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dist</span><span> </span><span>l_cancellation</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊑ F y"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>v_simple_fusion</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mono G ⟹ ∀x. ((F ∘ G) x ⊑ (H ∘ F) x) ⟹ F (gfp G) ⊑ gfp H"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>comp_eq_dest_lhs</span><span> </span><span>gfp_unfold</span><span> </span><span>gfp_upperbound</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Greatest fixpoint fusion theorems›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Combining lower Galois connections and greatest fixed points allows 
  elegant proofs of the weak fusion lemmas. 
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>fusion_gfp_geq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>monoH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mono H"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>distribF</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dist_over_inf F"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>comp_geq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x. ((H ∘ F) x ⊑ (F ∘ G) x)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gfp H ⊑ F (gfp G)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(gfp H) ⊑ (F ∘ F<span class="hidden">⇧</span><sup>♭</sup>) (gfp H)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>distribF</span><span> </span><span>l_cancellation</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H (gfp H) ⊑ H ((F ∘ F<span class="hidden">⇧</span><sup>♭</sup>) (gfp H))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>monoD</span><span> </span><span>monoH</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H (gfp H) ⊑ F ((G ∘ F<span class="hidden">⇧</span><sup>♭</sup>) (gfp H))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp_geq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>comp_def</span><span> </span><span>refine_trans</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(F<span class="hidden">⇧</span><sup>♭</sup>) (H (gfp H)) ⊑ (G ∘ F<span class="hidden">⇧</span><sup>♭</sup>) (gfp H)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>distribF</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">)</span><span> </span><span>l_galois_connection</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(F<span class="hidden">⇧</span><sup>♭</sup>) (gfp H) ⊑ (gfp G)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>comp_apply</span><span> </span><span>gfp_unfold</span><span> </span><span>gfp_upperbound</span><span> </span><span>monoH</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gfp H ⊑ F (gfp G)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>distribF</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">)</span><span> </span><span>l_galois_connection</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>fusion_gfp_eq</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>monoH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mono H"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>monoG</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mono G"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>distF</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dist_over_inf F"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fgh_comp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x. ((F ∘ G) x = (H ∘ F) x)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F (gfp G) = gfp H"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>antisym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F (gfp G) ⊑ (gfp H)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fgh_comp</span><span> </span><span>le_less</span><span> </span><span>v_simple_fusion</span><span> </span><span>monoG</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x. ((H ∘ F) x ⊑ (F ∘ G) x)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fgh_comp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gfp H ⊑ F (gfp G)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>monoH</span><span> </span><span>distF</span><span> </span><span>fusion_gfp_geq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Upper Galois connections›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>upper_galois_connections</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>u_adjoint</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::refinement_lattice ⇒ 'a) ⇒ ('a ⇒ 'a)"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_<span class="hidden">⇧</span><sup>#</sup>"</span></span></span><span> </span><span class="delimiter">[</span><span>201</span><span class="delimiter">]</span><span> </span><span>200</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(F<span class="hidden">⇧</span><sup>#</sup>) x ≡ ⨆{y. F y ⊑ x}"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dist_sup_mono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>distF</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dist_over_sup F"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mono F"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'a</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'a</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊑ y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F y = F (x ⊔ y)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>le_iff_sup</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = F x ⊔ F y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>distF</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F (⨆{x, y}) = ⨆{F x, F y}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"{x, y}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F (x ⊔ y) = F x ⊔ F y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F x ⊑ F y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>le_iff_sup</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>u_cancellation</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dist_over_sup F ⟹ (F ∘ F<span class="hidden">⇧</span><sup>#</sup>) x ⊑ x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dist_over_sup F"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>Y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Y = {F y | y. F y ⊑ x}"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>X</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X = {x}"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀ y ∈ Y. (∃ x ∈ X. y ⊑ x))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>X_def</span><span> </span><span>Y_def</span><span> </span><span>CollectD</span><span> </span><span>singletonI</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⨆ Y ⊑ ⨆ X"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Sup_mono</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⨆{F y | y. F y ⊑ x} ⊑ x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>X_def</span><span> </span><span>Y_def</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F (⨆{y. F y ⊑ x}) ⊑ x"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SUP_le_iff</span><span> </span><span>dist</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>comp_def</span><span> </span><span>u_adjoint_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>u_galois_connection</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dist_over_sup F ⟹ (F x ⊑ y) ⟷ (x ⊑ (F<span class="hidden">⇧</span><sup>#</sup>) y)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dist_over_sup F"</span></span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>monoF</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mono F"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>dist_sup_mono</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊑ (F<span class="hidden">⇧</span><sup>#</sup>) y"</span></span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"F x ⊑ F ((F<span class="hidden">⇧</span><sup>#</sup>) y)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>monoD</span><span> </span><span>monoF</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F ((F<span class="hidden">⇧</span><sup>#</sup>) y) ⊑ y"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dist</span><span> </span><span>u_cancellation</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F x ⊑ y"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F x ⊑ y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊑ ⨆{x. F x ⊑ y}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Sup_upper</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊑ (F<span class="hidden">⇧</span><sup>#</sup>) y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>u_adjoint_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>u_simple_fusion</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mono H ⟹ ∀x. ((F ∘ G) x ⊑ (G ∘ H) x) ⟹ lfp F ⊑ G (lfp H)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>comp_def</span><span> </span><span>lfp_lowerbound</span><span> </span><span>lfp_unfold</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Least fixpoint fusion theorems›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Combining upper Galois connections and least fixed points allows elegant proofs 
  of the strong fusion lemmas.
›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>fusion_lfp_leq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>monoH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mono H"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>distribF</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dist_over_sup F"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>comp_leq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x. ((F ∘ G) x ⊑ (H ∘ F) x)"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F (lfp G) ⊑ (lfp H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"((F ∘ F<span class="hidden">⇧</span><sup>#</sup>) (lfp H)) ⊑ lfp H"</span></span></span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>distribF</span><span> </span><span>u_cancellation</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H ((F ∘ F<span class="hidden">⇧</span><sup>#</sup>) (lfp H)) ⊑ H (lfp H)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>monoD</span><span> </span><span>monoH</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F ((G ∘ F<span class="hidden">⇧</span><sup>#</sup>) (lfp H)) ⊑ H (lfp H)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp_leq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>comp_def</span><span> </span><span>refine_trans</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(G ∘ F<span class="hidden">⇧</span><sup>#</sup>) (lfp H) ⊑ (F<span class="hidden">⇧</span><sup>#</sup>) (H (lfp H))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>distribF</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">)</span><span> </span><span>u_galois_connection</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(lfp G) ⊑ (F<span class="hidden">⇧</span><sup>#</sup>) (lfp H)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>comp_def</span><span> </span><span>def_lfp_unfold</span><span> </span><span>lfp_lowerbound</span><span> </span><span>monoH</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F (lfp G) ⊑ (lfp H)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>distribF</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">)</span><span> </span><span>u_galois_connection</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>fusion_lfp_eq</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>monoH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mono H"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>monoG</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mono G"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>distF</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dist_over_sup F"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fgh_comp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x. ((F ∘ G) x = (H ∘ F) x)"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F (lfp G) = (lfp H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>antisym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lfp H ⊑ F (lfp G)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>monoG</span><span> </span><span>fgh_comp</span><span> </span><span>eq_iff</span><span> </span><span>upper_galois_connections.u_simple_fusion</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x. (F ∘ G) x ⊑ (H ∘ F) x"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fgh_comp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F (lfp G) ⊑ (lfp H)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>monoH</span><span> </span><span>distF</span><span> </span><span>fusion_lfp_leq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span></pre>
</div>
</div><div id="Iteration">
<div class="head"><h1>Theory Iteration</h1>
<span class="command">theory</span> <span class="name">Iteration</span><br/>
<span class="keyword">imports</span> <a href="Galois_Connections.html"><span class="name">Galois_Connections</span></a> <a href="CRA.html"><span class="name">CRA</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Iteration \label{S:iteration}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Iteration</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Galois_Connections</span><span>
</span><span>  </span><span>CRA</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Possibly infinite iteration›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Iteration of finite or infinite steps can be defined using a least fixed point.
›</span></span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* hide_fact (open) Random_Sequence.iter_def *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>finite_or_infinite_iteration</span><span> </span><span class="delimiter">=</span><span> </span><span>seq_distrib</span><span> </span><span class="delimiter">+</span><span> </span><span>upper_galois_connections</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>iter</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_<span class="hidden">⇧</span><sup>ω</sup>"</span></span></span><span> </span><span class="delimiter">[</span><span>103</span><span class="delimiter">]</span><span> </span><span>102</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* this can be entered as \sup\circ *)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>ω</sup> ≡ lfp (λ x. nil ⊓ c;x)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>iter_step_mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mono (λ x. nil ⊓ c;x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>inf_mono</span><span> </span><span>order_refl</span><span> </span><span>seq_mono_right</span><span> </span><span>mono_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  This fixed point definition leads to the two core iteration lemmas:
  folding and induction.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>iter_unfold</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>ω</sup> = nil ⊓ c;c<span class="hidden">⇧</span><sup>ω</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>iter_def</span><span> </span><span>iter_step_mono</span><span> </span><span>lfp_unfold</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>iter_induct_nil</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nil ⊓ c;x ⊑ x ⟹ c<span class="hidden">⇧</span><sup>ω</sup> ⊑ x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>iter_def</span><span> </span><span>lfp_lowerbound</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>iter0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>ω</sup> ⊑ nil"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>iter_unfold</span><span> </span><span>sup.orderI</span><span> </span><span>sup_inf_absorb</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>iter1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>ω</sup> ⊑ c"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inf_le2</span><span> </span><span>iter0</span><span> </span><span>iter_unfold</span><span> </span><span>order.trans</span><span> </span><span>seq_mono_right</span><span> </span><span>seq_nil_right</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>iter2</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>ω</sup>;c<span class="hidden">⇧</span><sup>ω</sup> = c<span class="hidden">⇧</span><sup>ω</sup>"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>antisym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>ω</sup>;c<span class="hidden">⇧</span><sup>ω</sup> ⊑ c<span class="hidden">⇧</span><sup>ω</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>iter0</span><span> </span><span>seq_mono_right</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nil ⊓ c;c<span class="hidden">⇧</span><sup>ω</sup>;c<span class="hidden">⇧</span><sup>ω</sup> ⊑ nil ⊓ c;c<span class="hidden">⇧</span><sup>ω</sup> ⊓ c;c<span class="hidden">⇧</span><sup>ω</sup>;c<span class="hidden">⇧</span><sup>ω</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inf_greatest</span><span> </span><span>inf_le2</span><span> </span><span>inf_mono</span><span> </span><span>iter0</span><span> </span><span>order_refl</span><span> </span><span>seq_distrib_left.seq_mono_right</span><span> </span><span>seq_distrib_left_axioms</span><span> </span><span>seq_nil_right</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"… = c<span class="hidden">⇧</span><sup>ω</sup> ⊓ c;c<span class="hidden">⇧</span><sup>ω</sup>;c<span class="hidden">⇧</span><sup>ω</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>iter_unfold</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"… = (nil ⊓ c;c<span class="hidden">⇧</span><sup>ω</sup>);c<span class="hidden">⇧</span><sup>ω</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inf_seq_distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>ω</sup> ⊑ c<span class="hidden">⇧</span><sup>ω</sup>;c<span class="hidden">⇧</span><sup>ω</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>iter_induct_nil</span><span> </span><span>iter_unfold</span><span> </span><span>seq_assoc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>iter_mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c ⊑ d ⟹ c<span class="hidden">⇧</span><sup>ω</sup> ⊑ d<span class="hidden">⇧</span><sup>ω</sup>"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ⊑ d"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nil ⊓ c;d<span class="hidden">⇧</span><sup>ω</sup> ⊑ d;d<span class="hidden">⇧</span><sup>ω</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inf.absorb_iff2</span><span> </span><span>inf_left_commute</span><span> </span><span>inf_seq_distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nil ⊓ c;d<span class="hidden">⇧</span><sup>ω</sup> ⊑ d<span class="hidden">⇧</span><sup>ω</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inf.bounded_iff</span><span> </span><span>inf_sup_ord</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>iter_unfold</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>iter_induct_nil</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>iter_abort</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⊥ = nil<span class="hidden">⇧</span><sup>ω</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>antisym</span><span> </span><span>iter_induct_nil</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nil_iter</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⊤<span class="hidden">⇧</span><sup>ω</sup> = nil"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>inf_top.right_neutral</span><span> </span><span>iter_unfold</span><span> </span><span>seq_top</span><span class="delimiter">)</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
lemma iter_conj_distrib:
  assumes nil: "c ⊑ nil"
    and repeat: "c ⊑ c ; c"
  shows "c \&lt;iinter&gt; d<span class="hidden">⇧</span><sup>ω</sup> ⊑ (c \&lt;iinter&gt; d)<span class="hidden">⇧</span><sup>ω</sup>"
proof (unfold iter_def)
  def F ≡ "(λ x. c \&lt;iinter&gt; x)"
  def G ≡ "(λ x. nil ⊓ d;x)"
  def H ≡ "(λ x. nil ⊓ ((c \&lt;iinter&gt; d);x))"

  have FG: "F ∘ G = (λ x. c \&lt;iinter&gt; (nil ⊓ d;x))"  by (metis comp_def F_def G_def) 
  have HF: "H ∘ F = (λ x. (nil ⊓ (c \&lt;iinter&gt; d);(c \&lt;iinter&gt; x)))" by (metis comp_def H_def F_def) 

  have "F (lfp G) ⊑ lfp H"
  proof (rule fusion_lfp_leq)
    show "mono H" by (simp add: H_def iter_step_mono)
  next
    show "dist_over_sup F" by (simp add: F_def conj_Sup_distrib)
  next
    fix x
    have "c \&lt;iinter&gt; (nil ⊓ d;x) = (c \&lt;iinter&gt; nil) ⊓ (c \&lt;iinter&gt; d;x)" by (metis inf_conj_distrib conj_commute)
    also have "... ⊑ nil ⊓ (c \&lt;iinter&gt; d;x)" by (metis conjunction_sup inf_mono_left le_iff_sup nil)
    also have "... ⊑ nil ⊓ (c;c \&lt;iinter&gt; d;x)" by (metis inf_conj_distrib inf.absorb_iff2 inf_mono_right repeat)
    also have "... ⊑ nil ⊓ (c \&lt;iinter&gt; d);(c \&lt;iinter&gt; x)" by (meson inf_mono_right sequential_interchange)
    finally show "(F ∘ G) x ⊑ (H ∘ F) x" by (simp add: FG HF)
  qed

  then show "c \&lt;iinter&gt; lfp(λx. nil ⊓ d ; x) ⊑ lfp (λx. nil ⊓ (c \&lt;iinter&gt; d) ; x)" using F_def G_def H_def by simp
qed

lemma iter_conj_distrib1: "c<span class="hidden">⇧</span><sup>ω</sup> \&lt;iinter&gt; d<span class="hidden">⇧</span><sup>ω</sup> ⊑ (c<span class="hidden">⇧</span><sup>ω</sup> \&lt;iinter&gt; d)<span class="hidden">⇧</span><sup>ω</sup>"
  by (simp add: iter0 iter_conj_distrib)

lemma iter_conj_distrib2: "c<span class="hidden">⇧</span><sup>ω</sup> \&lt;iinter&gt; d<span class="hidden">⇧</span><sup>ω</sup> ⊑ (c \&lt;iinter&gt; d)<span class="hidden">⇧</span><sup>ω</sup>"
proof -
  have a: "c<span class="hidden">⇧</span><sup>ω</sup> ⊑ c" by (metis iter1)
  have b: "c<span class="hidden">⇧</span><sup>ω</sup> \&lt;iinter&gt; d<span class="hidden">⇧</span><sup>ω</sup> ⊑ (c<span class="hidden">⇧</span><sup>ω</sup> \&lt;iinter&gt; d)<span class="hidden">⇧</span><sup>ω</sup>" by (metis iter_conj_distrib1)
  have "c<span class="hidden">⇧</span><sup>ω</sup> \&lt;iinter&gt; d ⊑ c \&lt;iinter&gt; d" by (metis a conj_mono order.refl) 
  thus ?thesis using a b by (metis refine_trans iter_mono) 
qed
*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Finite iteration›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Iteration of a finite number of steps (Kleene star) is defined
  using the greatest fixed point.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>finite_iteration</span><span> </span><span class="delimiter">=</span><span> </span><span>seq_distrib</span><span> </span><span class="delimiter">+</span><span> </span><span>lower_galois_connections</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>fiter</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span> </span><span class="delimiter">[</span><span>101</span><span class="delimiter">]</span><span> </span><span>100</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>⋆</sup> ≡ gfp (λ x. nil ⊓ c;x)"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fin_iter_step_mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mono (λ x. nil ⊓ c;x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>inf_mono</span><span> </span><span>order_refl</span><span> </span><span>seq_mono_right</span><span> </span><span>mono_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  This definition leads to the two core iteration lemmas:
  folding and induction.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fiter_unfold</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>⋆</sup> = nil ⊓ c;c<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fiter_def</span><span> </span><span>gfp_unfold</span><span> </span><span>fin_iter_step_mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fiter_induct_nil</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊑ nil ⊓ c;x ⟹ x ⊑ c<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fiter_def</span><span> </span><span>gfp_upperbound</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fiter0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>⋆</sup> ⊑ nil"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fiter_unfold</span><span> </span><span>inf.cobounded1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fiter1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>⋆</sup> ⊑ c"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fiter0</span><span> </span><span>fiter_unfold</span><span> </span><span>inf_le2</span><span> </span><span>order.trans</span><span> </span><span>seq_mono_right</span><span> </span><span>seq_nil_right</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fiter_induct_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>⋆</sup>;d = gfp (λ x. c;x ⊓ d)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>F</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F = (λ x. x;d)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>G</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"G = (λ x. nil ⊓ c;x)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>H</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H = (λ x. c;x ⊓ d)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>FG</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"F ∘ G = (λ x. c;x;d ⊓ d)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>F_def</span><span> </span><span>G_def</span><span> </span><span>comp_def</span><span> </span><span>inf_commute</span><span> </span><span>inf_seq_distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>HF</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"H ∘ F = (λ x. c;x;d ⊓ d)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>comp_def</span><span> </span><span>seq_assoc</span><span> </span><span>H_def</span><span> </span><span>F_def</span><span class="delimiter">)</span><span> 
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>adjoint</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dist_over_inf F"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Inf_seq_distrib</span><span> </span><span>F_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>monoH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mono H"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>H_def</span><span> </span><span>inf_mono_left</span><span> </span><span>monoI</span><span> </span><span>seq_distrib_left.seq_mono_right</span><span> </span><span>seq_distrib_left_axioms</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>monoG</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mono G"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>G_def</span><span> </span><span>inf_mono_right</span><span> </span><span>mono_def</span><span> </span><span>seq_mono_right</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ x. ((F ∘ G) x = (H ∘ F) x)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FG</span><span> </span><span>HF</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F (gfp G) = gfp H"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>adjoint</span><span> </span><span>monoG</span><span> </span><span>monoH</span><span> </span><span>fusion_gfp_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(gfp (λ x. nil ⊓ c;x));d = gfp (λ x. c;x ⊓ d)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>F_def</span><span> </span><span>G_def</span><span> </span><span>H_def</span><span> </span><span>inf_commute</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fiter_def</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>fiter_induct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊑ d ⊓ c;x ⟹ x ⊑ c<span class="hidden">⇧</span><sup>⋆</sup>;d"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊑ d ⊓ c;x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊑ c;x ⊓ d"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inf_commute</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊑ gfp (λ x. c;x ⊓ d)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gfp_upperbound</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>fiter_induct_eq</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fiter2</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>⋆</sup>;c<span class="hidden">⇧</span><sup>⋆</sup> = c<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>⋆</sup>;c<span class="hidden">⇧</span><sup>⋆</sup> ⊑ c<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fiter0</span><span> </span><span>seq_mono_right</span><span> </span><span>seq_nil_right</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>rl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>⋆</sup> ⊑ c<span class="hidden">⇧</span><sup>⋆</sup>;c<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fiter_induct</span><span> </span><span>fiter_unfold</span><span> </span><span>inf.right_idem</span><span> </span><span>order_refl</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>antisym</span><span> </span><span>lr</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fiter3</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(c<span class="hidden">⇧</span><sup>⋆</sup>)<span class="hidden">⇧</span><sup>⋆</sup> = c<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>dual_order.refl</span><span> </span><span>fiter0</span><span> </span><span>fiter1</span><span> </span><span>fiter2</span><span> </span><span>fiter_induct</span><span> </span><span>inf.commute</span><span> </span><span>inf_absorb1</span><span> </span><span>seq_nil_right</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fiter_mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c ⊑ d ⟹ c<span class="hidden">⇧</span><sup>⋆</sup> ⊑ d<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ⊑ d"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>⋆</sup> ⊑ nil ⊓ d;c<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fiter0</span><span> </span><span>fiter1</span><span> </span><span>fiter2</span><span> </span><span>inf.bounded_iff</span><span> </span><span>refine_trans</span><span> </span><span>seq_mono_left</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>seq_nil_right</span><span> </span><span>fiter_induct</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Infinite iteration›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Iteration of infinite number of steps can be defined
  using a least fixed point.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>infinite_iteration</span><span> </span><span class="delimiter">=</span><span> </span><span>seq_distrib</span><span> </span><span class="delimiter">+</span><span> </span><span>lower_galois_connections</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>infiter</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a  ⇒ 'a"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_<span class="hidden">⇧</span><sup>∞</sup>"</span></span></span><span> </span><span class="delimiter">[</span><span>105</span><span class="delimiter">]</span><span> </span><span>106</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>∞</sup> ≡ lfp (λ x. c;x)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>infiter_step_mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mono (λ x. c;x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>inf_mono</span><span> </span><span>order_refl</span><span> </span><span>seq_mono_right</span><span> </span><span>mono_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  This definition leads to the two core iteration lemmas:
  folding and induction.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>infiter_unfold</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>∞</sup> = c;c<span class="hidden">⇧</span><sup>∞</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>infiter_def</span><span> </span><span>infiter_step_mono</span><span> </span><span>lfp_unfold</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>infiter_induct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c;x ⊑ x ⟹ c<span class="hidden">⇧</span><sup>∞</sup> ⊑ x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>infiter_def</span><span> </span><span>lfp_lowerbound</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>infiter_unfold_any</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>∞</sup> = (c <span class="hidden">⇧</span><sup>;</sup>^ i) ; c<span class="hidden">⇧</span><sup>∞</sup>"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>infiter_unfold</span><span> </span><span>seq_assoc</span><span> </span><span>seq_power_Suc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>infiter_annil</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>∞</sup>;x = c<span class="hidden">⇧</span><sup>∞</sup>"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀a. (⊥::'a) ⊑ a"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>eq_iff</span><span> </span><span>inf.cobounded2</span><span> </span><span>infiter_induct</span><span> </span><span>infiter_unfold</span><span> </span><span>inf_sup_ord</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>seq_assoc</span><span> </span><span>seq_bot</span><span> </span><span>weak_seq_inf_distrib</span><span> </span><span>seq_nil_right</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Combined iteration›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  The three different iteration operators can be combined to show that 
  finite iteration refines finite-or-infinite iteration.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>iteration</span><span> </span><span class="delimiter">=</span><span> </span><span>finite_or_infinite_iteration</span><span> </span><span class="delimiter">+</span><span> </span><span>finite_iteration</span><span> </span><span class="delimiter">+</span><span> 
</span><span>                   </span><span>infinite_iteration</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>refine_iter</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>ω</sup> ⊑ c<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>seq_nil_right</span><span> </span><span>order.refl</span><span> </span><span>iter_unfold</span><span> </span><span>fiter_induct</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>iter_absorption</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(c<span class="hidden">⇧</span><sup>ω</sup>)<span class="hidden">⇧</span><sup>⋆</sup> = c<span class="hidden">⇧</span><sup>ω</sup>"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>antisym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(c<span class="hidden">⇧</span><sup>ω</sup>)<span class="hidden">⇧</span><sup>⋆</sup> ⊑ c<span class="hidden">⇧</span><sup>ω</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fiter1</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>ω</sup> ⊑ (c<span class="hidden">⇧</span><sup>ω</sup>)<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fiter1</span><span> </span><span>fiter_induct</span><span> </span><span>inf_left_idem</span><span> </span><span>iter2</span><span> </span><span>iter_unfold</span><span> </span><span>seq_nil_right</span><span> </span><span>sup.cobounded2</span><span> </span><span>sup.orderE</span><span> </span><span>sup_commute</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>infiter_inf_top</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>∞</sup> = c<span class="hidden">⇧</span><sup>ω</sup> ; ⊤"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>∞</sup> ⊑ c<span class="hidden">⇧</span><sup>ω</sup> ; ⊤"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ; (c<span class="hidden">⇧</span><sup>ω</sup> ; ⊤) = nil ; ⊤ ⊓ c ; c<span class="hidden">⇧</span><sup>ω</sup> ; ⊤"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>semigroup.assoc</span><span> </span><span>seq.semigroup_axioms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>eq_refl</span><span> </span><span>finite_or_infinite_iteration.iter_unfold</span><span> 
</span><span>         </span><span>finite_or_infinite_iteration_axioms</span><span> </span><span>infiter_induct</span><span> 
</span><span>         </span><span>seq_distrib_right.inf_seq_distrib</span><span> </span><span>seq_distrib_right_axioms</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>rl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>ω</sup> ; ⊤ ⊑ c<span class="hidden">⇧</span><sup>∞</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inf_le2</span><span> </span><span>infiter_annil</span><span> </span><span>infiter_unfold</span><span> </span><span>iter_induct_nil</span><span> </span><span>seq_mono_left</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>antisym_conv</span><span> </span><span>lr</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>infiter_fiter_top</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>∞</sup> ⊑ c<span class="hidden">⇧</span><sup>⋆</sup> ; ⊤"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>eq_iff</span><span> </span><span>fiter_induct</span><span> </span><span>inf_top_left</span><span> </span><span>infiter_unfold</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inf_ref_infiter</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>ω</sup> ⊑ c<span class="hidden">⇧</span><sup>∞</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>infiter_unfold</span><span> </span><span>iter_induct_nil</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span></pre>
</div>
</div><div id="Conjunctive_Sequential">
<div class="head"><h1>Theory Conjunctive_Sequential</h1>
<span class="command">theory</span> <span class="name">Conjunctive_Sequential</span><br/>
<span class="keyword">imports</span> <a href="Sequential.html"><span class="name">Sequential</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sequential composition for conjunctive models \label{S:conjunctive-sequential}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Conjunctive_Sequential</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Sequential</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Sequential left-distributivity is only supported by conjunctive models
  but does not apply in general. The relational model is one such example.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>seq_finite_conjunctive</span><span> </span><span class="delimiter">=</span><span> </span><span>seq_distrib_right</span><span> </span><span class="delimiter">+</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>seq_inf_distrib</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c;(d<span class="hidden">⇩</span><sub>0</sub> ⊓ d<span class="hidden">⇩</span><sub>1</sub>) = c;d<span class="hidden">⇩</span><sub>0</sub> ⊓ c;d<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>seq_distrib_left</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>seq_distrib_left.intro</span><span> </span><span>seq_distrib_left_axioms.intro</span><span> 
</span><span>        </span><span>seq_inf_distrib</span><span> </span><span>sequential_axioms</span><span class="delimiter">)</span><span> 
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>seq_infinite_conjunctive</span><span> </span><span class="delimiter">=</span><span> </span><span>seq_distrib_right</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>seq_Inf_distrib</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"D ≠ {} ⟹ c ; ⨅D = (⨅d∈D. c ; d)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>seq_distrib</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>unfold_locales</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>c</span><span class="delimiter">::</span><span class="tfree">'a</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>d<span class="hidden">⇩</span><sub>0</sub></span><span class="delimiter">::</span><span class="tfree">'a</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>d<span class="hidden">⇩</span><sub>1</sub></span><span class="delimiter">::</span><span class="tfree">'a</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{d<span class="hidden">⇩</span><sub>0</sub>, d<span class="hidden">⇩</span><sub>1</sub>} ≠ {}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ; ⨅{d<span class="hidden">⇩</span><sub>0</sub>, d<span class="hidden">⇩</span><sub>1</sub>} = ⨅{c ; d |d. d ∈ {d<span class="hidden">⇩</span><sub>0</sub>, d<span class="hidden">⇩</span><sub>1</sub>}}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq_Inf_distrib</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⨅ ((;) c ` {d<span class="hidden">⇩</span><sub>0</sub>, d<span class="hidden">⇩</span><sub>1</sub>}) = ⨅{c ; a |a. a ∈ {d<span class="hidden">⇩</span><sub>0</sub>, d<span class="hidden">⇩</span><sub>1</sub>}}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>INF_Inf</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀(c::'a::refinement_lattice) D::'a::refinement_lattice set. D ≠ {} ⟹ c ; ⨅D = (⨅d::'a::refinement_lattice∈D. c ; d)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹{d<span class="hidden">⇩</span><sub>0</sub>::'a::refinement_lattice, d<span class="hidden">⇩</span><sub>1</sub>::'a::refinement_lattice} ≠ {}›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = c ; d<span class="hidden">⇩</span><sub>0</sub> ⊓ c ; d<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>Inf2_inf</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ; (d<span class="hidden">⇩</span><sub>0</sub> ⊓ d<span class="hidden">⇩</span><sub>1</sub>) ⊑ c ; d<span class="hidden">⇩</span><sub>0</sub> ⊓ c ; d<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>seq_INF_distrib</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X ≠ {} ⟹ c ; (⨅x∈X. d x) = (⨅x∈X. c ; d x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>xne</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X ≠ {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c ; (⨅x∈X. d x) = c ; ⨅(d ` X)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (⨅d∈(d ` X). c ; d)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>image_is_empty</span><span> </span><span>seq_Inf_distrib</span><span> </span><span>xne</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (⨅x∈X. c ; d x)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>image_comp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>b</span><span> </span><span>image_comp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>seq_INF_distrib_UNIV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c ; (⨅x. d x) = (⨅x. c ; d x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>seq_INF_distrib</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>INF_INF_seq_distrib</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Y ≠ {} ⟹ (⨅x∈X. c x) ; (⨅y∈Y. d y) = (⨅x∈X. ⨅y∈Y. c x ; d y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>INF_seq_distrib</span><span> </span><span>seq_INF_distrib</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>INF_INF_seq_distrib_UNIV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⨅x. c x) ; (⨅y. d y) = (⨅x. ⨅y. c x ; d y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>INF_INF_seq_distrib</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span></pre>
</div>
</div><div id="Infimum_Nat">
<div class="head"><h1>Theory Infimum_Nat</h1>
<span class="command">theory</span> <span class="name">Infimum_Nat</span><br/>
<span class="keyword">imports</span> <a href="Refinement_Lattice.html"><span class="name">Refinement_Lattice</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Infimum nat lemmas \label{S:infimum-nat}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Infimum_Nat</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> 
</span><span>  </span><span>Refinement_Lattice</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>infimum_nat</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>INF_partition_nat3</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ nat ⇒ 'a::refinement_lattice"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⨅j. f i j) =
    (⨅j∈{j. i = j}. f i j) ⊓
    (⨅j∈{j. i &lt; j}. f i j) ⊓
    (⨅j∈{j. j &lt; i}. f i j)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>univ_part</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"UNIV = {j. i = j} ∪ {j. i &lt; j} ∪ {j. j &lt; i}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⨅j ∈ {j. i = j} ∪ {j. i &lt; j} ∪ {j. j &lt; i}. f i j) =
          (⨅j∈{j. i = j}. f i j) ⊓
          (⨅j∈{j. i &lt; j}. f i j) ⊓
          (⨅j∈{j. j &lt; i}. f i j)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>INF_union</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>univ_part</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>INF_INF_partition_nat3</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ nat ⇒ 'a::refinement_lattice"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⨅i. ⨅j. f i j) =
    (⨅i. ⨅j∈{j. i = j}. f i j) ⊓
    (⨅i. ⨅j∈{j. i &lt; j}. f i j) ⊓
    (⨅i. ⨅j∈{j. j &lt; i}. f i j)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⨅i. ⨅j. f i j) = (⨅i. ((⨅j∈{j. i = j}. f i j) ⊓
                                  (⨅j∈{j. i &lt; j}. f i j) ⊓
                                  (⨅j∈{j. j &lt; i}. f i j)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>INF_partition_nat3</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (⨅i. ⨅j∈{j. i = j}. f i j) ⊓
                   (⨅i. ⨅j∈{j. i &lt; j}. f i j) ⊓
                   (⨅i. ⨅j∈{j. j &lt; i}. f i j)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>INF_inf_distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>INF_nat_shift</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⨅i∈{i. 0 &lt; i}. f i) = (⨅i. f (Suc i))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>greaterThan_0</span><span> </span><span>greaterThan_def</span><span> </span><span>range_composition</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>INF_nat_minus</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ 'a::refinement_lattice"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⨅j∈{j. i &lt; j}. f (j - i)) = (⨅k∈{k. 0 &lt; k}. f k)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>antisym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>INF_mono</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add.right_neutral</span><span> </span><span>add_diff_cancel_left'</span><span> </span><span>add_less_cancel_left</span><span> </span><span>order_refl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>INF_mono</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>order_refl</span><span> </span><span>zero_less_diff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: generalise to P j i? *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>INF_INF_guarded_switch</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ nat ⇒ 'a::refinement_lattice"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⨅i. ⨅j∈{j. j &lt; i}. f j (i - j)) = (⨅j. ⨅i∈{i. j &lt; i}. f j (i - j))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>antisym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀jj ii. jj &lt; ii ⟹ ∃i. ∃j&lt;i. f j (i - j) ⊑ f jj (ii - jj)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀jj ii. jj &lt; ii ⟹ ∃i. (⨅j∈{j. j &lt; i}. f j (i - j)) ⊑ f jj (ii - jj)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>INF_lower</span><span> </span><span>mem_Collect_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀jj ii. jj &lt; ii ⟹ (⨅i. ⨅j∈{j. j &lt; i}. f j (i - j)) ⊑ f jj (ii - jj)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>UNIV_I</span><span> </span><span>INF_lower</span><span> </span><span>dual_order.trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀jj. (⨅i. ⨅j∈{j. j &lt; i}. f j (i - j)) ⊑ (⨅ii∈{ii. jj &lt; ii}. f jj (ii - jj))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>INF_greatest</span><span> </span><span>mem_Collect_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⨅i. ⨅j∈{j. j &lt; i}. f j (i - j)) ⊑ (⨅jj. ⨅ii∈{ii. jj &lt; ii}. f jj (ii - jj))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>INF_greatest</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⨅i. ⨅j∈{j. j &lt; i}. f j (i - j)) ⊑ (⨅j. ⨅i∈{i. j &lt; i}. f j (i - j))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ii jj. jj &lt; ii ⟹ ∃j. ∃i&gt;j. f j (i - j) ⊑ f jj (ii - jj)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ii jj. jj &lt; ii ⟹ ∃j. (⨅i∈{i. j &lt; i}. f j (i - j)) ⊑ f jj (ii - jj)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>INF_lower</span><span> </span><span>mem_Collect_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ii jj. jj &lt; ii ⟹ (⨅j. ⨅i∈{i. j &lt; i}. f j (i - j)) ⊑ f jj (ii - jj)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>UNIV_I</span><span> </span><span>INF_lower</span><span> </span><span>dual_order.trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ii. (⨅j. ⨅i∈{i. j &lt; i}. f j (i - j)) ⊑ (⨅jj∈{jj. jj &lt; ii}. f jj (ii - jj))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>INF_greatest</span><span> </span><span>mem_Collect_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⨅j. ⨅i∈{i. j &lt; i}. f j (i - j)) ⊑ (⨅ii. ⨅jj∈{jj. jj &lt; ii}. f jj (ii - jj))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>INF_greatest</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⨅j. ⨅i∈{i. j &lt; i}. f j (i - j)) ⊑ (⨅i. ⨅j∈{j. j &lt; i}. f j (i - j))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Conjunctive_Iteration">
<div class="head"><h1>Theory Conjunctive_Iteration</h1>
<span class="command">theory</span> <span class="name">Conjunctive_Iteration</span><br/>
<span class="keyword">imports</span> <a href="Conjunctive_Sequential.html"><span class="name">Conjunctive_Sequential</span></a> <a href="Iteration.html"><span class="name">Iteration</span></a> <a href="Infimum_Nat.html"><span class="name">Infimum_Nat</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Iteration for conjunctive models \label{S:conjunctive-iteration}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Conjunctive_Iteration</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Conjunctive_Sequential</span><span>
</span><span>  </span><span>Iteration</span><span>
</span><span>  </span><span>Infimum_Nat</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Sequential left-distributivity is only supported by conjunctive models
  but does not apply in general. The relational model is one such example.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>iteration_finite_conjunctive</span><span> </span><span class="delimiter">=</span><span> </span><span>seq_finite_conjunctive</span><span> </span><span class="delimiter">+</span><span> </span><span>iteration</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isolation</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>ω</sup> = c<span class="hidden">⇧</span><sup>⋆</sup> ⊓ c<span class="hidden">⇧</span><sup>∞</sup>"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>F</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F = (λ x. c<span class="hidden">⇧</span><sup>⋆</sup> ⊓ x)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>G</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"G = (λ x. c;x)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>H</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H = (λ x. nil ⊓ c;x)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>FG</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"F ∘ G = (λ x. c<span class="hidden">⇧</span><sup>⋆</sup> ⊓ c;x)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>F_def</span><span> </span><span>G_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>HF</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"H ∘ F = (λ x. nil ⊓ c;(c<span class="hidden">⇧</span><sup>⋆</sup> ⊓ x))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>F_def</span><span> </span><span>H_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>adjoint</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dist_over_sup F"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>F_def</span><span> </span><span>inf_Sup</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>monoH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mono H"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>H_def</span><span> </span><span>inf_mono</span><span> </span><span>monoI</span><span> </span><span>order_refl</span><span> </span><span>seq_mono_right</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>monoG</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mono G"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>G_def</span><span> </span><span>inf.absorb_iff2</span><span> </span><span>monoI</span><span> </span><span>seq_inf_distrib</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ x. ((F ∘ G) x = (H ∘ F) x)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FG</span><span> </span><span>HF</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fiter_unfold</span><span> </span><span>inf_sup_aci</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>seq_inf_distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F (lfp G) = lfp H"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>adjoint</span><span> </span><span>monoH</span><span> </span><span>monoG</span><span> </span><span>fusion_lfp_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>⋆</sup> ⊓ lfp (λ x. c;x) = lfp (λ x. nil ⊓ c;x)"</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>F_def</span><span> </span><span>G_def</span><span> </span><span>H_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>infiter_def</span><span> </span><span>iter_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>iter_induct_isolate</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>⋆</sup>;d ⊓ c<span class="hidden">⇧</span><sup>∞</sup> = lfp (λ x. d ⊓ c;x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>F</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F = (λ x. c<span class="hidden">⇧</span><sup>⋆</sup>;d ⊓ x)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>G</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"G = (λ x. c;x)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>H</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H = (λ x. d ⊓ c;x)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>FG</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"F ∘ G = (λ x. c<span class="hidden">⇧</span><sup>⋆</sup>;d ⊓ c;x)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>F_def</span><span> </span><span>G_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>HF</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"H ∘ F = (λ x. d ⊓ c;c<span class="hidden">⇧</span><sup>⋆</sup>;d ⊓ c;x)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>F_def</span><span> </span><span>H_def</span><span> </span><span>weak_seq_inf_distrib</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>comp_apply</span><span> </span><span>inf.commute</span><span> </span><span>inf.left_commute</span><span> </span><span>seq_assoc</span><span> </span><span>seq_inf_distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>unroll</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>⋆</sup>;d = (nil ⊓ c;c<span class="hidden">⇧</span><sup>⋆</sup>);d"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fiter_unfold</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>distribute</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>⋆</sup>;d = d ⊓ c;c<span class="hidden">⇧</span><sup>⋆</sup>;d"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>unroll</span><span> </span><span>inf_seq_distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>FGx</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(F ∘ G) x = d ⊓ c;c<span class="hidden">⇧</span><sup>⋆</sup>;d ⊓ c;x"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FG</span><span> </span><span>distribute</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>adjoint</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dist_over_sup F"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>F_def</span><span> </span><span>inf_Sup</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>monoH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mono H"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>H_def</span><span> </span><span>inf_mono</span><span> </span><span>monoI</span><span> </span><span>order_refl</span><span> </span><span>seq_mono_right</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>monoG</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mono G"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>G_def</span><span> </span><span>inf.absorb_iff2</span><span> </span><span>monoI</span><span> </span><span>seq_inf_distrib</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ x. ((F ∘ G) x = (H ∘ F) x)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FGx</span><span> </span><span>HF</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>FG</span><span> </span><span>distribute</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F (lfp G) = lfp H"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>adjoint</span><span> </span><span>monoH</span><span> </span><span>monoG</span><span> </span><span>fusion_lfp_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>⋆</sup>;d ⊓ lfp (λ x. c;x) = lfp (λ x. d ⊓ c;x)"</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>F_def</span><span> </span><span>G_def</span><span> </span><span>H_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>infiter_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>iter_induct_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>ω</sup>;d = lfp (λ x. d ⊓ c;x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>ω</sup>;d = c<span class="hidden">⇧</span><sup>⋆</sup>;d ⊓ c<span class="hidden">⇧</span><sup>∞</sup>;d"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>isolation</span><span> </span><span>inf_seq_distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>⋆</sup>;d ⊓ c<span class="hidden">⇧</span><sup>∞</sup>;d = c<span class="hidden">⇧</span><sup>⋆</sup>;d ⊓ c<span class="hidden">⇧</span><sup>∞</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>infiter_annil</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>⋆</sup>;d ⊓ c<span class="hidden">⇧</span><sup>∞</sup> = lfp (λ x. d ⊓ c;x)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>iter_induct_isolate</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹c<span class="hidden">⇧</span><sup>ω</sup> ; d = c<span class="hidden">⇧</span><sup>⋆</sup> ; d ⊓ c<span class="hidden">⇧</span><sup>∞</sup> ; d›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹c<span class="hidden">⇧</span><sup>⋆</sup> ; d ⊓ c<span class="hidden">⇧</span><sup>∞</sup> ; d = c<span class="hidden">⇧</span><sup>⋆</sup> ; d ⊓ c<span class="hidden">⇧</span><sup>∞</sup>›</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>iter_induct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d ⊓ c;x ⊑ x ⟹ c<span class="hidden">⇧</span><sup>ω</sup>;d ⊑ x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>iter_induct_eq</span><span> </span><span>lfp_lowerbound</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>iter_isolate</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>⋆</sup>;d ⊓ c<span class="hidden">⇧</span><sup>∞</sup> = c<span class="hidden">⇧</span><sup>ω</sup>;d"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>iter_induct_eq</span><span> </span><span>iter_induct_isolate</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>iter_isolate2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c;c<span class="hidden">⇧</span><sup>⋆</sup>;d ⊓ c<span class="hidden">⇧</span><sup>∞</sup> = c;c<span class="hidden">⇧</span><sup>ω</sup>;d"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>infiter_unfold</span><span> </span><span>iter_isolate</span><span> </span><span>seq_assoc</span><span> </span><span>seq_inf_distrib</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>iter_decomp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(c ⊓ d)<span class="hidden">⇧</span><sup>ω</sup> = c<span class="hidden">⇧</span><sup>ω</sup>;(d;c<span class="hidden">⇧</span><sup>ω</sup>)<span class="hidden">⇧</span><sup>ω</sup>"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>antisym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span>      </span><span class="string"><span class="delete"><span class="delete">"c;c<span class="hidden">⇧</span><sup>ω</sup>;(d;c<span class="hidden">⇧</span><sup>ω</sup>)<span class="hidden">⇧</span><sup>ω</sup> ⊓ (d;c<span class="hidden">⇧</span><sup>ω</sup>)<span class="hidden">⇧</span><sup>ω</sup> ⊑ c<span class="hidden">⇧</span><sup>ω</sup>;(d;c<span class="hidden">⇧</span><sup>ω</sup>)<span class="hidden">⇧</span><sup>ω</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inf_commute</span><span> </span><span>order.refl</span><span> </span><span>inf_seq_distrib</span><span> </span><span>seq_nil_left</span><span> </span><span>iter_unfold</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(c ⊓ d)<span class="hidden">⇧</span><sup>ω</sup> ⊑ c<span class="hidden">⇧</span><sup>ω</sup>;(d;c<span class="hidden">⇧</span><sup>ω</sup>)<span class="hidden">⇧</span><sup>ω</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inf.left_commute</span><span> </span><span>iter_induct_nil</span><span> </span><span>iter_unfold</span><span> </span><span>seq_assoc</span><span> </span><span>inf_seq_distrib</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(c;(c ⊓ d)<span class="hidden">⇧</span><sup>ω</sup> ⊓ d;(c ⊓ d)<span class="hidden">⇧</span><sup>ω</sup>) ⊓ nil ⊑ (c ⊓ d)<span class="hidden">⇧</span><sup>ω</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inf_commute</span><span> </span><span>order.refl</span><span> </span><span>inf_seq_distrib</span><span> </span><span>iter_unfold</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>ω</sup>;(d;(c ⊓ d)<span class="hidden">⇧</span><sup>ω</sup> ⊓ nil) ⊑ (c ⊓ d)<span class="hidden">⇧</span><sup>ω</sup>"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nil ⊓ d;(c ⊓ d)<span class="hidden">⇧</span><sup>ω</sup> ⊓ c;(c ⊓ d)<span class="hidden">⇧</span><sup>ω</sup> ⊑ (c ⊓ d)<span class="hidden">⇧</span><sup>ω</sup>"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>eq_iff</span><span> </span><span>inf.semigroup_axioms</span><span> </span><span>inf_commute</span><span> </span><span>inf_seq_distrib</span><span> </span><span>iter_unfold</span><span> </span><span>semigroup.assoc</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>iter_induct_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inf_sup_aci</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>iter_induct</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d;c<span class="hidden">⇧</span><sup>ω</sup>;(d;(c ⊓ d)<span class="hidden">⇧</span><sup>ω</sup> ⊓ nil) ⊓ nil ⊑ d;(c ⊓ d)<span class="hidden">⇧</span><sup>ω</sup> ⊓ nil"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inf_mono</span><span> </span><span>order.refl</span><span> </span><span>seq_assoc</span><span> </span><span>seq_mono</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(d;c<span class="hidden">⇧</span><sup>ω</sup>)<span class="hidden">⇧</span><sup>ω</sup> ⊑ d;(c ⊓ d)<span class="hidden">⇧</span><sup>ω</sup> ⊓ nil"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inf_commute</span><span> </span><span>iter_induct_nil</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>ω</sup>;(d;c<span class="hidden">⇧</span><sup>ω</sup>)<span class="hidden">⇧</span><sup>ω</sup> ⊑ c<span class="hidden">⇧</span><sup>ω</sup>;(d;(c ⊓ d)<span class="hidden">⇧</span><sup>ω</sup> ⊓ nil)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>order.refl</span><span> </span><span>seq_mono</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>ω</sup>;(d;c<span class="hidden">⇧</span><sup>ω</sup>)<span class="hidden">⇧</span><sup>ω</sup> ⊑ (c ⊓ d)<span class="hidden">⇧</span><sup>ω</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>refine_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>iter_leapfrog_var</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(c;d)<span class="hidden">⇧</span><sup>ω</sup>;c ⊑ c;(d;c)<span class="hidden">⇧</span><sup>ω</sup>"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ⊓ c;d;c;(d;c)<span class="hidden">⇧</span><sup>ω</sup> ⊑ c;(d;c)<span class="hidden">⇧</span><sup>ω</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>iter_unfold</span><span> </span><span>order_refl</span><span> </span><span>seq_assoc</span><span> </span><span>seq_inf_distrib</span><span> </span><span>seq_nil_right</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>iter_induct_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>iter_induct</span><span> </span><span>seq_assoc</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>iter_leapfrog</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c;(d;c)<span class="hidden">⇧</span><sup>ω</sup> = (c;d)<span class="hidden">⇧</span><sup>ω</sup>;c"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>antisym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(c;d)<span class="hidden">⇧</span><sup>ω</sup>;c ⊑ c;(d;c)<span class="hidden">⇧</span><sup>ω</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>iter_leapfrog_var</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(d;c)<span class="hidden">⇧</span><sup>ω</sup> ⊑ ((d;c)<span class="hidden">⇧</span><sup>ω</sup>;d);c ⊓ nil"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inf.bounded_iff</span><span> </span><span>order.refl</span><span> </span><span>seq_assoc</span><span> </span><span>seq_mono</span><span> </span><span>iter_unfold</span><span> </span><span>iter1</span><span> </span><span>iter2</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(d;c)<span class="hidden">⇧</span><sup>ω</sup> ⊑ (d;(c;d)<span class="hidden">⇧</span><sup>ω</sup>);c ⊓ nil"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inf.absorb_iff2</span><span> </span><span>inf.boundedE</span><span> </span><span>inf_assoc</span><span> </span><span>iter_leapfrog_var</span><span> </span><span>inf_seq_distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c;(d;c)<span class="hidden">⇧</span><sup>ω</sup> ⊑ c;d;(c;d)<span class="hidden">⇧</span><sup>ω</sup>;c ⊓ nil;c"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inf.bounded_iff</span><span> </span><span>seq_assoc</span><span> </span><span>seq_mono_right</span><span> </span><span>seq_nil_left</span><span> </span><span>seq_nil_right</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c;(d;c)<span class="hidden">⇧</span><sup>ω</sup> ⊑ (c;d)<span class="hidden">⇧</span><sup>ω</sup>;c"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inf_commute</span><span> </span><span>inf_seq_distrib</span><span> </span><span>iter_unfold</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fiter_leapfrog</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c;(d;c)<span class="hidden">⇧</span><sup>⋆</sup> = (c;d)<span class="hidden">⇧</span><sup>⋆</sup>;c"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c;(d;c)<span class="hidden">⇧</span><sup>⋆</sup> ⊑ (c;d)<span class="hidden">⇧</span><sup>⋆</sup>;c"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(d ; c)<span class="hidden">⇧</span><sup>⋆</sup> = nil ⊓ d ; c ; (d ; c)<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>finite_iteration.fiter_unfold</span><span> </span><span>finite_iteration_axioms</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fiter_induct</span><span> </span><span>seq_assoc</span><span> </span><span>seq_distrib_left.weak_seq_inf_distrib</span><span> 
</span><span>          </span><span>seq_distrib_left_axioms</span><span> </span><span>seq_nil_right</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>rl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(c;d)<span class="hidden">⇧</span><sup>⋆</sup>;c ⊑ c;(d;c)<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(c;d)<span class="hidden">⇧</span><sup>⋆</sup>;c = c ⊓ c;d;(c;d)<span class="hidden">⇧</span><sup>⋆</sup>;c"</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>finite_iteration.fiter_unfold</span><span> </span><span>finite_iteration_axioms</span><span> 
</span><span>           </span><span>inf_seq_distrib</span><span> </span><span>seq_nil_left</span><span class="delimiter">)</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(c;d)<span class="hidden">⇧</span><sup>⋆</sup>;c ⊑ c;(d;c)<span class="hidden">⇧</span><sup>⋆</sup> ⟷ c ⊓ c;d;(c;d)<span class="hidden">⇧</span><sup>⋆</sup>;c ⊑ c;(d;c)<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a1</span><span class="delimiter">)</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"... ⟷ c;( nil ⊓ d;(c;d)<span class="hidden">⇧</span><sup>⋆</sup>;c) ⊑ c;(d;c)<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a1</span><span> </span><span>eq_iff</span><span> </span><span>fiter_unfold</span><span> </span><span>lr</span><span> </span><span>seq_assoc</span><span> </span><span>seq_inf_distrib</span><span> </span><span>seq_nil_right</span><span class="delimiter">)</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(nil ⊓ d;(c;d)<span class="hidden">⇧</span><sup>⋆</sup>;c) ⊑ (d;c)<span class="hidden">⇧</span><sup>⋆</sup> ⟹ c;( nil ⊓ d;(c;d)<span class="hidden">⇧</span><sup>⋆</sup>;c) ⊑ c;(d;c)<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq_mono_right</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(nil ⊓ d;(c;d)<span class="hidden">⇧</span><sup>⋆</sup>;c) ⊑ (d;c)<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d ; (c ; d)<span class="hidden">⇧</span><sup>⋆</sup> ; c ⊓ nil = d ; ((c ; d)<span class="hidden">⇧</span><sup>⋆</sup> ; c) ⊓ nil ⊓ nil"</span></span></span><span>
</span><span>           </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>seq_assoc</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d ; c ; (d ; (c ; d)<span class="hidden">⇧</span><sup>⋆</sup> ; c ⊓ nil) = d ; ((c ; d)<span class="hidden">⇧</span><sup>⋆</sup> ; c)"</span></span></span><span>
</span><span>           </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>a1</span><span> </span><span>inf_sup_aci</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>seq_assoc</span><span> 
</span><span>                </span><span>seq_finite_conjunctive.seq_inf_distrib</span><span> </span><span>seq_finite_conjunctive_axioms</span><span> 
</span><span>                </span><span>seq_nil_right</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>           </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>finite_iteration.fiter_induct</span><span> </span><span>finite_iteration_axioms</span><span> 
</span><span>                           </span><span>inf.cobounded1</span><span> </span><span>inf_sup_aci</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>seq_nil_right</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>   </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span>a3</span><span> </span><span>a4</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eq_iff</span><span> </span><span>lr</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>iteration_infinite_conjunctive</span><span> </span><span class="delimiter">=</span><span> </span><span>seq_infinite_conjunctive</span><span> </span><span class="delimiter">+</span><span> </span><span>iteration</span><span> </span><span class="delimiter">+</span><span> </span><span>infimum_nat</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fiter_seq_choice</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>⋆</sup> = (⨅i::nat. c <span class="hidden">⇧</span><sup>;</sup>^ i)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>antisym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>⋆</sup> ⊑ (⨅i. c <span class="hidden">⇧</span><sup>;</sup>^ i)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>INF_greatest</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>⋆</sup> ⊑ c <span class="hidden">⇧</span><sup>;</sup>^ i"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>i</span><span> </span><span>type</span><span class="delimiter">:</span><span> </span><span>nat</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>⋆</sup> ⊑ c <span class="hidden">⇧</span><sup>;</sup>^ 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fiter0</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>⋆</sup> ⊑ c ; c<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fiter_unfold</span><span> </span><span>inf_le2</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ⊑ c ; (c <span class="hidden">⇧</span><sup>;</sup>^ n)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc.hyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>seq_mono_right</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = c <span class="hidden">⇧</span><sup>;</sup>^ Suc n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>⋆</sup> ⊑ c <span class="hidden">⇧</span><sup>;</sup>^ Suc n"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⨅i. c <span class="hidden">⇧</span><sup>;</sup>^ i) ⊑ (c <span class="hidden">⇧</span><sup>;</sup>^ 0) ⊓ (⨅i. c <span class="hidden">⇧</span><sup>;</sup>^ Suc i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>INF_greatest</span><span> </span><span>INF_lower</span><span> </span><span>UNIV_I</span><span> </span><span>le_inf_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = nil ⊓ (⨅i. c ; (c <span class="hidden">⇧</span><sup>;</sup>^ i))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = nil ⊓ c ; (⨅i. c <span class="hidden">⇧</span><sup>;</sup>^ i)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>seq_INF_distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⨅i. c <span class="hidden">⇧</span><sup>;</sup>^ i) ⊑ c<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fiter_induct</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fiter_seq_choice_nonempty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c ; c<span class="hidden">⇧</span><sup>⋆</sup> = (⨅i∈{i. 0 &lt; i}. c <span class="hidden">⇧</span><sup>;</sup>^ i)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⨅i∈{i. 0 &lt; i}. c <span class="hidden">⇧</span><sup>;</sup>^ i) = (⨅i. c <span class="hidden">⇧</span><sup>;</sup>^ (Suc i))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>INF_nat_shift</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (⨅i. c ; (c <span class="hidden">⇧</span><sup>;</sup>^ i))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = c ; (⨅i. c <span class="hidden">⇧</span><sup>;</sup>^ i)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>seq_INF_distrib_UNIV</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = c ; c<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fiter_seq_choice</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>conj_iteration</span><span> </span><span class="delimiter">=</span><span> </span><span>cra</span><span> </span><span class="delimiter">+</span><span> </span><span>iteration_infinite_conjunctive</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conj_distrib4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>⋆</sup> \&lt;iinter&gt; d<span class="hidden">⇧</span><sup>⋆</sup> ⊑ (c \&lt;iinter&gt; d)<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>⋆</sup> \&lt;iinter&gt; d<span class="hidden">⇧</span><sup>⋆</sup> = (nil ⊓ (c;c<span class="hidden">⇧</span><sup>⋆</sup>)) \&lt;iinter&gt; d<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fiter_unfold</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>⋆</sup> \&lt;iinter&gt; d<span class="hidden">⇧</span><sup>⋆</sup> = (nil \&lt;iinter&gt; d<span class="hidden">⇧</span><sup>⋆</sup>) ⊓ ((c;c<span class="hidden">⇧</span><sup>⋆</sup>) \&lt;iinter&gt; d<span class="hidden">⇧</span><sup>⋆</sup>)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inf_conj_distrib</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>⋆</sup> \&lt;iinter&gt; d<span class="hidden">⇧</span><sup>⋆</sup> ⊑ nil ⊓ ((c;c<span class="hidden">⇧</span><sup>⋆</sup>) \&lt;iinter&gt; (d;d<span class="hidden">⇧</span><sup>⋆</sup>))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>conj_idem</span><span> </span><span>fiter0</span><span> </span><span>fiter_unfold</span><span> </span><span>inf.bounded_iff</span><span> </span><span>inf_le2</span><span> </span><span>local.conj_mono</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c<span class="hidden">⇧</span><sup>⋆</sup> \&lt;iinter&gt; d<span class="hidden">⇧</span><sup>⋆</sup> ⊑ nil ⊓ ((c \&lt;iinter&gt; d);(c<span class="hidden">⇧</span><sup>⋆</sup> \&lt;iinter&gt; d<span class="hidden">⇧</span><sup>⋆</sup>))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>inf_mono_right</span><span> </span><span>order.trans</span><span> </span><span>sequential_interchange</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>seq_nil_right</span><span> </span><span>fiter_induct</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span></pre>
</div>
</div><div id="Rely_Quotient">
<div class="head"><h1>Theory Rely_Quotient</h1>
<span class="command">theory</span> <span class="name">Rely_Quotient</span><br/>
<span class="keyword">imports</span> <a href="Conjunctive_Iteration.html"><span class="name">Conjunctive_Iteration</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Rely Quotient Operator \label{S:rely-quotient}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  The rely quotient operator is used to generalise a Jones-style rely condition
  to a process \cite{jon83a}.
  It is defined in terms of the parallel operator and a process $i$
  representing interference from the environment.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Rely_Quotient</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>CRA</span><span>
</span><span>  </span><span>Conjunctive_Iteration</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Basic rely quotient›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  The rely quotient of a process $c$ and an interference process $i$
  is the most general process $d$ such that $c$ is refined by $d \parallel i$.
  The following locale introduces the definition of the 
  rely quotient $c \quotient i$ as a non-deterministic choice over 
  all processes $d$ such that $c$ is refined by $d \parallel i$. 
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>rely_quotient</span><span> </span><span class="delimiter">=</span><span> </span><span>par_distrib</span><span> </span><span class="delimiter">+</span><span> </span><span>conjunction_parallel</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>rely_quotient</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ 'a"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"'/'/"</span></span></span><span> </span><span>85</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"c // i ≡ ⨅{ d. (c ⊑ d ∥ i)}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Any process $c$ is implemented by itself if the interference is skip.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>quotient_identity</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c // skip = c"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c // skip = ⨅{ d. (c ⊑ d ∥ skip) }"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>rely_quotient_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c // skip = ⨅{ d. (c ⊑ d)  }"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Collect_cong</span><span> </span><span>par_skip</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Inf_greatest</span><span> </span><span>Inf_lower2</span><span> </span><span>dual_order.antisym</span><span> </span><span>dual_order.refl</span><span> </span><span>mem_Collect_eq</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Provided the interference process $i$ is non-aborting (i.e. it refines chaos), 
  any process $c$ is refined by its rely quotient with $i$ in parallel with $i$.
  If interference $i$ was allowed to be aborting then, 
  because $(c \quotient \bot) \parallel \bot$ equals $\bot$,
  it does not refine $c$ in general. 
›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>rely_quotient</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>nonabort_i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chaos ⊑ i"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ⊑ (c // i) ∥ i"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>D</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D = { d ∥ i | d. (c ⊑ d ∥ i)}"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>C</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C = {c}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀d ∈ D. (∃ c ∈ C. c ⊑ d))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D_def</span><span> </span><span>C_def</span><span> </span><span>CollectD</span><span> </span><span>singletonI</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⨅ C ⊑ (⨅ D)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Inf_mono</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ⊑ ⨅{ d ∥ i | d. (c ⊑ d ∥ i)}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>C_def</span><span> </span><span>D_def</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = ⨅{ d ∥ i | d. d ∈ {d. (c ⊑ d ∥ i)}}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (⨅d ∈ {d. (c ⊑ d ∥ i)}. d ∥ i)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>INF_Inf</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = ⨅{ d | d. (c ⊑ d ∥ i)} ∥ i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"{ d | d. (c ⊑ d ∥ i)} = {}"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{ d | d. (c ⊑ d ∥ i)} = {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⨅d ∈ {d. (c ⊑ d ∥ i)}. d ∥ i) = ⨅{ d | d. (c ⊑ d ∥ i)} ∥ i"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nonabort_i</span><span> </span><span>Collect_empty_eq</span><span> </span><span>top_greatest</span><span>
</span><span>            </span><span>nonabort_par_top</span><span> </span><span>par_commute</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{ d | d. (c ⊑ d ∥ i)} ≠ {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{d. (c ⊑ d ∥ i)}  ≠ {}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⨅d ∈ {d. (c ⊑ d ∥ i)}. d ∥ i) = ⨅{ d. (c ⊑ d ∥ i)} ∥ i"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Inf_par_distrib</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (c // i) ∥ i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>rely_quotient_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  The following theorem represents the Galois connection between 
  the parallel operator (upper adjoint) and the rely quotient operator
  (lower adjoint). This basic relationship is used to prove the majority
  of the theorems about rely quotient.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>rely_refinement</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>nonabort_i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chaos ⊑ i"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c // i ⊑ d ⟷ c ⊑ d ∥ i"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c // i ⊑ d"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ⊑ (c // i) ∥ i"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rely_quotient</span><span> </span><span>nonabort_i</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ⊑ d ∥ i"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>par_mono</span><span> </span><span>a</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inf.absorb_iff2</span><span> </span><span>inf_commute</span><span> </span><span>le_infI2</span><span> </span><span>order_refl</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c ⊑ d ∥ i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⨅{ d. (c ⊑ d ∥ i)} ⊑ d"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Inf_lower</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c // i ⊑ d"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>rely_quotient_def</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Refining the ``numerator'' in a quotient, refines the quotient.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rely_mono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>c_refsto_d</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c ⊑ d"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(c // i) ⊑ (d // i)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ f. ((d ⊑ f ∥ i) ⟹ ∃ e. (c ⊑ e ∥ i) ∧ (e ⊑ f))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c_refsto_d</span><span> </span><span>order.trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⨅{ e. (c ⊑ e ∥ i)} ⊑  ⨅{ f. (d ⊑ f ∥ i)}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Inf_mono</span><span> </span><span>mem_Collect_eq</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rely_quotient_def</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Refining the ``denominator'' in a quotient, gives a reverse refinement 
  for the quotients. This corresponds to weaken rely condition law of
  Jones \cite{jon83a}, 
  i.e. assuming less about the environment.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>weaken_rely</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>i_refsto_j</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ⊑ j"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(c // j) ⊑ (c // i)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ f. ((c ⊑ f ∥ i) ⟹ ∃ e. (c ⊑ e ∥ j) ∧ (e ⊑ f))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i_refsto_j</span><span> </span><span>order.trans</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inf.absorb_iff2</span><span> </span><span>inf_le1</span><span> </span><span>inf_par_distrib</span><span> </span><span>inf_sup_ord</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>par_commute</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⨅{ e. (c ⊑ e ∥ j)} ⊑  ⨅{ f. (c ⊑ f ∥ i)}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Inf_mono</span><span> </span><span>mem_Collect_eq</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rely_quotient_def</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>par_nonabort</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>nonabort_i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chaos ⊑ i"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>nonabort_j</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chaos ⊑ j"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chaos ⊑ i ∥ j"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>chaos_par_chaos</span><span> </span><span>nonabort_i</span><span> </span><span>nonabort_j</span><span> </span><span>order_trans</span><span> </span><span>par_mono</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Nesting rely quotients of $j$ and $i$ means the same as a single quotient
  which is the parallel composition of $i$ and $j$.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nested_rely</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>j_nonabort</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chaos ⊑ j"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"((c // j) // i) = c // (i ∥ j)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>antisym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"((c // j) // i) ⊑ c // (i ∥ j)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ f. ((c ⊑ f ∥ i ∥ j) ⟹ ∃ e. (c ⊑ e ∥ j) ∧ (e ⊑ f ∥ i))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⨅{ d. (⨅{ e. (c ⊑ e ∥ j)} ⊑ d ∥ i)} ⊑  ⨅{ f. (c ⊑ f ∥ i ∥ j)}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Collect_mono</span><span> </span><span>Inf_lower</span><span> </span><span>Inf_superset_mono</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.rely_quotient_def</span><span> </span><span>par_assoc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c // (i ∥ j) ⊑ ((c // j) // i) "</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ⊑ ⨅{ e. (c ⊑ e ∥ j)} ∥ j"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>j_nonabort</span><span> </span><span>local.rely_quotient_def</span><span> </span><span>rely_quotient</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ d. ⨅{ e. (c ⊑ e ∥ j)} ⊑ d ∥ i  ⟹ (c ⊑ d ∥ i ∥ j)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>j_nonabort</span><span> </span><span>order_trans</span><span> </span><span>rely_refinement</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Collect_mono</span><span> </span><span>Inf_superset_mono</span><span> </span><span>local.rely_quotient_def</span><span> </span><span>par_assoc</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Distributed rely quotient›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>rely_distrib</span><span> </span><span class="delimiter">=</span><span> </span><span>rely_quotient</span><span> </span><span class="delimiter">+</span><span> </span><span>conjunction_sequential</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  The following is a fundamental law for introducing a parallel composition
  of process to refine a conjunction of specifications. 
  It represents an abstract view of the parallel introduction law of Jones \cite{jon83a}.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>introduce_parallel</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>nonabort_i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chaos ⊑  i"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>nonabort_j</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chaos ⊑  j"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c \&lt;iinter&gt; d ⊑  (j \&lt;iinter&gt; (c // i)) ∥ (i \&lt;iinter&gt; (d // j))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c ⊑ (c // i) ∥ i"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nonabort_i</span><span> </span><span>nonabort_j</span><span> </span><span>rely_quotient</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d ⊑ j ∥ (d // j)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rely_quotient</span><span> </span><span>par_commute</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nonabort_j</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c \&lt;iinter&gt; d ⊑  ((c // i) ∥ i) \&lt;iinter&gt; ( j ∥ (d // j))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>conj_mono</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>interchange</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c \&lt;iinter&gt; d ⊑  ((c // i) \&lt;iinter&gt; j) ∥ ( i \&lt;iinter&gt; (d // j))"</span></span></span><span> 
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>parallel_interchange</span><span> </span><span>refine_trans</span><span> </span><span>calculation</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>interchange</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local.conj_commute</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Rely quotients satisfy a range of distribution properties with respect
  to the other operators.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>distribute_rely_conjunction</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>nonabort_i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chaos ⊑  i"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(c \&lt;iinter&gt; d) // i  ⊑  (c // i) \&lt;iinter&gt; (d // i)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c \&lt;iinter&gt; d ⊑ ((c // i) ∥ i) \&lt;iinter&gt; ((d // i) ∥ i)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conj_mono</span><span> </span><span>rely_quotient</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nonabort_i</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c \&lt;iinter&gt; d ⊑ ((c // i) \&lt;iinter&gt; (d // i)) ∥ (i \&lt;iinter&gt; i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>parallel_interchange</span><span> </span><span>refine_trans</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c \&lt;iinter&gt; d ⊑ ((c // i) \&lt;iinter&gt; (d // i)) ∥ i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>conj_idem</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rely_refinement</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nonabort_i</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>distribute_rely_choice</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>nonabort_i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chaos ⊑  i"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(c ⊓ d) // i  ⊑  (c // i) ⊓ (d // i)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ⊓ d ⊑ ((c // i) ∥ i) ⊓ ((d // i) ∥ i)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>nonabort_i</span><span> </span><span>inf_mono</span><span> </span><span>rely_quotient</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ⊓ d ⊑ ((c // i) ⊓ (d // i)) ∥ i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inf_par_distrib</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>nonabort_i</span><span> </span><span>rely_refinement</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>distribute_rely_parallel1</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>nonabort_i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chaos ⊑  i"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>nonabort_j</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chaos ⊑  j"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(c ∥ d) // (i ∥ j)  ⊑  (c // i) ∥ (d // j)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(c ∥ d) ⊑ ((c // i) ∥ i) ∥ ((d // j) ∥ j)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>par_mono</span><span> </span><span>rely_quotient</span><span> </span><span>nonabort_i</span><span> </span><span>nonabort_j</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(c ∥ d) ⊑ (c // i) ∥ (d // j) ∥ j ∥ i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>par_assoc</span><span> </span><span>par_commute</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>par_assoc</span><span> </span><span>par_commute</span><span> </span><span>rely_refinement</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>nonabort_i</span><span> </span><span>nonabort_j</span><span> </span><span>par_nonabort</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>distribute_rely_parallel2</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>nonabort_i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chaos ⊑ i"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>i_par_i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∥ i ⊑ i"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(c ∥ d) // i  ⊑  (c // i) ∥ (d // i)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(c ∥ d) // i ⊑ ((c ∥ d) // (i ∥ i))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>weaken_rely</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>i_par_i</span><span> </span><span>par_nonabort</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>distribute_rely_parallel1</span><span> </span><span>refine_trans</span><span> </span><span>nonabort_i</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>distribute_rely_sequential</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>nonabort_i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chaos ⊑ i"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀ c. (∀ d. ((c ∥ i);(d ∥ i) ⊑ (c;d) ∥ i)))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(c;d) // i ⊑ (c // i);(d // i)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c;d ⊑ ((c // i) ∥ i);((d // i) ∥ i)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>rely_quotient</span><span> </span><span>nonabort_i</span><span> </span><span>seq_mono</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c;d ⊑ (c // i) ; (d // i) ∥ i"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>refine_trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>rely_refinement</span><span> </span><span>nonabort_i</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>distribute_rely_sequential_event</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>nonabort_i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chaos ⊑ i"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>nonabort_j</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chaos ⊑ j"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>nonabort_e</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chaos ⊑ e"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀ c. (∀ d. ((c ∥ i);e;(d ∥ j) ⊑ (c;e;d) ∥ (i;e;j))))"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(c;e;d) // (i;e;j) ⊑ (c // i);e;(d // j)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c;e;d ⊑ ((c // i) ∥ i);e;((d // j) ∥ j)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>order.refl</span><span> </span><span>rely_quotient</span><span> </span><span>nonabort_i</span><span> </span><span>nonabort_j</span><span> </span><span>seq_mono</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c;e;d ⊑ ((c // i);e;(d // j)) ∥ (i;e;j)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>refine_trans</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rely_refinement</span><span> </span><span>nonabort_i</span><span> </span><span>nonabort_j</span><span> </span><span>nonabort_e</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Inf_lower</span><span> </span><span>local.rely_quotient_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>introduce_parallel_with_rely</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>nonabort_i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chaos ⊑ i"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>nonabort_j0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chaos ⊑  j<span class="hidden">⇩</span><sub>0</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>nonabort_j1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chaos ⊑  j<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(c \&lt;iinter&gt; d) // i ⊑ (j<span class="hidden">⇩</span><sub>1</sub> \&lt;iinter&gt; (c // (j<span class="hidden">⇩</span><sub>0</sub> ∥ i))) ∥ (j<span class="hidden">⇩</span><sub>0</sub> \&lt;iinter&gt; (d // (j<span class="hidden">⇩</span><sub>1</sub> ∥ i)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(c \&lt;iinter&gt; d) // i ⊑ (c // i) \&lt;iinter&gt; (d // i)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>distribute_rely_conjunction</span><span> </span><span>nonabort_i</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(c \&lt;iinter&gt; d) // i ⊑ (j<span class="hidden">⇩</span><sub>1</sub> \&lt;iinter&gt; ((c // i) // j<span class="hidden">⇩</span><sub>0</sub>)) ∥ (j<span class="hidden">⇩</span><sub>0</sub> \&lt;iinter&gt; ((d // i) // j<span class="hidden">⇩</span><sub>1</sub>))"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>introduce_parallel</span><span> </span><span>nonabort_j0</span><span> </span><span>nonabort_j1</span><span> </span><span>inf_assoc</span><span> </span><span>inf.absorb_iff1</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nested_rely</span><span> </span><span>nonabort_i</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>introduce_parallel_with_rely_guarantee</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>nonabort_i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chaos ⊑  i"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>nonabort_j0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chaos ⊑  j<span class="hidden">⇩</span><sub>0</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>nonabort_j1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chaos ⊑  j<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(j<span class="hidden">⇩</span><sub>1</sub> ∥ j<span class="hidden">⇩</span><sub>0</sub>) \&lt;iinter&gt; (c \&lt;iinter&gt; d) // i ⊑ (j<span class="hidden">⇩</span><sub>1</sub> \&lt;iinter&gt; (c // (j<span class="hidden">⇩</span><sub>0</sub> ∥ i))) ∥ (j<span class="hidden">⇩</span><sub>0</sub> \&lt;iinter&gt; (d // (j<span class="hidden">⇩</span><sub>1</sub> ∥ i)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(j<span class="hidden">⇩</span><sub>1</sub> ∥ j<span class="hidden">⇩</span><sub>0</sub>) \&lt;iinter&gt; (c \&lt;iinter&gt; d) // i ⊑ (j<span class="hidden">⇩</span><sub>1</sub> ∥ j<span class="hidden">⇩</span><sub>0</sub>) \&lt;iinter&gt; ((j<span class="hidden">⇩</span><sub>1</sub> \&lt;iinter&gt; (c // (j<span class="hidden">⇩</span><sub>0</sub> ∥ i))) ∥ (j<span class="hidden">⇩</span><sub>0</sub> \&lt;iinter&gt; (d // (j<span class="hidden">⇩</span><sub>1</sub> ∥ i))))"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>introduce_parallel_with_rely</span><span> </span><span>nonabort_i</span><span> </span><span>nonabort_j0</span><span> </span><span>nonabort_j1</span><span> 
</span><span>        </span><span>conj_mono</span><span> </span><span>order.refl</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ⊑ (j<span class="hidden">⇩</span><sub>1</sub> \&lt;iinter&gt; j<span class="hidden">⇩</span><sub>1</sub> \&lt;iinter&gt; (c // (j<span class="hidden">⇩</span><sub>0</sub> ∥ i))) ∥ (j<span class="hidden">⇩</span><sub>0</sub> \&lt;iinter&gt; j<span class="hidden">⇩</span><sub>0</sub> \&lt;iinter&gt; (d // (j<span class="hidden">⇩</span><sub>1</sub> ∥ i)))"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>conj_assoc</span><span> </span><span>parallel_interchange</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>conj_idem</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wrap_rely_guar</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>nonabort_rg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chaos ⊑ rg"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>skippable</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rg ⊑ skip"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ⊑ rg \&lt;iinter&gt; c // rg"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c = c // skip"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>quotient_identity</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ⊑ c // rg"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>skippable</span><span> </span><span>weaken_rely</span><span> </span><span>nonabort_rg</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ⊑ rg \&lt;iinter&gt; c // rg"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conjoin_non_aborting</span><span> </span><span>conj_commute</span><span> </span><span>nonabort_rg</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ⊑ rg \&lt;iinter&gt; c // rg"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>rely_distrib_iteration</span><span> </span><span class="delimiter">=</span><span> </span><span>rely_distrib</span><span> </span><span class="delimiter">+</span><span> </span><span>iteration_finite_conjunctive</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>distribute_rely_iteration</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>nonabort_i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chaos ⊑ i"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀ c. (∀ d. ((c ∥ i);(d ∥ i) ⊑ (c;d) ∥ i)))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(c<span class="hidden">⇧</span><sup>ω</sup>;d) // i ⊑ (c // i)<span class="hidden">⇧</span><sup>ω</sup>;(d // i)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d ⊓ c ; ((c // i)<span class="hidden">⇧</span><sup>ω</sup>;(d // i) ∥ i) ⊑ ((d // i) ∥ i) ⊓ ((c // i) ∥ i);((c // i)<span class="hidden">⇧</span><sup>ω</sup>;(d // i) ∥ i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inf_mono</span><span> </span><span>order.refl</span><span> </span><span>rely_quotient</span><span> </span><span>nonabort_i</span><span> </span><span>seq_mono</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ⊑ ((d // i) ∥ i) ⊓ ((c // i);(c // i)<span class="hidden">⇧</span><sup>ω</sup>;(d // i) ∥ i )"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>inf_mono_right</span><span> </span><span>seq_assoc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ⊑ ((d // i) ⊓ (c // i);(c // i)<span class="hidden">⇧</span><sup>ω</sup>;(d // i)) ∥ i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inf_par_distrib</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = ((c // i)<span class="hidden">⇧</span><sup>ω</sup>;(d // i)) ∥ i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>iter_unfold</span><span> </span><span>inf_seq_distrib</span><span> </span><span>seq_nil_left</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>rely_refinement</span><span> </span><span>nonabort_i</span><span> </span><span>iter_induct</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div>