<div id="Prelim">
<div class="head"><h1>Theory Prelim</h1>
<span class="command">theory</span> <span class="name">Prelim</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL-Library/Stream.html"><span class="name">Stream</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Preliminaries›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Prelim</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Stream"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>any</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"any ≡ undefined"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>append_singl_rev</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a # as = [a] @ as"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_pair_induct</span><span class="delimiter">[</span><span>case_names</span><span> </span><span>Nil</span><span> </span><span>Cons</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P []"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀a b list. P list ⟹ P ((a,b) # list)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P lista"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>lista</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_pair_case</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">,</span><span> </span><span>case_names</span><span> </span><span>Nil</span><span> </span><span>Cons</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs = [] ⟹ P"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀a b list. xs = (a,b) # list ⟹ P"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>asList</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set ⇒ 'a list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"asList A ≡ SOME as. distinct as ∧ set as = A"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>asList</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct (asList A) ∧ set (asList A) = A"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>asList_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>someI_ex</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>finite_distinct_list</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>distinct_asList</span><span> </span><span class="delimiter">=</span><span> </span><span>asList</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>conjunct1</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>set_asList</span><span> </span><span class="delimiter">=</span><span> </span><span>asList</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>conjunct2</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_sdrop</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sdrop 0 = id"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>stl_o_sdrop</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"stl o sdrop n = sdrop (Suc n)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sdrop_o_stl</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sdrop n o stl = sdrop (Suc n)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hd_stake</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &gt; 0 ⟹ hd (stake i π) = shd π"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>i</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div><div id="Shallow">
<div class="head"><h1>Theory Shallow</h1>
<span class="command">theory</span> <span class="name">Shallow</span><br/>
<span class="keyword">imports</span> <a href="Prelim.html"><span class="name">Prelim</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Shallow embedding of HyperCTL*›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Shallow</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Prelim</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹We define a notion of ``shallow'' HyperCTL* formula (sfmla) that captures
HyperCTL* binders as meta-level HOL binders. We also define a proof system for this
shallow embedding.›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Kripke structures and paths›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'state</span><span class="delimiter">,</span><span class="tfree">'aprop</span><span class="delimiter">)</span><span> </span><span>path</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('state × 'aprop set) stream"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>stateOf</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"stateOf π ≡ fst (shd π)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>apropsOf</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"apropsOf π ≡ snd (shd π)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Kripke</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'state set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s0</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'state</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>δ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'state ⇒ 'state set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>AP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'aprop set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>L</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'state ⇒ 'aprop set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>s0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s0 ∈ S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>δ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ s. s ∈ S ⟹ δ s ⊆ S"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>L</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ s. s ∈ S ⟹ L s ⊆ AP"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Well-formed paths›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">coinductive</span></span><span> </span><span>wfp</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'aprop set ⇒ ('state,'aprop) path ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>AP'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'aprop set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>intro</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦s ∈ S; A ⊆ AP'; A ∩ AP = L s; stateOf π ∈ δ s; wfp AP' π⟧
 ⟹
 wfp AP' ((s,A) ## π)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wfp</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"wfp AP' π ⟷
 (∀ i. fst (π !! i) ∈ S ∧ snd (π !! i) ⊆ AP' ∧
       snd (π !! i) ∩ AP = L (fst (π !! i)) ∧
       fst (π !! (Suc i)) ∈ δ (fst (π !! i))
 )"</span></span></span><span>
</span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?L ⟷ (∀ i. ?R i)"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>iffI</span><span> </span><span>allI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?L</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?R i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>i</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>π</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>snth.simps</span><span> </span><span>fst_conv</span><span> </span><span>snd_conv</span><span> </span><span>stream.sel</span><span> </span><span>wfp.cases</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>R</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ i. ?R i"</span></span></span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?L</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>coinduct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s0</span><span> </span><span>fst_conv</span><span> </span><span>snd_conv</span><span> </span><span>snth.simps</span><span> </span><span>stream.sel</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inf_commute</span><span> </span><span>stream.collapse</span><span> </span><span>surj_pair</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wfp_sdrop</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"wfp AP' π ⟹ wfp AP' (sdrop i π)"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wfp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>sdrop_add</span><span> </span><span>sdrop_simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* context Kripke *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹end-of-context Kripke›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Shallow representations of formulas›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹A shallow (representation of a) HyperCTL* formula will be a predicate on lists of paths.  
The atomic formulas (operator $\textit{atom}$) are parameterized by atomic propositions (as customary in temporal logic), 
and additionally by a number indicating the position, in the list of paths, of the path to which the atomic proposition 
refers -- for example, $\textit{atom}\;a\;i$ holds for the list of paths $\pi l$ just in case proposition $a$ holds 
at the first state of $\pi l!i$, the $i$'th path in $\pi l$.  The temporal operators $\textit{next}$ and $\textit{until}$ act on all the paths of the argument 
list $\pi l$ synchronously.  Finally, the existential quantifier refers to the existence of a path whose origin state is that of 
the last path in $\pi l$.  

As an example: $\textit{exi}\; (\textit{exi}\; (\textit{until}\; (\textit{atom}\;a\;0)\;(\textit{atom}\;b\;1)))$ holds for the empty list 
iff there exist two paths $\rho_0$ and $\rho_1$ such that, synchronously,  
$a$ holds on $\rho_0$ until $b$ holds on $\rho_1$.  Another example will be the formula encoding Goguen-Meseguer noninterference.   
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Shallow HyperCTL* formulas:›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'state</span><span class="delimiter">,</span><span class="tfree">'aprop</span><span class="delimiter">)</span><span> </span><span>sfmla</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('state,'aprop) path list ⇒ bool"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Shallow</span><span> </span><span class="delimiter">=</span><span> </span><span>Kripke</span><span> </span><span>S</span><span> </span><span class="string"><span class="delete"><span class="delete">"s0"</span></span></span><span> </span><span>δ</span><span> </span><span>AP</span><span> </span><span>L</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'state set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s0</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'state</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>δ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'state ⇒ 'state set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>AP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'aprop set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>L</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'state ⇒ 'aprop set"</span></span></span><span>
</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>AP'</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>AP_AP'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"AP ⊆ AP'"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Primitive operators›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* I include false as a primitive since otherwise I would have to assume nonemptyness of
  the atomic propositions *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>fls</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('state,'aprop) sfmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"fls πl ≡ False"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>atom</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'aprop ⇒ nat ⇒ ('state,'aprop) sfmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"atom a i πl ≡ a ∈ apropsOf (πl!i)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>neg</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('state,'aprop) sfmla ⇒ ('state,'aprop) sfmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"neg φ πl ≡ ¬ φ πl"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>dis</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('state,'aprop) sfmla ⇒ ('state,'aprop) sfmla ⇒ ('state,'aprop) sfmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"dis φ ψ πl ≡ φ πl ∨ ψ πl"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"next"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('state,'aprop) sfmla ⇒ ('state,'aprop) sfmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"next φ πl ≡ φ (map stl πl)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>until</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('state,'aprop) sfmla ⇒ ('state,'aprop) sfmla ⇒ ('state,'aprop) sfmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"until φ ψ πl ≡
 ∃ i. ψ (map (sdrop i) πl) ∧ (∀ j ∈{0..&lt;i}. φ (map (sdrop j) πl))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>exii</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('state,'aprop) sfmla ⇒ ('state,'aprop) sfmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"exii φ πl ≡
 ∃ π. wfp AP' π ∧ stateOf π = (if πl ≠ [] then stateOf (last πl) else s0)
      ∧ φ (πl @ [π])"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>exi</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('state,'aprop) path ⇒ ('state,'aprop) sfmla) ⇒ ('state,'aprop) sfmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"exi F πl ≡
 ∃ π. wfp AP' π ∧ stateOf π = (if πl ≠ [] then stateOf (last πl) else s0)
      ∧ F π πl"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Derived operators›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tr ≡ neg fls"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"con φ ψ ≡ neg (dis (neg φ) (neg ψ))"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"imp φ ψ ≡ dis (neg φ) ψ"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eq φ ψ ≡ con (imp φ ψ) (imp ψ φ) "</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fall F ≡ neg (exi (λ π. neg (F π)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ev φ ≡ until tr φ"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"alw φ ≡ neg (ev (neg φ))"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wuntil φ ψ ≡ dis (until φ ψ) (alw φ)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>main_op_defs</span><span> </span><span class="delimiter">=</span><span>
</span><span>fls_def</span><span> </span><span>atom_def</span><span> </span><span>neg_def</span><span> </span><span>dis_def</span><span> </span><span>next_def</span><span> </span><span>until_def</span><span> </span><span>exi_def</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>der_op_defs</span><span> </span><span class="delimiter">=</span><span>
</span><span>tr_def</span><span> </span><span>con_def</span><span> </span><span>imp_def</span><span> </span><span>eq_def</span><span> </span><span>ev_def</span><span> </span><span>alw_def</span><span> </span><span>wuntil_def</span><span> </span><span>fall_def</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>op_defs</span><span> </span><span class="delimiter">=</span><span> </span><span>main_op_defs</span><span> </span><span>der_op_defs</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Reasoning rules›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹We provide introduction, elimination, unfolding and (co)induction rules
for the connectives and quantifiers.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Boolean operators›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fls_elim</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fls πl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>φ</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>op_defs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tr_intro</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tr πl"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>op_defs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dis_introL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ πl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dis φ ψ πl"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>op_defs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dis_introR</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ψ πl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dis φ ψ πl"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>op_defs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dis_elim</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dis φ ψ πl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ πl ⟹ χ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ψ πl ⟹ χ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>χ</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>op_defs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>con_intro</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ πl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ψ πl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"con φ ψ πl"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>op_defs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>con_elim</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"con φ ψ πl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ πl ⟹ ψ πl ⟹ χ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>χ</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>op_defs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>neg_intro</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ πl ⟹ False"</span></span></span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"neg φ πl"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>op_defs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>neg_elim</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"neg φ πl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ πl"</span></span></span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>χ</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>op_defs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>imp_intro</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ πl ⟹ ψ πl"</span></span></span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"imp φ ψ πl"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>op_defs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>imp_elim</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"imp φ ψ πl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ πl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ψ πl ⟹ χ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>χ</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>op_defs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>imp_mp</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"imp φ ψ πl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ πl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ψ πl"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>op_defs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eq_intro</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ πl ⟹ ψ πl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ψ πl ⟹ φ πl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eq φ ψ πl"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>op_defs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eq_elimL</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eq φ ψ πl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ πl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ψ πl ⟹ χ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>χ</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>op_defs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eq_elimR</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eq φ ψ πl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ψ πl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ πl ⟹ χ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>χ</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>op_defs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eq_equals</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"eq φ ψ πl ⟷ φ πl = ψ πl"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>eq_elimL</span><span> </span><span>eq_elimR</span><span> </span><span>eq_intro</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Quantifiers›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exi_intro</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wfp AP' π"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"πl ≠ [] ⟹ stateOf π = stateOf (last πl)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"πl = [] ⟹ stateOf π = s0"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F π πl"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exi F πl"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>exi_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exi_elim</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exi F πl"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"⋀ π. ⟦wfp AP' π; πl ≠ [] ⟹ stateOf π = stateOf (last πl); πl = [] ⟹ stateOf π = s0; F π πl⟧ ⟹ χ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>χ</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>exi_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fall_intro</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"⋀ π. ⟦wfp AP' π; πl ≠ [] ⟹ stateOf π = stateOf (last πl) ; πl = [] ⟹ stateOf π = s0⟧
       ⟹  F π πl"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fall F πl"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fall_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>exi_def</span><span> </span><span>neg_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fall_elim</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fall F πl"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"(⋀π. ⟦wfp AP' π; πl ≠ [] ⟹ stateOf π = stateOf (last πl); πl = [] ⟹ stateOf π = s0⟧
        ⟹ F π πl)
  ⟹ χ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>χ</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fall_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>exi_def</span><span> </span><span>neg_elim</span><span> </span><span>neg_intro</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Temporal connectives›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>next_intro</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ (map stl πl)"</span></span></span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"next φ πl"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>op_defs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>next_elim</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"next φ πl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ (map stl πl) ⟹ χ"</span></span></span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>χ</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>op_defs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>until_introR</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ψ πl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"until φ ψ πl"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>op_defs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>0</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>until_introL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>φ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ πl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"until φ ψ (map stl πl)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"until φ ψ πl"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ψ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ψ (map (sdrop (Suc i)) πl)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀j∈{0..&lt;i}. φ (map (sdrop (Suc j)) πl)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>u</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>op_defs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>j</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j ∈ {0..&lt;Suc i}"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ (map (sdrop j) πl)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span>φ</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>j</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ψ</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>op_defs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The elimination rules for until and eventually are induction rules.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>until_induct</span><span class="delimiter">[</span><span>induct</span><span> </span><span>pred</span><span class="delimiter">:</span><span> </span><span>until</span><span class="delimiter">,</span><span> </span><span>consumes</span><span> </span><span>1</span><span class="delimiter">,</span><span> </span><span>case_names</span><span> </span><span>Base</span><span> </span><span>Step</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"until φ ψ πl"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ πl. ψ πl ⟹ χ πl"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ πl. ⟦φ πl; until φ ψ (map stl πl); χ (map stl πl)⟧ ⟹ χ πl"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"χ πl"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ψ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ψ (map (sdrop i) πl)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>1</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∀j∈{0..&lt;i}. φ (map (sdrop j) πl)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>u</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>until_def</span><span> </span><span>next_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>k</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>k</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"k ≤ i"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"until φ ψ (map (sdrop k) πl) ∧ χ (map (sdrop k) πl)"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span class="string"><span class="delete"><span class="delete">"i-k"</span></span></span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>k</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k=i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>     </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>b</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ψ</span><span class="delimiter">]</span><span> </span><span>u</span><span> </span><span>ψ</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>until_introR</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>ii</span><span class="delimiter">)</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?πl'</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"map (sdrop k) πl"</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"until φ ψ  (map stl ?πl') ∧ χ (map stl ?πl')"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>     </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ?πl'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span>Suc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>     </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span class="delimiter">[</span><span>of</span><span> </span><span>0</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>until_unfold</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"until φ ψ πl = (ψ πl ∨ φ πl ∧ until φ ψ (map stl πl))"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?L = ?R"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?L</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?R</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>induct</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ev_introR</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ πl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ev φ πl"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ev_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>until_introR</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ev_introL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ev φ (map stl πl)"</span></span></span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ev φ πl"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ev_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>until_introL</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ev_induct</span><span class="delimiter">[</span><span>induct</span><span> </span><span>pred</span><span class="delimiter">:</span><span> </span><span>ev</span><span class="delimiter">,</span><span> </span><span>consumes</span><span> </span><span>1</span><span class="delimiter">,</span><span> </span><span>case_names</span><span> </span><span>Base</span><span> </span><span>Step</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ev φ πl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ πl. φ πl ⟹ χ πl"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ πl. ⟦ev φ (map stl πl); χ (map stl πl)⟧ ⟹ χ πl"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"χ πl"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ev_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>induct</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ev_unfold</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"ev φ πl = (φ πl ∨ ev φ (map stl πl))"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ev_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>tr_intro</span><span> </span><span>until_unfold</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ev</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ev φ πl ⟷ (∃ i. φ (map (sdrop i) πl))"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ev_def</span><span> </span><span>until_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The introduction rules for always and weak until are coinduction rules.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>alw_coinduct</span><span class="delimiter">[</span><span>coinduct</span><span> </span><span>pred</span><span class="delimiter">:</span><span> </span><span>alw</span><span class="delimiter">,</span><span> </span><span>consumes</span><span> </span><span>1</span><span class="delimiter">,</span><span> </span><span>case_names</span><span> </span><span>Hyp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"χ πl"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ πl. χ πl ⟹ alw φ πl ∨ (φ πl ∧ χ (map stl πl))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"alw φ πl"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ev (neg φ) πl"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ χ πl"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>induct</span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>op_defs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>alw_def</span><span> </span><span>ev_def</span><span> </span><span>neg_def</span><span> </span><span>until_introR</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>op_defs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>alw_elim</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"alw φ πl"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦φ πl; alw φ (map stl πl)⟧ ⟹ χ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"χ"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>alw_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>ev_introR</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>neg_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>alw_destL</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"alw φ πl ⟹ φ πl"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>alw_destR</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"alw φ πl ⟹ alw φ (map stl πl)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>alw_unfold</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"alw φ πl = (φ πl ∧ alw φ (map stl πl))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>alw_def</span><span> </span><span>ev_unfold</span><span> </span><span>neg_elim</span><span> </span><span>neg_intro</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>alw</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"alw φ πl ⟷ (∀ i. φ (map (sdrop i) πl))"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>alw_def</span><span> </span><span>ev</span><span> </span><span>neg_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sdrop_imp_alw</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ i. (⋀j. j ≤ i ⟹ φ [sdrop j π, sdrop j π']) ⟹ ψ [sdrop i π, sdrop i π']"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"imp (alw φ) (alw ψ) [π, π']"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>alw</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wuntil_coinduct</span><span class="delimiter">[</span><span>coinduct</span><span> </span><span>pred</span><span class="delimiter">:</span><span> </span><span>wuntil</span><span class="delimiter">,</span><span> </span><span>consumes</span><span> </span><span>1</span><span class="delimiter">,</span><span> </span><span>case_names</span><span> </span><span>Hyp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>χ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"χ πl"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ πl. χ πl ⟹ ψ πl ∨ (φ πl ∧ χ (map stl πl))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wuntil φ ψ πl"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ until φ ψ πl ∧ χ πl"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"alw φ πl"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>coinduct</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>until_introL</span><span> </span><span>until_introR</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>χ</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wuntil_def</span><span> </span><span>dis_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wuntil_elim</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>w</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wuntil φ ψ πl"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ψ πl ⟹ χ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦φ πl; wuntil φ ψ (map stl πl)⟧ ⟹ χ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>χ</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"alw φ πl"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>standard</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wuntil_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"until φ ψ πl"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>w</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wuntil_def</span><span> </span><span>dis_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>dis_introL</span><span> </span><span>until_unfold</span><span> </span><span>wuntil_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wuntil_unfold</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"wuntil φ ψ πl = (ψ πl ∨ φ πl ∧ wuntil φ ψ (map stl πl))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>alw_unfold</span><span> </span><span>dis_def</span><span> </span><span>until_unfold</span><span> </span><span>wuntil_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹More derived operators›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The conjunction of an arbitrary set of formulas:›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>scon</span><span> </span><span class="delimiter">::</span><span>
</span><span class="string"><span class="delete"><span class="delete">"('state,'aprop) sfmla set ⇒ ('state,'aprop) sfmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"scon φs πl ≡ ∀ φ ∈ φs. φ πl"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mcon_intro</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ φ. φ ∈ φs ⟹ φ πl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"scon φs πl"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>scon_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>scon_elim</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"scon φs πl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀ φ. φ ∈ φs ⟹ φ πl) ⟹ χ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>χ</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>scon_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Double-binding forall:›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fall2 F ≡ fall (λ π. fall (F π))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fall2_intro</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"⋀ π π'. ⟦wfp AP' π; wfp AP' π';
           πl ≠ [] ⟹ stateOf π = stateOf (last πl);
           πl = [] ⟹ stateOf π = s0;
           stateOf π' = stateOf π
          ⟧
       ⟹  F π π' πl"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fall2 F πl"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fall2_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>fall_intro</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fall2_elim</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fall2 F πl"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"(⋀π π'. ⟦wfp AP' π; wfp AP' π';
           πl ≠ [] ⟹ stateOf π = stateOf (last πl); πl = [] ⟹ stateOf π = s0;
           stateOf π' = stateOf π
          ⟧
          ⟹ F π π' πl)
  ⟹ χ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>χ</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fall2_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>fall_elim</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fall_elim</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* context Shallow *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹end-of-context Shallow›</span></span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div><div id="Noninterference">
<div class="head"><h1>Theory Noninterference</h1>
<span class="command">theory</span> <span class="name">Noninterference</span><br/>
<span class="keyword">imports</span> <a href="Shallow.html"><span class="name">Shallow</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Noninterference \`{a} la Goguen and Meseguer›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Noninterference</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Shallow</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Goguen-Meseguer noninterference›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Definition›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>GM_sec_model</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>st0</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'St</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>do</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'St ⇒ 'U ⇒ 'C ⇒ 'St"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>out</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'St ⇒ 'U ⇒ 'Out"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>GH</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'U set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>GL</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'U set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Extension of ``do'' to sequences of pairs (user, command):›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>doo</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'St ⇒ ('U × 'C) list ⇒ 'St"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"doo st [] = st"</span></span></span><span>
</span><span class="delimiter">|</span><span class="string"><span class="delete"><span class="delete">"doo st ((u,c) # ucl) = (doo (do st u c ) ucl)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>purge</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'U set ⇒ ('U × 'C) list ⇒ ('U × 'C) list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"purge G ucl ≡ filter (λ (u,c). u ∉ G) ucl"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>purge_Nil</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"purge G [] = []"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>purge_Cons_in</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∉ G ⟹ purge G ((u,c) # ucl) = (u,c) # purge G ucl"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>purge_Cons_notIn</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ G ⟹ purge G ((u,c) # ucl) = purge G ucl"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>purge_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>purge_append</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"purge G (ucl1 @ ucl2) = purge G ucl1 @ purge G ucl2"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>purge_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>filter_append</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>nonint</span><span> </span><span class="delimiter">::</span><span> </span><span>bool</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"nonint ≡ ∀ ucl. ∀ u ∈ GL. out (doo st0 ucl) u = out (doo st0 (purge GH ucl)) u"</span></span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* context GM_sec_model *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹end-of-context GM-sec-model›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Specialized Kripke structures›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹As a preparation for representing noninterference in HyperCTL*,
we define a specialized notion of Kripke structure.  It is enriched
with the following date: 
two binary state predicates f and g, intuitively capturing high-input
and low-output equivalence, respectively; 
a set Sink of
states immediately accessible from any state and such that, for the states in Sink,
there exist self-transitions and f holds.

This specialized structure, represented by the locale Shallow-Idle, is an auxiliary that streamlines our proofs, 
easing the connection
between finite paths (specific to Goguen-Meseguer noninterference) and
infinite paths (specific to the HyperCTL* semantics).
The desired Kripke structure produced from a Goguen-Meseguer model 
will actually be such a specialized structure.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Shallow_Idle</span><span> </span><span class="delimiter">=</span><span> </span><span>Shallow</span><span> </span><span>S</span><span> </span><span class="string"><span class="delete"><span class="delete">"s0"</span></span></span><span> </span><span>δ</span><span> </span><span>AP</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'state set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s0</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'state</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>δ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'state ⇒ 'state set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>AP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'aprop set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'state ⇒ 'state ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>g</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'state ⇒ 'state ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Sink</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'state set"</span></span></span><span>
</span><span>  </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>Sink_S</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Sink ⊆ S"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Sink</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ s. s ∈ S ⟹ ∃ s'. s' ∈ δ s ∩ Sink"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Sink_idle</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ s. s ∈ Sink ⟹ s ∈ δ s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Sink_f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ s1 s2. {s1,s2} ⊆ Sink ⟹ f s1 s2"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"toSink s ≡ SOME s'. s' ∈ δ s ∩ Sink"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>toSink</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ S ⟹ toSink s ∈ δ s ∩ Sink"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>toSink_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Sink</span><span> </span><span>someI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fall2_imp_alw</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"fall2 (λ π' π πl. imp (alw (φ πl)) (alw (ψ πl)) (πl @ [π,π'])) []
 ⟷
 (∀ π π'. wfp AP' π ∧ wfp AP' π' ∧ stateOf π = s0 ∧ stateOf π' = s0
           ⟶ imp (alw (φ [])) (alw (ψ [])) [π,π']
 )"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>fall2_intro</span><span> </span><span>imp_intro</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>fall2_elim</span><span> </span><span>imp_elim</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>imp_elim</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wfp_stateOf_shift_stake_sconst</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>π</span><span> </span><span>i</span><span>
</span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"π1 ≡ shift (stake (Suc i) π) (sconst (toSink (fst (π !! i)), L (toSink (fst (π !! i)))))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>π</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wfp AP' π"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wfp AP' π1 ∧ stateOf π1 = stateOf π"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>π1_less</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ k. k &lt; Suc i ⟹ π1 !! k = π !! k"</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>π1_geq</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ k. k &gt; i ⟹ π1 !! k = (toSink (fst (π !! i)) , L (toSink (fst (π !! i))))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>π1_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>stake.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>k</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (π1 !! Suc k) ∈ δ (fst (π1 !! k))"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"k &lt; Suc i"</span></span></span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>     </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"π1 !! k = π !! k"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>     </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>     </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"k &lt; i"</span></span></span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc k &lt; Suc i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>       </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>π</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>π1_less</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span class="delimiter">]</span><span> </span><span>0</span><span> </span><span>wfp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>     </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>       </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc k &gt; i"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>k</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"k = i"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>       </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>π</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>π1_geq</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span class="delimiter">]</span><span> </span><span>0</span><span> </span><span>wfp</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>k</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>IntD1</span><span> </span><span>fstI</span><span> </span><span>toSink</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>     </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>k</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"k &gt; i"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sk</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc k &gt; i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>     </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>π1_geq</span><span class="delimiter">[</span><span>OF</span><span> </span><span>k</span><span class="delimiter">]</span><span> </span><span>π1_geq</span><span class="delimiter">[</span><span>OF</span><span> </span><span>sk</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>π</span><span> </span><span>wfp</span><span> </span><span>Sink_idle</span><span> </span><span>toSink</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>k</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (π1 !! k) ∈ S ∧ snd (π1 !! k) ⊆ AP' ∧ snd (π1 !! k) ∩ AP = L (fst (π1 !! k))"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"k &lt; Suc i"</span></span></span><span class="delimiter">,</span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>lifting</span><span class="delimiter">,</span><span> </span><span>no_types</span><span class="delimiter">)</span><span> </span><span>π</span><span> </span><span>wfp</span><span> </span><span>AP_AP'</span><span> </span><span>IntD1</span><span> </span><span>L</span><span> </span><span>δ</span><span> </span><span>inf.orderE</span><span> </span><span>order_trans</span><span> </span><span>rev_subsetD</span><span> </span><span>toSink</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wfp AP' π1"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wfp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"stateOf π1 = stateOf π"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>π1_def</span><span> </span><span>shift.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>stake.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>stream.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fall2_imp_alw_index</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ π π'. wfp AP' π ∧ wfp AP' π' ⟶
                     φ [] [π,π'] = f (stateOf π) (stateOf π') ∧
                     ψ [] [π,π'] = g (stateOf π) (stateOf π')"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"fall2 (λ π' π πl. imp (alw (φ πl)) (alw (ψ πl)) (πl @ [π,π'])) []
 ⟷
 (∀ π π'. wfp AP' π ∧ wfp AP' π' ∧ stateOf π = s0 ∧ stateOf π' = s0
           ⟶
           (∀ i. (∀ j ≤ i. f (fst (π !! j)) (fst (π' !! j))) ⟶ g (fst (π !! i)) (fst (π' !! i)))
 )"</span></span></span><span>
</span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?L ⟷ ?R"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ i π π'. wfp AP' π ∧ wfp AP' π' ⟶
                      f (fst (π !! i)) (fst (π' !! i)) = φ [] [sdrop i π, sdrop i π'] ∧
                      g (fst (π !! i)) (fst (π' !! i)) = ψ [] [sdrop i π, sdrop i π']"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fall2_imp_alw</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>iffI</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">,</span><span> </span><span>elim</span><span> </span><span>conjE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>π</span><span> </span><span>π'</span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>L</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ π π'. wfp AP' π ∧ wfp AP' π' ∧ stateOf π = s0 ∧ stateOf π' = s0
                       ⟶ imp (alw (φ [])) (alw (ψ [])) [π,π']"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ππ'</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wfp AP' π"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wfp AP' π'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"stateOf π = s0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"stateOf π' = s0"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>φ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀j≤i. f (fst (π !! j)) (fst (π' !! j))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ππ'i</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ i. wfp AP' (sdrop i π) ∧ wfp AP' (sdrop i π')"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ππ'</span><span> </span><span>wfp_sdrop</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>π1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"π1 = shift (stake (Suc i) π) (sconst (toSink (fst (π !! i)), L (toSink (fst (π !! i)))))"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>π1'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"π1' = shift (stake (Suc i) π') (sconst (toSink (fst (π' !! i)), L (toSink (fst (π' !! i)))))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>π1π1'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wfp AP' π1 ∧ stateOf π1 = s0 ∧ wfp AP' π1' ∧ stateOf π1' = s0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wfp_stateOf_shift_stake_sconst</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>π1_def</span><span> </span><span>π1'_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>π1π1'i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ i. wfp AP' (sdrop i π1) ∧ wfp AP' (sdrop i π1')"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ππ'</span><span> </span><span>wfp_sdrop</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>imp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"imp (alw (φ [])) (alw (ψ [])) [π1,π1']"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L</span><span>  </span><span>π1π1'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"alw (φ []) [π1,π1']"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>alw</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>k</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (π !! i) ∈ S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (π' !! i) ∈ S"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ππ'</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wfp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ [] (map (sdrop k) [π1, π1'])"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>φ</span><span> </span><span>0</span><span> </span><span>π1π1'i</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>π1_def</span><span> </span><span>π1'_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"k &lt; Suc i"</span></span></span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>stake.simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>toSink</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a</span><span class="delimiter">]</span><span> </span><span>toSink</span><span class="delimiter">[</span><span>OF</span><span> </span><span>b</span><span class="delimiter">]</span><span> </span><span>Sink_f</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"alw (ψ []) [π1,π1']"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ψ [] [sdrop i π1, sdrop i π1']"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>alw</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g (fst (π1 !! i)) (fst (π1' !! i))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>0</span><span> </span><span>π1π1'i</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g (fst (π !! i)) (fst (π' !! i))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>π1_def</span><span> </span><span>π1'_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>stake.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sdrop_imp_alw</span><span> </span><span>1</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* context Shallow-Idle *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹end-of-context Shallow-Idle›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Faithful representation as a HyperCTL* property›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Starting with a Goguen-Meseguer model, we will produce a specialized
Kripke structure and a shallow HyperCTL* formula.
Then we we will prove that the structure satisfies the formula iff the
Goguen-Meseguer model satisfies noninterference.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹
The Kripke structure has two kinds of states: ``idle'' states storing Goguen-Meseguer states,
and normal states storing Goguen-Meseguer states, users and commands: the former 
will be used for synchronization and the latter for Goguen-Meseguer steps.
The Kripke labels store user-command actions and user-output observations.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'St</span><span class="delimiter">,</span><span class="tfree">'U</span><span class="delimiter">,</span><span class="tfree">'C</span><span class="delimiter">)</span><span> </span><span>state</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>isIdle</span><span class="delimiter">:</span><span> </span><span>Idle</span><span> </span><span class="delimiter">(</span><span>getGMState</span><span class="delimiter">:</span><span> </span><span class="tfree">'St</span><span class="delimiter">)</span><span> </span><span class="delimiter">|</span><span> </span><span>isState</span><span class="delimiter">:</span><span> </span><span>State</span><span> </span><span class="delimiter">(</span><span>getGMState</span><span class="delimiter">:</span><span> </span><span class="tfree">'St</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>getGMUser</span><span class="delimiter">:</span><span> </span><span class="tfree">'U</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>getGMCom</span><span class="delimiter">:</span><span> </span><span class="tfree">'C</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'U</span><span class="delimiter">,</span><span class="tfree">'C</span><span class="delimiter">,</span><span class="tfree">'Out</span><span class="delimiter">)</span><span> </span><span>aprop</span><span> </span><span class="delimiter">=</span><span> </span><span>Last</span><span> </span><span class="tfree">'U</span><span> </span><span class="tfree">'C</span><span> </span><span class="delimiter">|</span><span> </span><span>Obs</span><span> </span><span class="tfree">'U</span><span> </span><span class="tfree">'Out</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>getGMUserCom</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"getGMUserCom s = (getGMUser s, getGMCom s)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>getGMUserCom</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"getGMUserCom (State st u c) = (u,c)"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>getGMUserCom_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>GM_sec_model</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>L</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('St,'U,'C) state ⇒ ('U,'C,'Out) aprop set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"L (Idle st) = {Obs u' (out st u') | u'. True}"</span></span></span><span>
</span><span class="delimiter">|</span><span class="string"><span class="delete"><span class="delete">"L (State st u c) = {Last u c} ∪ {Obs u' (out st u') | u'. True}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Get the Goguen-Meseguer state:›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>getGMState</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"getGMState (Idle st) = st"</span></span></span><span>
</span><span class="delimiter">|</span><span class="string"><span class="delete"><span class="delete">"getGMState (State st u c) = st"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Last_in_L</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Last u c ∈ L s ⟷ (∃ st. s = State st u c)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Obs_in_L</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Obs u ou ∈ L s ⟷ ou = out (getGMState s) u"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>δ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('St,'U,'C) state ⇒ ('St,'U,'C) state set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"δ (Idle st) = {Idle st} ∪ {State (do st u' c') u' c' | u' c'. True}"</span></span></span><span>
</span><span class="delimiter">|</span><span class="string"><span class="delete"><span class="delete">"δ (State st u c) = {Idle st} ∪ {State (do st u' c') u' c' | u' c'. True}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>s0</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s0 ≡ State st0 any any"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'U, 'b) state ⇒ ('c, 'U, 'b) state ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"f s s' ≡
 ∀ u c. u ∉ GH ⟶ ((∃ st. s = State st u c) ⟷ (∃ st'. s' = State st' u c))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>g</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('St, 'a, 'b) state ⇒ ('St, 'c, 'd) state ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"g s s' ≡ ∀ u1. u1 ∈ GL ⟶ out (getGMState s) u1 = out (getGMState s') u1"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>f_id</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f s s"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>f_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Sink</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('St,'U,'C) state set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"Sink = {Idle st | st . True}"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* context GM_sec_model *)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>GM_sec_model</span><span> </span><span class="delimiter">&lt;</span><span> </span><span>Shallow_Idle</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>S</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"UNIV::('St,'U,'C) state set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>AP</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"UNIV :: ('U,'C,'Out) aprop set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>AP'</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"UNIV :: ('U,'C,'Out) aprop set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s0</span><span> </span><span class="delimiter">=</span><span> </span><span>s0</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>L</span><span> </span><span class="delimiter">=</span><span> </span><span>L</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>δ</span><span> </span><span class="delimiter">=</span><span> </span><span>δ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span> </span><span class="delimiter">=</span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>g</span><span> </span><span class="delimiter">=</span><span> </span><span>g</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Sink</span><span> </span><span class="delimiter">=</span><span> </span><span>Sink</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃s'. s' ∈ δ s ∩ Sink"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"Idle (getGMState s)"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Sink_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ Sink"</span></span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ δ s"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Sink_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s1</span><span> </span><span>s2</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{s1, s2} ⊆ Sink"</span></span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f s1 s2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Sink_def</span><span> </span><span>f_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>GM_sec_model</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>apropsOf_L_stateOf</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"wfp AP' π ⟹ apropsOf π = L (stateOf π)"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wfp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Int_UNIV_right</span><span> </span><span>snth.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The equality of two states w.r.t.\ a given ``last'' user-command pair:›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>eqOnUC</span><span> </span><span class="delimiter">::</span><span>
</span><span class="string"><span class="delete"><span class="delete">"nat ⇒ nat ⇒ 'U ⇒ 'C ⇒ (('St,'U,'C) state,('U,'C,'Out) aprop) sfmla"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"eqOnUC i i' u c ≡ eq (atom (Last u c) i) (atom (Last u c) i')"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The equality of two states w.r.t.\ all their ``last'' user-command pairs with
the user not in GH:›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>eqButGH</span><span> </span><span class="delimiter">::</span><span>
</span><span class="string"><span class="delete"><span class="delete">"nat ⇒ nat ⇒ (('St,'U,'C) state,('U,'C,'Out) aprop) sfmla"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"eqButGH i i' ≡ scon {eqOnUC i i' u c | u c. (u,c) ∈ (UNIV - GH) × UNIV}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The equality of two states w.r.t.\ a given ``observed'' user-observation pair:›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>eqOnUOut</span><span> </span><span class="delimiter">::</span><span>
</span><span class="string"><span class="delete"><span class="delete">"nat ⇒ nat ⇒ 'U ⇒ 'Out ⇒ (('St,'U,'C) state,('U,'C,'Out) aprop) sfmla"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"eqOnUOut i i' u ou ≡ eq (atom (Obs u ou) i) (atom (Obs u ou) i')"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The equality of two states w.r.t.\ all their ``observed'' user-observation pairs with
the user in GL:›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>eqOnGL</span><span> </span><span class="delimiter">::</span><span>
</span><span class="string"><span class="delete"><span class="delete">"nat ⇒ nat ⇒ (('St,'U,'C) state,('U,'C,'Out) aprop) sfmla"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"eqOnGL i i' ≡ scon {eqOnUOut i i' u ou | u ou. (u,ou) ∈ GL × UNIV}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eqOnUC_0_Suc0</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wfp AP' π"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wfp AP' π'"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"eqOnUC 0 (Suc 0) u c [π, π']
 ⟷
 ((∃st. stateOf π = State st u c) =
  (∃st'. stateOf π' = State st' u c)
 )"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eqOnUC_def</span><span> </span><span>atom_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>eq_equals</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eqOnUOut_0_Suc0</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wfp AP' π"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wfp AP' π'"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"eqOnUOut 0 (Suc 0) u ou [π, π']
 ⟷
 (ou = out (getGMState (stateOf π)) u ⟷
  ou = out (getGMState (stateOf π')) u
 )"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eqOnUOut_def</span><span> </span><span>atom_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>eq_equals</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The (shallow) noninterference formula -- it will be proved equivalent to nonint,
the original statement of noninterference.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>nonintSfmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('St,'U,'C) state,('U,'C,'Out) aprop) sfmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"nonintSfmla ≡
 fall2 (λ π' π πl.
        imp (alw (eqButGH (length πl) (Suc (length πl))))
            (alw (eqOnGL (length πl) (Suc (length πl))))
        (πl @ [π,π'])
       )"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹First, we show that nonintSfmla is equivalent to nonintSI, a variant of noninterference
that speaks about Synchronized Infinite paths.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>nonintSI</span><span> </span><span class="delimiter">::</span><span> </span><span>bool</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"nonintSI ≡
 ∀ π π'. wfp UNIV π ∧ wfp UNIV π' ∧ stateOf π = s0 ∧ stateOf π' = s0
           ⟶
          (∀ i. (∀ j ≤ i. f (fst (π !! j)) (fst (π' !! j))) ⟶ g (fst (π !! i)) (fst (π' !! i)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nonintSfmla_nonintSI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nonintSfmla [] ⟷ nonintSI"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>φ</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ πl = eqButGH (length πl) (Suc (length πl))"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>πl</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('St,'U,'C) state,('U,'C,'Out) aprop) path list"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>ψ</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ψ πl = eqOnGL (length πl) (Suc (length πl))"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>πl</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('St,'U,'C) state,('U,'C,'Out) aprop) path list"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ π π'. wfp UNIV π ∧ wfp UNIV π' ⟶
                 φ [] [π,π'] = f (stateOf π) (stateOf π') ∧
                 ψ [] [π,π'] = g (stateOf π) (stateOf π')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>φ_def</span><span> </span><span>ψ_def</span><span> </span><span>f_def</span><span> </span><span>g_def</span><span> </span><span>eqButGH_def</span><span> </span><span>eqOnGL_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>scon_def</span><span> </span><span>eqOnUC_0_Suc0</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>fall2_imp_alw_index</span><span class="delimiter">[</span><span>of</span><span> </span><span>φ</span><span> </span><span>ψ</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>nonintSfmla_def</span><span> </span><span>nonintSI_def</span><span> </span><span>φ_def</span><span> </span><span>ψ_def</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹In turn, nonintSI will be shown equivalent to nonintS, a variant speaking about
Synchronized finite paths. To this end, we introduce a notion of well-formed finite path (wffp) -- besides
finiteness, another difference from the previously defined infinite paths is that, thanks to
the fact that here AP coincides with AP', paths are mere sequences of states as opposed
to pairs (state,set of atomic predicates).›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>wffp</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('St,'U,'C) state list ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>Singl</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp [s]"</span></span></span><span>
</span><span class="delimiter">|</span><span>
</span><span>Cons</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦s' ∈ δ s; wffp (s' # sl)⟧
 ⟹
 wffp (s # s' # sl)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wffp_induct2</span><span class="delimiter">[</span><span>consumes</span><span> </span><span>1</span><span class="delimiter">,</span><span> </span><span>case_names</span><span> </span><span>Singl</span><span> </span><span>Cons</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp sl"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ s. P [s]"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ s sl. ⟦hd sl ∈ δ s; wffp sl; P sl⟧ ⟹ P (s # sl)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P sl"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>induct</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>nonintS</span><span> </span><span class="delimiter">::</span><span> </span><span>bool</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"nonintS ≡
 ∀ sl sl'. wffp sl ∧ wffp sl' ∧ hd sl = s0 ∧ hd sl' = s0 ∧
            list_all2 f sl sl' ⟶ g (last sl) (last sl')"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wffp_NE</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp sl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sl ≠ []"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>induct</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wffp</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"wffp sl ⟷ sl ≠ [] ∧ (∀ i. Suc i &lt; length sl ⟶ sl!(Suc i) ∈ δ(sl!i))"</span></span></span><span>
</span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?L ⟷ ?A ∧ (∀ i. ?R i)"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>iffI</span><span> </span><span>allI</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?L</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?R i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>s'</span><span> </span><span>s</span><span> </span><span>sl</span><span> </span><span>i</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>i</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?A ∧ (∀ i. ?R i)"</span></span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?L</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>sl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>s</span><span> </span><span>sl</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>safe</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>sl</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>wffp.intros</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>wffp.intros</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wffp_NE</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wffp_hdI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp sl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hd sl ∈ δ s"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp (s # sl)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>sl</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wffp_append</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>sl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp sl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sl1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp sl1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hd sl1 ∈ δ (last sl)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp (sl @ sl1)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sl</span><span> </span><span>h</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>sl</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sl1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wffp_append_iff</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"wffp (sl @ sl1) ⟷
 (wffp sl ∧ sl1 = []) ∨
 (sl = [] ∧ wffp sl1) ∨
 (wffp sl ∧ wffp sl1 ∧ hd sl1 ∈ δ (last sl))"</span></span></span><span>
</span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_ ⟷ ?R"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp (sl @ sl1)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?R</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span class="string"><span class="delete"><span class="delete">"sl @ sl1"</span></span></span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>sl</span><span> </span><span>sl1</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>list.induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>s</span><span> </span><span>sl</span><span> </span><span>sl1</span><span> </span><span>sl2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>C</span><span> </span><span class="delimiter">=</span><span> </span><span>Cons</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"sl1 = [] ∨ sl2 = []"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>sll1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>sl1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sl1 = s # sll1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sl</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sl = sll1 @  sl2"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>sl1</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wsl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp sl"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>C</span><span> </span><span>False</span><span> </span><span>append_is_Nil_conv</span><span> </span><span>list.inject</span><span> </span><span>sl</span><span> </span><span>wffp.simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>sl</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>sl</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>wsl</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>C</span><span> </span><span>False</span><span> </span><span>wffp_hdI</span><span> </span><span>append_is_Nil_conv</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>hd_append</span><span>
</span><span>                </span><span>last.simps</span><span> </span><span>list.inject</span><span> </span><span>sl</span><span> </span><span>sl1</span><span> </span><span>wffp.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span class="delimiter">(</span><span>insert</span><span> </span><span>C</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wffp_append</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wffp_to_wfp</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>π_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"π = map (λ s. (s, L s)) sl @- sconst (toSink (last sl), L (toSink (last sl)))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>sl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp sl"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"wfp UNIV π ∧
 (∀ i &lt; length sl. sl ! i = fst (π !! i)) ∧
 (∀ i ≥ length sl. fst (π !! i) = toSink (last sl)) ∧
 stateOf π = hd sl"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wfp</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>safe</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span> </span><span>s</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ snd (π !! i)"</span></span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ L (fst (π !! i))"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>π_def</span><span> </span><span>wffp</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length sl"</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ L (fst (π !! i))"</span></span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ snd (π !! i)"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>π_def</span><span> </span><span>wffp</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length sl"</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>j</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j &lt; length sl"</span></span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sl!j = fst (π !! j)"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>π_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>sl</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>j</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>1</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>j</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j ≥ length sl"</span></span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (π !! j) = toSink (last sl)"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sl</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>π_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>2</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (π !! Suc i) ∈ δ (fst (π !! i))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"length sl ≤ Suc i"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc i &lt; length sl"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (π !! Suc i) = sl!(Suc i) ∧ fst (π !! i) = sl!i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sl</span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wffp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>sl</span><span> </span><span class="delimiter">=</span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>22</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (π !! Suc i) = toSink (last sl)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"length sl ≤ i"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (π !! i) = toSink (last sl)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>22</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>IntD2</span><span> </span><span>Sink_idle</span><span> </span><span>UNIV_I</span><span> </span><span>toSink</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"last sl = sl!i"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sl</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_eq_plus1</span><span> </span><span>diff_add_inverse2</span><span> </span><span>last_conv_nth</span><span> </span><span>le0</span><span> </span><span>le_Suc_eq</span><span> </span><span>length_0_conv</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (π !! i) = sl!i"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>False</span><span> </span><span>1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>22</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>IntD1</span><span> </span><span>UNIV_I</span><span> </span><span>toSink</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"stateOf π = hd sl"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wffp_NE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>sl</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>π_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>sl</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wffp_imp_appendL</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp (sl1 @ sl2) ⟹ sl1 ≠ [] ⟹ wffp sl1"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>wffp_append_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wffp_imp_appendR</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp (sl1 @ sl2) ⟹ sl2 ≠ [] ⟹ wffp sl2"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>wffp_append_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wffp_iff_map_Idle</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp sl"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"∃ n st.
   (n &gt; 0 ∧ sl = map Idle (replicate n st)) ∨
   (∃ st1 u1 c1 sl1. sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>wffp_induct2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Singl</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Idle</span><span> </span><span>st</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Idle</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc 0"</span></span></span><span class="delimiter">]</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>st</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>State</span><span> </span><span>st1</span><span> </span><span>u1</span><span> </span><span>c1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>State</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>0</span><span class="delimiter">]</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>st</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>s</span><span> </span><span>sl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span> </span><span>st</span><span>
</span><span>   </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>n</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n &gt; 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sl = map Idle (replicate n st)"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>n</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n = Suc n'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>n</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>sl'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sl = (Idle st) # map Idle (replicate n' st)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Idle</span><span> </span><span>st1</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>st1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"st1 = st"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹hd sl ∈ δ s›</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sl'</span><span> </span><span>Idle</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>     </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc n"</span></span></span><span class="delimiter">]</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>st</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sl</span><span> </span><span>Idle</span><span> </span><span>st1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>State</span><span> </span><span>st1</span><span> </span><span>u1</span><span> </span><span>c1</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s # sl = map Idle (replicate 0 st) @ [State st1 u1 c1] @ sl"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>     </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span> </span><span>st</span><span> </span><span>st1</span><span> </span><span>u1</span><span> </span><span>c1</span><span> </span><span>sl1</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>sl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Idle</span><span> </span><span>st2</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>     </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>       </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s # sl = map Idle (replicate (Suc 0) st2) @ [State st1 u1 c1] @ sl1"</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sl</span><span> </span><span>Idle</span><span> </span><span>0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>       </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>     </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>       </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>n'</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>sl'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sl = (Idle st) # map Idle (replicate n' st) @ [State st1 u1 c1] @ sl1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>       </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>st2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"st2 = st"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹hd sl ∈ δ s›</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sl'</span><span> </span><span>Idle</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>       </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s # sl = map Idle (replicate (Suc n) st) @ [State st1 u1 c1] @ sl1"</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sl</span><span> </span><span>Idle</span><span> </span><span>st2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>       </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>     </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>State</span><span> </span><span>st1</span><span> </span><span>u1</span><span> </span><span>c1</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s # sl = map Idle (replicate 0 st) @ [State st1 u1 c1] @ sl"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>     </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wffp_cases3</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">,</span><span> </span><span>consumes</span><span> </span><span>1</span><span class="delimiter">,</span><span> </span><span>case_names</span><span> </span><span>Idle</span><span> </span><span>State</span><span> </span><span>Idle_State</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp sl"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">obtains</span></span><span>
</span><span>n</span><span> </span><span>st</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"n &gt; 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sl = map Idle (replicate n st)"</span></span></span><span>
</span><span class="delimiter">|</span><span>
</span><span>st</span><span> </span><span>u</span><span> </span><span>c</span><span> </span><span>sl1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"sl = State st u c # sl1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sl1 ≠ [] ⟹ wffp sl1 ∧ hd sl1 ∈ δ (State st u c)"</span></span></span><span>
</span><span class="delimiter">|</span><span>
</span><span>n</span><span> </span><span>st</span><span> </span><span>u</span><span> </span><span>c</span><span> </span><span>sl1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"n &gt; 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sl = map Idle (replicate n st) @ [State (do st u c) u c] @ sl1"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sl1 ≠ [] ⟹ wffp sl1 ∧ hd sl1 ∈ δ (State (do st u c) u c)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span> </span><span>st</span><span>
</span><span>   </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>n</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n &gt; 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sl = map Idle (replicate n st)"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span> </span><span>st</span><span> </span><span>st1</span><span> </span><span>u1</span><span> </span><span>c1</span><span> </span><span>sl1</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>sl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sl1 ≠ [] ⟹ wffp sl1 ∧ hd sl1 ∈ δ (State st1 u1 c1)"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append_is_Nil_conv</span><span> </span><span>assms</span><span> </span><span>last.simps</span><span> </span><span>not_Cons_self2</span><span> </span><span>sl</span><span> </span><span>wffp_append_iff</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>thesis</span><span>
</span><span>   </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>     </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sl = State st1 u1 c1 # sl1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sl</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>     </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>   </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>n'</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"replicate n st = replicate n' st @ [st]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>replicate_Suc</span><span> </span><span>replicate_append_same</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp (map Idle [st] @ [State st1 u1 c1])"</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sl</span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>map_append</span><span> </span><span>append_assoc</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>append_assoc</span><span> </span><span>append_is_Nil_conv</span><span> </span><span>append_self_conv</span><span>
</span><span>                 </span><span>append_singl_rev</span><span> </span><span>neq_Nil_conv</span><span> </span><span>wffp_imp_appendL</span><span> </span><span>wffp_imp_appendR</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>st1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"st1 = do st u1 c1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>wffp.cases</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n &gt; 0"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>     </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>sl</span><span> </span><span>st1</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wffp_iff_map_Idle</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wffp_cases2</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">,</span><span> </span><span>consumes</span><span> </span><span>1</span><span class="delimiter">,</span><span> </span><span>case_names</span><span> </span><span>Idle</span><span> </span><span>State</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp sl"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">obtains</span></span><span>
</span><span>n</span><span> </span><span>st</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"n &gt; 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sl = map Idle (replicate n st)"</span></span></span><span>
</span><span class="delimiter">|</span><span>
</span><span>n</span><span> </span><span>st</span><span> </span><span>st1</span><span> </span><span>u</span><span> </span><span>c</span><span> </span><span>sl1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"sl = map Idle (replicate n st) @ [State st1 u c] @ sl1"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sl1 ≠ [] ⟹ wffp sl1 ∧ hd sl1 ∈ δ (State st1 u c)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>sl</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>wffp_cases3</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>metis</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append_Cons</span><span> </span><span>append_Nil</span><span> </span><span>list.map</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>replicate_0</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append_Cons</span><span> </span><span>append_Nil</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wffp_Idle_Idle</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp (sl1 @ [Idle st1] @ [Idle st2] @ sl2)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"st2 = st1"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp [Idle st1, Idle st2]"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>wffp_imp_appendR</span><span> </span><span>append_assoc</span><span> </span><span>append_singl_rev</span><span> </span><span>list.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>wffp_imp_appendL</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wffp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wffp_Idle_State</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp (sl1 @ [Idle st1] @ [State st2 u2 c2] @ sl2)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"st2 = st1 ∨ st2 = do st1 u2 c2"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp [Idle st1, State st2 u2 c2]"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>wffp_imp_appendR</span><span> </span><span>append_assoc</span><span> </span><span>append_singl_rev</span><span> </span><span>list.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>wffp_imp_appendL</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wffp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wffp_State_Idle</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp (sl1 @ [State st1 u1 c1] @ [Idle st2] @ sl2)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"st2 = st1"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp [State st1 u1 c1, Idle st2]"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>wffp_imp_appendR</span><span> </span><span>append_assoc</span><span> </span><span>append_singl_rev</span><span> </span><span>list.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>wffp_imp_appendL</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wffp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wffp_State_State</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp (sl1 @ [State st1 u1 c1] @ [State st2 u2 c2] @ sl2)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"st2 = do st1 u2 c2"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp [State st1 u1 c1, State st2 u2 c2]"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>wffp_imp_appendR</span><span> </span><span>append_assoc</span><span> </span><span>append_singl_rev</span><span> </span><span>list.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>wffp_imp_appendL</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wffp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wfp_to_wffp</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>sl_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sl = map fst (stake i π)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &gt; 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>π</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wfp UNIV π"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"wffp sl ∧
 (∀ j &lt; length sl. fst (π !! j) = sl ! j) ∧
 stateOf π = hd sl"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wffp</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>j</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"stake i π ≠ []"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"stateOf π = hd sl"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sl_def</span><span> </span><span>hd_map</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span class="delimiter">(</span><span>insert</span><span> </span><span>assms</span><span class="delimiter">,</span><span> </span><span>unfold</span><span> </span><span>sl_def</span><span> </span><span>wfp</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nonintSI_nonintS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nonintSI ⟷ nonintS"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>unfold</span><span> </span><span>nonintS_def</span><span> </span><span>nonintSI_def</span><span class="delimiter">,</span><span> </span><span>safe</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>sl</span><span> </span><span>sl'</span><span> </span><span>i</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>π</span><span> </span><span>π'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>π</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"π = map (λ s. (s, L s)) sl @- sconst (toSink (last sl), L (toSink (last sl)))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>π'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"π' = map (λ s. (s, L s)) sl' @- sconst (toSink (last sl'), L (toSink (last sl')))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ π π'.
    wfp UNIV π ∧ wfp UNIV π' ∧ stateOf π = s0 ∧ stateOf π' = s0
    ⟶
    (∀ i. (∀ j ≤ i. f (fst (π !! j)) (fst (π' !! j))) ⟶ g (fst (π !! i)) (fst (π' !! i)))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>slsl'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp sl"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp sl'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hd sl = s0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hd sl' = s0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"list_all2 f sl sl'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length sl = length sl'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ i &lt; length sl. f (sl ! i) (sl' ! i)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>list_all2_conv_all_nth</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>i0</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i0 = length sl - 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>slsl'_NE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sl ≠ [] ∧ sl' ≠ []"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>slsl'</span><span> </span><span>wffp_NE</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>last</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"last sl = sl!i0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"last sl' = sl'!i0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>i0_def</span><span> </span><span>l</span><span> </span><span>slsl'</span><span> </span><span>last_conv_nth</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>i0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i0 &lt; length sl"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i0 &lt; length sl'"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>i0_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l</span><span> </span><span>slsl'</span><span> </span><span>slsl'_NE</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>j</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ j ≤ i0. f (sl ! j) (sl' ! j)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i</span><span> </span><span>slsl'_NE</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>i0_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_diff_eq_diff_pred</span><span> </span><span>Suc_diff_le</span><span> </span><span>Zero_neq_Suc</span><span> </span><span>diff_is_0_eq'</span><span>
</span><span>            </span><span>le_less_linear</span><span> </span><span>length_greater_0_conv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g (last sl) (last sl')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>last</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>0</span><span> </span><span>slsl'</span><span> </span><span>j</span><span> </span><span>i0</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wffp_to_wfp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>π</span><span class="delimiter">]</span><span> </span><span>wffp_to_wfp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>π'</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>π</span><span> </span><span>π'</span><span> </span><span>i</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∀ sl sl'. wffp sl ∧ wffp sl' ∧ hd sl = s0 ∧ hd sl' = s0 ∧ list_all2 f sl sl' ⟶ g (last sl) (last sl')"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ππ'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wfp UNIV π"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wfp UNIV π'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>state</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"stateOf π = s0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"stateOf π' = s0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀j≤i. f (fst (π !! j)) (fst (π' !! j))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>R</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∀ sl sl'. wffp sl ∧ wffp sl' ∧ hd sl = s0 ∧ hd sl' = s0 ∧ length sl = length sl'
            ⟶
            ((∀ i &lt; length sl. f (sl!i) (sl'!i)) ⟶ g (last sl) (last sl'))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>list_all2_conv_all_nth</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>i0</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i0 = Suc i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>i0_ge</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i0 &gt; 0"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>i0_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ii0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; i0"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>i0_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀j&lt;i0. f (fst (π !! j)) (fst (π' !! j))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>i0_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>sl</span><span> </span><span>sl'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>sl_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sl = map fst (stake i0 π)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sl'_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sl' = map fst (stake i0 π')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>i0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i0 = length sl"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length sl' = length sl"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>i0_def</span><span> </span><span>sl_def</span><span> </span><span>sl'_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sl!i = last sl"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sl'!i = last sl'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i0</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>i0_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>last_conv_nth</span><span> </span><span>length_greater_0_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>diff_Suc_1</span><span> </span><span>i0</span><span> </span><span>i0_ge</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g (fst (π !! i)) (fst (π' !! i))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wfp_to_wffp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>sl_def</span><span> </span><span>i0_ge</span><span> </span><span>ππ'</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>wfp_to_wffp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>sl'_def</span><span> </span><span>i0_ge</span><span> </span><span>ππ'</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>R</span><span> </span><span>state</span><span> </span><span>f</span><span> </span><span>ii0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>1</span><span> </span><span>i0</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Finally, we show that nonintS is equivalent to standard
noninterference (predicate nonint).›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹purgeIdle removes the idle steps from a finite path:›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>purgeIdle</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('St, 'U, 'C) state list ⇒ ('St, 'U, 'C) state list"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"purgeIdle ≡ filter isState"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>purgeIdle_simps</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"purgeIdle [] = []"</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"purgeIdle ((Idle st) # sl) = purgeIdle sl"</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"purgeIdle ((State st u c) # sl) = (State st u c) # purgeIdle sl"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>purgeIdle_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>purgeIdle_append</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"purgeIdle (sl1 @ sl2) = purgeIdle sl1 @ purgeIdle sl2"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>purgeIdle_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>filter_append</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>purgeIdle_set_isState</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ set (purgeIdle sl)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isState s"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>purgeIdle_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>filter_set</span><span> </span><span>member_filter</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>purgeIdle_Nil_iff</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"purgeIdle sl = [] ⟷ (∀s∈set sl. ¬ isState s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>purgeIdle_def</span><span> </span><span>filter_empty_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>purgeIdle_Cons_iff</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"purgeIdle sl = s # sll
 ⟷
 (∃ sl1 sl2. sl = sl1 @ s # sl2 ∧
            (∀s1∈set sl1. ¬ isState s1) ∧ isState s ∧ purgeIdle sl2 = sll)"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>purgeIdle_def</span><span> </span><span>filter_eq_Cons_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>purgeIdle_map_Idle</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"purgeIdle (map Idle s) = []"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>purgeIdle_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>purgeIdle_replicate_Idle</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"purgeIdle (replicate n (Idle st)) = []"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>purgeIdle_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wffp_purgeIdle_Nil</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp sl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"purgeIdle sl = []"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ n st. n &gt; 0 ∧ sl = replicate n (Idle st)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>sl</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>wffp_induct2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Singl</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc 0"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>s</span><span> </span><span>sl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span>st</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>sl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sl = replicate n (Idle st)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>st1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s = Idle st1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hd (replicate n (Idle st)) = Idle st"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Cons.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>hd_replicate</span><span> </span><span>replicate_empty</span><span> </span><span>sl</span><span> </span><span>wffp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc n"</span></span></span><span class="delimiter">]</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>st</span><span class="delimiter">]</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sl</span><span> </span><span>1</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wffp_hd_purgeIdle</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>wsl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp sl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>psl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"purgeIdle sl ≠ []"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ist</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isState s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hsl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hd sl ∈ δ s"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hd (purgeIdle sl) ∈ δ s"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wsl</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>wffp_cases3</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Idle</span><span> </span><span>n</span><span> </span><span>st</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>psl</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Idle</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>State</span><span> </span><span>st</span><span> </span><span>u</span><span> </span><span>c</span><span> </span><span>sl1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>psl</span><span> </span><span>hsl</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>State</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Idle_State</span><span> </span><span>n</span><span> </span><span>st</span><span> </span><span>u</span><span> </span><span>c</span><span> </span><span>sl1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>psl</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n &gt; 0›</span></span></span><span> </span><span>ist</span><span> </span><span>hsl</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Idle_State</span><span> </span><span>purgeIdle_append</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wffp_purgeIdle</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp sl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"purgeIdle sl ≠ []"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp (purgeIdle sl)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>sl</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>length_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>sl</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>IH</span><span> </span><span class="delimiter">=</span><span> </span><span>1</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹wffp sl›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>sl</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>wffp_cases2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Idle</span><span> </span><span>n</span><span> </span><span>st</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"purgeIdle sl = []"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Idle</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹purgeIdle sl ≠ []›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>State</span><span> </span><span>n</span><span> </span><span>st</span><span> </span><span>st1</span><span> </span><span>u</span><span> </span><span>c</span><span> </span><span>sl1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"purgeIdle sl = State st1 u c # purgeIdle sl1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>map_replicate</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>purgeIdle_append</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"purgeIdle sl1 = []"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>psl1</span><span> </span><span class="delimiter">=</span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>1</span><span> </span><span>psl1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>sl1NE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sl1 ≠ []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>sl1</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>sl1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp sl1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hsl1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hd sl1 ∈ δ (State st1 u c)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>State</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length sl1 &lt; length sl"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>State</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>sl1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp (purgeIdle sl1)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>sl1</span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hd (purgeIdle sl1) ∈ δ (State st1 u c)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>False</span><span> </span><span>GM_sec_model.wffp_hd_purgeIdle</span><span> </span><span>State</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>sl1NE</span><span> </span><span>state.discI</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isState_purgeIdle</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"(∃ sl. purgeIdle sl = sll) ⟷ list_all isState sll"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>purgeIdle_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ball_set_list_all</span><span> </span><span>purgeIdle_def</span><span> </span><span>purgeIdle_set_isState</span><span> </span><span>filter_True</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wffp_last_purgeIdle</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp sl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"purgeIdle sl ≠ []"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"getGMState (last (purgeIdle sl)) = getGMState (last sl)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>sl</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>wffp_induct2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Singl</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>s</span><span> </span><span>sl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>slNE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sl ≠ []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>wffp_NE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"purgeIdle sl = []"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span>st</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>sl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sl = replicate n (Idle st)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Cons.hyps</span><span> </span><span>wffp_purgeIdle_Nil</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>n</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n &gt; 0"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>slNE</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>hsl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hd sl = Idle st"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lsl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"last sl = Idle st"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isState s"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"getGMState s = st"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹hd sl ∈ δ s›</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hsl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>slNE</span><span> </span><span>n</span><span> </span><span>1</span><span> </span><span>hsl</span><span> </span><span>lsl</span><span> </span><span>s</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sl</span><span> </span><span>purgeIdle_replicate_Idle</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wffp_isState_doo</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp sl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"list_all isState sl"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"doo (getGMState (hd sl)) (map getGMUserCom (tl sl)) = getGMState (last sl)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>sl</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>wffp_induct2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>s</span><span> </span><span>sl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>st</span><span> </span><span>u</span><span> </span><span>c</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s = State st u c"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span> </span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sl ≠ []"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sl1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sl = hd sl # tl sl"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wffp_NE</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹wffp sl›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>st1</span><span> </span><span>u1</span><span> </span><span>c1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>hsl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hd sl = State st1 u1 c1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>isState_purgeIdle</span><span> </span><span>isState_def</span><span> </span><span>purgeIdle_Cons_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"getGMState (hd sl) = do st u1 c1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹hd sl ∈ δ s›</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hsl</span><span> </span><span>s</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"doo st (map getGMUserCom sl) = doo (do st u1 c1) (map getGMUserCom (tl sl))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>sl1</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>1</span><span> </span><span>hsl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sl</span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>1</span><span> </span><span>s</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isState_hd_purgeIdle</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>wsl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp sl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ist</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isState (hd sl)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"purgeIdle sl ≠ [] ∧ hd (purgeIdle sl) = hd sl"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ist</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>hd_Cons_tl</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wffp_NE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wsl</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"hd sl"</span></span></span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span>sl</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wffp_isState_doo_purgeIdle</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>sl</span><span> </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span>sll</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sll ≡ purgeIdle sl"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>wsl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp sl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ist</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isState (hd sl)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"doo (getGMState (hd sl)) (map getGMUserCom (tl sll)) = getGMState (last sl)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>1</span><span> </span><span class="delimiter">=</span><span> </span><span>isState_hd_purgeIdle</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wsl</span><span> </span><span>ist</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>wsll</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp sll"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>sll</span><span> </span><span>wffp_purgeIdle</span><span> </span><span>wsl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"doo (getGMState (hd sll)) (map getGMUserCom (tl sll)) = getGMState (last sll)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>wffp_isState_doo</span><span> </span><span>isState_purgeIdle</span><span> </span><span>sll</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>1</span><span> </span><span>sll</span><span> </span><span>wffp_last_purgeIdle</span><span> </span><span>wsl</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_getGMUserCom_surj</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isState s"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ sl. wffp sl ∧ list_all isState sl ∧ hd sl = s ∧ map getGMUserCom (tl sl) = ucl"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>ucl</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>s</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>list_pair_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"[s]"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>u</span><span> </span><span>c</span><span> </span><span>ucl</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>st1</span><span> </span><span>u1</span><span> </span><span>c1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s = State st1 u1 c1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>s1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s1 = State (do st1 u c) u c"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>sl</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>sl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp sl ∧ list_all isState sl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hsl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hd sl = s1"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>msl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"map getGMUserCom (tl sl) = ucl"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>s1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>s1_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s</span><span> </span><span>s1_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"s # sl"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>purgeIdle_purge_ex</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp sl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"list_all isState sl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map getGMUserCom (tl sl) = ucl"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ sl'. hd sl' = ss' ∧ wffp sl' ∧
              list_all2 f (tl sl) (tl sl') ∧
              map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>sl</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>ucl</span><span> </span><span>ss'</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>wffp_induct2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Singl</span><span> </span><span>s</span><span> </span><span>ucl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"[ss']"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ss'</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>ss</span><span> </span><span>sl</span><span> </span><span>ucl</span><span> </span><span>ss'</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>wsl</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹wffp sl›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>slNE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sl ≠ []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>wffp_NE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s</span><span> </span><span>sl1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>sl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sl = s # sl1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wffp_NE</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹wffp sl›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>sl</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>st</span><span> </span><span>u</span><span> </span><span>c</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s = State st u c"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>ucl1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ucl1 = tl ucl"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ucl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ucl = (u,c) # ucl1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hsl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hd sl = s"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>s</span><span> </span><span>ucl1_def</span><span> </span><span>sl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"list_all isState sl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"map getGMUserCom (tl sl) = ucl1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ucl1_def</span><span> </span><span>s</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>st'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"st' = getGMState ss'"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ GH"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>u</span><span> </span><span class="delimiter">=</span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>s'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('St, 'U, 'C) state"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s' = Idle st'"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>sl'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>hsl'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hd sl' = s'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>wsl'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp sl'"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>slsl'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"list_all2 f (tl sl) (tl sl')"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span> </span><span>2</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>s'</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>sl'NE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sl' ≠ []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>wffp_NE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp (ss' # sl')"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wsl'</span><span> </span><span>hsl'</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>s'_def</span><span> </span><span>st'_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ss'</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f s s'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>u</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>s'_def</span><span> </span><span>st'_def</span><span> </span><span>s</span><span> </span><span>f_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>     </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"list_all2 f sl sl'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>slsl'</span><span> </span><span>hsl</span><span> </span><span>hsl'</span><span> </span><span>slNE</span><span> </span><span>sl'NE</span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span>list_all2_Cons</span><span> </span><span>neq_Nil_conv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map getGMUserCom (purgeIdle sl') = purge GH ucl"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>hd_Cons_tl</span><span class="delimiter">[</span><span>OF</span><span> </span><span>sl'NE</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hsl'</span><span> </span><span>ucl</span><span> </span><span>s'_def</span><span> </span><span>u</span><span> </span><span>m</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"ss' # sl'"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>u</span><span> </span><span class="delimiter">=</span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>s'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s' = State (do st' u c) u c"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>sl'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>hsl'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hd sl' = s'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>wsl'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp sl'"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>slsl'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"list_all2 f (tl sl) (tl sl')"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span> </span><span>2</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>s'</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>sl'NE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sl' ≠ []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>wffp_NE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp (ss' # sl')"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wsl'</span><span> </span><span>hsl'</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>s'_def</span><span> </span><span>st'_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ss'</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f s s'"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>s'_def</span><span> </span><span>st'_def</span><span> </span><span>s</span><span> </span><span>f_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>     </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"list_all2 f sl sl'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>slsl'</span><span> </span><span>hsl</span><span> </span><span>hsl'</span><span> </span><span>slNE</span><span> </span><span>sl'NE</span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span>list_all2_Cons</span><span> </span><span>neq_Nil_conv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map getGMUserCom (purgeIdle sl') = purge GH ucl"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>hd_Cons_tl</span><span class="delimiter">[</span><span>OF</span><span> </span><span>sl'NE</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hsl'</span><span> </span><span>ucl</span><span> </span><span>s'_def</span><span> </span><span>u</span><span> </span><span>m</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"ss' # sl'"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>purgeIdle_getGMUserCom_purge</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>sl</span><span> </span><span>sl'</span><span>
</span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ucl ≡ map getGMUserCom (purgeIdle (tl sl))"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ucl' ≡ map getGMUserCom (purgeIdle (tl sl'))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>wsl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp sl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>wsl'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp sl'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"list_all2 f sl sl'"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"purge GH ucl = purge GH ucl'"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length sl = length sl'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>list_all2_lengthD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>ucl</span><span> </span><span>ucl'</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>list_induct2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>s</span><span> </span><span>sl</span><span> </span><span>s'</span><span> </span><span>sl'</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"sl = []"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sl' = []"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>sl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sl = hd sl # tl sl"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>sl</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>sl'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sl' = hd sl' # tl sl'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹length sl = length sl'›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>sl'</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>wsl</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp sl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>wsl'</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp sl'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sl</span><span> </span><span>Cons</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Cons.prems</span><span> </span><span>append_singl_rev</span><span> </span><span>list.distinct</span><span> </span><span>sl'</span><span> </span><span>wffp_imp_appendR</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f (hd sl) (hd sl')"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹list_all2 f (s # sl) (s' # sl')›</span></span></span><span> </span><span>sl</span><span> </span><span>sl'</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>list_all2_Cons</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"hd sl"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Idle</span><span> </span><span>st</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>hsl</span><span> </span><span class="delimiter">=</span><span> </span><span>Idle</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"hd sl'"</span></span></span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Idle</span><span> </span><span>st'</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>hsl'</span><span> </span><span class="delimiter">=</span><span> </span><span>Idle</span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>sl</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>sl'</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hsl</span><span> </span><span>hsl'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>State</span><span> </span><span>st'</span><span> </span><span>u'</span><span> </span><span>c'</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>hsl'</span><span> </span><span class="delimiter">=</span><span> </span><span>State</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>u'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u' ∈ GH"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hsl</span><span> </span><span>hsl'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>f_def</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>sl</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>sl'</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span>u'</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hsl</span><span> </span><span>hsl'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>State</span><span> </span><span>st</span><span> </span><span>u</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>hsl</span><span> </span><span class="delimiter">=</span><span> </span><span>State</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"hd sl'"</span></span></span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Idle</span><span> </span><span>st'</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>hsl'</span><span> </span><span class="delimiter">=</span><span> </span><span>Idle</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ GH"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hsl</span><span> </span><span>hsl'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>f_def</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>sl</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>sl'</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span>u</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hsl</span><span> </span><span>hsl'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>State</span><span> </span><span>st'</span><span> </span><span>u'</span><span> </span><span>c'</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>hsl'</span><span> </span><span class="delimiter">=</span><span> </span><span>State</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uu'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(u' ∈ GH ⟷ u ∈ GH) ∧ (u ∉ GH ⟶ u' = u ∧ c' = c)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hsl</span><span> </span><span>hsl'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>f_def</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>sl</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>sl'</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span>uu'</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hsl</span><span> </span><span>hsl'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ GH"</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nonintS_iff_nonint</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"nonintS ⟷ nonint"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>nonintS_def</span><span> </span><span>nonint_def</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>safe</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>ucl</span><span> </span><span>u</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span>
</span><span>  </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀sl sl'. wffp sl ∧ wffp sl' ∧ hd sl = s0 ∧ hd sl' = s0 ∧ list_all2 f sl sl' ⟶
               g (last sl) (last sl')"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ GL"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>sl</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>wsl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp sl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"list_all isState sl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hsl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hd sl = s0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"map getGMUserCom (tl sl) = ucl"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>map_getGMUserCom_surj</span><span class="delimiter">[</span><span>of</span><span> </span><span>s0</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>sl'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>hsl'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hd sl' = hd sl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>wsl'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp sl'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"list_all2 f (tl sl) (tl sl')"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>purgeIdle_purge_ex</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>slNE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sl ≠ []"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sl'NE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sl' ≠ []"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wsl</span><span> </span><span>wsl'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>wffp_NE</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"getGMState (hd sl) = st0"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hsl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tl (purgeIdle sl') = purgeIdle (tl sl')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>hd_Cons_tl</span><span class="delimiter">[</span><span>OF</span><span> </span><span>sl'NE</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>sym</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>hd_Cons_tl</span><span class="delimiter">[</span><span>OF</span><span> </span><span>sl'NE</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hsl</span><span> </span><span>hsl'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"list_all2 f sl sl'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>hd_Cons_tl</span><span class="delimiter">[</span><span>OF</span><span> </span><span>slNE</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>hd_Cons_tl</span><span class="delimiter">[</span><span>OF</span><span> </span><span>sl'NE</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f</span><span> </span><span>hsl'</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>f_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>g</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g (last sl) (last sl')"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span>wsl</span><span> </span><span>wsl'</span><span> </span><span>hsl</span><span> </span><span>hsl'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"getGMState (last sl) = doo st0 ucl"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>m</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>2</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wffp_isState_doo</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wsl</span><span> </span><span>l</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"getGMState (last sl') = doo st0 (purge GH ucl)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wffp_isState_doo_purgeIdle</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wsl'</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hsl'</span><span> </span><span>hsl</span><span> </span><span>m'</span><span> </span><span>3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"out (doo st0 ucl) u = out (doo st0 (purge GH ucl)) u"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>g_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>u</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>sl</span><span> </span><span>sl'</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ucl. ∀u∈GL. out (doo st0 ucl) u = out (doo st0 (purge GH ucl)) u"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>wsl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp sl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>wsl'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wffp sl'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hsl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hd sl = s0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hsl'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hd sl' = s0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"list_all2 f sl sl'"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>ucl</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ucl = map getGMUserCom (tl (purgeIdle sl))"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>ucl'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ucl' = map getGMUserCom (tl (purgeIdle sl'))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tl (purgeIdle sl) = purgeIdle (tl sl)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tl (purgeIdle sl') = purgeIdle (tl sl')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>hd_Cons_tl</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wffp_NE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wsl</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>hsl</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>     </span><span class="delimiter">(</span><span>subst</span><span> </span><span>hd_Cons_tl</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wffp_NE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wsl'</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>hsl'</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"purge GH ucl = purge GH ucl'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ucl_def</span><span> </span><span>ucl'_def</span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>purgeIdle_getGMUserCom_purge</span><span> </span><span>f</span><span> </span><span>wsl</span><span> </span><span>wsl'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"getGMState (last sl) = doo st0 ucl ∧ getGMState (last sl') = doo st0 ucl'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wffp_isState_doo_purgeIdle</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wsl</span><span class="delimiter">]</span><span> </span><span>wffp_isState_doo_purgeIdle</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wsl'</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hsl</span><span> </span><span>hsl'</span><span> </span><span>ucl_def</span><span> </span><span>ucl'_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g (last sl) (last sl')"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>g_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>nonintSfmla_iff_nonint</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"nonintSfmla [] ⟷ nonint"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>nonintSI_nonintS</span><span> </span><span>nonintS_iff_nonint</span><span> </span><span>nonintSfmla_nonintSI</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* context GM_sec_model *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹end-of-context GM-sec-model›</span></span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div><div id="Deep">
<div class="head"><h1>Theory Deep</h1>
<span class="command">theory</span> <span class="name">Deep</span><br/>
<span class="keyword">imports</span> <a href="Shallow.html"><span class="name">Shallow</span></a> <a href="../../HOL/HOL-Library/Infinite_Set.html"><span class="name">Infinite_Set</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Deep representation of HyperCTL* -- syntax and semantics›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Deep</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Shallow</span><span> </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Infinite_Set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Path variables and environments›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>pvar</span><span> </span><span class="delimiter">=</span><span> </span><span>Pvariable</span><span> </span><span class="delimiter">(</span><span>natOf</span><span> </span><span class="delimiter">:</span><span> </span><span>nat</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Deeply embedded (syntactic) formulas›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="tfree">'aprop</span><span> </span><span>dfmla</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>Atom</span><span> </span><span class="tfree">'aprop</span><span> </span><span>pvar</span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>Fls</span><span> </span><span class="delimiter">|</span><span> </span><span>Neg</span><span> </span><span class="string"><span class="delete"><span class="delete">"'aprop dfmla"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span>Dis</span><span> </span><span class="string"><span class="delete"><span class="delete">"'aprop dfmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"'aprop dfmla"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>Next</span><span> </span><span class="string"><span class="delete"><span class="delete">"'aprop dfmla"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span>Until</span><span> </span><span class="string"><span class="delete"><span class="delete">"'aprop dfmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"'aprop dfmla"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>Exi</span><span> </span><span>pvar</span><span> </span><span class="string"><span class="delete"><span class="delete">"'aprop dfmla"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Derived operators›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Tr ≡ Neg Fls"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Con φ ψ ≡ Neg (Dis (Neg φ) (Neg ψ))"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Imp φ ψ ≡ Dis (Neg φ) ψ"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Eq φ ψ ≡ Con (Imp φ ψ) (Imp ψ φ) "</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fall p φ ≡ Neg (Exi p (Neg φ))"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ev φ ≡ Until Tr φ"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Alw φ ≡ Neg (Ev (Neg φ))"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Wuntil φ ψ ≡ Dis (Until φ ψ) (Alw φ)"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fall2 p p' φ ≡ Fall p (Fall p' φ)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>der_Op_defs</span><span> </span><span class="delimiter">=</span><span>
</span><span>Tr_def</span><span> </span><span>Con_def</span><span> </span><span>Imp_def</span><span> </span><span>Eq_def</span><span> </span><span>Ev_def</span><span> </span><span>Alw_def</span><span> </span><span>Wuntil_def</span><span> </span><span>Fall_def</span><span> </span><span>Fall2_def</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Well-formed formulas are those that do not have a temporal operator
outside the scope of any quantifier -- indeed, in HyperCTL* such a situation does not make sense, 
since the temporal operators refer to previously introduced/quantified paths.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>wff</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'aprop dfmla ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"wff (Atom a p) = True"</span></span></span><span>
</span><span class="delimiter">|</span><span class="string"><span class="delete"><span class="delete">"wff Fls = True"</span></span></span><span>
</span><span class="delimiter">|</span><span class="string"><span class="delete"><span class="delete">"wff (Neg φ) = wff φ"</span></span></span><span>
</span><span class="delimiter">|</span><span class="string"><span class="delete"><span class="delete">"wff (Dis φ ψ) = (wff φ ∧ wff ψ)"</span></span></span><span>
</span><span class="delimiter">|</span><span class="string"><span class="delete"><span class="delete">"wff (Next φ) = False"</span></span></span><span>
</span><span class="delimiter">|</span><span class="string"><span class="delete"><span class="delete">"wff (Until φ ψ) = False"</span></span></span><span>
</span><span class="delimiter">|</span><span class="string"><span class="delete"><span class="delete">"wff (Exi p φ) = True"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The ability to pick a fresh variable›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_fresh_pvar</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (P :: pvar set)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>p</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ∉ P"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (natOf ` P)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>finite_imageI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n ∉ natOf ` P"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>unbounded_k_infinite</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Pvariable n ∉ P"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>imageI</span><span> </span><span>pvar.sel</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>getFresh</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"pvar set ⇒ pvar"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"getFresh P ≡ SOME p. p ∉ P"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>getFresh</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite P"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"getFresh P ∉ P"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>exE_some</span><span> </span><span>finite_fresh_pvar</span><span> </span><span>getFresh_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The free-variables operator›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>FV</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'aprop dfmla ⇒ pvar set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"FV (Atom a p) = {p}"</span></span></span><span>
</span><span class="delimiter">|</span><span class="string"><span class="delete"><span class="delete">"FV Fls = {}"</span></span></span><span>
</span><span class="delimiter">|</span><span class="string"><span class="delete"><span class="delete">"FV (Neg φ) = FV φ"</span></span></span><span>
</span><span class="delimiter">|</span><span class="string"><span class="delete"><span class="delete">"FV (Dis φ ψ) = FV φ ∪ FV ψ"</span></span></span><span>
</span><span class="delimiter">|</span><span class="string"><span class="delete"><span class="delete">"FV (Next φ) = FV φ"</span></span></span><span>
</span><span class="delimiter">|</span><span class="string"><span class="delete"><span class="delete">"FV (Until φ ψ) = FV φ ∪ FV ψ"</span></span></span><span>
</span><span class="delimiter">|</span><span class="string"><span class="delete"><span class="delete">"FV (Exi p φ) = FV φ - {p}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Environments›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>env</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"pvar ⇒ nat"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eqOn P env env1 ≡ ∀ p. p ∈ P ⟶ env p = env1 p"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eqOn_Un</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"eqOn (P ∪ Q) env env1 ⟷ eqOn P env env1 ∧ eqOn Q env env1"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eqOn_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eqOn_update</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"eqOn P (env(p := π)) (env1(p := π)) ⟷ eqOn (P - {p}) env env1"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eqOn_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eqOn_singl</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"eqOn {p} env env1 ⟷ env p = env1 p"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eqOn_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Shallow</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The semantic operator›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The semantics will interpret deep (syntactic) formulas as shallow formulas.
Recall that the latter are predicates on lists of paths -- the interpretation will
be parameterized by an environment mapping each path variable to a number indicating
the index (in the list) for the path denoted by the variable.

The semantics will only
be meaningful if the indexes of a formula's free variables are smaller than the length
of the path list -- we call this property ``compatibility''.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>sem</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'aprop dfmla ⇒ env ⇒ ('state,'aprop) sfmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"sem (Atom a p) env = atom a (env p)"</span></span></span><span>
</span><span class="delimiter">|</span><span class="string"><span class="delete"><span class="delete">"sem Fls env = fls"</span></span></span><span>
</span><span class="delimiter">|</span><span class="string"><span class="delete"><span class="delete">"sem (Neg φ) env = neg (sem φ env)"</span></span></span><span>
</span><span class="delimiter">|</span><span class="string"><span class="delete"><span class="delete">"sem (Dis φ ψ) env = dis (sem φ env) (sem ψ env)"</span></span></span><span>
</span><span class="delimiter">|</span><span class="string"><span class="delete"><span class="delete">"sem (Next φ) env = next (sem φ env)"</span></span></span><span>
</span><span class="delimiter">|</span><span class="string"><span class="delete"><span class="delete">"sem (Until φ ψ) env = until (sem φ env) (sem ψ env)"</span></span></span><span>
</span><span class="delimiter">|</span><span class="string"><span class="delete"><span class="delete">"sem (Exi p φ) env = exi (λ π πl. sem φ (env(p := length πl)) (πl @ [π]))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sem_Exi_explicit</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"sem (Exi p φ) env πl ⟷
 (∃ π. wfp AP' π ∧ stateOf π = (if πl ≠ [] then stateOf (last πl) else s0) ∧
       sem φ (env(p := length πl)) (πl @ [π]))"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sem.simps</span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>exi_def</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sem_derived</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"sem Tr env = tr"</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"sem (Con φ ψ) env = con (sem φ env) (sem ψ env)"</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"sem (Imp φ ψ) env = imp (sem φ env) (sem ψ env)"</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"sem (Eq φ ψ) env = eq (sem φ env) (sem ψ env)"</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"sem (Fall p φ) env = fall (λ π πl. sem φ (env(p := length πl)) (πl @ [π]))"</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"sem (Ev φ) env = ev (sem φ env)"</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"sem (Alw φ) env = alw (sem φ env)"</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"sem (Wuntil φ ψ) env = wuntil (sem φ env) (sem ψ env)"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>der_Op_defs</span><span> </span><span>der_op_defs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>neg_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sem_Fall2</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"sem (Fall2 p p' φ) env =
 fall2 (λ π' π πl. sem φ (env (p := length πl, p' := Suc(length πl))) (πl @ [π,π']))"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Fall2_def</span><span> </span><span>fall2_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fall_def</span><span> </span><span>exi_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>neg_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Compatibility of a pair (environment,path list) on a set of variables means
no out-or-range references:›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cpt P env πl ≡ ∀ p ∈ P. env p &lt; length πl"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cpt_Un</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"cpt (P ∪ Q) env πl ⟷ cpt P env πl ∧ cpt Q env πl"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cpt_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cpt_singl</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"cpt {p} env πl ⟷ env p &lt; length πl"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cpt_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cpt_map_stl</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"cpt P env πl ⟹ cpt P env (map stl πl)"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cpt_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Next we prove that the semantics of well-formed formulas only depends on the interpretation
of the free variables of a formula and on the current state of the last recorded path --
we call the latter the ``pointer'' of the path list.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>pointerOf</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('state,'aprop) path list ⇒ 'state"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"pointerOf πl = (if πl ≠ [] then stateOf (last πl) else s0)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Equality of two pairs (environment,path list) on a set of variables:›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>eqOn</span><span> </span><span class="delimiter">::</span><span>
</span><span class="string"><span class="delete"><span class="delete">"pvar set ⇒ env ⇒ ('state,'aprop) path list ⇒ env ⇒ ('state,'aprop) path list ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"eqOn P env πl env1 πl1 ≡ ∀ p. p ∈ P ⟶ πl!(env p) = πl1!(env1 p)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eqOn_Un</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"eqOn (P ∪ Q) env πl env1 πl1 ⟷ eqOn P env πl env1 πl1 ∧ eqOn Q env πl env1 πl1"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eqOn_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eqOn_singl</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"eqOn {p} env πl env1 πl1 ⟷ πl!(env p) = πl1!(env1 p)"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eqOn_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eqOn_map_stl</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"cpt P env πl ⟹ cpt P env1 πl1 ⟹
 eqOn P env πl env1 πl1 ⟹ eqOn P env (map stl πl) env1 (map stl πl1)"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eqOn_def</span><span> </span><span>cpt_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cpt_map_sdrop</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"cpt P env πl ⟹ cpt P env (map (sdrop i) πl)"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cpt_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cpt_update</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cpt (P - {p}) env πl"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cpt P (env(p := length πl)) (πl @ [π])"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cpt_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Diff_iff</span><span> </span><span>less_SucI</span><span> </span><span>singleton_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eqOn_map_sdrop</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"cpt V env πl ⟹ cpt V env1 πl1 ⟹
 eqOn V env πl env1 πl1 ⟹ eqOn V env (map (sdrop i) πl) env1 (map (sdrop i) πl1)"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eqOn_def</span><span> </span><span>cpt_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eqOn_update</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cpt (P - {p}) env πl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cpt (P - {p}) env1 πl1"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"eqOn P (env(p := length πl)) (πl @ [π]) (env1(p := length πl1)) (πl1 @ [π])
 ⟷
 eqOn (P - {p}) env πl env1 πl1"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eqOn_def</span><span> </span><span>cpt_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>DiffI</span><span> </span><span>nth_append</span><span> </span><span>singleton_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eqOn_FV_sem_NE</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cpt (FV φ) env πl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cpt (FV φ) env1 πl1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eqOn (FV φ) env πl env1 πl1"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"πl ≠ []"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"πl1 ≠ []"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"last πl = last πl1"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sem φ env πl = sem φ env1 πl1"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>φ</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>env</span><span> </span><span>πl</span><span> </span><span>env1</span><span> </span><span>πl1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Until</span><span> </span><span>φ</span><span> </span><span>ψ</span><span> </span><span>env</span><span> </span><span>πl</span><span> </span><span>env1</span><span> </span><span>πl1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ i. sem φ env (map (sdrop i) πl) = sem φ env1 (map (sdrop i) πl1) ∧
              sem ψ env (map (sdrop i) πl) = sem ψ env1 (map (sdrop i) πl1)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Until</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>last_map</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>op_defs</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Exi</span><span> </span><span>p</span><span> </span><span>φ</span><span> </span><span>env</span><span> </span><span>πl</span><span> </span><span>env1</span><span> </span><span>πl1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⋀ π. cpt (FV φ) (env(p := length πl)) (πl @ [π]) ∧
         cpt (FV φ) (env1(p := length πl1)) (πl1 @ [π]) ∧
         eqOn (FV φ) (env(p := length πl)) (πl @ [π]) (env1(p := length πl1)) (πl1 @ [π])"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sem.simps</span><span> </span><span>exi_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Exi</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>iff_exI</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append_is_Nil_conv</span><span> </span><span>last_snoc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>last_map</span><span> </span><span>op_defs</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The next theorem states that the semantics of a formula on an environment
and a list of paths only depends on the pointer of the list of paths.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>eqOn_FV_sem</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wff φ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pointerOf πl = pointerOf πl1"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cpt (FV φ) env πl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cpt (FV φ) env1 πl1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eqOn (FV φ) env πl env1 πl1"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sem φ env πl = sem φ env1 πl1"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>φ</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>env</span><span> </span><span>πl</span><span> </span><span>env1</span><span> </span><span>πl1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Until</span><span> </span><span>φ</span><span> </span><span>ψ</span><span> </span><span>env</span><span> </span><span>πl</span><span> </span><span>env1</span><span> </span><span>πl1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ i. sem φ env (map (sdrop i) πl) = sem φ env1 (map (sdrop i) πl1) ∧
              sem ψ env (map (sdrop i) πl) = sem ψ env1 (map (sdrop i) πl1)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Until</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>last_map</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>op_defs</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Exi</span><span> </span><span>p</span><span> </span><span>φ</span><span> </span><span>env</span><span> </span><span>πl</span><span> </span><span>env1</span><span> </span><span>πl1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ π. sem φ (env(p := length πl)) (πl @ [π]) =
             sem φ (env1(p := length πl1)) (πl1 @ [π])"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>eqOn_FV_sem_NE</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Exi</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sem.simps</span><span> </span><span>exi_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Exi</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>iff_exI</span><span> </span><span>conj_cong</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>last_map</span><span> </span><span>op_defs</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>FV_sem</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wff φ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ p ∈ FV φ. env p = env1 p"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cpt (FV φ) env πl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cpt (FV φ) env1 πl"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sem φ env πl = sem φ env1 πl"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>eqOn_FV_sem</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eqOn_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹As a consequence, the interpretation of a closed formula (i.e., a formula
with no free variables) will not depend on the environment and, from the
list of paths, will only depend on its pointer:›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>interp_closed</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wff φ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"FV φ = {}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pointerOf πl = pointerOf πl1"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sem φ env πl = sem φ env1 πl1"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>eqOn_FV_sem</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eqOn_def</span><span> </span><span>cpt_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Therefore, it makes sense to define the interpretation of a closed formula
by choosing any environment and any list of paths such that its pointer is the initial state
(e.g., the empty list) -- knowing that the choices are irrelevant.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"semClosed φ ≡ sem φ (any::env) (SOME πl. pointerOf πl = s0)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>semClosed</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>φ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wff φ"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"FV φ = {}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pointerOf πl = s0"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"semClosed φ = sem φ env πl"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pointerOf (SOME πl. pointerOf πl = s0) = s0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>someI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>semClosed_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>interp_closed</span><span class="delimiter">[</span><span>OF</span><span> </span><span>φ</span><span class="delimiter">]</span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>semClosed_Nil</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>φ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wff φ"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"FV φ = {}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"semClosed φ = sem φ env []"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>semClosed</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The conjunction of a finite set of formulas›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹This is defined by making the set into a list (by choosing any ordering of the
elements) and iterating binary conjunction.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Scon</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'aprop dfmla set ⇒ 'aprop dfmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"Scon φs ≡ foldr Con (asList φs) Tr"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sem_Scon</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite φs"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sem (Scon φs) env = scon ((λ φ. sem φ env) ` φs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>φl</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φl = asList φs"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sem (foldr Con φl Tr) env = scon ((λ φ. sem φ env) ` (set φl))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>φl</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>scon_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>φl_def</span><span> </span><span>Scon_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>set_asList</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>FV_Scon</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite φs"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"FV (Scon φs) = ⋃ (FV ` φs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>φl</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φl = asList φs"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"FV (foldr Con φl Tr) = ⋃ (set (map FV φl))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>φl</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>der_Op_defs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>φl_def</span><span> </span><span>Scon_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>set_map</span><span> </span><span>set_asList</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* context Shallow  *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹end-of-context Shallow›</span></span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div><div id="Finite_Noninterference">
<div class="head"><h1>Theory Finite_Noninterference</h1>
<span class="command">theory</span> <span class="name">Finite_Noninterference</span><br/>
<span class="keyword">imports</span> <a href="Noninterference.html"><span class="name">Noninterference</span></a> <a href="Deep.html"><span class="name">Deep</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Noninterference for models with finitely many users, commands and outputs›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Finite_Noninterference</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Noninterference</span><span> </span><span>Deep</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹In the Noninterference section, we showed how to express Goguen-Meseguer
noninterference as a shallow HyperCTL* formula.  Here we show that, if one assumes
finiteness of the sets of users, commands and outputs,
then one can express the property as (the denotation of) a syntactic formula.
Note that we do {\em not} need to assume the state space finite -- this is
important for a potential application to infinite-state systems.›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The Goguen-Meseguer security model with finiteness assumptions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>GM_sec_model_finite</span><span> </span><span class="delimiter">=</span><span> </span><span>GM_sec_model</span><span> </span><span>st0</span><span> </span><span>do</span><span> </span><span>out</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>st0</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'St</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>do</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'St ⇒ 'U ⇒ 'C ⇒ 'St"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>out</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'St ⇒ 'U ⇒ 'Out"</span></span></span><span>
</span><span>  </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>finite_U</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (UNIV :: 'U set)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>finite_C</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (UNIV :: 'C set)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>finite_Out</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (UNIV :: 'Out set)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_UminusGH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (UNIV - GH)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>finite_Diff</span><span> </span><span>finite_U</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_GL</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite GL"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Diff_UNIV</span><span> </span><span>finite_Diff2</span><span> </span><span>finite_U</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>EqOnUC</span><span> </span><span class="delimiter">::</span><span>
</span><span class="string"><span class="delete"><span class="delete">"pvar ⇒ pvar ⇒ 'U ⇒ 'C ⇒ ('U,'C,'Out) aprop dfmla"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"EqOnUC p p' u c ≡ Eq (Atom (Last u c) p) (Atom (Last u c) p')"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>EqOnUC_eqOnUC</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"env p = i"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"env p' = i'"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sem (EqOnUC p p' u c) env = eqOnUC i i' u c"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>EqOnUC_def</span><span> </span><span>eqOnUC_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>EqButGH</span><span> </span><span class="delimiter">::</span><span>
</span><span class="string"><span class="delete"><span class="delete">"pvar ⇒ pvar ⇒ ('U,'C,'Out) aprop dfmla"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"EqButGH p p' ≡ Scon {EqOnUC p p' u c | u c. (u,c) ∈ (UNIV - GH) × UNIV}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_EqButGH</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"finite {EqOnUC p p' u c | u c. (u,c) ∈ (UNIV - GH) × UNIV}"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite ?K"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?K = (λ (u,c). EqOnUC p p' u c) ` ((UNIV - GH) × UNIV)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>1</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>finite_imageI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>finite_C</span><span> </span><span>finite_SigmaI</span><span> </span><span>finite_UminusGH</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>EqButGH_eqButGH</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"env p = i"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"env p' = i'"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sem (EqButGH p p') env = eqButGH i i'"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>finite_EqButGH</span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>EqButGH_def</span><span> </span><span>eqButGH_def</span><span> </span><span>sem_Scon</span><span class="delimiter">[</span><span>OF</span><span> </span><span>finite_EqButGH</span><span class="delimiter">]</span><span> </span><span>image_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>hide_lams</span><span class="delimiter">,</span><span> </span><span>no_types</span><span class="delimiter">)</span><span> </span><span>EqOnUC_eqOnUC</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>FV_EqButGH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"FV (EqButGH p p') ⊆ {p,p'}"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?L ⊆ ?R"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?L = ⋃ {FV (EqOnUC p p' u c) | u c. (u,c) ∈ (UNIV - GH) × UNIV}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>EqButGH_def</span><span> </span><span>FV_Scon</span><span class="delimiter">[</span><span>OF</span><span> </span><span>finite_EqButGH</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ⊆ ?R"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>EqOnUC_def</span><span> </span><span>der_Op_defs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>EqOnUOut</span><span> </span><span class="delimiter">::</span><span>
</span><span class="string"><span class="delete"><span class="delete">"pvar ⇒ pvar ⇒ 'U ⇒ 'Out ⇒ ('U,'C,'Out) aprop dfmla"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"EqOnUOut p p' u ou ≡ Eq (Atom (Obs u ou) p) (Atom (Obs u ou) p')"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>EqOnUOut_eqOnUOut</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"env p = i"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"env p' = i'"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sem (EqOnUOut p p' u ou) env = eqOnUOut i i' u ou"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>EqOnUOut_def</span><span> </span><span>eqOnUOut_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>EqOnGL</span><span> </span><span class="delimiter">::</span><span>
</span><span class="string"><span class="delete"><span class="delete">"pvar ⇒ pvar ⇒ ('U,'C,'Out) aprop dfmla"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"EqOnGL p p' ≡ Scon {EqOnUOut p p' u ou | u ou. (u,ou) ∈ GL × UNIV}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_EqOnGL</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"finite {EqOnUOut p p' u ou | u ou. (u,ou) ∈ GL × UNIV}"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite ?K"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?K = (λ (u,ou). EqOnUOut p p' u ou) ` (GL × UNIV)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>1</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>finite_imageI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>finite_Out</span><span> </span><span>finite_SigmaI</span><span> </span><span>finite_GL</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>EqOnGL_eqOnGL</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"env p = i"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"env p' = i'"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sem (EqOnGL p p') env = eqOnGL i i'"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>finite_EqOnGL</span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>EqOnGL_def</span><span> </span><span>eqOnGL_def</span><span> </span><span>sem_Scon</span><span class="delimiter">[</span><span>OF</span><span> </span><span>finite_EqOnGL</span><span class="delimiter">]</span><span> </span><span>image_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>hide_lams</span><span class="delimiter">,</span><span> </span><span>no_types</span><span class="delimiter">)</span><span> </span><span>EqOnUOut_eqOnUOut</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>FV_EqOnGL</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"FV (EqOnGL p p') ⊆ {p,p'}"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?L ⊆ ?R"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?L = ⋃ {FV (EqOnUOut p p' u ou) | u ou. (u,ou) ∈ GL × UNIV}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>EqOnGL_def</span><span> </span><span>FV_Scon</span><span class="delimiter">[</span><span>OF</span><span> </span><span>finite_EqOnGL</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ⊆ ?R"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>EqOnUOut_def</span><span> </span><span>der_Op_defs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p0 = getFresh {}"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p1 = getFresh {p0}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>p0p1</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p0 ≠ p1"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>p1_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Diff_cancel</span><span> </span><span>getFresh</span><span> </span><span>infinite_imp_nonempty</span><span> </span><span>infinite_remove</span><span> </span><span>insertI1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>nonintDfmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('U,'C,'Out) aprop dfmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"nonintDfmla ≡
 Fall2 p0 p1 (Imp (Alw (EqButGH p0 p1)) (Alw (EqOnGL p0 p1)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sem_nonintDfmla</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sem nonintDfmla env = nonintSfmla"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>nonintDfmla_def</span><span> </span><span>nonintSfmla_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wff_nonintDfmla</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wff nonintDfmla"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>nonintDfmla_def</span><span> </span><span>Fall2_def</span><span> </span><span>Fall_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>closed_nonintDfmla</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"FV nonintDfmla = {}"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>nonintDfmla_def</span><span> </span><span>Fall2_def</span><span> </span><span>Fall_def</span><span> </span><span>der_Op_defs</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FV_EqButGH</span><span> </span><span>FV_EqOnGL</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹In the end, we obtain that the semantics of the closed (syntactic) formula
nonintDfmla expresses noninterference faithfully:›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>semClosed_nonintDfmla</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"semClosed nonintDfmla = nonint"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>nonintSfmla_iff_nonint</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>sem_nonintDfmla</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>semClosed_Nil</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* context GM_sec_model_finite  *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹end-of-context GM-sec-model-finite›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div><div id="HyperCTL">
<div class="head"><h1>Theory HyperCTL</h1>
<span class="command">theory</span> <span class="name">HyperCTL</span><br/>
<span class="keyword">imports</span> <a href="Finite_Noninterference.html"><span class="name">Finite_Noninterference</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Hyper CTL*›</span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>HyperCTL</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Finite_Noninterference</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div>