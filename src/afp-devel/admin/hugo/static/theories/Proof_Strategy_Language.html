<div id="Try_Hard">
<div class="head">
<h1>Theory Try_Hard</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      src/Try_Hard.thy
    Author:     Yutaka Nagashima, Data61, CSIRO

This file defines the default strategy "TryHard".
*)</span>

<span class="keyword1"><span class="command">theory</span></span> Try_Hard
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">keywords</span></span> <span class="quoted">"strategy"</span>     <span class="main">::</span> thy_decl
     <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted">"find_proof"</span>   <span class="main">::</span> diag
     <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted">"try_hard"</span>     <span class="main">::</span> diag
     <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted">"try_hard_one"</span> <span class="main">::</span> diag
     <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted">"try_hard_all"</span> <span class="main">::</span> diag
     <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted">"try_parallel"</span> <span class="main">::</span> diag
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹Utils.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹Subtool.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹Dynamic_Tactic_Generation.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹Constructor_Class.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹Instantiation.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹Monadic_Prover.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹Parser_Combinator.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹PSL_Parser.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹Isar_Interface.ML›</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Prevent overwriting the default basic strategies.›</span></span>
<span class="keyword1"><span class="command">strategy</span></span> Simp <span class="main">=</span> Simp
<span class="keyword1"><span class="command">strategy</span></span> Blast <span class="main">=</span> Blast
<span class="keyword1"><span class="command">strategy</span></span> Clarsimp <span class="main">=</span> Clarsimp
<span class="keyword1"><span class="command">strategy</span></span> Fastforce <span class="main">=</span> Fastforce
<span class="keyword1"><span class="command">strategy</span></span> Auto <span class="main">=</span> Auto
<span class="keyword1"><span class="command">strategy</span></span> Induct <span class="main">=</span> Induct
<span class="keyword1"><span class="command">strategy</span></span> InductTac <span class="main">=</span> InductTac
<span class="keyword1"><span class="command">strategy</span></span> Rule <span class="main">=</span> Rule
<span class="keyword1"><span class="command">strategy</span></span> Erule <span class="main">=</span> Erule
<span class="keyword1"><span class="command">strategy</span></span> Cases <span class="main">=</span> Cases
<span class="keyword1"><span class="command">strategy</span></span> Coinduction <span class="main">=</span> Coinduction
<span class="keyword1"><span class="command">strategy</span></span> IsSolved <span class="main">=</span> IsSolved
<span class="keyword1"><span class="command">strategy</span></span> Defer <span class="main">=</span> Defer
<span class="keyword1"><span class="command">strategy</span></span> IntroClasses <span class="main">=</span> IntroClasses
<span class="keyword1"><span class="command">strategy</span></span> Transfer <span class="main">=</span> Transfer
<span class="keyword1"><span class="command">strategy</span></span> Normalization <span class="main">=</span> Normalization
<span class="keyword1"><span class="command">strategy</span></span> Hammer <span class="main">=</span> Hammer
<span class="keyword1"><span class="command">strategy</span></span> Nitpick <span class="main">=</span> Nitpick
<span class="keyword1"><span class="command">strategy</span></span> Quickcheck <span class="main">=</span> Quickcheck

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Small scale strategies.›</span></span>
<span class="keyword1"><span class="command">strategy</span></span> Auto_Solve <span class="main">=</span> Thens <span class="main">[</span>Auto<span class="main">,</span> IsSolved<span class="main">]</span>
<span class="keyword1"><span class="command">strategy</span></span> Blast_Solve <span class="main">=</span> Thens <span class="main">[</span>Blast<span class="main">,</span> IsSolved<span class="main">]</span>
<span class="keyword1"><span class="command">strategy</span></span> FF_Solve <span class="main">=</span> Thens <span class="main">[</span>Fastforce<span class="main">,</span> IsSolved<span class="main">]</span>
<span class="keyword1"><span class="command">strategy</span></span> Auto_Solve1 <span class="main">=</span> Thens <span class="main">[</span>Subgoal<span class="main">,</span> Auto<span class="main">,</span> IsSolved<span class="main">]</span>
<span class="keyword1"><span class="command">strategy</span></span> Auto_Hammer <span class="main">=</span> Thens <span class="main">[</span>Subgoal<span class="main">,</span> Auto<span class="main">,</span> RepeatN<span class="main">(</span>Hammer<span class="main">)</span><span class="main">,</span> IsSolved<span class="main">]</span>
<span class="keyword1"><span class="command">strategy</span></span> Solve_One <span class="main">=</span> Ors <span class="main">[</span>Fastforce<span class="main">,</span> Auto_Solve1<span class="main">,</span> Hammer<span class="main">]</span>
<span class="keyword1"><span class="command">strategy</span></span> Solve_Many <span class="main">=</span> Thens <span class="main">[</span>Repeat <span class="main">(</span>Solve_One<span class="main">)</span><span class="main">,</span> IsSolved<span class="main">]</span>
<span class="keyword1"><span class="command">strategy</span></span> DInduct <span class="main">=</span> Dynamic <span class="main">(</span>Induct<span class="main">)</span>
<span class="keyword1"><span class="command">strategy</span></span> DInductTac <span class="main">=</span> Dynamic <span class="main">(</span>InductTac<span class="main">)</span>
<span class="keyword1"><span class="command">strategy</span></span> DCoinduction <span class="main">=</span> Dynamic <span class="main">(</span>Coinduction<span class="main">)</span>
<span class="keyword1"><span class="command">strategy</span></span> DCases <span class="main">=</span> Dynamic <span class="main">(</span>Cases<span class="main">)</span>
<span class="keyword1"><span class="command">strategy</span></span> DCaseTac <span class="main">=</span> Dynamic <span class="main">(</span>CaseTac<span class="main">)</span>
<span class="keyword1"><span class="command">strategy</span></span> DAuto <span class="main">=</span> Dynamic <span class="main">(</span>Auto<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Defining default strategies.
They can be called by the keywords: try_hard, try_hard_one, try_hard_all, and try_parallel.
- try_hard tries to discharge at least one sub-goal.
- try_hard_one tries to discharge the first sub-goal.
- try_hard_all tries to discharge all the current sub-goals.
- try_parallel tries to discharge at least one sub-goal exploiting parallelism.
›</span></span>

<span class="keyword1"><span class="command">strategy</span></span> Basic <span class="main">=</span>
  Ors <span class="main">[</span>
       Auto_Solve<span class="main">,</span>
       Blast_Solve<span class="main">,</span>
       FF_Solve<span class="main">,</span>
       Thens <span class="main">[</span>IntroClasses<span class="main">,</span> Auto_Solve<span class="main">]</span><span class="main">,</span>
       Thens <span class="main">[</span>Transfer<span class="main">,</span> Auto_Solve<span class="main">]</span><span class="main">,</span>
       Thens <span class="main">[</span>Normalization<span class="main">,</span> IsSolved<span class="main">]</span><span class="main">,</span>
       Thens <span class="main">[</span>DInduct<span class="main">,</span> Auto_Solve<span class="main">]</span><span class="main">,</span>
       Thens <span class="main">[</span>Hammer<span class="main">,</span> IsSolved<span class="main">]</span><span class="main">,</span>
       Thens <span class="main">[</span>DCases<span class="main">,</span> Auto_Solve<span class="main">]</span><span class="main">,</span>
       Thens <span class="main">[</span>DCoinduction<span class="main">,</span> Auto_Solve<span class="main">]</span><span class="main">,</span>
       <span class="comment1">(*Occasionally, auto reveals hidden facts.*)</span>
       Thens <span class="main">[</span>Auto<span class="main">,</span> RepeatN<span class="main">(</span>Hammer<span class="main">)</span><span class="main">,</span> IsSolved<span class="main">]</span><span class="main">,</span>
       Thens <span class="main">[</span>DAuto<span class="main">,</span> IsSolved<span class="main">]</span>
       <span class="main">]</span>

<span class="keyword1"><span class="command">strategy</span></span> Advanced <span class="main">=</span>
  Ors <span class="main">[</span>
       Solve_Many<span class="main">,</span>
       Thens <span class="main">[</span>DCases<span class="main">,</span> DCases<span class="main">,</span> Auto_Solve<span class="main">]</span><span class="main">,</span>
       Thens <span class="main">[</span>DCases<span class="main">,</span> Solve_Many<span class="main">]</span><span class="main">,</span>
       Thens <span class="main">[</span>IntroClasses<span class="main">,</span>
              Repeat <span class="main">(</span>Ors <span class="main">[</span>Fastforce<span class="main">,</span> Thens <span class="main">[</span>Transfer<span class="main">,</span> Fastforce<span class="main">]</span><span class="main">,</span> Solve_Many<span class="main">]</span><span class="main">)</span><span class="main">,</span>
              IsSolved<span class="main">]</span><span class="main">,</span>
       Thens <span class="main">[</span>Transfer<span class="main">,</span> Solve_Many<span class="main">]</span><span class="main">,</span>
       Thens <span class="main">[</span>DInduct<span class="main">,</span> Solve_Many<span class="main">]</span><span class="main">,</span>
       Thens <span class="main">[</span>DCoinduction<span class="main">,</span> Solve_Many<span class="main">]</span>
       <span class="main">]</span>

<span class="keyword1"><span class="command">strategy</span></span> Try_Hard_All <span class="main">=</span>
  Ors <span class="main">[</span>
       Basic<span class="main">,</span>
       Thens <span class="main">[</span>DInductTac<span class="main">,</span> Auto_Solve<span class="main">]</span><span class="main">,</span>
       Thens <span class="main">[</span>DCaseTac<span class="main">,</span> Auto_Solve<span class="main">]</span><span class="main">,</span>
       Advanced<span class="main">,</span>
       Thens <span class="main">[</span>DCaseTac<span class="main">,</span> Solve_Many<span class="main">]</span><span class="main">,</span>
       Thens <span class="main">[</span>DInductTac<span class="main">,</span> Solve_Many<span class="main">]</span>
       <span class="main">]</span>

<span class="keyword1"><span class="command">strategy</span></span> Try_Hard_One <span class="main">=</span> Thens <span class="main">[</span>Subgoal<span class="main">,</span> Try_Hard_All<span class="main">]</span>

<span class="comment1">(*The subgoal command occasionally makes it impossible to apply induct_tac and case_tac.*)</span>
<span class="keyword1"><span class="command">strategy</span></span> Try_Hard <span class="main">=</span>
  Ors <span class="main">[</span>
       Thens <span class="main">[</span>Subgoal<span class="main">,</span> Basic<span class="main">]</span><span class="main">,</span>
       Thens <span class="main">[</span>DInductTac<span class="main">,</span> Auto_Solve<span class="main">]</span><span class="main">,</span>
       Thens <span class="main">[</span>DCaseTac<span class="main">,</span> Auto_Solve<span class="main">]</span><span class="main">,</span>
       Thens <span class="main">[</span>Subgoal<span class="main">,</span> Advanced<span class="main">]</span><span class="main">,</span>
       Thens <span class="main">[</span>DCaseTac<span class="main">,</span> Solve_Many<span class="main">]</span><span class="main">,</span>
       Thens <span class="main">[</span>DInductTac<span class="main">,</span> Solve_Many<span class="main">]</span>
       <span class="main">]</span>

<span class="keyword1"><span class="command">strategy</span></span> PBasic <span class="main">=</span>
  POrs <span class="main">[</span>
       Auto_Solve<span class="main">,</span>
       FF_Solve<span class="main">,</span>
       Blast_Solve<span class="main">,</span>
       Thens <span class="main">[</span>IntroClasses<span class="main">,</span> Auto_Solve<span class="main">]</span><span class="main">,</span>
       Thens <span class="main">[</span>Transfer<span class="main">,</span> Auto_Solve<span class="main">]</span><span class="main">,</span>
       Thens <span class="main">[</span>Normalization<span class="main">,</span> IsSolved<span class="main">]</span><span class="main">,</span>
       Thens <span class="main">[</span>Hammer<span class="main">,</span> IsSolved<span class="main">]</span><span class="main">,</span>
       Thens <span class="main">[</span>DInduct<span class="main">,</span> Auto_Solve<span class="main">]</span><span class="main">,</span>
       Thens <span class="main">[</span>DCases<span class="main">,</span> Auto_Solve<span class="main">]</span><span class="main">,</span>
       Thens <span class="main">[</span>DCoinduction<span class="main">,</span> Auto_Solve<span class="main">]</span><span class="main">,</span>
       <span class="comment1">(*Occasionally, auto reveals hidden facts.*)</span>
       Thens <span class="main">[</span>Auto<span class="main">,</span> RepeatN<span class="main">(</span>Hammer<span class="main">)</span><span class="main">,</span> IsSolved<span class="main">]</span><span class="main">,</span>
       Thens <span class="main">[</span>DAuto<span class="main">,</span> IsSolved<span class="main">]</span>
       <span class="main">]</span>

<span class="keyword1"><span class="command">strategy</span></span> PAdvanced <span class="main">=</span>
  POrs <span class="main">[</span>
       Thens <span class="main">[</span>DAuto<span class="main">,</span> IsSolved<span class="main">]</span><span class="main">,</span>
       Thens <span class="main">[</span>DCases<span class="main">,</span> DCases<span class="main">,</span> Auto_Solve<span class="main">]</span><span class="main">,</span>
       Thens <span class="main">[</span>IntroClasses<span class="main">,</span>
              Repeat <span class="main">(</span>Ors <span class="main">[</span>Fastforce<span class="main">,</span> Thens <span class="main">[</span>Transfer<span class="main">,</span> Fastforce<span class="main">]</span><span class="main">,</span> Hammer<span class="main">]</span><span class="main">)</span><span class="main">,</span>
              IsSolved<span class="main">]</span><span class="main">,</span>
       Solve_Many<span class="main">,</span>
       PThenOne <span class="main">[</span>DCases<span class="main">,</span> Solve_Many<span class="main">]</span><span class="main">,</span>
       Thens <span class="main">[</span>Transfer<span class="main">,</span> Solve_Many<span class="main">]</span><span class="main">,</span>
       PThenOne <span class="main">[</span>DInduct<span class="main">,</span> Solve_Many<span class="main">]</span><span class="main">,</span>
       PThenOne <span class="main">[</span>DCoinduction<span class="main">,</span> Solve_Many<span class="main">]</span>
       <span class="main">]</span>

<span class="keyword1"><span class="command">strategy</span></span> Try_Parallel <span class="main">=</span>
  POrs <span class="main">[</span>
       Thens <span class="main">[</span>Subgoal<span class="main">,</span> PBasic<span class="main">]</span><span class="main">,</span>
       PThenOne <span class="main">[</span>DInductTac<span class="main">,</span> Auto_Solve<span class="main">]</span><span class="main">,</span>
       PThenOne <span class="main">[</span>DCaseTac<span class="main">,</span> Auto_Solve<span class="main">]</span><span class="main">,</span>
       Thens <span class="main">[</span>Subgoal<span class="main">,</span> PAdvanced<span class="main">]</span><span class="main">,</span>
       PThenOne <span class="main">[</span>DCaseTac<span class="main">,</span> Solve_Many<span class="main">]</span><span class="main">,</span>
       PThenOne <span class="main">[</span>DInductTac<span class="main">,</span> Solve_Many<span class="main">]</span>
       <span class="main">]</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/Utils.ML">
<div class="head">
<h1>File ‹Utils.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Utils.ML
    Author:     Yutaka Nagashima, Data61, CSIRO

This file provides utility functions that are not specific to Isabelle/HOL.
*)</span>

<span class="comment1">(*** UTILS : Utility functions not specific to Isabelle/HOL. ***)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">UTILS</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> flip           <span class="main">:</span> <span class="main">(</span>'a <span class="main">-&gt;</span> 'b <span class="main">-&gt;</span> 'c<span class="main">)</span> <span class="main">-&gt;</span> 'b <span class="main">-&gt;</span> 'a <span class="main">-&gt;</span> 'c<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> delay          <span class="main">:</span> <span class="main">(</span>'a <span class="main">-&gt;</span> 'b<span class="main">)</span> * 'a <span class="main">-&gt;</span> 'b<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> map_arg        <span class="main">:</span> 'a <span class="main">-&gt;</span> <span class="main">(</span>'a <span class="main">-&gt;</span> 'b<span class="main">)</span> list <span class="main">-&gt;</span> 'b list<span class="main">;</span>
  <span class="comment1">(*map_pair and pair_to_list are useful only if the pair consists of the same type.*)</span>
  <span class="keyword1"><span class="keyword">val</span></span> map_pair       <span class="main">:</span> <span class="main">(</span>'a <span class="main">-&gt;</span> 'b<span class="main">)</span> <span class="main">-&gt;</span> 'a * 'a <span class="main">-&gt;</span> 'b * 'b<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> pair_to_list   <span class="main">:</span> 'a * 'a <span class="main">-&gt;</span> 'a list<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> list_to_pair   <span class="main">:</span> 'a list <span class="main">-&gt;</span> 'a * 'a<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> init           <span class="main">:</span> 'a list <span class="main">-&gt;</span> 'a list<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> intersperse    <span class="main">:</span> 'a <span class="main">-&gt;</span> 'a list <span class="main">-&gt;</span> 'a list<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> is_in_paren    <span class="main">:</span> string <span class="main">-&gt;</span> bool<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> ??             <span class="main">:</span> <span class="main">(</span>'a <span class="main">-&gt;</span> bool<span class="main">)</span> * <span class="main">(</span>'a <span class="main">-&gt;</span> 'a<span class="main">)</span> <span class="main">-&gt;</span> 'a <span class="main">-&gt;</span> 'a<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> rm_parentheses_with_contents_in_the_end <span class="main">:</span> string <span class="main">-&gt;</span> string<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> rm_parentheses <span class="main">:</span> string <span class="main">-&gt;</span> string<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> remove__s      <span class="main">:</span> string <span class="main">-&gt;</span> string<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> push_to_front  <span class="main">:</span> string <span class="main">-&gt;</span> string list <span class="main">-&gt;</span> string list<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> the'           <span class="main">:</span> string <span class="main">-&gt;</span> 'a option <span class="main">-&gt;</span> 'a<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> prefix_if_nonempty <span class="main">:</span> string <span class="main">-&gt;</span> string list <span class="main">-&gt;</span> string list<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> debug          <span class="main">:</span> bool<span class="main">;</span> <span class="comment1">(*flag for debugging.*)</span>
  <span class="keyword1"><span class="keyword">val</span></span> try_with       <span class="main">:</span> 'b <span class="main">-&gt;</span> <span class="main">(</span>'a <span class="main">-&gt;</span> 'b<span class="main">)</span> <span class="main">-&gt;</span> 'a <span class="main">-&gt;</span> 'b<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> are_same       <span class="main">:</span> <span class="main">(</span>string * string<span class="main">)</span> <span class="main">-&gt;</span> bool<span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(*** Utils : Utility functions not specific to Isabelle/HOL. ***)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Utils</span><span class="main">:</span><span class="entity">UTILS</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">flip</span> <span class="entity">f</span> <span class="entity">x</span> <span class="entity">y</span> <span class="main">=</span> <span class="entity">f</span> <span class="entity">y</span> <span class="entity">x</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">infix</span></span> delay<span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="main">(</span><span class="entity">f</span> <span class="entity">delay</span> <span class="entity">x</span><span class="main">)</span> <span class="main">=</span>  <span class="entity">f</span> <span class="entity">x</span><span class="main">;</span>

<span class="comment1">(*map_arg maps a parameter to a list of functions.*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_arg</span> <span class="main">_</span>      <span class="main">[</span><span class="main">]</span>           <span class="main">=</span> <span class="main">[</span><span class="main">]</span>
 <span class="main">|</span>  <span class="entity">map_arg</span> <span class="entity">param</span> <span class="main">(</span><span class="entity">func</span>::<span class="entity">funcs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">func</span> <span class="entity">param</span> :: <span class="entity">map_arg</span> <span class="entity">param</span> <span class="entity">funcs</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_pair</span> <span class="entity">func</span> <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="entity">b</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">func</span> <span class="entity">a</span><span class="main">,</span> <span class="entity">func</span> <span class="entity">b</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pair_to_list</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">[</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">]</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">list_to_pair</span> <span class="main">[</span><span class="entity">a</span><span class="main">,</span><span class="entity">b</span><span class="main">]</span> <span class="main">=</span> <span class="main">(</span><span class="entity">a</span><span class="main">,</span><span class="entity">b</span><span class="main">)</span>
 <span class="main">|</span>  <span class="entity">list_to_pair</span> <span class="main">_</span> <span class="main">=</span> error <span class="inner_quoted">"list_to_pair failed. The length of lsit is not two."</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">init</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> error <span class="inner_quoted">"init failed. empty list"</span>
 <span class="main">|</span>  <span class="entity">init</span> <span class="entity">xs</span> <span class="main">=</span> take <span class="main">(</span>length <span class="entity">xs</span> - <span class="inner_numeral">1</span><span class="main">)</span> <span class="entity">xs</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">intersperse</span> <span class="main">_</span>   <span class="main">[</span><span class="main">]</span>      <span class="main">=</span> <span class="main">[</span><span class="main">]</span>
 <span class="main">|</span>  <span class="entity">intersperse</span> <span class="main">_</span>   <span class="main">(</span><span class="entity">x</span>::<span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> <span class="main">[</span><span class="entity">x</span><span class="main">]</span>
 <span class="main">|</span>  <span class="entity">intersperse</span> <span class="entity">int</span> <span class="main">(</span><span class="entity">x</span>::<span class="entity">xs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">x</span>::<span class="entity">int</span>::<span class="entity">intersperse</span> <span class="entity">int</span> <span class="entity">xs</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_in_paren</span> <span class="entity">str</span> <span class="main">=</span> String.isPrefix <span class="inner_quoted">"("</span> <span class="entity">str</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rm_parentheses_with_contents_in_the_end</span> <span class="entity">str</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tokens</span> <span class="main">=</span> Symbol.explode <span class="entity">str</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parser</span> <span class="main">=</span> Scan.repeat <span class="main">(</span>Scan.unless <span class="main">(</span>$$ <span class="inner_quoted">"("</span> <span class="main">)</span> <span class="main">(</span>Scan.one Symbol.not_eof<span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">result</span> <span class="main">=</span> Scan.finite Symbol.stopper <span class="entity">parser</span> <span class="entity">tokens</span> |&gt; fst |&gt; String.concat<span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">result</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">infix</span></span> ??<span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ass</span> <span class="entity">??</span> <span class="entity">f</span> <span class="main">=</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">ass</span> <span class="entity">x</span>  <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">f</span> <span class="entity">x</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">x</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rm_parentheses</span> <span class="entity">str</span> <span class="main">=</span> <span class="main">(</span><span class="entity">is_in_paren</span> <span class="entity">??</span> unenclose<span class="main">)</span> <span class="entity">str</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">remove__s</span> <span class="entity">name</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">suffix_is__</span> <span class="main">=</span> String.isSuffix <span class="inner_quoted">"_"</span> <span class="entity">name</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">remove_</span>     <span class="main">=</span> unsuffix <span class="inner_quoted">"_"</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">wo__s</span>       <span class="main">=</span> <span class="main">(</span><span class="entity">suffix_is__</span> ? <span class="main">(</span><span class="entity">remove__s</span> o <span class="entity">remove_</span><span class="main">)</span><span class="main">)</span> <span class="entity">name</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">wo__s</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">push_to_front</span> <span class="entity">key</span> <span class="entity">things</span> <span class="main">=</span>
  filter     <span class="main">(</span>String.isSubstring <span class="entity">key</span><span class="main">)</span> <span class="entity">things</span> @
  filter_out <span class="main">(</span>String.isSubstring <span class="entity">key</span><span class="main">)</span> <span class="entity">things</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">the'</span> <span class="main">(</span><span class="entity">mssg</span><span class="main">:</span>string<span class="main">)</span>  NONE        <span class="main">=</span> error <span class="entity">mssg</span>
 <span class="main">|</span>  <span class="entity">the'</span> <span class="main">(</span><span class="main">_</span>   <span class="main">:</span>string<span class="main">)</span> <span class="main">(</span>SOME <span class="entity">thing</span><span class="main">)</span> <span class="main">=</span> <span class="entity">thing</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prefix_if_nonempty</span> <span class="main">_</span>        <span class="main">[</span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="main">]</span>
 <span class="main">|</span>  <span class="entity">prefix_if_nonempty</span> <span class="entity">prefixed</span> <span class="entity">xs</span> <span class="main">=</span> <span class="entity">prefixed</span> :: <span class="entity">xs</span> <span class="main">:</span> string list<span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">debug</span> <span class="main">=</span> false<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">try_with</span>  <span class="main">(</span><span class="entity">fallback</span><span class="main">:</span>'b<span class="main">)</span> <span class="main">(</span><span class="entity">f</span><span class="main">:</span>'a <span class="main">-&gt;</span> 'b<span class="main">)</span> <span class="main">(</span><span class="entity">x</span><span class="main">:</span>'a<span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> try <span class="entity">f</span> <span class="entity">x</span> <span class="keyword2"><span class="keyword">of</span></span>
  NONE <span class="main">=&gt;</span> <span class="entity">fallback</span>
<span class="main">|</span> SOME <span class="entity">y</span> <span class="main">=&gt;</span> <span class="entity">y</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">to_bool</span> EQUAL <span class="main">=</span> true
 <span class="main">|</span>  <span class="entity">to_bool</span> <span class="main">_</span>     <span class="main">=</span> false<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">are_same</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">to_bool</span> o String.compare<span class="main">)</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(*** SEQ2 : Auxiliary functions on Seq.seq ***)</span>
<span class="comment1">(*
  SEQ2 contains useful functions defined on Seq.seq that do not appear the Isabelle source code.
  AEQ2 does not have significant duplication with the Isabelle source code. 
*)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">SEQ2</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> mk_pairs      <span class="main">:</span> <span class="main">(</span>'a <span class="main">-&gt;</span> 'b Seq.seq<span class="main">)</span> * 'c <span class="main">-&gt;</span> 'a <span class="main">-&gt;</span> 'd <span class="main">-&gt;</span> <span class="main">(</span>'c * <span class="main">(</span>'b * 'd<span class="main">)</span><span class="main">)</span> Seq.seq<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> map_arg       <span class="main">:</span> 'a <span class="main">-&gt;</span> <span class="main">(</span>'a <span class="main">-&gt;</span> 'b<span class="main">)</span> Seq.seq <span class="main">-&gt;</span> 'b Seq.seq<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> pairs         <span class="main">:</span> 'a Seq.seq <span class="main">-&gt;</span> 'b Seq.seq <span class="main">-&gt;</span> <span class="main">(</span>'a * 'b<span class="main">)</span> Seq.seq<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> foldr         <span class="main">:</span> <span class="main">(</span>'a * 'b <span class="main">-&gt;</span> 'b<span class="main">)</span> <span class="main">-&gt;</span> 'b <span class="main">-&gt;</span> 'a Seq.seq <span class="main">-&gt;</span> 'b<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> foldr1        <span class="main">:</span> <span class="main">(</span>'a * 'a <span class="main">-&gt;</span> 'a<span class="main">)</span> <span class="main">-&gt;</span>       'a Seq.seq <span class="main">-&gt;</span> 'a<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> seq_number    <span class="main">:</span> 'a Seq.seq <span class="main">-&gt;</span> <span class="main">(</span>int * 'a<span class="main">)</span> Seq.seq<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> same_seq      <span class="main">:</span> <span class="main">(</span>'a * 'a <span class="main">-&gt;</span> bool<span class="main">)</span> <span class="main">-&gt;</span> 'a Seq.seq * 'a Seq.seq <span class="main">-&gt;</span> bool<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> powerset      <span class="main">:</span> 'a Seq.seq <span class="main">-&gt;</span> 'a Seq.seq Seq.seq<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> seq_to_option <span class="main">:</span> 'a Seq.seq <span class="main">-&gt;</span> 'a option<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> try_seq       <span class="main">:</span> <span class="main">(</span>'a <span class="main">-&gt;</span> 'b Seq.seq<span class="main">)</span> <span class="main">-&gt;</span> 'a <span class="main">-&gt;</span> 'b Seq.seq<span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(*** Seq2 : Auxiliary functions on Seq.seq ***)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Seq2</span> <span class="main">:</span> <span class="entity">SEQ2</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_pairs</span> <span class="main">(</span><span class="main">(</span><span class="entity">func</span><span class="main">,</span> <span class="entity">logs</span><span class="main">)</span><span class="main">:</span><span class="main">(</span><span class="main">(</span>'a <span class="main">-&gt;</span> 'b Seq.seq<span class="main">)</span> * 'c<span class="main">)</span><span class="main">)</span> <span class="entity">goal</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">seq</span>   <span class="main">=</span> <span class="entity">func</span> <span class="entity">goal</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pairs</span> <span class="main">=</span> Seq.map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">logs</span><span class="main">,</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">seq</span>
    <span class="keyword2"><span class="keyword">in</span></span> 
      <span class="entity">pairs</span>
    <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_arg</span> <span class="entity">para</span> <span class="entity">funcs</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> Seq.pull <span class="entity">funcs</span> <span class="keyword2"><span class="keyword">of</span></span>
    NONE <span class="main">=&gt;</span> Seq.empty
  <span class="main">|</span> SOME <span class="main">(</span><span class="entity">func</span><span class="main">,</span> <span class="entity">funcs_tl</span><span class="main">)</span> <span class="main">=&gt;</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tail</span> <span class="main">_</span> <span class="main">=</span> <span class="entity">map_arg</span> <span class="entity">para</span> <span class="entity">funcs_tl</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">result</span> <span class="main">=</span> Seq.make <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">)</span> <span class="main">=&gt;</span> SOME <span class="main">(</span><span class="entity">func</span> <span class="entity">para</span><span class="main">,</span> <span class="entity">tail</span> <span class="main">(</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword2"><span class="keyword">in</span></span>
       <span class="entity">result</span>
      <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pairs</span> <span class="main">(</span><span class="entity">seq1</span><span class="main">:</span>'a Seq.seq<span class="main">)</span> <span class="main">(</span><span class="entity">seq2</span><span class="main">:</span>'b Seq.seq<span class="main">)</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> Seq.pull <span class="entity">seq1</span> <span class="keyword2"><span class="keyword">of</span></span>
    NONE        <span class="main">=&gt;</span> Seq.empty
  <span class="main">|</span> SOME <span class="main">(</span><span class="entity">x</span><span class="main">,</span><span class="entity">xs</span><span class="main">)</span> <span class="main">=&gt;</span> Seq.cons <span class="main">(</span>pair <span class="entity">x</span> <span class="main">(</span>Seq.hd <span class="entity">seq2</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="entity">pairs</span> <span class="entity">xs</span> <span class="main">(</span>Seq.tl <span class="entity">seq2</span><span class="main">)</span><span class="main">)</span> <span class="main">:</span> <span class="main">(</span>'a * 'b<span class="main">)</span> Seq.seq<span class="main">;</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">foldr</span> <span class="entity">f</span> <span class="entity">b</span> <span class="entity">xs</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> Seq.pull <span class="entity">xs</span> <span class="keyword2"><span class="keyword">of</span></span>
    NONE         <span class="main">=&gt;</span> <span class="entity">b</span>
  <span class="main">|</span> SOME <span class="main">(</span><span class="entity">y</span><span class="main">,</span> <span class="entity">ys</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">f</span> <span class="main">(</span><span class="entity">y</span><span class="main">,</span> <span class="entity">foldr</span> <span class="entity">f</span> <span class="entity">b</span> <span class="entity">ys</span><span class="main">)</span><span class="main">;</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">foldr1</span> <span class="entity">func</span> <span class="entity">sq</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> Seq.pull <span class="entity">sq</span> <span class="keyword2"><span class="keyword">of</span></span>
    NONE   <span class="main">=&gt;</span> error <span class="inner_quoted">"Empty seq in foldr1."</span>
  <span class="main">|</span> SOME <span class="main">_</span> <span class="main">=&gt;</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">itr_seq</span> <span class="entity">st</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> Seq.pull <span class="entity">st</span> <span class="keyword2"><span class="keyword">of</span></span>
        NONE                <span class="main">=&gt;</span> error <span class="inner_quoted">"Empty seq."</span>
      <span class="main">|</span> SOME <span class="main">(</span><span class="entity">st_hd</span><span class="main">,</span> <span class="entity">st_tl</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">case</span></span> Seq.pull <span class="entity">st_tl</span> <span class="keyword2"><span class="keyword">of</span></span>
          NONE <span class="main">=&gt;</span> <span class="entity">st_hd</span>
        <span class="main">|</span> SOME <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">func</span> <span class="main">(</span><span class="entity">st_hd</span><span class="main">,</span> <span class="entity">itr_seq</span>  <span class="entity">st_tl</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">itr_seq</span> <span class="entity">sq</span>
    <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
  
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">seq_number</span> <span class="main">(</span><span class="entity">xs</span><span class="main">:</span>'a Seq.seq<span class="main">)</span> <span class="main">:</span> <span class="main">(</span>int * 'a<span class="main">)</span> Seq.seq <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">seq_number'</span> <span class="main">(</span><span class="entity">xs</span> <span class="main">:</span> 'a Seq.seq<span class="main">)</span> <span class="main">(</span><span class="entity">n</span><span class="main">:</span>int<span class="main">)</span> <span class="main">(</span><span class="entity">ys</span> <span class="main">:</span> <span class="main">(</span>int * 'a<span class="main">)</span> Seq.seq<span class="main">)</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> Seq.pull <span class="entity">xs</span> <span class="keyword2"><span class="keyword">of</span></span>
        NONE              <span class="main">=&gt;</span> <span class="entity">ys</span> <span class="main">:</span> <span class="main">(</span>int * 'a<span class="main">)</span> Seq.seq
      <span class="main">|</span> SOME <span class="main">(</span><span class="entity">x</span><span class="main">:</span>'a<span class="main">,</span> <span class="entity">tail</span><span class="main">)</span> <span class="main">=&gt;</span> 
         <span class="keyword2"><span class="keyword">if</span></span>   <span class="entity">n</span> &lt; <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span> error <span class="inner_quoted">"seq_number' in Utils failed. negative index!"</span>
         <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">seq_number'</span> <span class="entity">tail</span> <span class="main">(</span><span class="entity">n</span> + <span class="inner_numeral">1</span><span class="main">)</span> <span class="main">(</span>Seq.append  <span class="entity">ys</span> <span class="main">(</span>Seq.single <span class="main">(</span><span class="entity">n</span><span class="main">,</span> <span class="entity">x</span><span class="main">)</span><span class="main">)</span> <span class="main">:</span> <span class="main">(</span>int * 'a<span class="main">)</span> Seq.seq<span class="main">)</span><span class="main">;</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">seq_number'</span> <span class="entity">xs</span> <span class="inner_numeral">0</span> Seq.empty
    <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

  <span class="comment1">(*For "same_seq test (xs, ys)" to be true, they have to be of the same length.*)</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">same_seq</span> <span class="main">(</span><span class="entity">are_same</span> <span class="main">:</span> <span class="main">(</span><span class="main">(</span>'a * 'a<span class="main">)</span> <span class="main">-&gt;</span> bool<span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="entity">xs</span><span class="main">:</span>'a Seq.seq<span class="main">,</span>  <span class="entity">ys</span><span class="main">:</span>'a Seq.seq<span class="main">)</span><span class="main">:</span>bool <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> Seq.pull <span class="entity">xs</span> <span class="keyword2"><span class="keyword">of</span></span>
    NONE <span class="main">=&gt;</span> <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> Seq.pull <span class="entity">ys</span> <span class="keyword2"><span class="keyword">of</span></span> 
      NONE   <span class="main">=&gt;</span> true
    <span class="main">|</span> SOME <span class="main">_</span> <span class="main">=&gt;</span> false<span class="main">)</span>
  <span class="main">|</span> SOME <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> Seq.pull <span class="entity">ys</span> <span class="keyword2"><span class="keyword">of</span></span>
      NONE   <span class="main">=&gt;</span> false
    <span class="main">|</span> SOME <span class="main">(</span><span class="entity">y</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">are_same</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">same_seq</span> <span class="entity">are_same</span> <span class="main">(</span>Seq.tl <span class="entity">xs</span><span class="main">,</span> Seq.tl <span class="entity">ys</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>

  <span class="comment1">(*Starts from smaller sets.*)</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">powerset</span> <span class="main">(</span><span class="entity">xs</span><span class="main">:</span>'a Seq.seq<span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">poset</span> <span class="main">(</span><span class="entity">ys</span><span class="main">,</span> <span class="entity">base</span><span class="main">)</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> Seq.pull <span class="entity">ys</span> <span class="keyword2"><span class="keyword">of</span></span>
        NONE <span class="main">=&gt;</span> Seq.single <span class="entity">base</span>
      <span class="main">|</span> SOME <span class="main">(</span><span class="entity">head</span><span class="main">,</span> <span class="entity">tail</span><span class="main">)</span> <span class="main">=&gt;</span> Seq.append <span class="main">(</span><span class="entity">poset</span> <span class="main">(</span><span class="entity">tail</span><span class="main">,</span> <span class="entity">base</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="entity">poset</span> <span class="main">(</span><span class="entity">tail</span><span class="main">,</span> Seq.cons <span class="entity">head</span> <span class="entity">base</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">poset</span> <span class="main">(</span><span class="entity">xs</span><span class="main">,</span> Seq.empty<span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

  <span class="comment1">(*seq_to_op ignores tails*)</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">seq_to_option</span> <span class="main">(</span><span class="entity">seq</span><span class="main">:</span>'a Seq.seq<span class="main">)</span> <span class="main">:</span> 'a option <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> Seq.pull <span class="entity">seq</span> <span class="keyword2"><span class="keyword">of</span></span>
     NONE <span class="main">=&gt;</span> NONE
   <span class="main">|</span> SOME <span class="main">(</span><span class="entity">head</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> SOME <span class="entity">head</span><span class="main">;</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">try_seq</span> <span class="main">(</span><span class="entity">f</span><span class="main">:</span>'a <span class="main">-&gt;</span> 'b Seq.seq<span class="main">)</span> <span class="main">(</span><span class="entity">x</span><span class="main">:</span>'a<span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> try <span class="entity">f</span> <span class="entity">x</span> <span class="keyword2"><span class="keyword">of</span></span>
    NONE <span class="main">=&gt;</span> Seq.empty
  <span class="main">|</span> SOME <span class="entity">y</span> <span class="main">=&gt;</span> <span class="entity">y</span><span class="main">)</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(*** ISABELLE_UTILS : Utility functions specific to Isabelle/HOL. ***)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">ISABELLE_UTILS</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> get_1st_subg                  <span class="main">:</span> thm <span class="main">-&gt;</span> term option<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> flatten_trm                   <span class="main">:</span> term <span class="main">-&gt;</span> term list<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_trms_in_thm               <span class="main">:</span> thm <span class="main">-&gt;</span> term list<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_typ_names_in_trm          <span class="main">:</span> term <span class="main">-&gt;</span> string list<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_const_names_in_thm        <span class="main">:</span> thm <span class="main">-&gt;</span> string list<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_const_names_in_1st_subg   <span class="main">:</span> thm <span class="main">-&gt;</span> string list<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_abs_names_in_trm          <span class="main">:</span> term <span class="main">-&gt;</span> string list<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_abs_names_in_thm          <span class="main">:</span> thm <span class="main">-&gt;</span> string list<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_abs_name_in_1st_subg      <span class="main">:</span> thm <span class="main">-&gt;</span> string list<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_typ_names_in_thm          <span class="main">:</span> thm <span class="main">-&gt;</span> string list<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_typ_names_in_1st_subg     <span class="main">:</span> thm <span class="main">-&gt;</span> string list<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_free_var_names_in_trms    <span class="main">:</span> term list <span class="main">-&gt;</span> string list<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_free_var_names_in_thm     <span class="main">:</span> thm <span class="main">-&gt;</span> string list<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_free_var_names_in_1st_subg<span class="main">:</span> thm <span class="main">-&gt;</span> string list<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_all_var_names_in_1st_subg <span class="main">:</span> thm <span class="main">-&gt;</span> string list<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> proof_state_to_thm            <span class="main">:</span> <span class="entity">Proof.state</span> <span class="main">-&gt;</span> thm<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> mk_proof_obligation           <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string <span class="main">-&gt;</span> thm<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> TIMEOUT_in                    <span class="main">:</span> real <span class="main">-&gt;</span> <span class="main">(</span>'a <span class="main">-&gt;</span> 'b Seq.seq<span class="main">)</span> <span class="main">-&gt;</span> 'a <span class="main">-&gt;</span> 'b Seq.seq<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> TIMEOUT                       <span class="main">:</span> <span class="main">(</span>'a <span class="main">-&gt;</span> 'b Seq.seq<span class="main">)</span> <span class="main">-&gt;</span> 'a <span class="main">-&gt;</span> 'b Seq.seq<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> same_except_for_fst_prem      <span class="main">:</span> thm <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> bool<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> defer                         <span class="main">:</span> thm <span class="main">-&gt;</span> thm Seq.seq<span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(*** Isabelle_Utils : Utility functions specific to Isabelle/HOL. ***)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Isabelle_Utils</span> <span class="main">:</span> <span class="entity">ISABELLE_UTILS</span>  <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_1st_subg</span> <span class="main">(</span><span class="entity">goal</span><span class="main">:</span>thm<span class="main">)</span> <span class="main">=</span> <span class="main">(</span>SOME o hd<span class="main">)</span> <span class="main">(</span>Thm.prems_of <span class="entity">goal</span><span class="main">)</span> <span class="keyword3"><span class="keyword">handle</span></span> Empty <span class="main">=&gt;</span> NONE <span class="main">:</span> term option<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">flatten_trm</span> <span class="main">(</span><span class="entity">trm1</span> $ <span class="entity">trm2</span><span class="main">)</span> <span class="main">=</span> flat <span class="main">[</span><span class="entity">flatten_trm</span> <span class="entity">trm1</span><span class="main">,</span> <span class="entity">flatten_trm</span> <span class="entity">trm2</span><span class="main">]</span>
  <span class="main">|</span> <span class="entity">flatten_trm</span> <span class="entity">trm</span> <span class="main">=</span> <span class="main">[</span><span class="entity">trm</span><span class="main">]</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_trms_in_thm</span> <span class="main">(</span><span class="entity">thm</span><span class="main">:</span>thm<span class="main">)</span> <span class="main">=</span> Thm.cprop_of <span class="entity">thm</span> |&gt; Thm.term_of |&gt; <span class="entity">flatten_trm</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_const_names_in_thm</span> <span class="entity">thm</span> <span class="main">=</span> <span class="entity">thm</span>
  |&gt; Thm.cprop_of
  |&gt; Thm.term_of
  |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">subg</span><span class="main">:</span>term <span class="main">=&gt;</span> Term.add_const_names <span class="entity">subg</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_const_names_in_1st_subg</span> <span class="main">(</span><span class="entity">goal</span><span class="main">:</span>thm<span class="main">)</span> <span class="main">=</span> <span class="entity">goal</span>
  |&gt; <span class="entity">get_1st_subg</span>
  |&gt; Option.map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">subg</span><span class="main">:</span>term <span class="main">=&gt;</span> Term.add_const_names <span class="entity">subg</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
  |&gt; these<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_typs_in_trm</span> <span class="main">(</span>Const <span class="main">(</span><span class="main">_</span> <span class="main">,</span><span class="entity">T</span><span class="main">)</span><span class="main">)</span>    <span class="main">=</span> <span class="main">[</span><span class="entity">T</span><span class="main">]</span>
 <span class="main">|</span>  <span class="entity">get_typs_in_trm</span> <span class="main">(</span>Free <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span>     <span class="main">=</span> <span class="main">[</span><span class="entity">T</span><span class="main">]</span>
 <span class="main">|</span>  <span class="entity">get_typs_in_trm</span> <span class="main">(</span>Var <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span>      <span class="main">=</span> <span class="main">[</span><span class="entity">T</span><span class="main">]</span>
 <span class="main">|</span>  <span class="entity">get_typs_in_trm</span> <span class="main">(</span>Bound <span class="main">_</span><span class="main">)</span>         <span class="main">=</span> <span class="main">[</span><span class="main">]</span>
 <span class="main">|</span>  <span class="entity">get_typs_in_trm</span> <span class="main">(</span>Abs <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">T</span><span class="main">,</span> <span class="entity">trm</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">T</span> :: <span class="entity">get_typs_in_trm</span> <span class="entity">trm</span>
 <span class="main">|</span>  <span class="entity">get_typs_in_trm</span> <span class="main">(</span><span class="entity">trm1</span> $ <span class="entity">trm2</span><span class="main">)</span>     <span class="main">=</span> <span class="entity">get_typs_in_trm</span> <span class="entity">trm1</span> @ <span class="entity">get_typs_in_trm</span> <span class="entity">trm2</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">local</span></span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_typ_names'</span> <span class="main">(</span>Type <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">typs</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">name</span> :: flat <span class="main">(</span>map <span class="entity">get_typ_names'</span> <span class="entity">typs</span><span class="main">)</span>
   <span class="main">|</span>  <span class="entity">get_typ_names'</span> <span class="main">(</span>TFree <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span>   <span class="main">=</span> <span class="main">[</span><span class="entity">name</span><span class="main">]</span>
   <span class="main">|</span>  <span class="entity">get_typ_names'</span> <span class="main">(</span>TVar <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span>       <span class="main">=</span> <span class="main">[</span><span class="main">]</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">in</span></span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_typs_names</span> <span class="main">(</span><span class="entity">typs</span><span class="main">:</span>typ list<span class="main">)</span> <span class="main">=</span> map <span class="entity">get_typ_names'</span> <span class="entity">typs</span> |&gt; flat<span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_abs_names_in_trm</span> <span class="main">(</span>Abs <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">trm</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">name</span> :: <span class="main">(</span><span class="entity">trm</span> |&gt; <span class="entity">flatten_trm</span> |&gt; map <span class="entity">get_abs_names_in_trm</span> |&gt; flat<span class="main">)</span>
 <span class="main">|</span>  <span class="entity">get_abs_names_in_trm</span> <span class="main">(</span><span class="entity">trm1</span> $ <span class="entity">trm2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">get_abs_names_in_trm</span> <span class="entity">trm1</span> @ <span class="entity">get_abs_names_in_trm</span> <span class="entity">trm2</span>
 <span class="main">|</span>  <span class="entity">get_abs_names_in_trm</span> <span class="main">_</span> <span class="main">=</span> <span class="main">[</span><span class="main">]</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_abs_names_in_thm</span> <span class="entity">thm</span> <span class="main">=</span> <span class="entity">thm</span> |&gt; Thm.cprop_of |&gt; Thm.term_of |&gt; <span class="entity">get_abs_names_in_trm</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_abs_name_in_1st_subg</span> <span class="main">(</span><span class="entity">goal</span><span class="main">:</span>thm<span class="main">)</span> <span class="main">=</span> <span class="entity">goal</span>
  |&gt; <span class="entity">get_1st_subg</span>
  |&gt; Option.map <span class="entity">get_abs_names_in_trm</span>
  |&gt; these
  |&gt; map <span class="entity">Utils.remove__s</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_typ_names_in_trm</span> <span class="entity">trm</span> <span class="main">=</span> <span class="entity">trm</span> 
  |&gt; <span class="entity">get_typs_in_trm</span>
  |&gt; <span class="entity">get_typs_names</span>
  |&gt; duplicates <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span>
  |&gt; map <span class="entity">Utils.remove__s</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_typ_names_in_thm</span> <span class="entity">thm</span> <span class="main">=</span> <span class="entity">thm</span> 
  |&gt; <span class="entity">get_trms_in_thm</span>
  |&gt; map <span class="entity">get_typ_names_in_trm</span>
  |&gt; flat
  |&gt; duplicates <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span>
  |&gt; map <span class="entity">Utils.remove__s</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_typ_names_in_1st_subg</span> <span class="main">(</span><span class="entity">goal</span><span class="main">:</span>thm<span class="main">)</span> <span class="main">=</span> <span class="entity">goal</span>
  |&gt; <span class="entity">get_1st_subg</span>
  |&gt; Option.map <span class="entity">get_typ_names_in_trm</span>
  |&gt; these
  |&gt; map <span class="entity">Utils.remove__s</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_free_var_names_in</span> <span class="entity">trm</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> Term.is_Free <span class="entity">trm</span> 
  <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span>Term.dest_Free <span class="entity">trm</span> |&gt; fst |&gt; <span class="entity">Utils.remove__s</span><span class="main">]</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="main">]</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_free_var_names_in_trms</span> <span class="entity">trms</span> <span class="main">=</span> <span class="entity">trms</span>
  |&gt; map <span class="entity">get_free_var_names_in</span>
  |&gt; List.concat
  |&gt; distinct <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_free_var_names_in_thm</span> <span class="entity">thm</span> <span class="main">=</span> <span class="entity">thm</span>
  |&gt; <span class="entity">get_trms_in_thm</span>
  |&gt; <span class="entity">get_free_var_names_in_trms</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_free_var_names_in_1st_subg</span> <span class="main">(</span><span class="entity">goal</span><span class="main">:</span>thm<span class="main">)</span> <span class="main">=</span> <span class="entity">goal</span>
  |&gt; <span class="entity">get_1st_subg</span>
  |&gt; Option.map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">subg</span><span class="main">:</span>term <span class="main">=&gt;</span> Term.add_frees <span class="entity">subg</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
  |&gt; Option.map <span class="main">(</span>map fst<span class="main">)</span>
  |&gt; these
  |&gt; map <span class="entity">Utils.remove__s</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_all_var_names_in_1st_subg</span> <span class="main">(</span><span class="entity">goal</span><span class="main">:</span>thm<span class="main">)</span> <span class="main">=</span>
    Option.map <span class="main">(</span>map fst o strip_all_vars<span class="main">)</span> <span class="main">(</span><span class="entity">get_1st_subg</span> <span class="entity">goal</span><span class="main">)</span>
  |&gt; these
  |&gt; map <span class="entity">Utils.remove__s</span> <span class="main">:</span> string list<span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">proof_state_to_thm</span> <span class="main">=</span> <span class="main">#</span>goal o <span class="entity">Proof.goal</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_proof_obligation</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">prop_str</span><span class="main">:</span>string<span class="main">)</span> <span class="main">=</span> 
  Syntax.read_prop <span class="entity">ctxt</span> <span class="entity">prop_str</span>
  |&gt; Thm.cterm_of <span class="entity">ctxt</span>
  |&gt; Thm.trivial<span class="main">;</span>

<span class="keyword2"><span class="keyword">local</span></span>
<span class="comment1">(* SINGLE is copied from Tactical.ML, but the types are more general.*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">SINGLE</span> <span class="entity">tacf</span> <span class="main">=</span> Option.map fst o Seq.pull o <span class="entity">tacf</span><span class="main">;</span>

<span class="comment1">(* DETERM_TIMEOUT was originally written by Jasmin Blanchette in nitpick_util.ML.
 * This version has exception handling on top of his version.*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">DETERM_TIMEOUT</span> <span class="entity">delay</span> <span class="entity">tac</span> <span class="entity">st</span> <span class="main">=</span>
  Seq.of_list <span class="main">(</span>the_list <span class="main">(</span>Timeout.apply <span class="entity">delay</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">SINGLE</span> <span class="entity">tac</span> <span class="entity">st</span><span class="main">)</span> <span class="main">(</span><span class="main">)</span>
   <span class="keyword3"><span class="keyword">handle</span></span> Timeout.TIMEOUT <span class="main">_</span> <span class="main">=&gt;</span> NONE<span class="main">)</span><span class="main">)</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">in</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">TIMEOUT_in</span> <span class="entity">real</span> <span class="entity">tac</span> <span class="main">=</span> <span class="entity">DETERM_TIMEOUT</span> <span class="main">(</span>seconds <span class="entity">real</span><span class="main">)</span> <span class="entity">tac</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">TIMEOUT</span> <span class="entity">tac</span>         <span class="main">=</span> <span class="entity">DETERM_TIMEOUT</span> <span class="main">(</span>seconds <span class="inner_numeral">0.3</span><span class="main">)</span> <span class="entity">tac</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(*same_except_for_fst_prem checks if two thms are the same except for the first premise of the second.*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">same_except_for_fst_prem</span> <span class="main">(</span><span class="entity">goal1</span><span class="main">:</span>thm<span class="main">)</span> <span class="main">(</span><span class="entity">goal2</span><span class="main">:</span>thm<span class="main">)</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">let</span></span>
  <span class="comment1">(*goal1 should have one less premise.*)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">concl1</span>                            <span class="main">=</span> Thm.concl_of <span class="entity">goal1</span> <span class="main">:</span> term <span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">concl2</span>                            <span class="main">=</span> Thm.concl_of <span class="entity">goal2</span> <span class="main">:</span> term <span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq_concl</span>                          <span class="main">=</span> Term.aconv <span class="main">(</span><span class="entity">concl1</span><span class="main">,</span> <span class="entity">concl2</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prems1</span>                            <span class="main">=</span> Thm.prems_of <span class="entity">goal1</span> <span class="main">:</span> term list<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prems2</span>                            <span class="main">=</span> Thm.prems_of <span class="entity">goal2</span> <span class="main">:</span> term list <span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goal1_has_a_prem</span>                  <span class="main">=</span> List.null <span class="entity">prems1</span> <span class="main">:</span> bool <span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prems1_prems2tl</span> <span class="entity">prems1</span> <span class="entity">prems2</span>     <span class="main">=</span> <span class="entity">prems1</span> ~~ List.tl <span class="entity">prems2</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prems1_equiv_prems2</span> <span class="entity">prems1</span> <span class="entity">prems2</span> <span class="main">=</span> List.all <span class="main">(</span>Term.aconv<span class="main">)</span> <span class="main">(</span><span class="entity">prems1_prems2tl</span> <span class="entity">prems1</span> <span class="entity">prems2</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">test</span> <span class="entity">prems1</span> <span class="entity">prems2</span>                <span class="main">=</span> <span class="entity">eq_concl</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">prems1_equiv_prems2</span> <span class="entity">prems1</span> <span class="entity">prems2</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">in</span></span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">goal1_has_a_prem</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">test</span> <span class="entity">prems1</span> <span class="entity">prems2</span> <span class="keyword2"><span class="keyword">else</span></span> true
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">defer</span> <span class="main">=</span> defer_tac <span class="inner_numeral">1</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(*** FIND_THEOREMS2: provides an interface of find_theorem for PSL. ***)</span>
<span class="comment1">(*
 FIND_THEOREMS2 provides an interface of find_theorem for PSL.
 FIND_THEOREMS2 does not include significant code duplication with the Isabelle source code.
*)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">FIND_THEOREMS2</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">include</span></span> <span class="entity">FIND_THEOREMS</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">context</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">ref</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">get_rules</span> <span class="main">=</span> <span class="entity">context</span> <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">ref</span> * thm<span class="main">)</span> list<span class="main">;</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">get_rule_names</span> <span class="main">=</span> <span class="entity">context</span> <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> string list<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_criterion             <span class="main">:</span> string <span class="main">-&gt;</span> string <span class="main">-&gt;</span> <span class="main">(</span>bool * 'a <span class="entity">criterion</span><span class="main">)</span> list<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> name_to_rules             <span class="main">:</span> <span class="entity">context</span> <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> string <span class="main">-&gt;</span> string <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">ref</span> * thm<span class="main">)</span> list<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> names_to_rules            <span class="main">:</span> <span class="entity">context</span> <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> string <span class="main">-&gt;</span> string list <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">ref</span> * thm<span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> get_rule_names            <span class="main">:</span> <span class="entity">get_rules</span> <span class="main">-&gt;</span> <span class="entity">context</span> <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> xstring list<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_simp_rules            <span class="main">:</span> <span class="entity">get_rules</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_induct_rules          <span class="main">:</span> <span class="entity">get_rules</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_coinduction_rules     <span class="main">:</span> <span class="entity">get_rules</span><span class="main">;</span>
  <span class="comment1">(*These get_(elim, intro, dest)_rules may not be powerful enough.*)</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_elim_rules            <span class="main">:</span> <span class="entity">get_rules</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_intro_rules           <span class="main">:</span> <span class="entity">get_rules</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_dest_rules            <span class="main">:</span> <span class="entity">get_rules</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_split_rules           <span class="main">:</span> <span class="entity">get_rules</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_simp_rule_names       <span class="main">:</span> <span class="entity">get_rule_names</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_induct_rule_names     <span class="main">:</span> <span class="entity">get_rule_names</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_coinduction_rule_names<span class="main">:</span> <span class="entity">get_rule_names</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_elim_rule_names       <span class="main">:</span> <span class="entity">get_rule_names</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_intro_rule_names      <span class="main">:</span> <span class="entity">get_rule_names</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_dest_rule_names       <span class="main">:</span> <span class="entity">get_rule_names</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_split_rule_names      <span class="main">:</span> <span class="entity">get_rule_names</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_fact_names_mesh       <span class="main">:</span> <span class="entity">Proof.state</span> <span class="main">-&gt;</span> string list<span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(*** Find_Theorems2: provides an interface of find_theorem for PSL. ***)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Find_Theorems2</span> <span class="main">:</span> <span class="entity">FIND_THEOREMS2</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword3"><span class="keyword">open</span></span> Find_Theorems<span class="main">;</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">context</span> <span class="main">=</span> <span class="entity">Proof.context</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">ref</span> <span class="main">=</span> Facts.ref<span class="main">;</span>
<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">get_rules</span> <span class="main">=</span> <span class="entity">context</span> <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">ref</span> * thm<span class="main">)</span> list<span class="main">;</span>
<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">get_rule_names</span> <span class="main">=</span> <span class="entity">context</span> <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> string list<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_criterion</span> <span class="entity">kind_name</span> <span class="entity">name</span> <span class="main">=</span> <span class="main">[</span><span class="main">(</span>true<span class="main">,</span> <span class="entity">Name</span> <span class="entity">name</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span>true<span class="main">,</span> <span class="entity">Name</span> <span class="entity">kind_name</span><span class="main">)</span><span class="main">]</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">name_to_rules</span> <span class="entity">ctxt</span> <span class="entity">goal</span> <span class="entity">kind_name</span> <span class="entity">name</span> <span class="main">=</span>
  <span class="entity">find_theorems</span> <span class="entity">ctxt</span> <span class="main">(</span>SOME <span class="entity">goal</span><span class="main">)</span> NONE true <span class="main">(</span><span class="entity">get_criterion</span> <span class="entity">kind_name</span> <span class="entity">name</span><span class="main">)</span> |&gt; snd<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">names_to_rules</span> <span class="entity">ctxt</span> <span class="entity">goal</span> <span class="entity">kind_name</span> <span class="entity">names</span> <span class="main">=</span> <span class="entity">names</span>
  |&gt; map <span class="main">(</span><span class="entity">name_to_rules</span> <span class="entity">ctxt</span> <span class="entity">goal</span> <span class="entity">kind_name</span><span class="main">)</span>
  |&gt; flat
  |&gt; distinct <span class="main">(</span>Thm.eq_thm o <span class="entity">Utils.map_pair</span> snd<span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_rule_names</span> <span class="main">(</span><span class="entity">get_rules</span><span class="main">:</span><span class="entity">context</span> <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">ref</span> * thm<span class="main">)</span> list<span class="main">)</span> <span class="entity">ctxt</span> <span class="entity">goal</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">related_rules</span>          <span class="main">=</span> <span class="entity">get_rules</span> <span class="entity">ctxt</span> <span class="entity">goal</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">related_rule_names</span>     <span class="main">=</span> map <span class="main">(</span>Facts.string_of_ref o fst<span class="main">)</span> <span class="entity">related_rules</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_thm</span>  <span class="entity">thm_nm</span>        <span class="main">=</span> SOME <span class="main">(</span>Proof_Context.get_thm  <span class="entity">ctxt</span> <span class="entity">thm_nm</span><span class="main">)</span> <span class="keyword3"><span class="keyword">handle</span></span> ERROR <span class="main">_</span> <span class="main">=&gt;</span> NONE<span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_thms</span> <span class="entity">thm_nm</span>        <span class="main">=</span> SOME <span class="main">(</span>Proof_Context.get_thms <span class="entity">ctxt</span>
      <span class="main">(</span><span class="entity">Utils.rm_parentheses_with_contents_in_the_end</span> <span class="entity">thm_nm</span><span class="main">)</span><span class="main">)</span> <span class="keyword3"><span class="keyword">handle</span></span> ERROR <span class="main">_</span> <span class="main">=&gt;</span> NONE<span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">cannot_get_thm</span>  <span class="entity">thm_nm</span> <span class="main">=</span> is_none <span class="main">(</span><span class="entity">get_thm</span> <span class="entity">thm_nm</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">cannot_get_thms</span> <span class="entity">thm_nm</span> <span class="main">=</span> is_none <span class="main">(</span><span class="entity">get_thms</span> <span class="entity">thm_nm</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">cannot_get</span> <span class="entity">thm_nm</span>      <span class="main">=</span> <span class="entity">cannot_get_thm</span> <span class="entity">thm_nm</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">cannot_get_thms</span> <span class="entity">thm_nm</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">available_rule_names</span>   <span class="main">=</span> filter_out <span class="entity">cannot_get</span> <span class="entity">related_rule_names</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">available_rule_names</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_simp_rules</span> <span class="main">(</span><span class="entity">ctxt</span><span class="main">:</span><span class="entity">context</span><span class="main">)</span> <span class="main">(</span><span class="entity">goal</span><span class="main">:</span>thm<span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">const_names</span>   <span class="main">=</span> <span class="entity">Isabelle_Utils.get_const_names_in_1st_subg</span> <span class="entity">goal</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">related_rules</span> <span class="main">=</span> <span class="entity">names_to_rules</span> <span class="entity">ctxt</span> <span class="entity">goal</span> <span class="inner_quoted">""</span> <span class="entity">const_names</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simpset_thms</span>  <span class="main">=</span> <span class="entity">ctxt</span> |&gt; simpset_of |&gt; Raw_Simplifier.dest_ss |&gt; <span class="main">#</span>simps |&gt; map snd<span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">eq_test</span> <span class="main">(</span><span class="entity">thm1</span><span class="main">,</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">thm2</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Thm.eq_thm <span class="main">(</span><span class="entity">thm1</span><span class="main">,</span> <span class="entity">thm2</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">unique_rules</span>  <span class="main">=</span> subtract <span class="entity">eq_test</span> <span class="entity">simpset_thms</span> <span class="entity">related_rules</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">unique_rules</span> <span class="main">:</span> <span class="main">(</span>Facts.ref * thm<span class="main">)</span> list
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_simp_rule_names</span> <span class="entity">ctxt</span> <span class="entity">goal</span> <span class="main">=</span> <span class="entity">get_rule_names</span> <span class="entity">get_simp_rules</span> <span class="entity">ctxt</span> <span class="entity">goal</span> <span class="main">:</span> string list<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_induct_rules</span> <span class="main">(</span><span class="entity">ctxt</span><span class="main">:</span><span class="entity">context</span><span class="main">)</span> <span class="main">(</span><span class="entity">goal</span><span class="main">:</span>thm<span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">const_names</span>  <span class="main">=</span> <span class="entity">Isabelle_Utils.get_const_names_in_1st_subg</span> <span class="entity">goal</span> <span class="main">:</span> string list<span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">induct_rules</span> <span class="main">=</span> <span class="entity">names_to_rules</span> <span class="entity">ctxt</span> <span class="entity">goal</span> <span class="inner_quoted">".induct"</span> <span class="entity">const_names</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">induct_rules</span> <span class="main">:</span> <span class="main">(</span>Facts.ref * thm<span class="main">)</span> list
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_induct_rule_names</span> <span class="entity">ctxt</span> <span class="entity">goal</span> <span class="main">=</span> <span class="entity">get_rule_names</span> <span class="entity">get_induct_rules</span> <span class="entity">ctxt</span> <span class="entity">goal</span> <span class="main">:</span> string list<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_coinduction_rules</span> <span class="main">(</span><span class="entity">ctxt</span><span class="main">:</span><span class="entity">context</span><span class="main">)</span> <span class="main">(</span><span class="entity">goal</span><span class="main">:</span>thm<span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">const_names</span>   <span class="main">=</span> <span class="entity">Isabelle_Utils.get_const_names_in_1st_subg</span> <span class="entity">goal</span> <span class="main">:</span> string list<span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_coinduct_rules</span> <span class="entity">post</span> <span class="main">=</span> <span class="entity">names_to_rules</span> <span class="entity">ctxt</span> <span class="entity">goal</span> <span class="entity">post</span> <span class="entity">const_names</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">coinduct_rules1</span> <span class="main">=</span> <span class="entity">get_coinduct_rules</span> <span class="inner_quoted">".coinduct"</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">coinduct_rules2</span> <span class="main">=</span> <span class="entity">get_coinduct_rules</span> <span class="inner_quoted">".coinduct_strong"</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">coinduct_rules1</span> @ <span class="entity">coinduct_rules2</span><span class="main">:</span> <span class="main">(</span>Facts.ref * thm<span class="main">)</span> list
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_coinduction_rule_names</span> <span class="entity">ctxt</span> <span class="entity">goal</span> <span class="main">=</span> <span class="entity">get_rule_names</span> <span class="entity">get_coinduction_rules</span> <span class="entity">ctxt</span> <span class="entity">goal</span> <span class="main">:</span> string list<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_elim_rules</span>  <span class="entity">ctxt</span> <span class="entity">goal</span> <span class="main">=</span> <span class="entity">find_theorems</span> <span class="entity">ctxt</span> <span class="main">(</span>SOME <span class="entity">goal</span><span class="main">)</span> NONE true <span class="main">[</span><span class="main">(</span>true<span class="main">,</span> <span class="entity">Elim</span><span class="main">)</span><span class="main">]</span> |&gt; snd<span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_intro_rules</span> <span class="entity">ctxt</span> <span class="entity">goal</span> <span class="main">=</span> <span class="entity">find_theorems</span> <span class="entity">ctxt</span> <span class="main">(</span>SOME <span class="entity">goal</span><span class="main">)</span> <span class="main">(</span>SOME <span class="inner_numeral">100</span><span class="main">)</span> true <span class="main">[</span><span class="main">(</span>true<span class="main">,</span> <span class="entity">Intro</span><span class="main">)</span><span class="main">]</span> |&gt; snd<span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_dest_rules</span>  <span class="entity">ctxt</span> <span class="entity">goal</span> <span class="main">=</span> <span class="entity">find_theorems</span> <span class="entity">ctxt</span> <span class="main">(</span>SOME <span class="entity">goal</span><span class="main">)</span> <span class="main">(</span>SOME <span class="inner_numeral">100</span><span class="main">)</span> true <span class="main">[</span><span class="main">(</span>true<span class="main">,</span> <span class="entity">Dest</span><span class="main">)</span><span class="main">]</span> |&gt; snd<span class="main">;</span>
        
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_elim_rule_names</span>  <span class="entity">ctxt</span> <span class="entity">goal</span> <span class="main">=</span> <span class="entity">get_rule_names</span> <span class="entity">get_elim_rules</span>  <span class="entity">ctxt</span> <span class="entity">goal</span> <span class="main">:</span> string list<span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_intro_rule_names</span> <span class="entity">ctxt</span> <span class="entity">goal</span> <span class="main">=</span> <span class="entity">get_rule_names</span> <span class="entity">get_intro_rules</span> <span class="entity">ctxt</span> <span class="entity">goal</span> <span class="main">:</span> string list<span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_dest_rule_names</span>  <span class="entity">ctxt</span> <span class="entity">goal</span> <span class="main">=</span> <span class="entity">get_rule_names</span> <span class="entity">get_dest_rules</span>  <span class="entity">ctxt</span> <span class="entity">goal</span> <span class="main">:</span> string list<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_split_rules</span> <span class="entity">ctxt</span> <span class="entity">goal</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="comment1">(*For split, we need to use typ_names instead of const_names.*)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">used_typ_names</span> <span class="main">=</span> <span class="entity">Isabelle_Utils.get_typ_names_in_1st_subg</span> <span class="entity">goal</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">related_rules</span>  <span class="main">=</span> <span class="entity">names_to_rules</span> <span class="entity">ctxt</span> <span class="entity">goal</span> <span class="inner_quoted">"split"</span> <span class="entity">used_typ_names</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">related_rules</span> <span class="main">:</span> <span class="main">(</span>Facts.ref * thm<span class="main">)</span> list
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_split_rule_names</span> <span class="entity">ctxt</span> <span class="entity">goal</span> <span class="main">=</span> <span class="entity">get_rule_names</span> <span class="entity">get_split_rules</span> <span class="entity">ctxt</span> <span class="entity">goal</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_fact_names_mesh</span> <span class="main">(</span><span class="entity">state</span><span class="main">:</span> <span class="entity">Proof.state</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">context</span><span class="main">:</span> <span class="entity">Proof.context</span><span class="main">,</span> <span class="entity">goal</span><span class="main">:</span> thm<span class="main">,</span> <span class="entity">facts</span><span class="main">:</span> thm list<span class="main">}</span> <span class="main">=</span> <span class="entity">Proof.goal</span> <span class="entity">state</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">hyps</span><span class="main">:</span> term list<span class="main">,</span> <span class="entity">cncl</span><span class="main">:</span> term<span class="main">)</span> <span class="main">=</span> <span class="entity">ATP_Util.strip_subgoal</span> <span class="entity">goal</span> <span class="inner_numeral">1</span> <span class="entity">context</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">params</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">{</span><span class="entity">provers</span><span class="main">:</span> string list<span class="main">,</span><span class="main">...</span><span class="main">}</span><span class="main">:</span> <span class="entity">Sledgehammer_Commands.params</span> <span class="main">=</span>
      <span class="entity">Sledgehammer_Commands.default_params</span> <span class="main">(</span><span class="entity">Proof.theory_of</span> <span class="entity">state</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">keywords</span>    <span class="main">=</span> Thy_Header.get_keywords' <span class="entity">context</span><span class="main">:</span> Keyword.keywords<span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rule_table</span>  <span class="main">=</span> <span class="entity">Sledgehammer_Fact.clasimpset_rule_table_of</span> <span class="entity">context</span>
      <span class="main">:</span> <span class="entity">ATP_Problem_Generate.status</span> Termtab.table<span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_facts</span>   <span class="main">=</span> <span class="entity">Sledgehammer_Fact.all_facts</span> <span class="entity">context</span> true true <span class="entity">keywords</span> <span class="main">[</span><span class="main">]</span> <span class="entity">facts</span> <span class="entity">rule_table</span>
      <span class="main">:</span> <span class="entity">Sledgehammer_Fact.raw_fact</span> list<span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">no_override</span> <span class="main">=</span> <span class="entity">Sledgehammer_Fact.no_fact_override</span><span class="main">:</span> <span class="entity">Sledgehammer_Fact.fact_override</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">relevant_facts</span> <span class="main">:</span> <span class="main">(</span>string * <span class="entity">Sledgehammer_MaSh.fact</span> list<span class="main">)</span> list <span class="main">=</span>
      <span class="entity">Sledgehammer_MaSh.relevant_facts</span> <span class="entity">context</span> <span class="entity">params</span> <span class="main">(</span>hd <span class="entity">provers</span><span class="main">)</span> <span class="inner_numeral">200</span> <span class="entity">no_override</span> <span class="entity">hyps</span> <span class="entity">cncl</span> <span class="entity">all_facts</span><span class="main">;</span>
    <span class="comment1">(*convert relevant facts into a string list*)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">relevant_fact_names</span> <span class="main">=</span> <span class="entity">relevant_facts</span> |&gt; map <span class="main">#</span><span class="inner_numeral">2</span> |&gt; flat |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span> <span class="main">#</span><span class="inner_numeral">1</span> <span class="main">(</span><span class="main">#</span><span class="inner_numeral">1</span> <span class="entity">x</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">relevant_fact_names</span> <span class="main">:</span> string list
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(*** DYNAMIC_UTILS: Utility functions useful to generate tactics at run-time. ***)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">DYNAMIC_UTILS</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">context</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">state</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">src</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">seq</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">nontac</span>   <span class="main">=</span> 'a <span class="main">-&gt;</span> 'a <span class="entity">seq</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">node</span>    <span class="main">=</span> <span class="entity">Subgoal</span> <span class="main">|</span> <span class="entity">Done</span> <span class="main">|</span> <span class="entity">Defer</span>
                   <span class="main">|</span> <span class="entity">Apply</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="main">{</span>using<span class="main">:</span>string list<span class="main">,</span> methN<span class="main">:</span>string<span class="main">,</span> back<span class="main">:</span>int<span class="main">}</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">log</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">logtac</span>   <span class="main">=</span> 'a <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">log</span> * 'a<span class="main">)</span> <span class="entity">seq</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">st_monad</span> <span class="main">=</span> <span class="entity">log</span> <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">log</span> * 'a<span class="main">)</span> <span class="entity">seq</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">stttac</span>   <span class="main">=</span> 'a <span class="main">-&gt;</span> 'a <span class="entity">st_monad</span><span class="main">;</span>

  <span class="keyword1"><span class="keyword">val</span></span> check_src           <span class="main">:</span> <span class="entity">context</span> <span class="main">-&gt;</span> <span class="entity">src</span> <span class="main">-&gt;</span> <span class="entity">src</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> checked_src_to_meth <span class="main">:</span> <span class="entity">context</span> <span class="main">-&gt;</span> <span class="entity">src</span> <span class="main">-&gt;</span> <span class="entity">Method.method</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> str_to_tokens       <span class="main">:</span> <span class="entity">context</span> <span class="main">-&gt;</span> string <span class="main">-&gt;</span> Token.T list<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_tokens          <span class="main">:</span> string <span class="main">-&gt;</span> Token.T list <span class="main">-&gt;</span> <span class="entity">src</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_meth_nm         <span class="main">:</span> string <span class="main">-&gt;</span> string list <span class="main">-&gt;</span> string<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> reform              <span class="main">:</span> <span class="entity">log</span> * 'goal <span class="entity">nontac</span> <span class="main">-&gt;</span> 'goal <span class="entity">logtac</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> writer_to_state     <span class="main">:</span> <span class="main">(</span><span class="entity">log</span> * 'state<span class="main">)</span> <span class="entity">seq</span> <span class="main">-&gt;</span> 'state <span class="entity">st_monad</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> nontac_to_logtac    <span class="main">:</span> <span class="entity">node</span> <span class="main">-&gt;</span> 'a <span class="entity">nontac</span> <span class="main">-&gt;</span> 'a <span class="entity">logtac</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> logtac_to_stttac    <span class="main">:</span> 'a <span class="entity">logtac</span> <span class="main">-&gt;</span> 'a <span class="entity">stttac</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> log_n_nontac_to_stttac     <span class="main">:</span> <span class="entity">log</span> * 'a <span class="entity">nontac</span> <span class="main">-&gt;</span> 'a <span class="entity">stttac</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> string_to_nontac_on_pstate <span class="main">:</span> string <span class="main">-&gt;</span> <span class="entity">state</span> <span class="entity">nontac</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> string_to_stttac_on_pstate <span class="main">:</span> string <span class="main">-&gt;</span> <span class="entity">state</span> <span class="entity">stttac</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> mk_apply_script            <span class="main">:</span> <span class="entity">log</span> <span class="main">-&gt;</span> string<span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(*** Dynamic_Utils: Utility functions useful to generate tactics at run-time. ***)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Dynamic_Utils</span> <span class="main">:</span> <span class="entity">DYNAMIC_UTILS</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">context</span>     <span class="main">=</span> <span class="entity">Proof.context</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">state</span>       <span class="main">=</span> <span class="entity">Proof.state</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">src</span>         <span class="main">=</span> Token.src<span class="main">;</span>
<span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">seq</span>      <span class="main">=</span> 'a Seq.seq<span class="main">;</span>
<span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">nontac</span>   <span class="main">=</span> 'a <span class="main">-&gt;</span> 'a <span class="entity">seq</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">node</span>    <span class="main">=</span> <span class="entity">Subgoal</span> <span class="main">|</span> <span class="entity">Done</span> <span class="main">|</span> <span class="entity">Defer</span>
                 <span class="main">|</span> <span class="entity">Apply</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="main">{</span>using<span class="main">:</span>string list<span class="main">,</span> methN<span class="main">:</span>string<span class="main">,</span> back<span class="main">:</span>int<span class="main">}</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">log</span>         <span class="main">=</span> <span class="entity">node</span> list<span class="main">;</span>
<span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">logtac</span>   <span class="main">=</span> 'a <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">log</span> * 'a<span class="main">)</span> <span class="entity">seq</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">st_monad</span> <span class="main">=</span> <span class="entity">log</span> <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">log</span> * 'a<span class="main">)</span> <span class="entity">seq</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">stttac</span>   <span class="main">=</span> 'a <span class="main">-&gt;</span> 'a <span class="entity">st_monad</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">local</span></span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_token_getter_n_src_checker</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">src</span>          <span class="main">=</span> Token.src<span class="main">;</span>
    <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">ctxt</span>         <span class="main">=</span> <span class="entity">Proof.context</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">meth</span>         <span class="main">=</span> <span class="entity">Method.method</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span>           <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">keywords</span>      <span class="main">=</span> Thy_Header.get_keywords <span class="entity">thy</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">str_to_tokens</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">str</span> <span class="main">=&gt;</span> Token.explode <span class="entity">keywords</span> Position.none <span class="entity">str</span> |&gt;
      filter_out <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">token</span><span class="main">:</span>Token.T <span class="main">=&gt;</span> Token.is_kind Token.Space <span class="entity">token</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">checker'</span>      <span class="main">=</span> <span class="entity">Method.check_src</span> <span class="entity">ctxt</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">get_method</span>    <span class="main">=</span> <span class="main">(</span><span class="entity">Method.method</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="inner_quoted">"I am dummy."</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="entity">str_to_tokens</span> <span class="main">:</span> string <span class="main">-&gt;</span> Token.T list<span class="main">,</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">source</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">checker'</span> <span class="entity">source</span><span class="main">,</span> <span class="entity">get_method</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">in</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">check_src</span> <span class="entity">ctxt</span> <span class="entity">src</span> <span class="main">=</span> <span class="main">(</span><span class="entity">get_token_getter_n_src_checker</span> <span class="entity">ctxt</span> |&gt; snd<span class="main">)</span> <span class="entity">src</span> |&gt; fst<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">checked_src_to_meth</span> <span class="entity">ctxt</span> <span class="entity">src</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="entity">get_token_getter_n_src_checker</span> <span class="entity">ctxt</span> |&gt; snd<span class="main">)</span> <span class="entity">src</span> |&gt; snd |&gt; fst<span class="main">)</span> <span class="entity">src</span> <span class="entity">ctxt</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">str_to_tokens</span> <span class="main">(</span><span class="entity">ctxt</span><span class="main">:</span><span class="entity">Proof.context</span><span class="main">)</span> <span class="main">(</span><span class="entity">str</span><span class="main">:</span>string<span class="main">)</span> <span class="main">:</span> Token.T list <span class="main">=</span>
  <span class="main">(</span><span class="entity">get_token_getter_n_src_checker</span> <span class="entity">ctxt</span> |&gt; fst<span class="main">)</span> <span class="entity">str</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_tokens</span> <span class="main">(</span><span class="entity">meth_nm</span><span class="main">:</span>string<span class="main">)</span> <span class="main">(</span><span class="entity">attributes</span><span class="main">:</span>Token.T list<span class="main">)</span> <span class="main">=</span>
  Token.make_src <span class="main">(</span><span class="entity">meth_nm</span><span class="main">,</span> Position.none<span class="main">)</span> <span class="entity">attributes</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_meth_nm</span> <span class="main">(</span><span class="entity">meth</span><span class="main">:</span>string<span class="main">)</span> <span class="main">(</span><span class="entity">attributes</span><span class="main">:</span>string list<span class="main">)</span> <span class="main">=</span> 
  <span class="entity">Utils.intersperse</span> <span class="inner_quoted">" "</span> <span class="main">(</span><span class="entity">meth</span> :: <span class="entity">attributes</span><span class="main">)</span> |&gt; String.concat<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">reform</span> <span class="main">(</span><span class="entity">param</span><span class="main">:</span><span class="main">(</span>'meth_str * <span class="main">(</span>'goal <span class="entity">nontac</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">func</span>       <span class="main">=</span> snd <span class="entity">param</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">left</span>       <span class="main">=</span> fst <span class="entity">param</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">new_func</span> <span class="entity">b</span> <span class="main">=</span> Seq.map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">right</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">left</span><span class="main">,</span> <span class="entity">right</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="entity">func</span> <span class="entity">b</span><span class="main">)</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">in</span></span>
  <span class="entity">new_func</span> <span class="main">:</span> 'goal <span class="main">-&gt;</span> <span class="main">(</span>'meth_str * 'goal<span class="main">)</span> Seq.seq
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">string_to_nontac_on_pstate</span> <span class="entity">meth_name</span> <span class="entity">proof_state</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt</span>        <span class="main">=</span> <span class="entity">Proof.context_of</span> <span class="entity">proof_state</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">meth</span>        <span class="main">=</span> <span class="entity">Utils.rm_parentheses</span> <span class="entity">meth_name</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">split</span> <span class="entity">str</span>   <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">strs</span> <span class="main">=</span> space_explode <span class="inner_quoted">" "</span> <span class="entity">str</span> <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span>hd <span class="entity">strs</span><span class="main">,</span> tl <span class="entity">strs</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">hd_tl</span>       <span class="main">=</span> <span class="entity">split</span> <span class="entity">meth</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tokens</span>      <span class="main">=</span> <span class="entity">str_to_tokens</span> <span class="entity">ctxt</span> <span class="main">(</span>String.concatWith <span class="inner_quoted">" "</span> <span class="main">(</span>snd <span class="entity">hd_tl</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">src</span>         <span class="main">=</span> Token.make_src <span class="main">(</span>fst <span class="entity">hd_tl</span><span class="main">,</span> Position.none<span class="main">)</span> <span class="entity">tokens</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">checked_src</span> <span class="main">=</span> <span class="entity">check_src</span> <span class="entity">ctxt</span> <span class="entity">src</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">text</span>        <span class="main">=</span> <span class="entity">Method.Source</span> <span class="entity">checked_src</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">text_range</span>  <span class="main">=</span> <span class="main">(</span><span class="entity">text</span><span class="main">,</span> <span class="main">(</span>Position.none<span class="main">,</span> Position.none<span class="main">)</span><span class="main">)</span> <span class="main">:</span> <span class="entity">Method.text_range</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">results</span>     <span class="main">=</span> <span class="entity">Seq2.try_seq</span> <span class="main">(</span><span class="entity">Proof.apply</span> <span class="entity">text_range</span><span class="main">)</span> <span class="entity">proof_state</span>
                    <span class="main">:</span>  <span class="entity">Proof.state</span> Seq.result Seq.seq<span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">filtered_results</span> <span class="main">=</span> Seq.filter_results <span class="entity">results</span> <span class="main">:</span>  <span class="entity">Proof.state</span> Seq.seq<span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">filtered_results</span> <span class="main">:</span> <span class="entity">Proof.state</span> Seq.seq
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">writer_to_state</span> <span class="main">(</span><span class="entity">writerTSeq</span> <span class="main">:</span> <span class="main">(</span><span class="entity">log</span> * 'state<span class="main">)</span> <span class="entity">seq</span><span class="main">)</span> <span class="main">(</span><span class="entity">trace</span> <span class="main">:</span> <span class="entity">log</span><span class="main">)</span> <span class="main">=</span>
  Seq.map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">this_step</span><span class="main">,</span> <span class="entity">pstate</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">trace</span> @ <span class="entity">this_step</span><span class="main">,</span> <span class="entity">pstate</span><span class="main">)</span><span class="main">)</span> <span class="entity">writerTSeq</span> <span class="main">:</span> <span class="main">(</span><span class="entity">log</span> * 'state<span class="main">)</span> <span class="entity">seq</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_back</span> <span class="main">(</span><span class="entity">n</span><span class="main">,</span> <span class="main">(</span><span class="entity">Apply</span> <span class="main">{</span>methN <span class="main">=</span> <span class="entity">methN</span><span class="main">,</span> using <span class="main">=</span> <span class="entity">using</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">,</span> <span class="entity">result</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="main">[</span><span class="entity">Apply</span> <span class="main">{</span>methN <span class="main">=</span> <span class="entity">methN</span><span class="main">,</span> using <span class="main">=</span> <span class="entity">using</span><span class="main">,</span> back <span class="main">=</span> <span class="entity">n</span><span class="main">}</span><span class="main">]</span><span class="main">,</span> <span class="entity">result</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">add_back</span> <span class="main">(</span><span class="inner_numeral">0</span><span class="main">,</span> <span class="main">(</span><span class="entity">other</span><span class="main">,</span> <span class="entity">result</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>tracing <span class="inner_quoted">"add_back 0"</span><span class="main">;</span><span class="main">(</span><span class="main">[</span><span class="entity">other</span><span class="main">]</span><span class="main">,</span> <span class="entity">result</span><span class="main">)</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">add_back</span> <span class="main">_</span> <span class="main">=</span> <span class="main">(</span>tracing <span class="inner_quoted">"add_back in Dynamic_Utils.thy failed."</span><span class="main">;</span> error <span class="inner_quoted">"add_back"</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">nontac_to_logtac</span> <span class="main">(</span><span class="entity">node</span><span class="main">:</span><span class="entity">node</span><span class="main">)</span> <span class="main">(</span><span class="entity">nontac</span><span class="main">:</span>'a <span class="entity">nontac</span><span class="main">)</span> <span class="main">(</span><span class="entity">goal</span><span class="main">:</span>'a<span class="main">)</span> <span class="main">:</span> <span class="main">(</span><span class="entity">log</span> * 'a<span class="main">)</span> <span class="entity">seq</span> <span class="main">=</span> 
    Seq.map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">result</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">node</span><span class="main">,</span> <span class="entity">result</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="entity">nontac</span> <span class="entity">goal</span><span class="main">)</span>
 |&gt; <span class="entity">Seq2.seq_number</span>
 |&gt; <span class="entity">Seq2.try_seq</span> <span class="main">(</span>Seq.map <span class="entity">add_back</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">logtac_to_stttac</span> <span class="main">(</span><span class="entity">logtac</span><span class="main">:</span>'a <span class="entity">logtac</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">goal</span><span class="main">:</span>'a<span class="main">)</span> <span class="main">=&gt;</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">logtac_results</span> <span class="main">=</span> <span class="entity">logtac</span> <span class="entity">goal</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">state_monad</span>    <span class="main">=</span> <span class="entity">writer_to_state</span> <span class="entity">logtac_results</span><span class="main">:</span>'a <span class="entity">st_monad</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">state_monad</span> <span class="main">:</span> 'a <span class="entity">st_monad</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span> <span class="main">:</span> 'a <span class="entity">stttac</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">log_n_nontac_to_stttac</span> <span class="main">(</span><span class="entity">log</span><span class="main">:</span><span class="entity">log</span><span class="main">,</span> <span class="entity">nontac</span><span class="main">:</span>'a <span class="entity">nontac</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">log</span><span class="main">,</span> <span class="entity">nontac</span><span class="main">)</span>
 |&gt; <span class="entity">reform</span>
 |&gt; <span class="entity">logtac_to_stttac</span>
 <span class="main">:</span> 'a <span class="entity">stttac</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">string_to_stttac_on_pstate</span> <span class="main">(</span><span class="entity">meth_name</span><span class="main">:</span>string<span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">nontac</span>         <span class="main">=</span> <span class="entity">string_to_nontac_on_pstate</span> <span class="entity">meth_name</span>               <span class="main">:</span> <span class="entity">state</span> <span class="entity">nontac</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">nontac_with_TO</span> <span class="main">=</span> <span class="entity">Isabelle_Utils.TIMEOUT_in</span> <span class="inner_numeral">1.0</span>  <span class="entity">nontac</span>              <span class="main">:</span> <span class="entity">state</span> <span class="entity">nontac</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">trace_node</span>     <span class="main">=</span> <span class="entity">Apply</span> <span class="main">{</span>using <span class="main">=</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span> methN <span class="main">=</span> <span class="entity">meth_name</span><span class="main">,</span> back <span class="main">=</span> <span class="inner_numeral">0</span><span class="main">}</span>    <span class="main">:</span> <span class="entity">node</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">logtac</span>         <span class="main">=</span> <span class="entity">nontac_to_logtac</span> <span class="entity">trace_node</span> <span class="entity">nontac_with_TO</span>         <span class="main">:</span> <span class="entity">state</span> <span class="entity">logtac</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">stttac</span>         <span class="main">=</span> <span class="entity">logtac_to_stttac</span> <span class="entity">logtac</span>                            <span class="main">:</span> <span class="entity">state</span> <span class="entity">stttac</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">stttac</span> <span class="main">:</span> <span class="entity">state</span> <span class="entity">stttac</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">local</span></span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_using</span>  <span class="main">(</span><span class="main">[</span><span class="main">]</span>   <span class="main">:</span> string list<span class="main">)</span> <span class="main">=</span> <span class="inner_quoted">""</span>
   <span class="main">|</span>  <span class="entity">mk_using</span>  <span class="main">(</span><span class="entity">using</span><span class="main">:</span> string list<span class="main">)</span> <span class="main">=</span> <span class="inner_quoted">"using "</span> ^ String.concatWith <span class="inner_quoted">" "</span> <span class="entity">using</span> ^ <span class="inner_quoted">" "</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_apply</span> <span class="entity">methN</span>  <span class="main">=</span> <span class="inner_quoted">"apply "</span> ^ <span class="entity">methN</span> ^ <span class="inner_quoted">""</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_backs</span> <span class="main">(</span><span class="entity">n</span><span class="main">:</span>int<span class="main">)</span> <span class="main">=</span> replicate <span class="entity">n</span> <span class="inner_quoted">"back"</span> |&gt; String.concatWith <span class="inner_quoted">" "</span> <span class="keyword3"><span class="keyword">handle</span></span> Subscript <span class="main">=&gt;</span>
    <span class="main">(</span>tracing <span class="inner_quoted">"mk_backs in Isabelle_Utils.thy failed. It should take 0 or a positive integer."</span><span class="main">;</span><span class="inner_quoted">""</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_apply_script1</span> <span class="main">{</span><span class="entity">methN</span> <span class="main">:</span> string<span class="main">,</span> <span class="entity">using</span> <span class="main">:</span> string list<span class="main">,</span> <span class="entity">back</span> <span class="main">:</span> int<span class="main">}</span> <span class="main">=</span>
    <span class="entity">mk_using</span> <span class="entity">using</span> ^ <span class="entity">mk_apply</span> <span class="entity">methN</span> ^ <span class="entity">mk_backs</span> <span class="entity">back</span> ^ <span class="inner_quoted">"\n"</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_proof_script1</span> <span class="main">(</span><span class="entity">Done</span>    <span class="main">:</span> <span class="entity">node</span><span class="main">)</span> <span class="main">=</span> <span class="inner_quoted">"done \n"</span>
   <span class="main">|</span>  <span class="entity">mk_proof_script1</span> <span class="main">(</span><span class="entity">Subgoal</span> <span class="main">:</span> <span class="entity">node</span><span class="main">)</span> <span class="main">=</span> <span class="inner_quoted">"subgoal \n"</span>
   <span class="main">|</span>  <span class="entity">mk_proof_script1</span> <span class="main">(</span><span class="entity">Defer</span>   <span class="main">:</span> <span class="entity">node</span><span class="main">)</span> <span class="main">=</span> <span class="inner_quoted">"defer \n"</span>
   <span class="main">|</span>  <span class="entity">mk_proof_script1</span> <span class="main">(</span><span class="entity">Apply</span> <span class="entity">n</span> <span class="main">:</span> <span class="entity">node</span><span class="main">)</span> <span class="main">=</span> <span class="entity">mk_apply_script1</span> <span class="entity">n</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">in</span></span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_apply_script</span> <span class="main">(</span><span class="entity">log</span><span class="main">:</span><span class="entity">log</span><span class="main">)</span> <span class="main">=</span>
   <span class="main">(</span>tracing <span class="main">(</span><span class="inner_quoted">"Number of lines of commands: "</span> ^ <span class="main">(</span>length <span class="entity">log</span> |&gt; Int.toString<span class="main">)</span><span class="main">)</span><span class="main">;</span>
    map <span class="entity">mk_proof_script1</span> <span class="entity">log</span>
    |&gt; String.concat
    |&gt; Active.sendback_markup_properties <span class="main">[</span>Markup.padding_command<span class="main">]</span><span class="main">)</span> <span class="main">:</span> string<span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span></pre>
</div><div id="files/Subtool.ML">
<div class="head">
<h1>File ‹Subtool.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Subtool.ML
    Author:     Yutaka Nagashima, Data61, CSIRO

This file provides utility functions that are useful to generate tactics at run-time.
*)</span>

<span class="comment1">(*** SUBTOOL: The state monad tactic interface for sub-tools. ***)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">SUBTOOL</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> state_stttac  <span class="main">:</span> <span class="entity">Proof.state</span> <span class="entity">Dynamic_Utils.stttac</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(*** SUBTOOLS: A collection of sub-tools. ***)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">SUBTOOLS</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> quickcheck  <span class="main">:</span> <span class="entity">Proof.state</span> <span class="entity">Dynamic_Utils.stttac</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> nitpick     <span class="main">:</span> <span class="entity">Proof.state</span> <span class="entity">Dynamic_Utils.stttac</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> hammer      <span class="main">:</span> <span class="entity">Proof.state</span> <span class="entity">Dynamic_Utils.stttac</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> is_solved   <span class="main">:</span> <span class="entity">Proof.state</span> <span class="entity">Dynamic_Utils.stttac</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> defer       <span class="main">:</span> <span class="entity">Proof.state</span> <span class="entity">Dynamic_Utils.stttac</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> subgoal     <span class="main">:</span> <span class="entity">Proof.state</span> <span class="entity">Dynamic_Utils.stttac</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(*** SUBTOOLS: A collection of sub-tools. ***)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Subtools</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="comment1">(** Quickcheck_Tactic: Quickcheck as assertion tactic. **)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Quickcheck_Tactic</span> <span class="main">:</span> <span class="entity">SUBTOOL</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">nontac</span> <span class="main">(</span><span class="entity">state</span><span class="main">:</span><span class="entity">Proof.state</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="comment1">(*do_trace and show_trace are provided for the purpose of debugging.*)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">do_trace</span>        <span class="main">=</span> false<span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">show_trace</span> <span class="entity">text</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">do_trace</span> <span class="keyword2"><span class="keyword">then</span></span> tracing <span class="entity">text</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">quickcheck</span>      <span class="main">=</span> <span class="entity">Quickcheck.quickcheck</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">single</span>          <span class="main">=</span> Seq.single <span class="entity">state</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">trace_no_cexm</span> <span class="main">_</span> <span class="main">=</span> <span class="entity">show_trace</span> <span class="inner_quoted">"Quickcheck.quickcheck found no counterexample"</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">trace_cexm</span> <span class="main">_</span>    <span class="main">=</span> <span class="entity">show_trace</span> <span class="inner_quoted">"Quickcheck.quickcheck found a  counterexample"</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">trace_scexn</span> <span class="main">_</span>   <span class="main">=</span> <span class="entity">show_trace</span> <span class="main">(</span><span class="inner_quoted">"Quickcheck.quickcheck found a potentially spurious "</span> ^
                                      <span class="inner_quoted">"counterexample due to underspecified functions"</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_result</span> <span class="main">_</span>    <span class="main">=</span>  <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">quickcheck</span> <span class="main">[</span><span class="main">]</span> <span class="inner_numeral">1</span> <span class="entity">state</span> <span class="keyword2"><span class="keyword">of</span></span>
      NONE <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">trace_no_cexm</span> <span class="main">(</span><span class="main">)</span><span class="main">;</span> <span class="entity">single</span><span class="main">)</span>
    <span class="main">|</span> SOME <span class="main">(</span><span class="entity">genuine</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">genuine</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="entity">trace_cexm</span> <span class="main">(</span><span class="main">)</span><span class="main">;</span> Seq.empty<span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="entity">trace_scexn</span> <span class="main">(</span><span class="main">)</span><span class="main">;</span> <span class="entity">single</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">Utils.try_with</span> <span class="entity">single</span> <span class="entity">get_result</span> <span class="entity">state</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">state_stttac</span> <span class="main">=</span> <span class="entity">Dynamic_Utils.log_n_nontac_to_stttac</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">nontac</span><span class="main">)</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(** Nitpick_Tactic: Nitpick as assertion tactic. **)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Nitpick_Tactic</span> <span class="main">:</span> <span class="entity">SUBTOOL</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">nontac</span> <span class="main">(</span><span class="entity">state</span><span class="main">:</span><span class="entity">Proof.state</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">single</span>             <span class="main">=</span> Seq.single <span class="entity">state</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span><span class="main">:</span>theory         <span class="main">=</span> <span class="main">(</span><span class="entity">Proof.theory_of</span> <span class="entity">state</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">params</span>             <span class="main">=</span> <span class="entity">Nitpick_Commands.default_params</span> <span class="entity">thy</span> <span class="main">[</span><span class="main">]</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">nitpick_result</span>     <span class="main">=</span> <span class="entity">Nitpick.pick_nits_in_subgoal</span> <span class="entity">state</span> <span class="entity">params</span> <span class="entity">Nitpick.Normal</span> <span class="inner_numeral">1</span> <span class="inner_numeral">1</span><span class="main">;</span>
    <span class="comment1">(*"genuine" means "genuine counter-example".*)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">nitpick_succeed</span>    <span class="main">=</span> fst <span class="entity">nitpick_result</span> <span class="main">=</span> <span class="inner_quoted">"genuine"</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">nitpick_tac_result</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">nitpick_succeed</span> <span class="keyword2"><span class="keyword">then</span></span> Seq.empty <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">single</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">nitpick_tac_result</span> <span class="main">:</span> <span class="entity">Proof.state</span> Seq.seq
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">state_stttac</span> <span class="main">=</span> <span class="entity">Dynamic_Utils.log_n_nontac_to_stttac</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">nontac</span><span class="main">)</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(** Sledgehammer_Tacctic: Sledgehammer as a state monad based tactic. **)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Sledgehammer_Tacctic</span> <span class="main">:</span> <span class="entity">SUBTOOL</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword2"><span class="keyword">local</span></span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">text</span>         <span class="main">=</span> <span class="entity">Method.text</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">text_range</span>   <span class="main">=</span> <span class="entity">Method.text_range</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">ctxt</span>         <span class="main">=</span> <span class="entity">Proof.context</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">T</span>            <span class="main">=</span> Token.T<span class="main">;</span>
<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">ref</span>          <span class="main">=</span> Facts.ref<span class="main">;</span>
<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">srcs</span>         <span class="main">=</span> Token.src list<span class="main">;</span>
<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">keywords</span>     <span class="main">=</span> Keyword.keywords<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">sh_output_to_sh_logtac</span> <span class="main">(</span><span class="entity">sh_output</span><span class="main">:</span>string<span class="main">)</span> <span class="main">(</span><span class="entity">state</span><span class="main">:</span><span class="entity">Proof.state</span><span class="main">)</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">let</span></span>
  <span class="comment1">(*syntax sugars*)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span>           <span class="main">=</span> <span class="entity">Proof.theory_of</span> <span class="entity">state</span>       <span class="main">:</span> theory<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt</span>          <span class="main">=</span> <span class="entity">Proof.context_of</span> <span class="entity">state</span>      <span class="main">:</span> <span class="entity">ctxt</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">keywords</span>      <span class="main">=</span> Thy_Header.get_keywords <span class="entity">thy</span> <span class="main">:</span> <span class="entity">keywords</span><span class="main">;</span>

  <span class="comment1">(*function body*)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">op_w_stopper</span>  <span class="main">=</span> <span class="entity">sh_output</span> ^ <span class="inner_quoted">" parserStopsWithMe"</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tokens</span>        <span class="main">=</span> Token.explode <span class="entity">keywords</span> Position.none <span class="entity">op_w_stopper</span>
                    |&gt; filter_out <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">token</span><span class="main">:</span><span class="entity">T</span> <span class="main">=&gt;</span> Token.is_kind Token.Space <span class="entity">token</span><span class="main">)</span> <span class="main">:</span> <span class="entity">T</span> list<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">is_using</span>      <span class="main">=</span> String.isPrefix <span class="inner_quoted">"using "</span> <span class="entity">sh_output</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parse_using</span>   <span class="main">=</span> Parse.and_list1 Parse.thms1 <span class="main">:</span> <span class="main">(</span><span class="entity">ref</span> * <span class="entity">srcs</span><span class="main">)</span> list list Token.parser<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parse_method</span>  <span class="main">=</span> <span class="entity">Method.parse</span>                 <span class="main">:</span> <span class="entity">text_range</span> Token.parser<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parse_one</span>     <span class="main">=</span> Scan.one <span class="main">(</span>K true<span class="main">)</span>            <span class="main">:</span> <span class="entity">T</span> list <span class="main">-&gt;</span> <span class="entity">T</span> * <span class="entity">T</span> list<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parser</span>        <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_using</span>
                      <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="entity">parse_one</span> |-- <span class="entity">parse_using</span><span class="main">)</span> -- <span class="main">(</span><span class="entity">parse_one</span> |-- <span class="entity">parse_method</span><span class="main">)</span>
                      <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="entity">parse_one</span> |-- <span class="entity">parse_method</span><span class="main">)</span> &gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">x</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">p_get_meth</span>    <span class="main">=</span> <span class="main">(</span><span class="entity">parse_one</span> |-- <span class="entity">parse_using</span><span class="main">)</span> -- <span class="entity">parse_one</span>
                    <span class="main">:</span> <span class="entity">T</span> list <span class="main">-&gt;</span> <span class="main">(</span><span class="main">(</span><span class="entity">ref</span> * <span class="entity">srcs</span><span class="main">)</span> list list * <span class="entity">T</span><span class="main">)</span> * <span class="entity">T</span> list<span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_str</span> <span class="entity">tkns</span>  <span class="main">=</span> <span class="entity">tkns</span>
                    |&gt; <span class="entity">Utils.init</span> <span class="comment1">(*drops "parserStopsWithMe" slowly.*)</span>
                    |&gt; map Token.unparse |&gt; String.concatWith <span class="inner_quoted">" "</span> <span class="main">:</span> string<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">methN</span><span class="main">:</span>string  <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span>   <span class="entity">is_using</span>
                      <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">p_get_meth</span> <span class="entity">tokens</span> |&gt; snd |&gt; <span class="entity">get_str</span>
                      <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">parse_one</span>  <span class="entity">tokens</span> |&gt; snd |&gt; <span class="entity">get_str</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">result</span>        <span class="main">=</span> <span class="entity">parser</span> <span class="entity">tokens</span>
                    <span class="main">:</span> <span class="main">(</span><span class="main">(</span><span class="entity">ref</span> * <span class="entity">srcs</span><span class="main">)</span> list list * <span class="entity">text_range</span><span class="main">)</span> * <span class="entity">T</span> list<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">using_raw</span>     <span class="main">=</span> <span class="main">(</span><span class="main">#</span><span class="inner_numeral">1</span> o <span class="main">#</span><span class="inner_numeral">1</span><span class="main">)</span> <span class="entity">result</span> <span class="main">:</span> <span class="main">(</span><span class="entity">ref</span> * <span class="entity">srcs</span><span class="main">)</span> list list<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">text_range</span>    <span class="main">=</span> <span class="main">(</span><span class="main">#</span><span class="inner_numeral">2</span> o <span class="main">#</span><span class="inner_numeral">1</span><span class="main">)</span> <span class="entity">result</span> <span class="main">:</span> <span class="entity">text_range</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">check_text</span>    <span class="main">=</span> <span class="entity">Method.check_text</span> <span class="entity">ctxt</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fail_trange</span>   <span class="main">=</span> <span class="main">(</span><span class="entity">Method.Basic</span> <span class="main">(</span>K <span class="entity">Method.fail</span><span class="main">)</span><span class="main">,</span> Position.no_range<span class="main">)</span> <span class="main">:</span> <span class="entity">Method.text_range</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">checked_range</span> <span class="main">=</span> <span class="main">(</span>apfst <span class="entity">check_text</span> <span class="entity">text_range</span> <span class="keyword3"><span class="keyword">handle</span></span> ERROR <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">fail_trange</span><span class="main">)</span> <span class="main">:</span> <span class="entity">text_range</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">using_strings</span> <span class="main">=</span> <span class="entity">using_raw</span> |&gt; List.concat |&gt; map <span class="main">(</span>Facts.string_of_ref o <span class="main">#</span><span class="inner_numeral">1</span><span class="main">)</span> <span class="keyword3"><span class="keyword">handle</span></span> Empty <span class="main">=&gt;</span>
                      <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">Utils.debug</span>
                       <span class="keyword2"><span class="keyword">then</span></span> tracing <span class="inner_quoted">"using_strings in sh_output_to_sh_logtac failed."</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="main">)</span><span class="main">;</span>
                       <span class="main">[</span><span class="inner_quoted">"Failed constructing using_strings."</span><span class="main">]</span><span class="main">)</span>
                    <span class="main">:</span> string list<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">node</span> <span class="main">:</span> <span class="entity">Dynamic_Utils.node</span> <span class="main">=</span> <span class="entity">Dynamic_Utils.Apply</span> <span class="main">{</span>using <span class="main">=</span> <span class="entity">using_strings</span><span class="main">,</span> methN <span class="main">=</span> <span class="entity">methN</span><span class="main">,</span> back <span class="main">=</span> <span class="inner_numeral">0</span><span class="main">}</span><span class="main">;</span>
  <span class="comment1">(*print messages for debugging.*)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">app</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">node</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="entity">Dynamic_Utils.Apply</span> <span class="entity">app_node</span> <span class="main">=&gt;</span> <span class="entity">app_node</span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> error <span class="inner_quoted">"app in Sledgehammer_Tactic panics."</span><span class="main">;</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tracing1</span> <span class="main">_</span> <span class="main">=</span> tracing <span class="main">(</span><span class="inner_quoted">"methN in node is "</span> ^ <span class="main">#</span>methN <span class="entity">app</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tracing2</span> <span class="main">_</span> <span class="main">=</span> tracing <span class="inner_quoted">"using_strings are ..."</span><span class="main">;</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tracing3</span> <span class="main">_</span> <span class="main">=</span> map tracing <span class="entity">using_strings</span><span class="main">;</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">Utils.debug</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="entity">tracing1</span> <span class="main">(</span><span class="main">)</span><span class="main">;</span> <span class="entity">tracing2</span> <span class="main">(</span><span class="main">)</span><span class="main">;</span> <span class="entity">tracing3</span> <span class="main">(</span><span class="main">)</span><span class="main">;</span> <span class="main">(</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> Basics.try<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">state_w_using</span> <span class="main">=</span> <span class="entity">Proof.using_cmd</span> <span class="entity">using_raw</span> <span class="entity">state</span> <span class="main">:</span> <span class="entity">Proof.state</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">timeout</span>       <span class="main">=</span> Timeout.apply <span class="main">(</span>seconds <span class="inner_numeral">60.0</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tac_results</span>   <span class="main">=</span> <span class="entity">timeout</span> <span class="main">(</span><span class="entity">Proof.apply</span> <span class="entity">checked_range</span><span class="main">)</span> <span class="entity">state_w_using</span>
                      |&gt; Seq.filter_results
                     <span class="comment1">(*Why Seq.try Seq.hd? Because we want to evaluate the head of
                       sequence strictly here to catch errors immediately.*)</span>
                      |&gt; <span class="entity">Utils.try_with</span> Seq.empty <span class="main">(</span>Seq.try Seq.hd<span class="main">)</span><span class="main">:</span> <span class="entity">Proof.state</span> Seq.seq<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">results_w_log</span> <span class="main">=</span> Seq.map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">[</span><span class="entity">node</span><span class="main">]</span><span class="main">,</span> <span class="entity">x</span><span class="main">)</span><span class="main">)</span> <span class="entity">tac_results</span> <span class="main">:</span> <span class="main">(</span><span class="entity">Dynamic_Utils.log</span> * <span class="entity">Proof.state</span><span class="main">)</span> Seq.seq<span class="main">;</span>
<span class="keyword2"><span class="keyword">in</span></span>
  <span class="entity">results_w_log</span> <span class="main">:</span> <span class="main">(</span><span class="entity">Dynamic_Utils.log</span> * <span class="entity">Proof.state</span><span class="main">)</span> Seq.seq
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">hammer_logtac</span> <span class="main">(</span><span class="entity">pstate</span><span class="main">:</span><span class="entity">Proof.state</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="comment1">(*syntax sugars*)</span>
    <span class="keyword1"><span class="keyword">infix</span></span> &lt;$&gt;
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">x</span> <span class="entity">&lt;$&gt;</span> <span class="entity">f</span>            <span class="main">=</span> Option.map <span class="entity">f</span> <span class="entity">x</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">valOf</span>              <span class="main">=</span> Option.valOf<span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">omap</span>               <span class="main">=</span> Option.map<span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span>                <span class="main">=</span> <span class="entity">Proof.theory_of</span> <span class="entity">pstate</span> <span class="main">:</span> theory<span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">params</span>             <span class="main">=</span> <span class="entity">Sledgehammer_Commands.default_params</span> <span class="entity">thy</span>
                             <span class="main">[</span><span class="main">(</span><span class="inner_quoted">"isar_proofs"</span><span class="main">,</span> <span class="inner_quoted">"false"</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="inner_quoted">"smt_proofs"</span><span class="main">,</span> <span class="inner_quoted">"false"</span><span class="main">)</span><span class="main">]</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Auto_Try</span>           <span class="main">=</span> <span class="entity">Sledgehammer_Prover.Auto_Try</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fact_override</span>      <span class="main">=</span> <span class="entity">Sledgehammer_Fact.no_fact_override</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">run_sledgehammer</span>   <span class="main">=</span> <span class="entity">Sledgehammer.run_sledgehammer</span> <span class="entity">params</span> <span class="entity">Auto_Try</span> NONE <span class="inner_numeral">1</span> <span class="entity">fact_override</span>
                           <span class="main">:</span> <span class="entity">Proof.state</span> <span class="main">-&gt;</span> bool * <span class="main">(</span>string * string list<span class="main">)</span><span class="main">;</span>
    <span class="comment1">(*function body*)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">result</span>             <span class="main">=</span> SOME <span class="main">(</span><span class="entity">run_sledgehammer</span> <span class="entity">pstate</span><span class="main">)</span>
                             <span class="keyword3"><span class="keyword">handle</span></span> ERROR <span class="main">_</span> <span class="main">=&gt;</span>
                             <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">Utils.debug</span> <span class="keyword2"><span class="keyword">then</span></span> tracing <span class="inner_quoted">"ERROR in result/hammer_logtac"</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="main">)</span><span class="main">;</span>
                              NONE<span class="main">)</span>
                           <span class="main">:</span> <span class="main">(</span>bool * <span class="main">(</span>string * string list<span class="main">)</span><span class="main">)</span> option<span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">orig_string</span>        <span class="main">=</span> <span class="entity">result</span> <span class="entity">&lt;$&gt;</span> snd <span class="entity">&lt;$&gt;</span> snd <span class="entity">&lt;$&gt;</span> hd <span class="keyword3"><span class="keyword">handle</span></span> Empty <span class="main">=&gt;</span>
                             <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">Utils.debug</span> <span class="keyword2"><span class="keyword">then</span></span> tracing <span class="inner_quoted">"Empty in orig_string/hammer_logtac"</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="main">)</span><span class="main">;</span> 
                              NONE<span class="main">)</span> <span class="main">:</span> string option<span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">did_smt_timeout</span> <span class="main">(</span><span class="entity">out</span>::<span class="entity">timed</span>::<span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">Utils.are_same</span> <span class="main">(</span><span class="inner_quoted">"out)"</span><span class="main">,</span> <span class="entity">out</span><span class="main">)</span><span class="main">)</span> <span class="keyword1"><span class="keyword">andalso</span></span>
                                          <span class="main">(</span><span class="entity">Utils.are_same</span> <span class="main">(</span><span class="inner_quoted">"timed"</span><span class="main">,</span> <span class="entity">timed</span><span class="main">)</span><span class="main">)</span>
     <span class="main">|</span>  <span class="entity">did_smt_timeout</span> <span class="main">_</span> <span class="main">=</span> error <span class="inner_quoted">"Something went wrong in Subtool.ML"</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">one_line_apply</span>     <span class="main">=</span> <span class="entity">orig_string</span> <span class="entity">&lt;$&gt;</span> space_explode <span class="inner_quoted">" "</span>
                            <span class="entity">&lt;$&gt;</span> drop <span class="inner_numeral">2</span>                           <span class="comment1">(* drop "Try this:"*)</span>
                            <span class="entity">&lt;$&gt;</span> rev <span class="entity">&lt;$&gt;</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">tokens</span> <span class="main">=&gt;</span>
                                <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">did_smt_timeout</span> <span class="entity">tokens</span> <span class="keyword2"><span class="keyword">then</span></span> drop <span class="inner_numeral">5</span> <span class="entity">tokens</span> <span class="keyword2"><span class="keyword">else</span></span> drop <span class="inner_numeral">2</span> <span class="entity">tokens</span><span class="main">)</span>
                            <span class="entity">&lt;$&gt;</span> rev           <span class="comment1">(* drop "(0.1 ms)." and such.*)</span>
                            <span class="entity">&lt;$&gt;</span> String.concatWith <span class="inner_quoted">" "</span>            <span class="main">:</span> string option<span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">apply_script_cntnt</span> <span class="main">=</span> <span class="entity">omap</span> YXML.content_of <span class="entity">one_line_apply</span> <span class="main">:</span> string option<span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sh_returned</span>        <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> is_some <span class="entity">apply_script_cntnt</span>
                             <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">valOf</span> <span class="entity">result</span> |&gt; fst <span class="keyword2"><span class="keyword">else</span></span> false <span class="main">:</span> bool<span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="keyword2"><span class="keyword">if</span></span>   <span class="entity">sh_returned</span>
    <span class="keyword2"><span class="keyword">then</span></span>
      <span class="entity">sh_output_to_sh_logtac</span> <span class="main">(</span><span class="entity">valOf</span> <span class="entity">apply_script_cntnt</span><span class="main">)</span> <span class="entity">pstate</span>
    <span class="keyword2"><span class="keyword">else</span></span> Seq.empty <span class="main">:</span> <span class="main">(</span><span class="entity">Dynamic_Utils.log</span> * <span class="entity">Proof.state</span><span class="main">)</span> Seq.seq
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">in</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">state_stttac</span> <span class="main">=</span> <span class="entity">Dynamic_Utils.logtac_to_stttac</span> <span class="entity">hammer_logtac</span> <span class="main">:</span> <span class="entity">Proof.state</span> <span class="entity">Dynamic_Utils.stttac</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(** The exposed part of Subtools **)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">quickcheck</span> <span class="main">=</span> <span class="entity">Quickcheck_Tactic.state_stttac</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">nitpick</span>    <span class="main">=</span> <span class="entity">Nitpick_Tactic.state_stttac</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">hammer</span>     <span class="main">=</span> <span class="entity">Sledgehammer_Tacctic.state_stttac</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">to_stttac</span>  <span class="main">=</span> <span class="entity">Dynamic_Utils.log_n_nontac_to_stttac</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_solved_nontac</span><span class="main">(</span><span class="entity">state</span><span class="main">:</span><span class="entity">Proof.state</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">done</span>    <span class="main">=</span> <span class="entity">Proof.local_done_proof</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goal</span>    <span class="main">=</span> <span class="entity">state</span> |&gt; <span class="entity">Proof.goal</span> |&gt; <span class="main">#</span>goal <span class="main">:</span> thm<span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">no_goal</span> <span class="main">=</span> Thm.nprems_of <span class="entity">goal</span> <span class="main">=</span> <span class="inner_numeral">0</span> <span class="main">:</span> bool<span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">result</span>  <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">no_goal</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">state</span> |&gt; <span class="entity">done</span> |&gt; Seq.single
      <span class="keyword3"><span class="keyword">handle</span></span> ERROR <span class="main">_</span> <span class="main">=&gt;</span> Seq.single <span class="entity">state</span> <span class="keyword2"><span class="keyword">else</span></span> Seq.empty<span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">result</span> <span class="main">:</span> <span class="entity">Proof.state</span> Seq.seq
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(** is_solved as a state monad tactic **)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">is_solved</span> <span class="main">=</span> <span class="entity">to_stttac</span> <span class="main">(</span><span class="main">[</span><span class="entity">Dynamic_Utils.Done</span><span class="main">]</span><span class="main">,</span> <span class="entity">is_solved_nontac</span><span class="main">)</span><span class="main">;</span>

<span class="comment1">(** defer as a state monad tactic **)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">defer</span> <span class="main">=</span> <span class="entity">to_stttac</span> <span class="main">(</span><span class="main">[</span><span class="entity">Dynamic_Utils.Defer</span><span class="main">]</span><span class="main">,</span> Seq.single o <span class="main">(</span><span class="entity">Proof.defer</span> <span class="inner_numeral">1</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>

<span class="comment1">(** subgoal as a state monad tactic **)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">subgoal_nontac</span> <span class="main">=</span> Seq.single o <span class="main">#</span><span class="inner_numeral">2</span> o <span class="entity">Subgoal.subgoal</span> <span class="main">(</span>Binding.empty<span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> NONE <span class="main">(</span>false<span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">subgoal</span> <span class="main">=</span> <span class="entity">to_stttac</span> <span class="main">(</span><span class="main">[</span><span class="entity">Dynamic_Utils.Subgoal</span><span class="main">]</span><span class="main">,</span> <span class="entity">subgoal_nontac</span><span class="main">)</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span></pre>
</div><div id="files/Dynamic_Tactic_Generation.ML">
<div class="head">
<h1>File ‹Dynamic_Tactic_Generation.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Dynamic_Tactic_Generation.ML
    Author:     Yutaka Nagashima, Data61, CSIRO

This file provides a mechanism to generate several state monad based tactics at runtime.
Boiler-plate programming is avoided by using ML's module system.
*)</span>

<span class="comment1">(*** DYNAMIC_TACTIC_GENERATOR_SEED: makes inputs to tactic-generator. ***)</span>
<span class="comment1">(*
  This following provides a mechanism to derive functions that are necessary to generate tactics at 
  run-time in the PSL framework. Essentially, the functor, "mk_Dynamic_Tactic_Generator", abstracts 
  functions that are commonly observed when dynamically generating tactics, thus avoiding
  code-duplication.
*)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">DYNAMIC_TACTIC_GENERATOR_SEED</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">modifier</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">modifiers</span> <span class="main">=</span> <span class="entity">modifier</span> list<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span>  get_all_modifiers <span class="main">:</span> <span class="entity">Proof.state</span> <span class="main">-&gt;</span> <span class="entity">modifiers</span><span class="main">;</span>
  <span class="comment1">(*mods_to_string should reorder parameters and remove duplicated modifier declarations.*)</span>
  <span class="keyword1"><span class="keyword">val</span></span>  mods_to_string    <span class="main">:</span> <span class="entity">modifiers</span> <span class="main">-&gt;</span> string<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span>  reordered_mods    <span class="main">:</span> <span class="entity">modifiers</span> <span class="main">-&gt;</span> <span class="entity">modifiers</span> list<span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(*** DYNAMIC_TACTIC_GENERATOR: makes tactic-generator. ***)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">DYNAMIC_TACTIC_GENERATOR</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">include</span></span> <span class="entity">DYNAMIC_TACTIC_GENERATOR_SEED</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> meth_name_n_modifiers_to_nontac_on_state<span class="main">:</span> string <span class="main">-&gt;</span> <span class="entity">modifiers</span> <span class="main">-&gt;</span> <span class="entity">Proof.state</span> <span class="entity">Dynamic_Utils.nontac</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> meth_name_n_modifiers_to_logtac_on_state<span class="main">:</span> string <span class="main">-&gt;</span> <span class="entity">modifiers</span> <span class="main">-&gt;</span> <span class="entity">Proof.state</span> <span class="entity">Dynamic_Utils.logtac</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> meth_name_n_modifiers_to_stttac_on_state<span class="main">:</span> string <span class="main">-&gt;</span> <span class="entity">modifiers</span> <span class="main">-&gt;</span> <span class="entity">Proof.state</span> <span class="entity">Dynamic_Utils.stttac</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(*** mk_Dynamic_Tactic_Generator: makes DYNAMIC_TACTIC_GENERATOR from DYNAMIC_TACTIC_GENERATOR_SEED. ***)</span>
<span class="keyword1"><span class="keyword">functor</span></span> <span class="entity">mk_Dynamic_Tactic_Generator</span> <span class="main">(</span>Seed<span class="main">:</span><span class="entity">DYNAMIC_TACTIC_GENERATOR_SEED</span><span class="main">)</span> <span class="main">:</span> <span class="entity">DYNAMIC_TACTIC_GENERATOR</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>
  <span class="keyword3"><span class="keyword">open</span></span> <span class="entity">Seed</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">DG</span> <span class="main">=</span> Dynamic_Utils<span class="main">;</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">general_case</span> <span class="main">(</span><span class="entity">meth_name</span><span class="main">:</span>string<span class="main">)</span> <span class="main">(</span><span class="entity">mods</span><span class="main">:</span><span class="entity">modifiers</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">method_str_w_attr</span> <span class="main">=</span> <span class="inner_quoted">"("</span> ^ <span class="entity">meth_name</span> ^ <span class="entity">mods_to_string</span> <span class="entity">mods</span> ^ <span class="inner_quoted">")"</span><span class="main">;</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">nontac_on_state</span> <span class="entity">st</span> <span class="main">=</span> <span class="main">(</span><span class="entity">Utils.try_with</span> <span class="main">(</span>K Seq.empty<span class="main">)</span> <span class="entity">DG.string_to_nontac_on_pstate</span> <span class="entity">method_str_w_attr</span>
        |&gt; <span class="entity">Isabelle_Utils.TIMEOUT_in</span> <span class="inner_numeral">0.3</span><span class="main">)</span> <span class="entity">st</span><span class="main">;</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">trace_node</span>         <span class="main">=</span> <span class="entity">DG.Apply</span> <span class="main">{</span>using <span class="main">=</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span> methN <span class="main">=</span> <span class="entity">method_str_w_attr</span><span class="main">,</span> back <span class="main">=</span> <span class="inner_numeral">0</span><span class="main">}</span><span class="main">;</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">logtac_on_state</span> <span class="main">=</span> <span class="entity">DG.nontac_to_logtac</span> <span class="entity">trace_node</span> <span class="entity">nontac_on_state</span><span class="main">;</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">stttac_on_state</span> <span class="main">=</span> <span class="entity">DG.logtac_to_stttac</span> <span class="entity">logtac_on_state</span><span class="main">;</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">(</span><span class="entity">nontac_on_state</span><span class="main">,</span> <span class="entity">logtac_on_state</span><span class="main">,</span> <span class="entity">stttac_on_state</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">meth_name_n_modifiers_to_nontac_on_state</span> <span class="main">=</span> <span class="main">#</span><span class="inner_numeral">1</span> oo <span class="entity">general_case</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">meth_name_n_modifiers_to_logtac_on_state</span> <span class="main">=</span> <span class="main">#</span><span class="inner_numeral">2</span> oo <span class="entity">general_case</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">meth_name_n_modifiers_to_stttac_on_state</span> <span class="main">=</span> <span class="main">#</span><span class="inner_numeral">3</span> oo <span class="entity">general_case</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(*** DYNAMIC_TACTIC: makes a series of state-monad based tactics from proof state. ***)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">DYNAMIC_TACTIC</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> get_state_stttacs  <span class="main">:</span> <span class="entity">Proof.state</span> <span class="main">-&gt;</span> <span class="entity">Proof.state</span> <span class="entity">Dynamic_Utils.stttac</span> Seq.seq<span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(*** DYNAMIC_TACTIC_GENERATION ***)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">DYNAMIC_TACTIC_GENERATION</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">get_stttacs</span> <span class="main">=</span> <span class="entity">Proof.state</span> <span class="main">-&gt;</span> <span class="entity">Proof.state</span> <span class="entity">Dynamic_Utils.stttac</span> Seq.seq<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> rule        <span class="main">:</span> <span class="entity">get_stttacs</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> erule       <span class="main">:</span> <span class="entity">get_stttacs</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> simp        <span class="main">:</span> <span class="entity">get_stttacs</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> induct      <span class="main">:</span> <span class="entity">get_stttacs</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> induct_tac  <span class="main">:</span> <span class="entity">get_stttacs</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> coinduction <span class="main">:</span> <span class="entity">get_stttacs</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> cases       <span class="main">:</span> <span class="entity">get_stttacs</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> case_tac    <span class="main">:</span> <span class="entity">get_stttacs</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> clarsimp    <span class="main">:</span> <span class="entity">get_stttacs</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> blast       <span class="main">:</span> <span class="entity">get_stttacs</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> fastforce   <span class="main">:</span> <span class="entity">get_stttacs</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> auto        <span class="main">:</span> <span class="entity">get_stttacs</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(*** Dynamic_Tactic_Generation ***)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Dynamic_Tactic_Generation</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>
<span class="comment1">(** Rule_Seed_Base: Shared by Rule_Seed and Erule_Seed. **)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Rule_Seed_Base</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">modifier</span> <span class="main">=</span> <span class="entity">Rule</span> <span class="keyword2"><span class="keyword">of</span></span> string<span class="main">;</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">modifiers</span> <span class="main">=</span> <span class="entity">modifier</span> list<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">order</span> <span class="main">(</span><span class="entity">mods</span><span class="main">:</span><span class="entity">modifiers</span><span class="main">)</span> <span class="main">=</span> <span class="entity">mods</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_name</span> <span class="main">(</span><span class="entity">Rule</span> <span class="entity">name</span><span class="main">)</span> <span class="main">=</span> <span class="entity">name</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">get_names</span> <span class="main">=</span> map <span class="entity">get_name</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mods_to_string</span> <span class="main">(</span><span class="entity">mods</span><span class="main">:</span><span class="entity">modifiers</span><span class="main">)</span> <span class="main">=</span>
  <span class="entity">mods</span> |&gt; <span class="entity">order</span> |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">rules</span> <span class="main">=&gt;</span> <span class="entity">get_names</span> <span class="entity">rules</span><span class="main">)</span> |&gt; <span class="entity">Dynamic_Utils.get_meth_nm</span> <span class="inner_quoted">""</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">reordered_mods</span> <span class="main">=</span> single o I<span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(** Dynamic_Rule: The tactic generator for the rule method. **)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Dynamic_Rule</span> <span class="main">:</span> <span class="entity">DYNAMIC_TACTIC</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="comment1">(* Rule_Seed: The seed to make the tactic-generator for the rule-method. *)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Rule_Seed</span> <span class="main">:</span> <span class="entity">DYNAMIC_TACTIC_GENERATOR_SEED</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword3"><span class="keyword">open</span></span> <span class="entity">Rule_Seed_Base</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_all_modifiers</span> <span class="main">(</span><span class="entity">state</span><span class="main">:</span><span class="entity">Proof.state</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">context</span><span class="main">:</span> <span class="entity">Proof.context</span><span class="main">,</span> <span class="entity">goal</span><span class="main">:</span> thm<span class="main">,</span><span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">Proof.goal</span> <span class="entity">state</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">intros</span> <span class="main">=</span> map <span class="entity">Rule</span> <span class="main">(</span><span class="entity">Find_Theorems2.get_intro_rule_names</span> <span class="entity">context</span> <span class="entity">goal</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">intros</span> <span class="main">:</span> <span class="entity">modifiers</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(* RTG: Rule Tactic Generator. *)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">RTG</span> <span class="main">:</span> <span class="entity">DYNAMIC_TACTIC_GENERATOR</span> <span class="main">=</span> <span class="entity">mk_Dynamic_Tactic_Generator</span> <span class="main">(</span><span class="entity">Rule_Seed</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_state_stttacs</span> <span class="main">(</span><span class="entity">state</span><span class="main">:</span><span class="entity">Proof.state</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rule</span>           <span class="main">=</span> <span class="inner_quoted">"HOL.rule"</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_modifiers</span>  <span class="main">=</span> <span class="entity">RTG.get_all_modifiers</span> <span class="entity">state</span> <span class="main">:</span> <span class="entity">RTG.modifiers</span><span class="main">;</span>
    <span class="comment1">(*For rule, I prefer not to create powerset.*)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_modifierss</span> <span class="main">=</span> map single <span class="entity">all_modifiers</span> |&gt; Seq.of_list <span class="main">:</span> <span class="entity">RTG.modifiers</span> Seq.seq<span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">stttacs</span>        <span class="main">=</span> Seq.map <span class="main">(</span><span class="entity">RTG.meth_name_n_modifiers_to_stttac_on_state</span> <span class="entity">rule</span><span class="main">)</span> <span class="entity">all_modifierss</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">stttac</span>     <span class="main">=</span> 'a <span class="entity">Dynamic_Utils.stttac</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">stttacs</span> <span class="main">:</span> <span class="entity">Proof.state</span> <span class="entity">stttac</span> Seq.seq
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(** Dynamic_Erule: The tactic generator for the erule method. **)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Dynamic_Erule</span> <span class="main">:</span> <span class="entity">DYNAMIC_TACTIC</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="comment1">(* Erule_Seed: The seed to make the tactic generator for the erule method. *)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Erule_Seed</span> <span class="main">:</span> <span class="entity">DYNAMIC_TACTIC_GENERATOR_SEED</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword3"><span class="keyword">open</span></span> <span class="entity">Rule_Seed_Base</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_all_modifiers</span> <span class="main">(</span><span class="entity">state</span><span class="main">:</span><span class="entity">Proof.state</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">context</span><span class="main">:</span> <span class="entity">Proof.context</span><span class="main">,</span> <span class="entity">goal</span><span class="main">:</span> thm<span class="main">,</span><span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">Proof.goal</span> <span class="entity">state</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">intros</span> <span class="main">=</span> map <span class="entity">Rule</span> <span class="main">(</span><span class="entity">Find_Theorems2.get_elim_rule_names</span> <span class="entity">context</span> <span class="entity">goal</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">intros</span> <span class="main">:</span> <span class="entity">modifiers</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(* ETG: Erule Tactic Generator. *)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">ETG</span> <span class="main">:</span> <span class="entity">DYNAMIC_TACTIC_GENERATOR</span> <span class="main">=</span> <span class="entity">mk_Dynamic_Tactic_Generator</span> <span class="main">(</span><span class="entity">Erule_Seed</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_state_stttacs</span> <span class="main">(</span><span class="entity">state</span><span class="main">:</span><span class="entity">Proof.state</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rule</span>           <span class="main">=</span> <span class="inner_quoted">"HOL.erule"</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_modifiers</span>  <span class="main">=</span> <span class="entity">ETG.get_all_modifiers</span> <span class="entity">state</span> <span class="main">:</span> <span class="entity">ETG.modifiers</span><span class="main">;</span>
    <span class="comment1">(*for erule, I prefer not to create powerset.*)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_modifierss</span> <span class="main">=</span> map single <span class="entity">all_modifiers</span> |&gt; Seq.of_list <span class="main">:</span> <span class="entity">ETG.modifiers</span> Seq.seq<span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">stttacs</span>        <span class="main">=</span> Seq.map <span class="main">(</span><span class="entity">ETG.meth_name_n_modifiers_to_stttac_on_state</span> <span class="entity">rule</span><span class="main">)</span> <span class="entity">all_modifierss</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">stttac</span>     <span class="main">=</span> 'a <span class="entity">Dynamic_Utils.stttac</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">stttacs</span> <span class="main">:</span> <span class="entity">Proof.state</span> <span class="entity">stttac</span> Seq.seq
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(** Dynamic_Simp: The tactic generator for the simp method. **)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Dynamic_Simp</span> <span class="main">:</span> <span class="entity">DYNAMIC_TACTIC</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="comment1">(* Simp_Seed: The seed to make the tactic-generator for the simp method. *)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Simp_Seed</span> <span class="main">:</span> <span class="entity">DYNAMIC_TACTIC_GENERATOR_SEED</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">modifier</span> <span class="main">=</span> <span class="entity">Add</span> <span class="keyword2"><span class="keyword">of</span></span> string<span class="main">;</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">modifiers</span> <span class="main">=</span> <span class="entity">modifier</span> list<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_adds</span> <span class="main">(</span><span class="entity">consts</span><span class="main">:</span>string list<span class="main">)</span> <span class="main">=</span> map <span class="entity">Add</span> <span class="entity">consts</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">order</span> <span class="main">(</span><span class="entity">mods</span><span class="main">:</span><span class="entity">modifiers</span><span class="main">)</span> <span class="main">=</span> <span class="entity">mods</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_name</span> <span class="main">(</span><span class="entity">Add</span> <span class="entity">name</span><span class="main">)</span> <span class="main">=</span> <span class="entity">name</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">get_names</span> <span class="main">=</span> map <span class="entity">get_name</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mods_to_string</span> <span class="main">(</span><span class="entity">mods</span><span class="main">:</span><span class="entity">modifiers</span><span class="main">)</span> <span class="main">=</span> <span class="entity">mods</span> |&gt; <span class="entity">order</span>
  |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">adds</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="inner_quoted">"add:"</span><span class="main">]</span> @ <span class="entity">get_names</span> <span class="entity">adds</span><span class="main">)</span>
  |&gt; <span class="entity">Dynamic_Utils.get_meth_nm</span> <span class="inner_quoted">""</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_all_modifiers</span> <span class="main">(</span><span class="entity">state</span><span class="main">:</span><span class="entity">Proof.state</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">context</span><span class="main">:</span> <span class="entity">Proof.context</span><span class="main">,</span> <span class="entity">goal</span><span class="main">:</span> thm<span class="main">,</span><span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">Proof.goal</span> <span class="entity">state</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simp_rule_names</span> <span class="main">=</span> <span class="entity">Find_Theorems2.get_simp_rule_names</span> <span class="entity">context</span> <span class="entity">goal</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">standard_rules</span>  <span class="main">=</span> <span class="main">[</span><span class="inner_quoted">"arith"</span><span class="main">,</span> <span class="inner_quoted">"algebra"</span><span class="main">,</span> <span class="inner_quoted">"ac_simps"</span><span class="main">,</span> <span class="inner_quoted">"field_simps"</span><span class="main">,</span> <span class="inner_quoted">"algebra_simps"</span><span class="main">,</span> <span class="inner_quoted">"divide_simps"</span><span class="main">]</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_simp_mods</span>   <span class="main">=</span> <span class="entity">get_adds</span> <span class="main">(</span><span class="entity">standard_rules</span> @ <span class="entity">simp_rule_names</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">all_simp_mods</span> <span class="main">:</span> <span class="entity">modifiers</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">reordered_mods</span> <span class="main">=</span> single o I<span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(* STG: Simp_Tactic_Generator *)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">STG</span> <span class="main">:</span> <span class="entity">DYNAMIC_TACTIC_GENERATOR</span> <span class="main">=</span>
  <span class="entity">mk_Dynamic_Tactic_Generator</span> <span class="main">(</span><span class="entity">Simp_Seed</span><span class="main">)</span> <span class="main">:</span> <span class="entity">DYNAMIC_TACTIC_GENERATOR</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_state_stttacs</span> <span class="main">(</span><span class="entity">state</span><span class="main">:</span><span class="entity">Proof.state</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simp</span>             <span class="main">=</span> <span class="inner_quoted">"simp "</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_modifiers</span>    <span class="main">=</span> <span class="entity">STG.get_all_modifiers</span> <span class="entity">state</span> <span class="main">:</span> <span class="entity">STG.modifiers</span><span class="main">;</span>
    <span class="comment1">(*For simp, I prefer not to create powerset.*)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_modifierss</span>   <span class="main">=</span> map single <span class="entity">all_modifiers</span> |&gt; Seq.of_list <span class="main">:</span> <span class="entity">STG.modifiers</span> Seq.seq<span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ssstacs</span> <span class="main">=</span> Seq.map <span class="main">(</span><span class="entity">STG.meth_name_n_modifiers_to_stttac_on_state</span> <span class="entity">simp</span><span class="main">)</span> <span class="entity">all_modifierss</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">stttac</span> <span class="main">=</span> 'a <span class="entity">Dynamic_Utils.stttac</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">ssstacs</span> <span class="main">:</span> <span class="entity">Proof.state</span> <span class="entity">stttac</span> Seq.seq
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(** Dynamic_Induct: The tactic generator for the induct method. **)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Dynamic_Induct</span> <span class="main">:</span> <span class="entity">DYNAMIC_TACTIC</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="comment1">(* Induct_Seed: The seed to make the tactic-generator for the induct method. *)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Induct_Seed</span> <span class="main">:</span> <span class="entity">DYNAMIC_TACTIC_GENERATOR_SEED</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">modifier</span> <span class="main">=</span> 
  <span class="entity">On</span>        <span class="keyword2"><span class="keyword">of</span></span> string
<span class="main">|</span> <span class="entity">Arbitrary</span> <span class="keyword2"><span class="keyword">of</span></span> string
<span class="main">|</span> <span class="entity">Rule</span>      <span class="keyword2"><span class="keyword">of</span></span> string<span class="main">;</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">modifiers</span> <span class="main">=</span> <span class="entity">modifier</span> list<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_ons</span>   <span class="main">(</span><span class="entity">fvars</span><span class="main">:</span>string list<span class="main">)</span> <span class="main">=</span> map <span class="entity">On</span> <span class="entity">fvars</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_arbs</span>  <span class="main">(</span><span class="entity">fvars</span><span class="main">:</span>string list<span class="main">)</span> <span class="main">=</span> map <span class="entity">Arbitrary</span> <span class="entity">fvars</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_rules</span> <span class="main">(</span><span class="entity">rules</span><span class="main">:</span>string list<span class="main">)</span> <span class="main">=</span> map <span class="entity">Rule</span> <span class="entity">rules</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">order'</span> <span class="entity">ordered</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> <span class="entity">ordered</span>
 <span class="main">|</span>  <span class="entity">order'</span> <span class="main">(</span><span class="entity">ons</span><span class="main">,</span> <span class="entity">arbs</span><span class="main">,</span> <span class="entity">rules</span><span class="main">)</span> <span class="main">(</span><span class="entity">On</span>        <span class="entity">var</span> :: <span class="entity">mods</span><span class="main">)</span> <span class="main">=</span> <span class="entity">order'</span> <span class="main">(</span><span class="entity">On</span> <span class="entity">var</span>::<span class="entity">ons</span><span class="main">,</span> <span class="entity">arbs</span><span class="main">,</span> <span class="entity">rules</span><span class="main">)</span> <span class="entity">mods</span>
 <span class="main">|</span>  <span class="entity">order'</span> <span class="main">(</span><span class="entity">ons</span><span class="main">,</span> <span class="entity">arbs</span><span class="main">,</span> <span class="entity">rules</span><span class="main">)</span> <span class="main">(</span><span class="entity">Arbitrary</span> <span class="entity">var</span> :: <span class="entity">mods</span><span class="main">)</span> <span class="main">=</span> <span class="entity">order'</span> <span class="main">(</span><span class="entity">ons</span><span class="main">,</span> <span class="entity">Arbitrary</span> <span class="entity">var</span>::<span class="entity">arbs</span><span class="main">,</span> <span class="entity">rules</span><span class="main">)</span> <span class="entity">mods</span>
 <span class="main">|</span>  <span class="entity">order'</span> <span class="main">(</span><span class="entity">ons</span><span class="main">,</span> <span class="entity">arbs</span><span class="main">,</span> <span class="entity">rules</span><span class="main">)</span> <span class="main">(</span><span class="entity">Rule</span>     <span class="entity">rule</span> :: <span class="entity">mods</span><span class="main">)</span> <span class="main">=</span> <span class="entity">order'</span> <span class="main">(</span><span class="entity">ons</span><span class="main">,</span> <span class="entity">arbs</span><span class="main">,</span> <span class="entity">Rule</span> <span class="entity">rule</span>::<span class="entity">rules</span><span class="main">)</span> <span class="entity">mods</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">order</span> <span class="main">(</span><span class="entity">mods</span><span class="main">:</span><span class="entity">modifiers</span><span class="main">)</span> <span class="main">=</span> <span class="comment1">(*(ons, arbs, rules)*)</span>
  <span class="entity">order'</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span><span class="main">[</span><span class="main">]</span><span class="main">,</span><span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="entity">mods</span> <span class="main">:</span> <span class="main">(</span><span class="entity">modifiers</span> * <span class="entity">modifiers</span> * <span class="entity">modifiers</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_name</span> <span class="main">(</span><span class="entity">On</span>        <span class="entity">name</span><span class="main">)</span> <span class="main">=</span> <span class="entity">name</span>
  <span class="main">|</span> <span class="entity">get_name</span> <span class="main">(</span><span class="entity">Arbitrary</span> <span class="entity">name</span><span class="main">)</span> <span class="main">=</span> <span class="entity">name</span>
  <span class="main">|</span> <span class="entity">get_name</span> <span class="main">(</span><span class="entity">Rule</span>      <span class="entity">name</span><span class="main">)</span> <span class="main">=</span> <span class="entity">name</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">get_names</span> <span class="main">=</span> map <span class="entity">get_name</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mods_to_string</span> <span class="main">(</span><span class="entity">mods</span><span class="main">:</span><span class="entity">modifiers</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span> 
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prefix_if_nonnil</span> <span class="main">=</span> <span class="entity">Utils.prefix_if_nonempty</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">mods</span> |&gt; <span class="entity">order</span> |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">ons</span><span class="main">,</span> <span class="entity">arbs</span><span class="main">,</span> <span class="entity">rules</span><span class="main">)</span> <span class="main">=&gt;</span>
    <span class="entity">get_names</span> <span class="entity">ons</span>
    @ <span class="entity">prefix_if_nonnil</span> <span class="inner_quoted">"arbitrary:"</span> <span class="main">(</span><span class="entity">get_names</span> <span class="entity">arbs</span><span class="main">)</span>
    @ <span class="entity">prefix_if_nonnil</span> <span class="inner_quoted">"rule:"</span>      <span class="main">(</span><span class="entity">get_names</span> <span class="entity">rules</span><span class="main">)</span><span class="main">)</span>
    |&gt; <span class="entity">Dynamic_Utils.get_meth_nm</span> <span class="inner_quoted">""</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_all_modifiers</span> <span class="main">(</span><span class="entity">state</span><span class="main">:</span><span class="entity">Proof.state</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">context</span><span class="main">:</span> <span class="entity">Proof.context</span><span class="main">,</span> <span class="entity">goal</span><span class="main">:</span> thm<span class="main">,</span><span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">Proof.goal</span> <span class="entity">state</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">free_var_names</span>   <span class="main">=</span> <span class="entity">Isabelle_Utils.get_free_var_names_in_1st_subg</span> <span class="entity">goal</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">induct_rules</span>     <span class="main">=</span> <span class="entity">Find_Theorems2.get_induct_rule_names</span> <span class="entity">context</span> <span class="entity">goal</span> <span class="main">:</span> string list<span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_induct_mods</span>  <span class="main">=</span> <span class="entity">get_ons</span> <span class="entity">free_var_names</span> @ <span class="entity">get_arbs</span> <span class="entity">free_var_names</span> @ <span class="entity">get_rules</span> <span class="entity">induct_rules</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">all_induct_mods</span> <span class="main">:</span> <span class="entity">modifiers</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pick_vars</span> <span class="main">=</span> filter     <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">modi</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">modi</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="entity">On</span> <span class="main">_</span> <span class="main">=&gt;</span> true <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false<span class="main">)</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dump_vars</span> <span class="main">=</span> filter_out <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">modi</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">modi</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="entity">On</span> <span class="main">_</span> <span class="main">=&gt;</span> true <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false<span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">reordered_mods</span> <span class="main">(</span><span class="entity">mods</span><span class="main">:</span><span class="entity">modifiers</span><span class="main">)</span><span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">vars</span>   <span class="main">=</span> <span class="entity">pick_vars</span> <span class="entity">mods</span> <span class="main">:</span> <span class="entity">modifiers</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">varss</span>  <span class="main">=</span> <span class="entity">Nitpick_Util.all_permutations</span> <span class="entity">vars</span> <span class="main">:</span> <span class="entity">modifiers</span> list<span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">others</span> <span class="main">=</span> <span class="entity">dump_vars</span> <span class="entity">mods</span> <span class="main">:</span> <span class="entity">modifiers</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">combs</span>  <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">vs</span> <span class="main">=&gt;</span> <span class="entity">vs</span> @ <span class="entity">others</span><span class="main">)</span> <span class="entity">varss</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">combs</span><span class="main">:</span><span class="entity">modifiers</span> list
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(* ITG: Induct_Tactic_Generator. *)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">ITG</span> <span class="main">:</span> <span class="entity">DYNAMIC_TACTIC_GENERATOR</span> <span class="main">=</span> <span class="entity">mk_Dynamic_Tactic_Generator</span> <span class="main">(</span><span class="entity">Induct_Seed</span><span class="main">)</span><span class="main">;</span>

<span class="keyword3"><span class="keyword">open</span></span> <span class="entity">Induct_Seed</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_state_stttacs</span> <span class="main">(</span><span class="entity">state</span><span class="main">:</span><span class="entity">Proof.state</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">induct</span>         <span class="main">=</span> <span class="inner_quoted">"induct"</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_modifiers</span>  <span class="main">=</span> <span class="entity">ITG.get_all_modifiers</span> <span class="entity">state</span> <span class="main">:</span> <span class="entity">ITG.modifiers</span><span class="main">;</span>
    <span class="comment1">(*We need to consider all permutations because induct is order sensitive.*)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_modifierss</span> <span class="main">=</span> <span class="entity">Seq2.powerset</span> <span class="main">(</span>Seq.of_list <span class="entity">all_modifiers</span><span class="main">)</span>
                      |&gt; Seq.map Seq.list_of
                      |&gt; Seq.map <span class="entity">reordered_mods</span>
                      |&gt; Seq.map Seq.of_list
                      |&gt; Seq.flat<span class="main">:</span> <span class="entity">ITG.modifiers</span> Seq.seq<span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">stttacs</span>    <span class="main">=</span> Seq.map <span class="main">(</span><span class="entity">ITG.meth_name_n_modifiers_to_stttac_on_state</span> <span class="entity">induct</span><span class="main">)</span> <span class="entity">all_modifierss</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">stttac</span> <span class="main">=</span> 'a <span class="entity">Dynamic_Utils.stttac</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">stttacs</span> <span class="main">:</span> <span class="entity">Proof.state</span> <span class="entity">stttac</span> Seq.seq
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(** Dynamic_Induct_Tac: The tactic generator for the induct_tac method. **)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Dynamic_Induct_Tac</span> <span class="main">:</span> <span class="entity">DYNAMIC_TACTIC</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="comment1">(* Induct_Tac_Seed: The seed to make the tactic-generator for the induct_tac method. *)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Induct_Tac_Seed</span> <span class="main">:</span> <span class="entity">DYNAMIC_TACTIC_GENERATOR_SEED</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">modifier</span> <span class="main">=</span>
  <span class="entity">On</span>        <span class="keyword2"><span class="keyword">of</span></span> string
<span class="main">|</span> <span class="entity">Rule</span>      <span class="keyword2"><span class="keyword">of</span></span> string<span class="main">;</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">modifiers</span> <span class="main">=</span> <span class="entity">modifier</span> list<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_ons</span>   <span class="main">(</span><span class="entity">fvars</span><span class="main">:</span>string list<span class="main">)</span> <span class="main">=</span> map <span class="entity">On</span> <span class="entity">fvars</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_rules</span> <span class="main">(</span><span class="entity">rules</span><span class="main">:</span>string list<span class="main">)</span> <span class="main">=</span> map <span class="entity">Rule</span> <span class="entity">rules</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">order'</span> <span class="entity">ordered</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> <span class="entity">ordered</span>
 <span class="main">|</span>  <span class="entity">order'</span> <span class="main">(</span><span class="entity">ons</span><span class="main">,</span> <span class="entity">rules</span><span class="main">)</span> <span class="main">(</span><span class="entity">On</span>        <span class="entity">var</span> :: <span class="entity">mods</span><span class="main">)</span> <span class="main">=</span> <span class="entity">order'</span> <span class="main">(</span><span class="entity">On</span> <span class="entity">var</span>::<span class="entity">ons</span><span class="main">,</span> <span class="entity">rules</span><span class="main">)</span> <span class="entity">mods</span>
 <span class="main">|</span>  <span class="entity">order'</span> <span class="main">(</span><span class="entity">ons</span><span class="main">,</span> <span class="entity">rules</span><span class="main">)</span> <span class="main">(</span><span class="entity">Rule</span>     <span class="entity">rule</span> :: <span class="entity">mods</span><span class="main">)</span> <span class="main">=</span> <span class="entity">order'</span> <span class="main">(</span><span class="entity">ons</span><span class="main">,</span> <span class="entity">Rule</span> <span class="entity">rule</span>::<span class="entity">rules</span><span class="main">)</span> <span class="entity">mods</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">order</span> <span class="main">(</span><span class="entity">mods</span><span class="main">:</span><span class="entity">modifiers</span><span class="main">)</span> <span class="main">=</span> <span class="comment1">(*(ons, rules)*)</span>
  <span class="entity">order'</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span><span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="entity">mods</span> <span class="main">:</span> <span class="main">(</span><span class="entity">modifiers</span> * <span class="entity">modifiers</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_name</span> <span class="main">(</span><span class="entity">On</span>        <span class="entity">name</span><span class="main">)</span> <span class="main">=</span> <span class="entity">name</span>
  <span class="main">|</span> <span class="entity">get_name</span> <span class="main">(</span><span class="entity">Rule</span>      <span class="entity">name</span><span class="main">)</span> <span class="main">=</span> <span class="entity">name</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">get_names</span> <span class="main">=</span> map <span class="entity">get_name</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mods_to_string</span> <span class="main">(</span><span class="entity">mods</span><span class="main">:</span><span class="entity">modifiers</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prefix_if_nonnil</span> <span class="main">=</span> <span class="entity">Utils.prefix_if_nonempty</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">mods</span> |&gt; <span class="entity">order</span> |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">ons</span><span class="main">,</span> <span class="entity">rules</span><span class="main">)</span> <span class="main">=&gt;</span>
    <span class="entity">get_names</span> <span class="entity">ons</span>
    @ <span class="entity">prefix_if_nonnil</span> <span class="inner_quoted">"rule:"</span>      <span class="main">(</span><span class="entity">get_names</span> <span class="entity">rules</span><span class="main">)</span><span class="main">)</span>
    |&gt; <span class="entity">Dynamic_Utils.get_meth_nm</span> <span class="inner_quoted">""</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_all_modifiers</span> <span class="main">(</span><span class="entity">state</span><span class="main">:</span><span class="entity">Proof.state</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">context</span><span class="main">:</span> <span class="entity">Proof.context</span><span class="main">,</span> <span class="entity">goal</span><span class="main">:</span> thm<span class="main">,</span><span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">Proof.goal</span> <span class="entity">state</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_var_names</span>   <span class="main">=</span> <span class="entity">Isabelle_Utils.get_all_var_names_in_1st_subg</span> <span class="entity">goal</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">induct_rules</span>    <span class="main">=</span> <span class="entity">Find_Theorems2.get_induct_rule_names</span> <span class="entity">context</span> <span class="entity">goal</span> <span class="main">:</span> string list<span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_induct_mods</span> <span class="main">=</span> <span class="entity">get_ons</span> <span class="entity">all_var_names</span> @ <span class="entity">get_rules</span> <span class="entity">induct_rules</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">all_induct_mods</span> <span class="main">:</span> <span class="entity">modifiers</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">reordered_mods</span> <span class="main">=</span> single o I<span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(* ITTG: Induct_Tac_Tactic_Generator *)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">ITTG</span> <span class="main">:</span> <span class="entity">DYNAMIC_TACTIC_GENERATOR</span> <span class="main">=</span>
  <span class="entity">mk_Dynamic_Tactic_Generator</span> <span class="main">(</span><span class="entity">Induct_Tac_Seed</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_state_stttacs</span> <span class="main">(</span><span class="entity">state</span><span class="main">:</span><span class="entity">Proof.state</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">induct</span>         <span class="main">=</span> <span class="inner_quoted">"induct_tac"</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_modifiers</span>  <span class="main">=</span> <span class="entity">ITTG.get_all_modifiers</span> <span class="entity">state</span> <span class="main">:</span> <span class="entity">ITTG.modifiers</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_modifierss</span> <span class="main">=</span> <span class="entity">Seq2.powerset</span> <span class="main">(</span>Seq.of_list <span class="entity">all_modifiers</span><span class="main">)</span>
                      |&gt; Seq.map Seq.list_of<span class="main">:</span> <span class="entity">ITTG.modifiers</span> Seq.seq<span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">stttacs</span>        <span class="main">=</span> Seq.map <span class="main">(</span><span class="entity">ITTG.meth_name_n_modifiers_to_stttac_on_state</span> <span class="entity">induct</span><span class="main">)</span> <span class="entity">all_modifierss</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">stttac</span> <span class="main">=</span> 'a <span class="entity">Dynamic_Utils.stttac</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> 
    <span class="entity">stttacs</span> <span class="main">:</span> <span class="entity">Proof.state</span> <span class="entity">stttac</span> Seq.seq
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(** Dynamic_Coinduction: The tactic generator for the coinduction method. **)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Dynamic_Coinduction</span> <span class="main">:</span> <span class="entity">DYNAMIC_TACTIC</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="comment1">(* Coinduction_Seed: The seed to make the tactic-generator for the coinduction method. *)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Coinduction_Seed</span> <span class="main">:</span> <span class="entity">DYNAMIC_TACTIC_GENERATOR_SEED</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">modifier</span> <span class="main">=</span> 
  <span class="entity">On</span>        <span class="keyword2"><span class="keyword">of</span></span> string
<span class="main">|</span> <span class="entity">Arbitrary</span> <span class="keyword2"><span class="keyword">of</span></span> string
<span class="main">|</span> <span class="entity">Rule</span>      <span class="keyword2"><span class="keyword">of</span></span> string<span class="main">;</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">modifiers</span> <span class="main">=</span> <span class="entity">modifier</span> list<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_ons</span>   <span class="main">(</span><span class="entity">fvars</span><span class="main">:</span>string list<span class="main">)</span> <span class="main">=</span> map <span class="entity">On</span> <span class="entity">fvars</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_arbs</span>  <span class="main">(</span><span class="entity">fvars</span><span class="main">:</span>string list<span class="main">)</span> <span class="main">=</span> map <span class="entity">Arbitrary</span> <span class="entity">fvars</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_rules</span> <span class="main">(</span><span class="entity">rules</span><span class="main">:</span>string list<span class="main">)</span> <span class="main">=</span> map <span class="entity">Rule</span> <span class="entity">rules</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">order'</span> <span class="entity">ordered</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> <span class="entity">ordered</span>
 <span class="main">|</span>  <span class="entity">order'</span> <span class="main">(</span><span class="entity">ons</span><span class="main">,</span> <span class="entity">arbs</span><span class="main">,</span> <span class="entity">rules</span><span class="main">)</span> <span class="main">(</span><span class="entity">On</span>        <span class="entity">var</span> :: <span class="entity">mods</span><span class="main">)</span> <span class="main">=</span> <span class="entity">order'</span> <span class="main">(</span><span class="entity">On</span> <span class="entity">var</span>::<span class="entity">ons</span><span class="main">,</span> <span class="entity">arbs</span><span class="main">,</span> <span class="entity">rules</span><span class="main">)</span> <span class="entity">mods</span>
 <span class="main">|</span>  <span class="entity">order'</span> <span class="main">(</span><span class="entity">ons</span><span class="main">,</span> <span class="entity">arbs</span><span class="main">,</span> <span class="entity">rules</span><span class="main">)</span> <span class="main">(</span><span class="entity">Arbitrary</span> <span class="entity">var</span> :: <span class="entity">mods</span><span class="main">)</span> <span class="main">=</span> <span class="entity">order'</span> <span class="main">(</span><span class="entity">ons</span><span class="main">,</span> <span class="entity">Arbitrary</span> <span class="entity">var</span>::<span class="entity">arbs</span><span class="main">,</span> <span class="entity">rules</span><span class="main">)</span> <span class="entity">mods</span>
 <span class="main">|</span>  <span class="entity">order'</span> <span class="main">(</span><span class="entity">ons</span><span class="main">,</span> <span class="entity">arbs</span><span class="main">,</span> <span class="entity">rules</span><span class="main">)</span> <span class="main">(</span><span class="entity">Rule</span>     <span class="entity">rule</span> :: <span class="entity">mods</span><span class="main">)</span> <span class="main">=</span> <span class="entity">order'</span> <span class="main">(</span><span class="entity">ons</span><span class="main">,</span> <span class="entity">arbs</span><span class="main">,</span> <span class="entity">Rule</span> <span class="entity">rule</span>::<span class="entity">rules</span><span class="main">)</span> <span class="entity">mods</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">order</span> <span class="main">(</span><span class="entity">mods</span><span class="main">:</span><span class="entity">modifiers</span><span class="main">)</span> <span class="main">=</span> <span class="comment1">(*(ons, arbs, rules)*)</span>
  <span class="entity">order'</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span><span class="main">[</span><span class="main">]</span><span class="main">,</span><span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="entity">mods</span> <span class="main">:</span> <span class="main">(</span><span class="entity">modifiers</span> * <span class="entity">modifiers</span> * <span class="entity">modifiers</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_name</span> <span class="main">(</span><span class="entity">On</span>        <span class="entity">name</span><span class="main">)</span> <span class="main">=</span> <span class="entity">name</span>
  <span class="main">|</span> <span class="entity">get_name</span> <span class="main">(</span><span class="entity">Arbitrary</span> <span class="entity">name</span><span class="main">)</span> <span class="main">=</span> <span class="entity">name</span>
  <span class="main">|</span> <span class="entity">get_name</span> <span class="main">(</span><span class="entity">Rule</span>      <span class="entity">name</span><span class="main">)</span> <span class="main">=</span> <span class="entity">name</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">get_names</span> <span class="main">=</span> map <span class="entity">get_name</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mods_to_string</span> <span class="main">(</span><span class="entity">mods</span><span class="main">:</span><span class="entity">modifiers</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span> 
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prefix_if_nonnil</span> <span class="main">=</span> <span class="entity">Utils.prefix_if_nonempty</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">mods</span> |&gt; <span class="entity">order</span> |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">ons</span><span class="main">,</span> <span class="entity">arbs</span><span class="main">,</span> <span class="entity">rules</span><span class="main">)</span> <span class="main">=&gt;</span>
    <span class="entity">get_names</span> <span class="entity">ons</span>
    @ <span class="entity">prefix_if_nonnil</span> <span class="inner_quoted">"arbitrary:"</span> <span class="main">(</span><span class="entity">get_names</span> <span class="entity">arbs</span><span class="main">)</span>
    @ <span class="entity">prefix_if_nonnil</span> <span class="inner_quoted">"rule:"</span>      <span class="main">(</span><span class="entity">get_names</span> <span class="entity">rules</span><span class="main">)</span><span class="main">)</span>
    |&gt; <span class="entity">Dynamic_Utils.get_meth_nm</span> <span class="inner_quoted">""</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_all_modifiers</span> <span class="main">(</span><span class="entity">state</span><span class="main">:</span><span class="entity">Proof.state</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">context</span><span class="main">:</span><span class="entity">Proof.context</span><span class="main">,</span> <span class="entity">goal</span><span class="main">:</span> thm<span class="main">,</span><span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">Proof.goal</span> <span class="entity">state</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">free_var_names</span>   <span class="main">=</span> <span class="entity">Isabelle_Utils.get_free_var_names_in_1st_subg</span> <span class="entity">goal</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">induct_rules</span>     <span class="main">=</span> <span class="entity">Find_Theorems2.get_coinduction_rule_names</span> <span class="entity">context</span> <span class="entity">goal</span> <span class="main">:</span> string list<span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_induct_mods</span>  <span class="main">=</span> <span class="entity">get_ons</span> <span class="entity">free_var_names</span> @ <span class="entity">get_arbs</span> <span class="entity">free_var_names</span> @ <span class="entity">get_rules</span> <span class="entity">induct_rules</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">all_induct_mods</span> <span class="main">:</span> <span class="entity">modifiers</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">reordered_mods</span> <span class="main">=</span> single o I<span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(* CITG: Coinduction_Tactic_Generator *)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">CITG</span> <span class="main">:</span> <span class="entity">DYNAMIC_TACTIC_GENERATOR</span> <span class="main">=</span> <span class="entity">mk_Dynamic_Tactic_Generator</span> <span class="main">(</span><span class="entity">Coinduction_Seed</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_state_stttacs</span> <span class="main">(</span><span class="entity">state</span><span class="main">:</span><span class="entity">Proof.state</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">coinduction</span>    <span class="main">=</span> <span class="inner_quoted">"coinduction"</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_modifiers</span>  <span class="main">=</span> <span class="entity">CITG.get_all_modifiers</span> <span class="entity">state</span> <span class="main">:</span> <span class="entity">CITG.modifiers</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_modifierss</span> <span class="main">=</span> <span class="entity">Seq2.powerset</span> <span class="main">(</span>Seq.of_list <span class="entity">all_modifiers</span><span class="main">)</span>
                      |&gt; Seq.map Seq.list_of<span class="main">:</span> <span class="entity">CITG.modifiers</span> Seq.seq<span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">stttacs</span>        <span class="main">=</span> Seq.map <span class="main">(</span><span class="entity">CITG.meth_name_n_modifiers_to_stttac_on_state</span> <span class="entity">coinduction</span><span class="main">)</span> <span class="entity">all_modifierss</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">stttac</span> <span class="main">=</span> 'a <span class="entity">Dynamic_Utils.stttac</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> 
    <span class="entity">stttacs</span> <span class="main">:</span> <span class="entity">Proof.state</span> <span class="entity">stttac</span> Seq.seq
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(** Dynamic_Cases: The tactic generator for the cases method. **)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Dynamic_Cases</span> <span class="main">:</span> <span class="entity">DYNAMIC_TACTIC</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="comment1">(* Cases_Seed: The seed to make the tactic-generator for the cases method. *)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Cases_Seed</span> <span class="main">:</span> <span class="entity">DYNAMIC_TACTIC_GENERATOR_SEED</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">modifier</span> <span class="main">=</span> <span class="entity">On</span> <span class="keyword2"><span class="keyword">of</span></span> string<span class="main">;</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">modifiers</span> <span class="main">=</span> <span class="entity">modifier</span> list<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_ons</span>   <span class="main">(</span><span class="entity">fvars</span><span class="main">:</span>string list<span class="main">)</span> <span class="main">=</span> map <span class="entity">On</span> <span class="entity">fvars</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">order</span> <span class="main">(</span><span class="entity">mods</span><span class="main">:</span><span class="entity">modifiers</span><span class="main">)</span> <span class="main">=</span> <span class="entity">mods</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_name</span> <span class="main">(</span><span class="entity">On</span> <span class="entity">name</span><span class="main">)</span> <span class="main">=</span> <span class="entity">name</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">get_names</span> <span class="main">=</span> map <span class="entity">get_name</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mods_to_string</span> <span class="main">(</span><span class="entity">mods</span><span class="main">:</span><span class="entity">modifiers</span><span class="main">)</span> <span class="main">=</span>
    <span class="entity">mods</span> |&gt; <span class="entity">order</span> |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ons</span> <span class="main">=&gt;</span> <span class="entity">get_names</span> <span class="entity">ons</span> |&gt; <span class="entity">Dynamic_Utils.get_meth_nm</span> <span class="inner_quoted">""</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_all_modifiers</span> <span class="main">(</span><span class="entity">state</span><span class="main">:</span><span class="entity">Proof.state</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">goal</span><span class="main">:</span> thm<span class="main">,</span><span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">Proof.goal</span> <span class="entity">state</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">free_var_names</span>   <span class="main">=</span> <span class="entity">Isabelle_Utils.get_free_var_names_in_1st_subg</span> <span class="entity">goal</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_cases_mods</span>  <span class="main">=</span> <span class="entity">get_ons</span> <span class="entity">free_var_names</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">all_cases_mods</span> <span class="main">:</span> <span class="entity">modifiers</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">reordered_mods</span> <span class="main">=</span> single o I<span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(* CTG: Cases_Tactic_Generator *)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">CTG</span> <span class="main">:</span> <span class="entity">DYNAMIC_TACTIC_GENERATOR</span> <span class="main">=</span> <span class="entity">mk_Dynamic_Tactic_Generator</span> <span class="main">(</span><span class="entity">Cases_Seed</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_state_stttacs</span> <span class="main">(</span><span class="entity">state</span><span class="main">:</span><span class="entity">Proof.state</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">induct</span>         <span class="main">=</span> <span class="inner_quoted">"cases"</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_modifiers</span>  <span class="main">=</span> <span class="entity">CTG.get_all_modifiers</span> <span class="entity">state</span> <span class="main">:</span> <span class="entity">CTG.modifiers</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_modifierss</span> <span class="main">=</span> map single <span class="entity">all_modifiers</span> |&gt; Seq.of_list <span class="main">:</span> <span class="entity">CTG.modifiers</span> Seq.seq<span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">stttacs</span>        <span class="main">=</span> Seq.map <span class="main">(</span><span class="entity">CTG.meth_name_n_modifiers_to_stttac_on_state</span> <span class="entity">induct</span><span class="main">)</span> <span class="entity">all_modifierss</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">stttac</span> <span class="main">=</span> 'a <span class="entity">Dynamic_Utils.stttac</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">stttacs</span> <span class="main">:</span> <span class="entity">Proof.state</span> <span class="entity">stttac</span> Seq.seq
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(** Dynamic_Case_Tac: The tactic generator for the case_tac method. **)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Dynamic_Case_Tac</span> <span class="main">:</span> <span class="entity">DYNAMIC_TACTIC</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="comment1">(* Case_Tac_Seed: The seed to make the tactic-generator for the case_tac method. *)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Case_Tac_Seed</span> <span class="main">:</span> <span class="entity">DYNAMIC_TACTIC_GENERATOR_SEED</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">modifier</span> <span class="main">=</span> <span class="entity">On</span> <span class="keyword2"><span class="keyword">of</span></span> string<span class="main">;</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">modifiers</span> <span class="main">=</span> <span class="entity">modifier</span> list<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_ons</span> <span class="main">(</span><span class="entity">all_vars</span><span class="main">:</span>string list<span class="main">)</span> <span class="main">=</span> map <span class="entity">On</span> <span class="entity">all_vars</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">order</span> <span class="main">(</span><span class="entity">mods</span><span class="main">:</span><span class="entity">modifiers</span><span class="main">)</span> <span class="main">=</span> <span class="entity">mods</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_name</span> <span class="main">(</span><span class="entity">On</span> <span class="entity">name</span><span class="main">)</span> <span class="main">=</span> <span class="entity">name</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">get_names</span> <span class="main">=</span> map <span class="entity">get_name</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mods_to_string</span> <span class="main">(</span><span class="entity">mods</span><span class="main">:</span><span class="entity">modifiers</span><span class="main">)</span> <span class="main">=</span>
    <span class="entity">mods</span> |&gt; <span class="entity">order</span> |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ons</span> <span class="main">=&gt;</span> <span class="entity">get_names</span> <span class="entity">ons</span> |&gt; <span class="entity">Dynamic_Utils.get_meth_nm</span> <span class="inner_quoted">""</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_all_modifiers</span> <span class="main">(</span><span class="entity">state</span><span class="main">:</span><span class="entity">Proof.state</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">goal</span><span class="main">:</span> thm<span class="main">,</span><span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">Proof.goal</span> <span class="entity">state</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_var_names</span>   <span class="main">=</span> <span class="entity">Isabelle_Utils.get_all_var_names_in_1st_subg</span> <span class="entity">goal</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_cases_mods</span>  <span class="main">=</span> <span class="entity">get_ons</span> <span class="entity">all_var_names</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">all_cases_mods</span> <span class="main">:</span> <span class="entity">modifiers</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">reordered_mods</span> <span class="main">=</span> single o I<span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(* CTTG: Case_Tac_Tactic_Generator *)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">CTTG</span> <span class="main">:</span> <span class="entity">DYNAMIC_TACTIC_GENERATOR</span> <span class="main">=</span> <span class="entity">mk_Dynamic_Tactic_Generator</span> <span class="main">(</span><span class="entity">Case_Tac_Seed</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_state_stttacs</span> <span class="main">(</span><span class="entity">state</span><span class="main">:</span><span class="entity">Proof.state</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">induct</span>         <span class="main">=</span> <span class="inner_quoted">"case_tac"</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_modifiers</span>  <span class="main">=</span> <span class="entity">CTTG.get_all_modifiers</span> <span class="entity">state</span> <span class="main">:</span> <span class="entity">CTTG.modifiers</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_modifierss</span> <span class="main">=</span> map single <span class="entity">all_modifiers</span> |&gt; Seq.of_list <span class="main">:</span> <span class="entity">CTTG.modifiers</span> Seq.seq<span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">stttacs</span>        <span class="main">=</span> Seq.map <span class="main">(</span><span class="entity">CTTG.meth_name_n_modifiers_to_stttac_on_state</span> <span class="entity">induct</span><span class="main">)</span> <span class="entity">all_modifierss</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">stttac</span> <span class="main">=</span> 'a <span class="entity">Dynamic_Utils.stttac</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> 
    <span class="entity">stttacs</span> <span class="main">:</span> <span class="entity">Proof.state</span> <span class="entity">stttac</span> Seq.seq
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(** Classical_Seed: The seed to make the tactic-generator for the classical method. **)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Classical_Seed</span> <span class="main">:</span> <span class="entity">DYNAMIC_TACTIC_GENERATOR_SEED</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">modifier</span> <span class="main">=</span> 
  <span class="entity">Simp</span>  <span class="keyword2"><span class="keyword">of</span></span> string
<span class="main">|</span> <span class="entity">Split</span> <span class="keyword2"><span class="keyword">of</span></span> string
<span class="main">|</span> <span class="entity">Dest</span>  <span class="keyword2"><span class="keyword">of</span></span> string
<span class="main">|</span> <span class="entity">Elim</span>  <span class="keyword2"><span class="keyword">of</span></span> string
<span class="main">|</span> <span class="entity">Intro</span> <span class="keyword2"><span class="keyword">of</span></span> string<span class="main">;</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">modifiers</span> <span class="main">=</span> <span class="entity">modifier</span> list<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">order'</span> <span class="entity">ordered</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> <span class="entity">ordered</span>
 <span class="main">|</span>  <span class="entity">order'</span> <span class="main">(</span><span class="entity">simps</span><span class="main">,</span> <span class="entity">splits</span><span class="main">,</span> <span class="entity">dests</span><span class="main">,</span> <span class="entity">elims</span><span class="main">,</span> <span class="entity">intros</span><span class="main">)</span> <span class="main">(</span><span class="entity">Simp</span>  <span class="entity">rule</span> ::<span class="entity">params</span><span class="main">)</span> <span class="main">=</span> <span class="entity">order'</span> <span class="main">(</span><span class="entity">Simp</span> <span class="entity">rule</span>::<span class="entity">simps</span><span class="main">,</span> <span class="entity">splits</span><span class="main">,</span> <span class="entity">dests</span><span class="main">,</span> <span class="entity">elims</span><span class="main">,</span> <span class="entity">intros</span><span class="main">)</span>  <span class="entity">params</span>
 <span class="main">|</span>  <span class="entity">order'</span> <span class="main">(</span><span class="entity">simps</span><span class="main">,</span> <span class="entity">splits</span><span class="main">,</span> <span class="entity">dests</span><span class="main">,</span> <span class="entity">elims</span><span class="main">,</span> <span class="entity">intros</span><span class="main">)</span> <span class="main">(</span><span class="entity">Split</span> <span class="entity">rule</span> ::<span class="entity">params</span><span class="main">)</span> <span class="main">=</span> <span class="entity">order'</span> <span class="main">(</span><span class="entity">simps</span><span class="main">,</span> <span class="entity">Split</span> <span class="entity">rule</span>::<span class="entity">splits</span><span class="main">,</span> <span class="entity">dests</span><span class="main">,</span> <span class="entity">elims</span><span class="main">,</span> <span class="entity">intros</span><span class="main">)</span> <span class="entity">params</span>
 <span class="main">|</span>  <span class="entity">order'</span> <span class="main">(</span><span class="entity">simps</span><span class="main">,</span> <span class="entity">splits</span><span class="main">,</span> <span class="entity">dests</span><span class="main">,</span> <span class="entity">elims</span><span class="main">,</span> <span class="entity">intros</span><span class="main">)</span> <span class="main">(</span><span class="entity">Dest</span>  <span class="entity">rule</span> ::<span class="entity">params</span><span class="main">)</span> <span class="main">=</span> <span class="entity">order'</span> <span class="main">(</span><span class="entity">simps</span><span class="main">,</span> <span class="entity">splits</span><span class="main">,</span> <span class="entity">Dest</span> <span class="entity">rule</span>::<span class="entity">dests</span><span class="main">,</span> <span class="entity">elims</span><span class="main">,</span> <span class="entity">intros</span><span class="main">)</span>  <span class="entity">params</span>
 <span class="main">|</span>  <span class="entity">order'</span> <span class="main">(</span><span class="entity">simps</span><span class="main">,</span> <span class="entity">splits</span><span class="main">,</span> <span class="entity">dests</span><span class="main">,</span> <span class="entity">elims</span><span class="main">,</span> <span class="entity">intros</span><span class="main">)</span> <span class="main">(</span><span class="entity">Elim</span>  <span class="entity">rule</span> ::<span class="entity">params</span><span class="main">)</span> <span class="main">=</span> <span class="entity">order'</span> <span class="main">(</span><span class="entity">simps</span><span class="main">,</span> <span class="entity">splits</span><span class="main">,</span> <span class="entity">dests</span><span class="main">,</span> <span class="entity">Elim</span> <span class="entity">rule</span>::<span class="entity">elims</span><span class="main">,</span> <span class="entity">intros</span><span class="main">)</span>  <span class="entity">params</span>
 <span class="main">|</span>  <span class="entity">order'</span> <span class="main">(</span><span class="entity">simps</span><span class="main">,</span> <span class="entity">splits</span><span class="main">,</span> <span class="entity">dests</span><span class="main">,</span> <span class="entity">elims</span><span class="main">,</span> <span class="entity">intros</span><span class="main">)</span> <span class="main">(</span><span class="entity">Intro</span> <span class="entity">rule</span> ::<span class="entity">params</span><span class="main">)</span> <span class="main">=</span> <span class="entity">order'</span> <span class="main">(</span><span class="entity">simps</span><span class="main">,</span> <span class="entity">splits</span><span class="main">,</span> <span class="entity">dests</span><span class="main">,</span> <span class="entity">elims</span><span class="main">,</span> <span class="entity">Intro</span> <span class="entity">rule</span>::<span class="entity">intros</span><span class="main">)</span> <span class="entity">params</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">order</span> <span class="main">(</span><span class="entity">mods</span><span class="main">:</span><span class="entity">modifiers</span><span class="main">)</span> <span class="main">=</span>
  <span class="entity">order'</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span><span class="main">[</span><span class="main">]</span><span class="main">,</span><span class="main">[</span><span class="main">]</span><span class="main">,</span><span class="main">[</span><span class="main">]</span><span class="main">,</span><span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="entity">mods</span> <span class="main">:</span> <span class="main">(</span><span class="entity">modifiers</span> * <span class="entity">modifiers</span> * <span class="entity">modifiers</span> * <span class="entity">modifiers</span> * <span class="entity">modifiers</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_name</span> <span class="main">(</span><span class="entity">Simp</span>  <span class="entity">name</span><span class="main">)</span> <span class="main">=</span> <span class="entity">name</span>
  <span class="main">|</span> <span class="entity">get_name</span> <span class="main">(</span><span class="entity">Split</span> <span class="entity">name</span><span class="main">)</span> <span class="main">=</span> <span class="entity">name</span>
  <span class="main">|</span> <span class="entity">get_name</span> <span class="main">(</span><span class="entity">Dest</span>  <span class="entity">name</span><span class="main">)</span> <span class="main">=</span> <span class="entity">name</span>
  <span class="main">|</span> <span class="entity">get_name</span> <span class="main">(</span><span class="entity">Elim</span>  <span class="entity">name</span><span class="main">)</span> <span class="main">=</span> <span class="entity">name</span>
  <span class="main">|</span> <span class="entity">get_name</span> <span class="main">(</span><span class="entity">Intro</span> <span class="entity">name</span><span class="main">)</span> <span class="main">=</span> <span class="entity">name</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">get_names</span> <span class="main">=</span> map <span class="entity">get_name</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mods_to_string</span> <span class="main">(</span><span class="entity">mods</span><span class="main">:</span><span class="entity">modifiers</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span> 
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prefix_if_nonnil</span> <span class="main">=</span> <span class="entity">Utils.prefix_if_nonempty</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">mods</span> |&gt; <span class="entity">order</span> |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">simps</span><span class="main">,</span> <span class="entity">splits</span><span class="main">,</span> <span class="entity">dests</span><span class="main">,</span> <span class="entity">elims</span><span class="main">,</span> <span class="entity">intros</span><span class="main">)</span> <span class="main">=&gt;</span>
      <span class="entity">prefix_if_nonnil</span> <span class="inner_quoted">"simp:"</span>  <span class="main">(</span><span class="entity">get_names</span> <span class="entity">simps</span><span class="main">)</span>
    @ <span class="entity">prefix_if_nonnil</span> <span class="inner_quoted">"split:"</span> <span class="main">(</span><span class="entity">get_names</span> <span class="entity">splits</span><span class="main">)</span>
    @ <span class="entity">prefix_if_nonnil</span> <span class="inner_quoted">"dest:"</span>  <span class="main">(</span><span class="entity">get_names</span> <span class="entity">dests</span><span class="main">)</span>
    @ <span class="entity">prefix_if_nonnil</span> <span class="inner_quoted">"elim:"</span>  <span class="main">(</span><span class="entity">get_names</span> <span class="entity">elims</span><span class="main">)</span>
    @ <span class="entity">prefix_if_nonnil</span> <span class="inner_quoted">"intro:"</span> <span class="main">(</span><span class="entity">get_names</span> <span class="entity">intros</span><span class="main">)</span><span class="main">)</span>
    |&gt; <span class="entity">Dynamic_Utils.get_meth_nm</span> <span class="inner_quoted">""</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">FT2</span> <span class="main">=</span>  Find_Theorems2<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_all_modifiers</span> <span class="main">(</span><span class="entity">state</span><span class="main">:</span><span class="entity">Proof.state</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">context</span><span class="main">:</span> <span class="entity">Proof.context</span><span class="main">,</span> <span class="entity">goal</span><span class="main">:</span> thm<span class="main">,</span><span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">Proof.goal</span> <span class="entity">state</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">split_names</span>   <span class="main">=</span> <span class="entity">FT2.get_split_rule_names</span> <span class="entity">context</span> <span class="entity">goal</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">elim_names</span>    <span class="main">=</span> <span class="entity">FT2.get_elim_rule_names</span>  <span class="entity">context</span> <span class="entity">goal</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">intro_names</span>   <span class="main">=</span> <span class="entity">FT2.get_intro_rule_names</span> <span class="entity">context</span> <span class="entity">goal</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dest_names</span>    <span class="main">=</span> <span class="entity">FT2.get_dest_rule_names</span>  <span class="entity">context</span> <span class="entity">goal</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">to_bool</span> EQUAL <span class="main">=</span> true
     <span class="main">|</span>  <span class="entity">to_bool</span> <span class="main">_</span>     <span class="main">=</span> false<span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">are_same</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">to_bool</span> o String.compare<span class="main">)</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simps</span>     <span class="main">=</span> subtract <span class="entity">are_same</span> <span class="main">(</span><span class="entity">split_names</span> @ <span class="entity">elim_names</span> @ <span class="entity">intro_names</span> @ <span class="entity">dest_names</span><span class="main">)</span>
                    <span class="main">(</span><span class="entity">FT2.get_fact_names_mesh</span> <span class="entity">state</span><span class="main">)</span> |&gt; map <span class="entity">Simp</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">splits</span>    <span class="main">=</span> map <span class="entity">Split</span> <span class="entity">split_names</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">elims</span>     <span class="main">=</span> map <span class="entity">Elim</span>  <span class="entity">elim_names</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">intros</span>    <span class="main">=</span> map <span class="entity">Intro</span> <span class="entity">intro_names</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dest</span>      <span class="main">=</span> map <span class="entity">Dest</span>  <span class="entity">dest_names</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">modifiers</span> <span class="main">=</span> <span class="entity">simps</span> @ <span class="entity">splits</span> @ <span class="entity">elims</span> @ <span class="entity">intros</span> @ <span class="entity">dest</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">modifiers</span> <span class="main">:</span> <span class="entity">modifiers</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">reordered_mods</span> <span class="main">=</span> single o I<span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">local</span></span>

<span class="comment1">(** CTG: Classical_Tactic_Generator. **)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">CTG</span> <span class="main">:</span> <span class="entity">DYNAMIC_TACTIC_GENERATOR</span> <span class="main">=</span> <span class="entity">mk_Dynamic_Tactic_Generator</span> <span class="main">(</span><span class="entity">Classical_Seed</span><span class="main">)</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">in</span></span>

<span class="comment1">(** Dynamic_Clarsimp: The tactic generator for the clarsimp method. **)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Dynamic_Clarsimp</span> <span class="main">:</span> <span class="entity">DYNAMIC_TACTIC</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_state_stttacs</span> <span class="main">(</span><span class="entity">state</span><span class="main">:</span><span class="entity">Proof.state</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_modifiers</span>    <span class="main">=</span> <span class="entity">CTG.get_all_modifiers</span> <span class="entity">state</span> <span class="main">:</span> <span class="entity">CTG.modifiers</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_modifierss</span>   <span class="main">=</span> map single <span class="entity">all_modifiers</span> |&gt; Seq.of_list <span class="main">:</span> <span class="entity">CTG.modifiers</span> Seq.seq<span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">stttacs</span> <span class="main">=</span> Seq.map <span class="main">(</span><span class="entity">CTG.meth_name_n_modifiers_to_stttac_on_state</span> <span class="inner_quoted">"clarsimp"</span><span class="main">)</span> <span class="entity">all_modifierss</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">stttac</span> <span class="main">=</span> 'a <span class="entity">Dynamic_Utils.stttac</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> 
    <span class="entity">stttacs</span> <span class="main">:</span> <span class="entity">Proof.state</span> <span class="entity">stttac</span> Seq.seq
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(** Dynamic_Fastforce: The tactic generator for the fastforce method. **)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Dynamic_Fastforce</span> <span class="main">:</span> <span class="entity">DYNAMIC_TACTIC</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_state_stttacs</span> <span class="main">(</span><span class="entity">state</span><span class="main">:</span><span class="entity">Proof.state</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_modifiers</span>    <span class="main">=</span> <span class="entity">CTG.get_all_modifiers</span> <span class="entity">state</span> <span class="main">:</span> <span class="entity">CTG.modifiers</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_modifierss</span>   <span class="main">=</span> map single <span class="entity">all_modifiers</span> |&gt; Seq.of_list <span class="main">:</span> <span class="entity">CTG.modifiers</span> Seq.seq<span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">stttacs</span> <span class="main">=</span> Seq.map <span class="main">(</span><span class="entity">CTG.meth_name_n_modifiers_to_stttac_on_state</span> <span class="inner_quoted">"fastforce"</span><span class="main">)</span> <span class="entity">all_modifierss</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">stttac</span> <span class="main">=</span> 'a <span class="entity">Dynamic_Utils.stttac</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> 
    <span class="entity">stttacs</span> <span class="main">:</span> <span class="entity">Proof.state</span> <span class="entity">stttac</span> Seq.seq
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
                                                    
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(** Dynamic_Blast: The tactic generator for the fastforce method. **)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Dynamic_Blast</span> <span class="main">:</span> <span class="entity">DYNAMIC_TACTIC</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_state_stttacs</span> <span class="main">(</span><span class="entity">state</span><span class="main">:</span><span class="entity">Proof.state</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_modifiers</span>    <span class="main">=</span> <span class="entity">CTG.get_all_modifiers</span> <span class="entity">state</span> <span class="main">:</span> <span class="entity">CTG.modifiers</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_modifierss</span>   <span class="main">=</span> map single <span class="entity">all_modifiers</span> |&gt; Seq.of_list <span class="main">:</span> <span class="entity">CTG.modifiers</span> Seq.seq<span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">stttacs</span> <span class="main">=</span> Seq.map <span class="main">(</span><span class="entity">CTG.meth_name_n_modifiers_to_stttac_on_state</span> <span class="inner_quoted">"blast"</span><span class="main">)</span> <span class="entity">all_modifierss</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">stttac</span> <span class="main">=</span> 'a <span class="entity">Dynamic_Utils.stttac</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">stttacs</span> <span class="main">:</span> <span class="entity">Proof.state</span> <span class="entity">stttac</span> Seq.seq
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(** Dynamic_Auto: The tactic generator for the auto method. **)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Dynamic_Auto</span> <span class="main">:</span> <span class="entity">DYNAMIC_TACTIC</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">mods</span> <span class="main">=</span> <span class="entity">CTG.modifiers</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">pstate</span> <span class="main">=</span> <span class="entity">Proof.state</span><span class="main">;</span>

<span class="comment1">(*We do not use incremental tactic specialisation for now.
fun increment  _                 ([]:mods)           (added:mods) (_:pstate) (_:pstate) _ = added
  | increment (meth_name:string) (new_mod::new_mods) (added:mods) (old_st:pstate) (orig_st:pstate) _ =
     let
       val pstate_to_thm    = Isabelle_Utils.proof_state_to_thm;
       val olds_and_new     = added@[new_mod] : mods;
       val new_nontac       = CTG.meth_name_n_modifiers_to_nontac_on_state meth_name olds_and_new;
       val new_states       = new_nontac orig_st : pstate Seq.seq;
       val new_state        = Seq.hd new_states handle Option.Option =&gt; old_st;
       val new_old_are_same = apply2 pstate_to_thm (old_st, new_state) |&gt; Thm.eq_thm : bool;
       val is_solved        = (new_state |&gt; Proof.goal |&gt; #goal |&gt; Thm.nprems_of) = 0
       fun if_diff lazy     = increment meth_name new_mods olds_and_new new_state orig_st lazy;
       fun if_same lazy     = increment meth_name new_mods added old_st orig_st lazy;
       val final_mods       = if is_solved then olds_and_new else
                              if new_old_are_same then if_same () else if_diff ();
     in
       final_mods
     end;
*)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_state_stttacs</span> <span class="main">(</span><span class="entity">state</span><span class="main">:</span><span class="entity">Proof.state</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_modifiers</span>    <span class="main">=</span> <span class="entity">CTG.get_all_modifiers</span> <span class="entity">state</span> <span class="main">:</span> <span class="entity">CTG.modifiers</span><span class="main">;</span>
  <span class="comment1">(*We do not use incremental tactic specialisation for now.
    val incremented_mods = increment "auto" all_modifiers [] state state ();*)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_modifierss</span>   <span class="main">=</span> map single <span class="entity">all_modifiers</span> |&gt; Seq.of_list <span class="main">:</span> <span class="entity">CTG.modifiers</span> Seq.seq<span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">stttacs</span> <span class="main">=</span> Seq.map <span class="main">(</span><span class="entity">CTG.meth_name_n_modifiers_to_stttac_on_state</span> <span class="inner_quoted">"auto"</span><span class="main">)</span> <span class="entity">all_modifierss</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">stttac</span> <span class="main">=</span> 'a <span class="entity">Dynamic_Utils.stttac</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> 
    <span class="entity">stttacs</span> <span class="main">:</span> <span class="entity">Proof.state</span> <span class="entity">stttac</span> Seq.seq
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(** Dynamic_Tactic_Generation: body. **)</span>
<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">get_stttacs</span> <span class="main">=</span> <span class="entity">Proof.state</span> <span class="main">-&gt;</span> <span class="entity">Proof.state</span> <span class="entity">Dynamic_Utils.stttac</span> Seq.seq<span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rule</span>        <span class="main">=</span> <span class="entity">Dynamic_Rule.get_state_stttacs</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">erule</span>       <span class="main">=</span> <span class="entity">Dynamic_Erule.get_state_stttacs</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simp</span>        <span class="main">=</span> <span class="entity">Dynamic_Simp.get_state_stttacs</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">induct</span>      <span class="main">=</span> <span class="entity">Dynamic_Induct.get_state_stttacs</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">induct_tac</span>  <span class="main">=</span> <span class="entity">Dynamic_Induct_Tac.get_state_stttacs</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">coinduction</span> <span class="main">=</span> <span class="entity">Dynamic_Coinduction.get_state_stttacs</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cases</span>       <span class="main">=</span> <span class="entity">Dynamic_Cases.get_state_stttacs</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">case_tac</span>    <span class="main">=</span> <span class="entity">Dynamic_Case_Tac.get_state_stttacs</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">clarsimp</span>    <span class="main">=</span> <span class="entity">Dynamic_Clarsimp.get_state_stttacs</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">blast</span>       <span class="main">=</span> <span class="entity">Dynamic_Blast.get_state_stttacs</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fastforce</span>   <span class="main">=</span> <span class="entity">Dynamic_Fastforce.get_state_stttacs</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">auto</span>        <span class="main">=</span> <span class="entity">Dynamic_Auto.get_state_stttacs</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span></pre>
</div><div id="files/Constructor_Class.ML">
<div class="head">
<h1>File ‹Constructor_Class.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Constructor_Class.ML
    Author:     Yutaka Nagashima, Data61, CSIRO

This file contains the hierarchical formalisation of modular constructor classes.
One has to provide minimal definitions to instantiate these classes.
The underlying concepts are explained in the following short paper:
 Close Encounters of the Higher Kind Emulating Constructor Classes in Standard ML
 available at https://arxiv.org/abs/1608.03350

This file is following the style of the Base package of Haskell.
This file uses the ML keyword "open" many times to encode the dependency among classes, while
keeping the code base small and clean.
*)</span>

<span class="comment1">(** TYP **)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">TYP</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">typ</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(** MONOID_MIN **)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">MONOID_MIN</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">monoid_min</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> mempty <span class="main">:</span> <span class="entity">monoid_min</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> mappend <span class="main">:</span> <span class="entity">monoid_min</span> <span class="main">-&gt;</span> <span class="entity">monoid_min</span> <span class="main">-&gt;</span> <span class="entity">monoid_min</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(** MONOID **)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">MONOID</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">monoid</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">include</span></span> <span class="entity">TYP</span> <span class="entity">MONOID_MIN</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">sharing</span></span> <span class="keyword1"><span class="keyword">type</span></span> monoid <span class="main">=</span> typ<span class="main">;</span>
  <span class="keyword1"><span class="keyword">sharing</span></span> <span class="keyword1"><span class="keyword">type</span></span> monoid <span class="main">=</span> monoid_min<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> mconcad <span class="main">:</span> <span class="entity">monoid</span> list <span class="main">-&gt;</span> <span class="entity">monoid</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(** mk_Monoid **)</span>
<span class="keyword1"><span class="keyword">functor</span></span> <span class="entity">mk_Monoid</span> <span class="main">(</span>Min<span class="main">:</span><span class="entity">MONOID_MIN</span><span class="main">)</span> <span class="main">:</span> <span class="entity">MONOID</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>
  <span class="keyword3"><span class="keyword">open</span></span> <span class="entity">Min</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">typ</span>    <span class="main">=</span> <span class="entity">Min.monoid_min</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">monoid</span> <span class="main">=</span> <span class="entity">Min.monoid_min</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mconcad</span> <span class="main">=</span> List.foldr <span class="main">(</span>uncurry <span class="entity">mappend</span><span class="main">)</span> <span class="entity">mempty</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(** FUNCTOR_MIN **)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">FUNCTOR_MIN</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">functo</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> fmap <span class="main">:</span> <span class="main">(</span>'a <span class="main">-&gt;</span> 'b<span class="main">)</span> <span class="main">-&gt;</span> 'a <span class="entity">functo</span> <span class="main">-&gt;</span> 'b <span class="entity">functo</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(** FUNCTOR **)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">FUNCTOR</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">include</span></span> <span class="entity">FUNCTOR_MIN</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> &lt;$  <span class="main">:</span>  'a * 'b <span class="entity">functo</span> <span class="main">-&gt;</span> 'a <span class="entity">functo</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> &lt;$&gt; <span class="main">:</span> <span class="main">(</span>'a <span class="main">-&gt;</span> 'b<span class="main">)</span> * 'a <span class="entity">functo</span> <span class="main">-&gt;</span> 'b <span class="entity">functo</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> void<span class="main">:</span> 'a <span class="entity">functo</span> <span class="main">-&gt;</span> unit <span class="entity">functo</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(** mk_Functor **)</span>
<span class="keyword1"><span class="keyword">functor</span></span> <span class="entity">mk_Functor</span> <span class="main">(</span>Min<span class="main">:</span><span class="entity">FUNCTOR_MIN</span><span class="main">)</span> <span class="main">:</span> <span class="entity">FUNCTOR</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>
  <span class="comment1">(* FUNCTOR_Min *)</span>
  <span class="keyword3"><span class="keyword">open</span></span> <span class="entity">Min</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">infix</span></span> <span class="inner_numeral">0</span> &lt;$ &lt;$&gt;<span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">x</span> <span class="entity">&lt;$</span> <span class="entity">f</span>  <span class="main">=</span> <span class="main">(</span><span class="entity">fmap</span> o K<span class="main">)</span> <span class="entity">x</span> <span class="entity">f</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">x</span> <span class="entity">&lt;$&gt;</span> <span class="entity">f</span> <span class="main">=</span> <span class="entity">fmap</span> <span class="entity">x</span> <span class="entity">f</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">void</span> <span class="entity">x</span>  <span class="main">=</span> <span class="main">(</span><span class="main">)</span> <span class="entity">&lt;$</span> <span class="entity">x</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(** APPLICATIVE_MIN **)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">APPLICATIVE_MIN</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">applicative</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> pure <span class="main">:</span> 'a <span class="main">-&gt;</span> 'a <span class="entity">applicative</span><span class="main">;</span>
  <span class="comment1">(* Sequential application. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> &lt;*&gt; <span class="main">:</span> <span class="main">(</span>'a <span class="main">-&gt;</span> 'b<span class="main">)</span> <span class="entity">applicative</span> * 'a <span class="entity">applicative</span> <span class="main">-&gt;</span> 'b <span class="entity">applicative</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(** applicative_Min_to_Functor_Min **)</span>
<span class="keyword1"><span class="keyword">functor</span></span> <span class="entity">applicative_Min_to_Functor_Min</span> <span class="main">(</span>Min<span class="main">:</span><span class="entity">APPLICATIVE_MIN</span><span class="main">)</span> <span class="main">:</span> <span class="entity">FUNCTOR_MIN</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>
  <span class="keyword3"><span class="keyword">open</span></span> <span class="entity">Min</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">infix</span></span> &lt;*&gt;<span class="main">;</span>
  <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">functo</span> <span class="main">=</span> 'a <span class="entity">applicative</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">fmap</span> <span class="entity">f</span> <span class="entity">xs</span> <span class="main">=</span> <span class="entity">pure</span> <span class="entity">f</span> <span class="entity">&lt;*&gt;</span> <span class="entity">xs</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(** APPLICATIVE **)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">APPLICATIVE</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">include</span></span> <span class="entity">APPLICATIVE_MIN</span> <span class="entity">FUNCTOR</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">sharing</span></span> <span class="keyword1"><span class="keyword">type</span></span> applicative <span class="main">=</span> functo<span class="main">;</span>
  <span class="comment1">(* Sequence actions, discarding the value of the first argument. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> *&gt; <span class="main">:</span> 'a <span class="entity">applicative</span> * 'b <span class="entity">applicative</span> <span class="main">-&gt;</span> 'b <span class="entity">applicative</span><span class="main">;</span>
  <span class="comment1">(* Sequence actions, discarding the value of the second argument. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> &lt;* <span class="main">:</span> 'a <span class="entity">applicative</span> * 'b <span class="entity">applicative</span> <span class="main">-&gt;</span> 'a <span class="entity">applicative</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> &lt;**&gt;   <span class="main">:</span> <span class="main">(</span>'a <span class="entity">applicative</span> * <span class="main">(</span>'a <span class="main">-&gt;</span> 'b<span class="main">)</span> <span class="entity">applicative</span><span class="main">)</span> <span class="main">-&gt;</span> 'b <span class="entity">applicative</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> liftA  <span class="main">:</span> <span class="main">(</span>'a <span class="main">-&gt;</span> 'b<span class="main">)</span> <span class="main">-&gt;</span> 'a <span class="entity">applicative</span> <span class="main">-&gt;</span> 'b <span class="entity">applicative</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> liftA2 <span class="main">:</span> <span class="main">(</span>'a <span class="main">-&gt;</span> 'b <span class="main">-&gt;</span> 'c<span class="main">)</span> <span class="main">-&gt;</span> 'a <span class="entity">applicative</span> <span class="main">-&gt;</span> 'b <span class="entity">applicative</span> <span class="main">-&gt;</span> 'c <span class="entity">applicative</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> liftA3 <span class="main">:</span> <span class="main">(</span>'a <span class="main">-&gt;</span> 'b <span class="main">-&gt;</span> 'c <span class="main">-&gt;</span> 'd<span class="main">)</span> <span class="main">-&gt;</span> 'a <span class="entity">applicative</span> <span class="main">-&gt;</span> 'b <span class="entity">applicative</span> <span class="main">-&gt;</span> 'c <span class="entity">applicative</span> <span class="main">-&gt;</span> 'd <span class="entity">applicative</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(** mk_Applicative **)</span>
<span class="keyword1"><span class="keyword">functor</span></span> <span class="entity">mk_Applicative</span> <span class="main">(</span>Min<span class="main">:</span><span class="entity">APPLICATIVE_MIN</span><span class="main">)</span> <span class="main">:</span> <span class="entity">APPLICATIVE</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>
  <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">applicative</span> <span class="main">=</span> 'a <span class="entity">Min.applicative</span><span class="main">;</span>
  <span class="comment1">(* FUNCTOR  *)</span>
  <span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Functor_Core</span> <span class="main">=</span> <span class="entity">applicative_Min_to_Functor_Min</span> <span class="main">(</span><span class="entity">Min</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Functor</span> <span class="main">=</span> <span class="entity">mk_Functor</span> <span class="main">(</span><span class="entity">Functor_Core</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword3"><span class="keyword">open</span></span> <span class="entity">Functor</span> <span class="entity">Min</span><span class="main">;</span>
  <span class="comment1">(* APPLICATIVE_AUX *)</span>
  <span class="keyword1"><span class="keyword">infix</span></span> &lt;*&gt; *&gt; &lt;* &lt;**&gt;<span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">u</span> <span class="entity">*&gt;</span> <span class="entity">v</span> <span class="main">=</span> <span class="entity">pure</span> <span class="main">(</span>K I<span class="main">)</span> <span class="entity">&lt;*&gt;</span> <span class="entity">u</span> <span class="entity">&lt;*&gt;</span> <span class="entity">v</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">u</span> <span class="entity">&lt;*</span> <span class="entity">v</span> <span class="main">=</span> <span class="entity">pure</span> K <span class="entity">&lt;*&gt;</span> <span class="entity">u</span> <span class="entity">&lt;*&gt;</span> <span class="entity">v</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">liftA</span> <span class="entity">f</span> <span class="entity">a</span> <span class="main">=</span> <span class="entity">pure</span> <span class="entity">f</span> <span class="entity">&lt;*&gt;</span> <span class="entity">a</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">liftA2</span> <span class="entity">f</span> <span class="entity">a</span> <span class="entity">b</span> <span class="main">=</span> <span class="entity">fmap</span> <span class="entity">f</span> <span class="entity">a</span> <span class="entity">&lt;*&gt;</span> <span class="entity">b</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">liftA3</span> <span class="entity">f</span> <span class="entity">a</span> <span class="entity">b</span> <span class="entity">c</span> <span class="main">=</span> <span class="entity">fmap</span> <span class="entity">f</span> <span class="entity">a</span> <span class="entity">&lt;*&gt;</span> <span class="entity">b</span> <span class="entity">&lt;*&gt;</span> <span class="entity">c</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">m</span> <span class="entity">&lt;**&gt;</span> <span class="entity">f</span> <span class="main">=</span> <span class="entity">f</span> <span class="entity">&lt;*&gt;</span> <span class="entity">m</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(** MONAD_MIN **)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">MONAD_MIN</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">monad</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> return <span class="main">:</span> 'a <span class="main">-&gt;</span> 'a <span class="entity">monad</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> bind <span class="main">:</span> 'a <span class="entity">monad</span> <span class="main">-&gt;</span> <span class="main">(</span>'a <span class="main">-&gt;</span> 'b <span class="entity">monad</span><span class="main">)</span> <span class="main">-&gt;</span> 'b <span class="entity">monad</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(** monad_Min_to_Applicative_Min **)</span>
<span class="keyword1"><span class="keyword">functor</span></span> <span class="entity">monad_Min_to_Applicative_Min</span> <span class="main">(</span>Min<span class="main">:</span><span class="entity">MONAD_MIN</span><span class="main">)</span> <span class="main">:</span> <span class="entity">APPLICATIVE_MIN</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>
  <span class="keyword3"><span class="keyword">open</span></span> <span class="entity">Min</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">applicative</span> <span class="main">=</span> 'a <span class="entity">monad</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pure</span> <span class="main">=</span> <span class="entity">return</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">&lt;*&gt;</span> <span class="main">(</span><span class="entity">fs</span><span class="main">,</span> <span class="entity">xs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">bind</span> <span class="entity">fs</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">fs'</span> <span class="main">=&gt;</span> <span class="entity">bind</span> <span class="entity">xs</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">xs'</span> <span class="main">=&gt;</span> <span class="entity">return</span> <span class="main">(</span><span class="entity">fs'</span> <span class="entity">xs'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(** MONAD **)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">MONAD</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">include</span></span> <span class="entity">APPLICATIVE</span> <span class="entity">MONAD_MIN</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">sharing</span></span> <span class="keyword1"><span class="keyword">type</span></span> monad <span class="main">=</span> applicative<span class="main">;</span>

  <span class="keyword1"><span class="keyword">val</span></span> &gt;&gt;=    <span class="main">:</span> 'a <span class="entity">monad</span> * <span class="main">(</span>'a <span class="main">-&gt;</span> 'b <span class="entity">monad</span><span class="main">)</span> <span class="main">-&gt;</span> 'b <span class="entity">monad</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> fail   <span class="main">:</span> string <span class="main">-&gt;</span> 'a <span class="entity">monad</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> &gt;&gt;     <span class="main">:</span> 'a <span class="entity">monad</span> * 'b <span class="entity">monad</span> <span class="main">-&gt;</span> 'b <span class="entity">monad</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> =&lt;&lt;    <span class="main">:</span> <span class="main">(</span>'a <span class="main">-&gt;</span> 'b <span class="entity">monad</span><span class="main">)</span> * 'a <span class="entity">monad</span> <span class="main">-&gt;</span> 'b <span class="entity">monad</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> comp   <span class="main">:</span> <span class="main">(</span>'a <span class="main">-&gt;</span> 'b <span class="entity">monad</span><span class="main">)</span> <span class="main">-&gt;</span> <span class="main">(</span>'b <span class="main">-&gt;</span> 'c <span class="entity">monad</span><span class="main">)</span> <span class="main">-&gt;</span> 'a <span class="main">-&gt;</span> 'c <span class="entity">monad</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> &gt;=&gt;    <span class="main">:</span> <span class="main">(</span>'a <span class="main">-&gt;</span> 'b <span class="entity">monad</span><span class="main">)</span> * <span class="main">(</span>'b <span class="main">-&gt;</span> 'c <span class="entity">monad</span><span class="main">)</span> <span class="main">-&gt;</span> 'a <span class="main">-&gt;</span> 'c <span class="entity">monad</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> &lt;=&lt;    <span class="main">:</span> <span class="main">(</span>'b <span class="main">-&gt;</span> 'c <span class="entity">monad</span><span class="main">)</span> * <span class="main">(</span>'a <span class="main">-&gt;</span> 'b <span class="entity">monad</span><span class="main">)</span> <span class="main">-&gt;</span> 'a <span class="main">-&gt;</span> 'c <span class="entity">monad</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> forever<span class="main">:</span> 'a <span class="entity">monad</span> <span class="main">-&gt;</span> 'b <span class="entity">monad</span><span class="main">;</span>  
  <span class="keyword1"><span class="keyword">val</span></span> liftM  <span class="main">:</span> <span class="main">(</span>'a <span class="main">-&gt;</span> 'b<span class="main">)</span> <span class="main">-&gt;</span> <span class="main">(</span>'a <span class="entity">monad</span> <span class="main">-&gt;</span> 'b <span class="entity">monad</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> join   <span class="main">:</span> 'a <span class="entity">monad</span> <span class="entity">monad</span> <span class="main">-&gt;</span> 'a <span class="entity">monad</span><span class="main">;</span>
  <span class="comment1">(* mapM, mapM_, forM, forM_, sequence, sequence_, foldM, and foldM here,
   * have additional type class constraints (Traversable and Foldable).
   * One can define them polymorphically using the ML keyword functor. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> filterM<span class="main">:</span> <span class="main">(</span>'a <span class="main">-&gt;</span> bool <span class="entity">monad</span><span class="main">)</span> <span class="main">-&gt;</span> 'a list <span class="main">-&gt;</span> 'a list <span class="entity">monad</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(** mk_Monad **)</span>
<span class="keyword1"><span class="keyword">functor</span></span> <span class="entity">mk_Monad</span> <span class="main">(</span>Min <span class="main">:</span> <span class="entity">MONAD_MIN</span><span class="main">)</span><span class="main">:</span> <span class="entity">MONAD</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>
  <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">monad</span> <span class="main">=</span> 'a <span class="entity">Min.monad</span><span class="main">;</span>
  <span class="comment1">(* APPLICATIVE *)</span>
  <span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Applicative_Min</span> <span class="main">=</span> <span class="entity">monad_Min_to_Applicative_Min</span> <span class="main">(</span><span class="entity">Min</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Applicative</span> <span class="main">=</span> <span class="entity">mk_Applicative</span> <span class="main">(</span><span class="entity">Applicative_Min</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword3"><span class="keyword">open</span></span> <span class="entity">Applicative</span><span class="main">;</span>
  <span class="comment1">(* MONAD_MIN *)</span>
  <span class="keyword3"><span class="keyword">open</span></span> <span class="entity">Min</span><span class="main">;</span>
  <span class="comment1">(* MONAD_AUX *)</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">comp</span> <span class="entity">f</span> <span class="entity">g</span>  <span class="main">=</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span> <span class="entity">bind</span> <span class="main">(</span><span class="entity">f</span> <span class="entity">x</span><span class="main">)</span> <span class="entity">g</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">infix</span></span> &gt;&gt;=  &gt;=&gt; &lt;=&lt; &gt;&gt; =&lt;&lt;<span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">m</span> <span class="entity">&gt;&gt;=</span> <span class="entity">f</span>   <span class="main">=</span> <span class="entity">bind</span> <span class="entity">m</span> <span class="entity">f</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">f</span> <span class="entity">=&lt;&lt;</span> <span class="entity">m</span>   <span class="main">=</span> <span class="entity">bind</span> <span class="entity">m</span> <span class="entity">f</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">f</span> <span class="entity">&gt;=&gt;</span> <span class="entity">g</span>   <span class="main">=</span> <span class="entity">comp</span> <span class="entity">f</span> <span class="entity">g</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">g</span> <span class="entity">&lt;=&lt;</span> <span class="entity">f</span>   <span class="main">=</span> <span class="entity">comp</span> <span class="entity">f</span> <span class="entity">g</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">m1</span> <span class="entity">&gt;&gt;</span> <span class="entity">m2</span>  <span class="main">=</span> <span class="entity">bind</span> <span class="entity">m1</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">m2</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">fail</span> <span class="entity">s</span>    <span class="main">=</span> error <span class="entity">s</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">liftM</span> <span class="entity">f</span> <span class="entity">m</span> <span class="main">=</span> <span class="entity">bind</span> <span class="entity">m</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">m'</span> <span class="main">=&gt;</span> <span class="entity">return</span> <span class="main">(</span><span class="entity">f</span> <span class="entity">m'</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">join</span> <span class="entity">n</span>    <span class="main">=</span> <span class="entity">bind</span> <span class="entity">n</span> I<span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">forever</span> <span class="entity">a</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_a'</span> <span class="entity">a'</span> <span class="main">=</span> <span class="entity">a</span> <span class="entity">&gt;&gt;</span> <span class="entity">get_a'</span> <span class="entity">a'</span> <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">get_a'</span> <span class="entity">a</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">filterM</span> <span class="entity">prop</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">swap_args</span> <span class="entity">f</span> <span class="entity">x</span> <span class="entity">y</span> <span class="main">=</span> <span class="entity">f</span> <span class="entity">y</span> <span class="entity">x</span><span class="main">;</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">foldr'</span> <span class="entity">f</span> <span class="main">=</span> Library.foldr <span class="main">(</span>uncurry <span class="entity">f</span><span class="main">)</span> |&gt; curry |&gt; <span class="entity">swap_args</span><span class="main">;</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">go</span> <span class="entity">x</span> <span class="entity">ret</span> <span class="main">=</span>
        <span class="entity">prop</span> <span class="entity">x</span> <span class="entity">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">flg</span> <span class="main">=&gt;</span>
        <span class="entity">ret</span>    <span class="entity">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ys</span>  <span class="main">=&gt;</span>
        <span class="entity">return</span> <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">flg</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">x</span>::<span class="entity">ys</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">ys</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">foldr'</span> <span class="entity">go</span> <span class="main">(</span><span class="entity">return</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(** ALTERNATIVE_MIN **)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">ALTERNATIVE_MIN</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">alternative</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> empty   <span class="main">:</span> 'a <span class="entity">alternative</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> &lt;|&gt;     <span class="main">:</span> 'a <span class="entity">alternative</span> * 'a <span class="entity">alternative</span> <span class="main">-&gt;</span> 'a <span class="entity">alternative</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> alt_pure<span class="main">:</span> 'a <span class="main">-&gt;</span> 'a <span class="entity">alternative</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> alt_seq <span class="main">:</span> <span class="main">(</span>'a <span class="main">-&gt;</span> 'b<span class="main">)</span> <span class="entity">alternative</span> * 'a <span class="entity">alternative</span> <span class="main">-&gt;</span> 'b <span class="entity">alternative</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(** alternative_Min_to_Applictive_Min **)</span>
<span class="keyword1"><span class="keyword">functor</span></span> <span class="entity">alternative_Min_to_Applictive_Min</span> <span class="main">(</span>Alternative_Min<span class="main">:</span><span class="entity">ALTERNATIVE_MIN</span><span class="main">)</span> <span class="main">:</span> <span class="entity">APPLICATIVE_MIN</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>
  <span class="keyword3"><span class="keyword">open</span></span> <span class="entity">Alternative_Min</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">applicative</span> <span class="main">=</span> 'a <span class="entity">alternative</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pure</span> <span class="main">=</span> <span class="entity">alt_pure</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">&lt;*&gt;</span>  <span class="main">=</span> <span class="entity">alt_seq</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(** ALTERNATIVE **)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">ALTERNATIVE</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">include</span></span> <span class="entity">APPLICATIVE</span> <span class="entity">ALTERNATIVE_MIN</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">sharing</span></span> <span class="keyword1"><span class="keyword">type</span></span> alternative <span class="main">=</span> applicative<span class="main">;</span>
  <span class="comment1">(* methods *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> some <span class="main">:</span> 'a <span class="entity">alternative</span> <span class="main">-&gt;</span> 'a list <span class="entity">alternative</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> many <span class="main">:</span> 'a <span class="entity">alternative</span> <span class="main">-&gt;</span> 'a list <span class="entity">alternative</span><span class="main">;</span>
  <span class="comment1">(* utility functions *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> optional <span class="main">:</span> 'a <span class="entity">alternative</span> <span class="main">-&gt;</span> 'a Option.option <span class="entity">alternative</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(** mk_Alternative **)</span>
<span class="keyword1"><span class="keyword">functor</span></span> <span class="entity">mk_Alternative</span> <span class="main">(</span>Alternative_Core<span class="main">:</span><span class="entity">ALTERNATIVE_MIN</span><span class="main">)</span> <span class="main">:</span> <span class="entity">ALTERNATIVE</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>
  <span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Applicative_Min</span>  <span class="main">=</span> <span class="entity">alternative_Min_to_Applictive_Min</span> <span class="main">(</span><span class="entity">Alternative_Core</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Applicative</span>      <span class="main">=</span> <span class="entity">mk_Applicative</span> <span class="main">(</span><span class="entity">Applicative_Min</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword3"><span class="keyword">open</span></span> <span class="entity">Applicative</span> <span class="entity">Alternative_Core</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">infix</span></span> &lt;$&gt; &lt;*&gt; &lt;|&gt;<span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">some</span>     <span class="main">(</span><span class="entity">v</span><span class="main">:</span>'a <span class="entity">alternative</span><span class="main">)</span> <span class="main">=</span> curry <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> ::<span class="main">)</span> <span class="entity">&lt;$&gt;</span> <span class="entity">v</span> <span class="entity">&lt;*&gt;</span> <span class="entity">many</span> <span class="entity">v</span> <span class="main">:</span> 'a list <span class="entity">alternative</span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="entity">many</span>     <span class="main">(</span><span class="entity">v</span><span class="main">:</span>'a <span class="entity">alternative</span><span class="main">)</span> <span class="main">=</span> <span class="entity">some</span> <span class="entity">v</span> <span class="entity">&lt;|&gt;</span> <span class="entity">pure</span> <span class="main">[</span><span class="main">]</span> <span class="main">:</span> 'a list <span class="entity">alternative</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">optional</span> <span class="main">(</span><span class="entity">v</span><span class="main">:</span>'a <span class="entity">alternative</span><span class="main">)</span> <span class="main">=</span> SOME <span class="entity">&lt;$&gt;</span> <span class="entity">v</span> <span class="entity">&lt;|&gt;</span> <span class="entity">pure</span> NONE<span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(** MONAD_0PLUS_MIN **)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">MONAD_0PLUS_MIN</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">monad</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> return <span class="main">:</span> 'a <span class="main">-&gt;</span> 'a <span class="entity">monad</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> bind <span class="main">:</span> 'a <span class="entity">monad</span> <span class="main">-&gt;</span> <span class="main">(</span>'a <span class="main">-&gt;</span> 'b <span class="entity">monad</span><span class="main">)</span> <span class="main">-&gt;</span> 'b <span class="entity">monad</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> mzero <span class="main">:</span> 'a <span class="entity">monad</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> mplus <span class="main">:</span> <span class="main">(</span>'a <span class="entity">monad</span> * 'a  <span class="entity">monad</span><span class="main">)</span> <span class="main">-&gt;</span> 'a <span class="entity">monad</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(** monad0plus_Min_to_Alternative_min **)</span>
<span class="keyword1"><span class="keyword">functor</span></span> <span class="entity">monad0plus_Min_to_Alternative_min</span><span class="main">(</span>M0p_Min<span class="main">:</span><span class="entity">MONAD_0PLUS_MIN</span><span class="main">)</span> <span class="main">:</span> <span class="entity">ALTERNATIVE_MIN</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>
  <span class="keyword3"><span class="keyword">open</span></span> <span class="entity">M0p_Min</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">alternative</span> <span class="main">=</span> 'a <span class="entity">monad</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">empty</span>            <span class="main">=</span> <span class="entity">mzero</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">&lt;|&gt;</span>              <span class="main">=</span> <span class="entity">mplus</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">alt_pure</span>         <span class="main">=</span> <span class="entity">return</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">alt_seq</span> <span class="main">(</span><span class="entity">fs</span><span class="main">,</span> <span class="entity">xs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">bind</span> <span class="entity">fs</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">fs'</span> <span class="main">=&gt;</span> <span class="entity">bind</span> <span class="entity">xs</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">xs'</span> <span class="main">=&gt;</span> <span class="entity">return</span> <span class="main">(</span><span class="entity">fs'</span> <span class="entity">xs'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(** MONAD_0PLUS **)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">MONAD_0PLUS</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">include</span></span> <span class="entity">MONAD</span><span class="main">;</span>
  <span class="comment1">(* Do not "include" ALTERNATIVE to avoid name conflicts. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> mzero <span class="main">:</span> 'a <span class="entity">monad</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> mplus <span class="main">:</span> <span class="main">(</span>'a <span class="entity">monad</span> * 'a  <span class="entity">monad</span><span class="main">)</span> <span class="main">-&gt;</span> 'a <span class="entity">monad</span><span class="main">;</span>

  <span class="comment1">(* auxiliary functions for 0PLUS *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> msum  <span class="main">:</span> 'a <span class="entity">monad</span> Seq.seq <span class="main">-&gt;</span> 'a <span class="entity">monad</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> guard <span class="main">:</span> bool <span class="main">-&gt;</span> unit <span class="entity">monad</span><span class="main">;</span>

  <span class="comment1">(* ALTERNATIVE_MIN *)</span>
  <span class="keyword1"><span class="keyword">include</span></span> <span class="entity">ALTERNATIVE_MIN</span><span class="main">;</span>
  <span class="comment1">(* ALTERNATIVE: we cannot use the keyword "include" to avoid the collision of Applicatives 
   * from Monad and Alternative. *)</span>
  <span class="keyword1"><span class="keyword">sharing</span></span> <span class="keyword1"><span class="keyword">type</span></span> alternative <span class="main">=</span> applicative<span class="main">;</span>
  <span class="comment1">(* methods *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> some <span class="main">:</span> 'a <span class="entity">alternative</span> <span class="main">-&gt;</span> 'a list <span class="entity">alternative</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> many <span class="main">:</span> 'a <span class="entity">alternative</span> <span class="main">-&gt;</span> 'a list <span class="entity">alternative</span><span class="main">;</span>
  <span class="comment1">(* utility functions *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> optional <span class="main">:</span> 'a <span class="entity">alternative</span> <span class="main">-&gt;</span> 'a Option.option <span class="entity">alternative</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(** mk_Monad_0Plus **)</span>
<span class="keyword1"><span class="keyword">functor</span></span> <span class="entity">mk_Monad_0Plus</span> <span class="main">(</span>Min <span class="main">:</span> <span class="entity">MONAD_0PLUS_MIN</span><span class="main">)</span> <span class="main">:</span> <span class="entity">MONAD_0PLUS</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>
  <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">monad</span> <span class="main">=</span> 'a <span class="entity">Min.monad</span><span class="main">;</span>
  <span class="comment1">(* MONAD *)</span>
  <span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Monad</span> <span class="main">=</span> <span class="entity">mk_Monad</span> <span class="main">(</span><span class="entity">Min</span> <span class="main">:</span> <span class="entity">MONAD_MIN</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword3"><span class="keyword">open</span></span> <span class="entity">Monad</span><span class="main">;</span>
  <span class="comment1">(* MONAD_0PLUS_MIN *)</span>
  <span class="keyword3"><span class="keyword">open</span></span> <span class="entity">Min</span><span class="main">;</span>
  <span class="comment1">(* MONAD0PLUS_AUX  *)</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">msum</span> <span class="entity">xs</span> <span class="main">=</span> <span class="entity">Seq2.foldr</span> <span class="entity">mplus</span> <span class="entity">mzero</span> <span class="entity">xs</span> <span class="main">:</span> 'a <span class="entity">monad</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">guard</span> true <span class="main">=</span> <span class="entity">pure</span> <span class="main">(</span><span class="main">)</span>
    <span class="main">|</span> <span class="entity">guard</span> <span class="main">_</span> <span class="main">=</span> <span class="entity">mzero</span><span class="main">;</span>

  <span class="comment1">(* ALTERNATIVE *)</span>
  <span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Alternative_Min</span> <span class="main">=</span> <span class="entity">monad0plus_Min_to_Alternative_min</span><span class="main">(</span><span class="entity">Min</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Alternative</span>     <span class="main">=</span> <span class="entity">mk_Alternative</span><span class="main">(</span><span class="entity">Alternative_Min</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword3"><span class="keyword">open</span></span> <span class="entity">Alternative</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(** TMONAD_MIN **)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">TMONAD_MIN</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">include</span></span> <span class="entity">MONAD_MIN</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">structure</span></span> Base<span class="main">:</span> <span class="entity">MONAD_MIN</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> lift <span class="main">:</span> 'a <span class="entity">Base.monad</span> <span class="main">-&gt;</span> 'a <span class="entity">monad</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(** TMONAD **)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">TMONAD</span> <span class="main">=</span> 
<span class="comment1">(* The signature of transformed monad (= the return type of monad transformer). *)</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">include</span></span> <span class="entity">MONAD</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">structure</span></span> Base <span class="main">:</span> <span class="entity">MONAD</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> lift <span class="main">:</span> 'a <span class="entity">Base.monad</span> <span class="main">-&gt;</span> 'a <span class="entity">monad</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(** mk_TMonad **)</span>
<span class="keyword1"><span class="keyword">functor</span></span> <span class="entity">mk_TMonad</span> <span class="main">(</span>Min <span class="main">:</span> <span class="entity">TMONAD_MIN</span><span class="main">)</span> <span class="main">:</span> <span class="entity">TMONAD</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>
  <span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Monad</span> <span class="main">=</span> <span class="entity">mk_Monad</span> <span class="main">(</span><span class="entity">Min</span> <span class="main">:</span> <span class="entity">MONAD_MIN</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword3"><span class="keyword">open</span></span> <span class="entity">Monad</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Base</span> <span class="main">=</span> <span class="entity">mk_Monad</span> <span class="main">(</span><span class="entity">Min.Base</span> <span class="main">:</span> <span class="entity">MONAD_MIN</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lift</span> <span class="main">=</span> <span class="entity">Min.lift</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(** TMONAD_0PLUS_MIN **)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">TMONAD_0PLUS_MIN</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">include</span></span> <span class="entity">MONAD_0PLUS_MIN</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">structure</span></span> Base<span class="main">:</span> <span class="entity">MONAD_0PLUS_MIN</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> lift <span class="main">:</span> 'a <span class="entity">Base.monad</span> <span class="main">-&gt;</span> 'a <span class="entity">monad</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(** TMONAD_0PLUS **)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">TMONAD_0PLUS</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">include</span></span> <span class="entity">MONAD_0PLUS</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">structure</span></span> Base <span class="main">:</span> <span class="entity">MONAD_0PLUS</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> lift <span class="main">:</span> 'a <span class="entity">Base.monad</span> <span class="main">-&gt;</span> 'a <span class="entity">monad</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(** mk_TMonad_0Plus **)</span>
<span class="keyword1"><span class="keyword">functor</span></span> <span class="entity">mk_TMonad_0Plus</span> <span class="main">(</span>Min <span class="main">:</span> <span class="entity">TMONAD_0PLUS_MIN</span><span class="main">)</span> <span class="main">:</span> <span class="entity">TMONAD_0PLUS</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>
  <span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Monad0Plus</span> <span class="main">=</span> <span class="entity">mk_Monad_0Plus</span> <span class="main">(</span><span class="entity">Min</span> <span class="main">:</span> <span class="entity">MONAD_0PLUS_MIN</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword3"><span class="keyword">open</span></span> <span class="entity">Monad0Plus</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Base</span> <span class="main">=</span> <span class="entity">mk_Monad_0Plus</span> <span class="main">(</span><span class="entity">Min.Base</span> <span class="main">:</span> <span class="entity">MONAD_0PLUS_MIN</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lift</span> <span class="main">=</span> <span class="entity">Min.lift</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span></pre>
</div><div id="files/Instantiation.ML">
<div class="head">
<h1>File ‹Instantiation.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Instantiation.ML
    Author:     Yutaka Nagashima, Data61, CSIRO

This file provides various instances of constructor classes.
The implementation is inspired by the corresponding formalisation used in the Haskell community.
*)</span>

<span class="comment1">(** Seq **)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Seq_M0P_Min</span> <span class="main">:</span> <span class="entity">MONAD_0PLUS_MIN</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>
  <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">monad</span>     <span class="main">=</span> 'a Seq.seq<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">return</span>        <span class="main">=</span> Seq.single<span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">bind</span> <span class="entity">seq</span> <span class="entity">func</span> <span class="main">=</span> Seq.flat <span class="main">(</span>Seq.map <span class="entity">func</span> <span class="entity">seq</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mzero</span>         <span class="main">=</span> Seq.empty<span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mplus</span> <span class="main">(</span><span class="entity">f</span><span class="main">,</span> <span class="entity">s</span><span class="main">)</span>  <span class="main">=</span> Seq.append <span class="entity">f</span> <span class="entity">s</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Seq_M0P</span> <span class="main">=</span> <span class="entity">mk_Monad_0Plus</span> <span class="main">(</span>Seq_M0P_Min<span class="main">)</span><span class="main">;</span>

<span class="comment1">(** List **)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">List_M0P_Min</span> <span class="main">:</span> <span class="entity">MONAD_0PLUS_MIN</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>
  <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">monad</span>     <span class="main">=</span> 'a list<span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">return</span> <span class="entity">x</span>      <span class="main">=</span> <span class="main">[</span><span class="entity">x</span><span class="main">]</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">bind</span> <span class="entity">seq</span> <span class="entity">func</span> <span class="main">=</span> flat <span class="main">(</span>map <span class="entity">func</span> <span class="entity">seq</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mzero</span>         <span class="main">=</span> <span class="main">[</span><span class="main">]</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mplus</span> <span class="main">(</span><span class="entity">f</span><span class="main">,</span> <span class="entity">s</span><span class="main">)</span>  <span class="main">=</span> <span class="entity">f</span> @ <span class="entity">s</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">ListCC</span> <span class="main">=</span> <span class="entity">mk_Monad_0Plus</span> <span class="main">(</span>List_M0P_Min<span class="main">)</span><span class="main">;</span>

<span class="comment1">(** Maybe **)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Option_M0P_Min</span> <span class="main">:</span> <span class="entity">MONAD_0PLUS_MIN</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>
  <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">monad</span>       <span class="main">=</span> 'a Option.option<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">return</span>          <span class="main">=</span> Option.SOME<span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">bind</span>  NONE      <span class="main">_</span>    <span class="main">=</span> NONE
   <span class="main">|</span>  <span class="entity">bind</span> <span class="main">(</span>SOME <span class="entity">sth</span><span class="main">)</span> <span class="entity">func</span> <span class="main">=</span> <span class="entity">func</span> <span class="entity">sth</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mzero</span>           <span class="main">=</span> Option.NONE<span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mplus</span> <span class="main">(</span>NONE<span class="main">,</span> <span class="entity">r</span><span class="main">)</span> <span class="main">=</span> <span class="entity">r</span>
   <span class="main">|</span>  <span class="entity">mplus</span> <span class="main">(</span><span class="entity">left</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">left</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Option_M0P</span> <span class="main">=</span> <span class="entity">mk_Monad_0Plus</span> <span class="main">(</span>Option_M0P_Min<span class="main">)</span><span class="main">;</span>

<span class="comment1">(** Strings as Monoid **)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Strings_Min</span> <span class="main">:</span> <span class="entity">MONOID_MIN</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">monoid_min</span> <span class="main">=</span> string list<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mempty</span> <span class="main">=</span> <span class="main">[</span><span class="main">]</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mappend</span> <span class="entity">src1</span> <span class="entity">src2</span> <span class="main">=</span> <span class="entity">src1</span> @ <span class="entity">src2</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Strings</span> <span class="main">=</span> <span class="entity">mk_Monoid</span> <span class="main">(</span>Strings_Min<span class="main">)</span> <span class="main">:</span> <span class="entity">MONOID</span><span class="main">;</span>

<span class="comment1">(** Cons Prod **)</span>
<span class="comment1">(*
 * We have to define CONS_PROD because Standard ML cannot handle
 * ML{* type ('f, 'g, 'p) cons_prod = ('p 'f) * ('p 'g); *}  
 *)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">CONS_PROD</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="comment1">(*Is this a valid specification for constructor products (:*:)?*)</span>
  <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">left_cons</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">right_cons</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">cons_prod</span> <span class="main">=</span> 'a <span class="entity">left_cons</span> * 'a <span class="entity">right_cons</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">functor</span></span> <span class="entity">mk_ConsProdMonadMin</span><span class="main">(</span><span class="keyword1"><span class="keyword">structure</span></span> Left<span class="main">:</span><span class="entity">MONAD_MIN</span><span class="main">;</span> <span class="keyword1"><span class="keyword">structure</span></span> Right<span class="main">:</span><span class="entity">MONAD_MIN</span><span class="main">)</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>
  <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">monad</span>      <span class="main">=</span> 'a <span class="entity">Left.monad</span> * 'a <span class="entity">Right.monad</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">return</span> <span class="entity">valu</span>    <span class="main">=</span> <span class="main">(</span><span class="entity">Left.return</span> <span class="entity">valu</span><span class="main">,</span> <span class="entity">Right.return</span> <span class="entity">valu</span><span class="main">)</span> <span class="main">:</span> 'a <span class="entity">monad</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">bind</span> <span class="main">(</span><span class="main">(</span><span class="entity">m</span><span class="main">,</span> <span class="entity">n</span><span class="main">)</span><span class="main">:</span>'a <span class="entity">monad</span><span class="main">)</span> <span class="main">(</span><span class="entity">func</span><span class="main">:</span><span class="main">(</span>'a <span class="main">-&gt;</span> 'b <span class="entity">Left.monad</span> * 'b <span class="entity">Right.monad</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
       <span class="main">(</span><span class="main">(</span><span class="entity">Left.bind</span>  <span class="entity">m</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">a</span> <span class="main">=&gt;</span> fst <span class="main">(</span><span class="entity">func</span> <span class="entity">a</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="entity">Right.bind</span> <span class="entity">n</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">a</span> <span class="main">=&gt;</span> snd <span class="main">(</span><span class="entity">func</span> <span class="entity">a</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">:</span> 'b <span class="entity">monad</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span> <span class="main">:</span> <span class="entity">MONAD_MIN</span><span class="main">;</span>

<span class="comment1">(* Example of mk_ConsProdMonadMin's use case. *)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">ListOptionConsProdMonadMin</span><span class="main">:</span><span class="entity">MONAD_MIN</span> <span class="main">=</span> <span class="entity">mk_ConsProdMonadMin</span><span class="main">(</span>
  <span class="keyword2"><span class="keyword">struct</span></span>
         <span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Left</span>  <span class="main">=</span> List_M0P_Min<span class="main">;</span>
         <span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Right</span> <span class="main">=</span> Option_M0P_Min
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span><span class="main">:</span><span class="entity">MONAD_MIN</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">ListOptionConsProdMonad</span> <span class="main">=</span> <span class="entity">mk_Monad</span><span class="main">(</span>ListOptionConsProdMonadMin<span class="main">)</span><span class="main">;</span>

<span class="entity">ListOptionConsProdMonadMin.return</span> <span class="inner_quoted">"foo"</span><span class="main">;</span>

<span class="comment1">(** State **)</span>
<span class="comment1">(* the minimum state monad0plus transformer *)</span>
<span class="keyword1"><span class="keyword">functor</span></span> <span class="entity">mk_stateMT_M0P_Min</span> <span class="main">(</span><span class="keyword1"><span class="keyword">structure</span></span> State <span class="main">:</span> <span class="entity">TYP</span><span class="main">;</span> <span class="keyword1"><span class="keyword">structure</span></span> Base <span class="main">:</span> <span class="entity">MONAD_0PLUS_MIN</span><span class="main">)</span> <span class="main">:</span> <span class="entity">TMONAD_0PLUS_MIN</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>
  <span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Base</span> <span class="main">=</span> <span class="entity">Base</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">monad</span> <span class="main">=</span> <span class="entity">State.typ</span> <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">State.typ</span> * 'a<span class="main">)</span> <span class="entity">Base.monad</span><span class="main">;</span>
  <span class="comment1">(*MONAD_CORE*)</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">return</span> <span class="entity">valu</span> <span class="main">=</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">state</span> <span class="main">=&gt;</span> <span class="entity">Base.return</span> <span class="main">(</span><span class="entity">state</span><span class="main">,</span> <span class="entity">valu</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">bind</span> <span class="entity">st_trans</span> <span class="entity">bfun</span> <span class="main">=</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">state0</span> <span class="main">=&gt;</span> 
    <span class="entity">Base.bind</span> <span class="main">(</span><span class="entity">st_trans</span> <span class="entity">state0</span><span class="main">)</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">state1</span><span class="main">,</span> <span class="entity">result1</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">bfun</span> <span class="entity">result1</span> <span class="entity">state1</span><span class="main">)</span><span class="main">;</span>
  <span class="comment1">(*MONADT*)</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">lift</span> <span class="entity">m</span>  <span class="main">=</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">state</span> <span class="main">=&gt;</span> <span class="entity">Base.bind</span> <span class="entity">m</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">result</span> <span class="main">=&gt;</span> <span class="entity">Base.return</span> <span class="main">(</span><span class="entity">state</span><span class="main">,</span> <span class="entity">result</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
  <span class="comment1">(*MONAD_0PLUS_CORE*)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mzero</span> <span class="main">=</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span><span class="comment1">(*state*)</span> <span class="main">=&gt;</span> <span class="entity">Base.mzero</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mplus</span> <span class="main">(</span><span class="entity">reader1</span><span class="main">,</span> <span class="entity">reader2</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">state</span> <span class="main">=&gt;</span> <span class="entity">Base.mplus</span> <span class="main">(</span><span class="entity">reader1</span> <span class="entity">state</span><span class="main">,</span> <span class="entity">reader2</span> <span class="entity">state</span><span class="main">)</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* the full state monad0plus transformer *)</span>
<span class="keyword1"><span class="keyword">functor</span></span> <span class="entity">mk_state_M0PT</span> <span class="main">(</span><span class="keyword1"><span class="keyword">structure</span></span> Log <span class="main">:</span> <span class="entity">TYP</span><span class="main">;</span> <span class="keyword1"><span class="keyword">structure</span></span> Base <span class="main">:</span> <span class="entity">MONAD_0PLUS_MIN</span><span class="main">)</span><span class="main">:</span> <span class="entity">TMONAD_0PLUS</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">SMT_M0P_Core</span> <span class="main">=</span> <span class="entity">mk_stateMT_M0P_Min</span><span class="main">(</span><span class="keyword2"><span class="keyword">struct</span></span> <span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">State</span> <span class="main">=</span> <span class="entity">Log</span><span class="main">;</span> <span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Base</span> <span class="main">=</span> <span class="entity">Base</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">SMT_M0P</span> <span class="main">=</span> <span class="entity">mk_TMonad_0Plus</span><span class="main">(</span><span class="entity">SMT_M0P_Core</span><span class="main">)</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">in</span></span>
  <span class="entity">SMT_M0P</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(* the minimum state monad *)</span>
<span class="keyword1"><span class="keyword">functor</span></span> <span class="entity">mk_StateM_Min</span> <span class="main">(</span>State <span class="main">:</span> <span class="entity">TYP</span><span class="main">)</span> <span class="main">:</span> <span class="entity">MONAD_MIN</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>
  <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">monad</span> <span class="main">=</span> <span class="entity">State.typ</span> <span class="main">-&gt;</span> <span class="main">(</span>'a * <span class="entity">State.typ</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">return</span> <span class="entity">v</span> <span class="main">=</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">s</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">v</span><span class="main">,</span> <span class="entity">s</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">bind</span> <span class="entity">st</span> <span class="entity">f</span> <span class="main">=</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">s</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">v</span><span class="main">,</span> <span class="entity">s'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">st</span> <span class="entity">s</span> <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">f</span> <span class="entity">v</span> <span class="entity">s'</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(* the full state monad *)</span>
<span class="keyword1"><span class="keyword">functor</span></span> <span class="entity">mk_StateM</span> <span class="main">(</span>State <span class="main">:</span> <span class="entity">TYP</span><span class="main">)</span> <span class="main">:</span> <span class="entity">MONAD</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>
  <span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">StateM_Min</span> <span class="main">=</span> <span class="entity">mk_StateM_Min</span> <span class="main">(</span><span class="entity">State</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">StateM</span> <span class="main">=</span> <span class="entity">mk_Monad</span> <span class="main">(</span><span class="entity">StateM_Min</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword3"><span class="keyword">open</span></span> <span class="entity">StateM</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(* the transformed monad0plus with update *)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">TSTATE_MONAD_0PLUS_MIN</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">include</span></span> <span class="entity">TMONAD_0PLUS</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> update <span class="main">:</span> <span class="main">(</span>'s <span class="main">-&gt;</span> 's<span class="main">)</span> <span class="main">-&gt;</span> 's <span class="main">-&gt;</span> <span class="main">(</span>'s * 's<span class="main">)</span> <span class="entity">Base.monad</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(* the transformed monad0plus with update, set, and fetch *)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">TSTATE_MONAD_0PLUS</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">include</span></span> <span class="entity">TMONAD_0PLUS</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> update <span class="main">:</span> <span class="main">(</span>'s <span class="main">-&gt;</span> 's<span class="main">)</span> <span class="main">-&gt;</span> 's <span class="main">-&gt;</span> <span class="main">(</span>'s * 's<span class="main">)</span> <span class="entity">Base.monad</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> set    <span class="main">:</span> 's <span class="main">-&gt;</span> 's <span class="main">-&gt;</span> <span class="main">(</span>'s * 's<span class="main">)</span> <span class="entity">Base.monad</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> fetch  <span class="main">:</span> 's <span class="main">-&gt;</span> <span class="main">(</span>'s * 's<span class="main">)</span> <span class="entity">Base.monad</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(* the minimum state monad0plus transformer with update *)</span>
<span class="keyword1"><span class="keyword">functor</span></span> <span class="entity">mk_TState_Monad_0Plus_Min</span> <span class="main">(</span><span class="keyword1"><span class="keyword">structure</span></span> State <span class="main">:</span> <span class="entity">TYP</span><span class="main">;</span> <span class="keyword1"><span class="keyword">structure</span></span> Base <span class="main">:</span> <span class="entity">MONAD_0PLUS_MIN</span><span class="main">)</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>
  <span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">TState_M0p</span> <span class="main">=</span> <span class="entity">mk_state_M0PT</span> <span class="main">(</span><span class="keyword2"><span class="keyword">struct</span></span> <span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Log</span> <span class="main">=</span> <span class="entity">State</span><span class="main">;</span> <span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Base</span> <span class="main">=</span> <span class="entity">Base</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span><span class="main">;</span>
  <span class="keyword3"><span class="keyword">open</span></span> <span class="entity">TState_M0p</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">update</span> <span class="entity">f</span> <span class="main">=</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">state</span> <span class="main">=&gt;</span> <span class="entity">Base.return</span> <span class="main">(</span><span class="entity">state</span><span class="main">,</span> <span class="entity">f</span> <span class="entity">state</span><span class="main">)</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span> <span class="main">:</span> <span class="entity">TSTATE_MONAD_0PLUS_MIN</span><span class="main">;</span>

<span class="comment1">(* the minimum state monad0plus transformer with update *)</span>
<span class="keyword1"><span class="keyword">functor</span></span> <span class="entity">mk_TState_Monad_0Plus</span> <span class="main">(</span><span class="keyword1"><span class="keyword">structure</span></span> State <span class="main">:</span> <span class="entity">TYP</span><span class="main">;</span> <span class="keyword1"><span class="keyword">structure</span></span> Base <span class="main">:</span> <span class="entity">MONAD_0PLUS_MIN</span><span class="main">)</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>
  <span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">TState_M0p_Min</span> <span class="main">=</span> <span class="entity">mk_TState_Monad_0Plus_Min</span> <span class="main">(</span><span class="keyword2"><span class="keyword">struct</span></span> <span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">State</span> <span class="main">=</span> <span class="entity">State</span><span class="main">;</span>
                                                               <span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Base</span> <span class="main">=</span> <span class="entity">Base</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">TState_M0P</span> <span class="main">=</span> <span class="entity">mk_TMonad_0Plus</span> <span class="main">(</span><span class="entity">TState_M0p_Min</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword3"><span class="keyword">open</span></span> <span class="entity">TState_M0P</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">update</span> <span class="main">=</span> <span class="entity">TState_M0p_Min.update</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">set</span> <span class="entity">s</span>   <span class="main">=</span> <span class="entity">update</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">s</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">fetch</span> <span class="entity">s</span> <span class="main">=</span> <span class="entity">update</span> I <span class="entity">s</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span> <span class="main">:</span> <span class="entity">TSTATE_MONAD_0PLUS</span><span class="main">;</span></pre>
</div><div id="files/Monadic_Prover.ML">
<div class="head">
<h1>File ‹Monadic_Prover.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Monadic_Prover.ML
    Author:     Yutaka Nagashima, Data61, CSIRO

The core of PSL. This file provides the skeleton of PSL.
Monadic_Interpreter_Params flesh out this skeleton with concrete evaluation functions.
*)</span>

<span class="comment1">(*** MONADIC_INTERPRETER_CORE: The core of PSL with the core-syntax. ***)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">MONADIC_INTERPRETER_CORE</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">include</span></span> <span class="entity">TMONAD_0PLUS</span>
  <span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">csubtool</span> <span class="main">=</span>  <span class="entity">CQuickcheck</span> <span class="main">|</span> <span class="entity">CNitpick</span> <span class="main">|</span> <span class="entity">CHammer</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">cspecial</span> <span class="main">=</span>  <span class="entity">CIsSolved</span> <span class="main">|</span> <span class="entity">CDefer</span> <span class="main">|</span> <span class="entity">CIntroClasses</span> <span class="main">|</span> <span class="entity">CTransfer</span> <span class="main">|</span> <span class="entity">CNormalization</span>
                     <span class="main">|</span> <span class="entity">CSubgoal</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">cprim_str</span> <span class="main">=</span> <span class="entity">CClarsimp</span> <span class="main">|</span> <span class="entity">CSimp</span> <span class="main">|</span> <span class="entity">CBlast</span> <span class="main">|</span> <span class="entity">CFastforce</span> <span class="main">|</span> <span class="entity">CAuto</span> <span class="main">|</span> <span class="entity">CInduct</span>
                     <span class="main">|</span> <span class="entity">CInductTac</span> <span class="main">|</span> <span class="entity">CCoinduction</span> <span class="main">|</span> <span class="entity">CCases</span> <span class="main">|</span> <span class="entity">CCaseTac</span> <span class="main">|</span> <span class="entity">CRule</span> <span class="main">|</span> <span class="entity">CErule</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">cstatic</span> <span class="main">=</span> <span class="entity">CPrim</span> <span class="keyword2"><span class="keyword">of</span></span> cprim_str <span class="main">|</span> <span class="entity">CSpec</span> <span class="keyword2"><span class="keyword">of</span></span> cspecial <span class="main">|</span> <span class="entity">CSubt</span> <span class="keyword2"><span class="keyword">of</span></span> csubtool <span class="main">|</span> <span class="entity">CUser</span> <span class="keyword2"><span class="keyword">of</span></span> string<span class="main">;</span>
  <span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">catom_str</span> <span class="main">=</span> <span class="entity">CSttc</span> <span class="keyword2"><span class="keyword">of</span></span> cstatic <span class="main">|</span> <span class="entity">CDyn</span> <span class="keyword2"><span class="keyword">of</span></span> cprim_str<span class="main">;</span>
  <span class="comment1">(*CPThen cannot be a part of core_str, as the constructor class does not provide enough information.*)</span>
  <span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">cstrategic</span> <span class="main">=</span> <span class="entity">CSolve1</span> <span class="main">|</span> <span class="entity">CRepeatN</span> <span class="main">|</span> <span class="entity">CCut</span> <span class="keyword2"><span class="keyword">of</span></span> int <span class="main">|</span> <span class="entity">CPSeq</span> <span class="main">|</span> <span class="entity">CPSeq1</span> <span class="main">|</span> <span class="entity">CPOr</span> <span class="main">|</span> <span class="entity">CPAlt</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">core_str</span> <span class="main">=</span>
    <span class="entity">CAtom</span> <span class="keyword2"><span class="keyword">of</span></span> catom_str
  <span class="main">|</span> <span class="entity">CSkip</span>
  <span class="main">|</span> <span class="entity">CFail</span>
  <span class="main">|</span> <span class="entity">COr</span>       <span class="keyword2"><span class="keyword">of</span></span> <span class="main">(</span>core_str * core_str<span class="main">)</span>
  <span class="main">|</span> <span class="entity">CSeq</span>      <span class="keyword2"><span class="keyword">of</span></span> <span class="main">(</span>core_str * core_str<span class="main">)</span>
  <span class="main">|</span> <span class="entity">CAlt</span>      <span class="keyword2"><span class="keyword">of</span></span> <span class="main">(</span>core_str * core_str<span class="main">)</span>
  <span class="main">|</span> <span class="entity">CRepBT</span>    <span class="keyword2"><span class="keyword">of</span></span> core_str
  <span class="main">|</span> <span class="entity">CRepNB</span>    <span class="keyword2"><span class="keyword">of</span></span> core_str
  <span class="main">|</span> <span class="entity">CFails</span>    <span class="keyword2"><span class="keyword">of</span></span> core_str <span class="comment1">(*Fails cannot be defined as just a syntactic sugar as the definition involves goal.*)</span>
  <span class="main">|</span> <span class="entity">CStrategic</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="main">(</span>cstrategic * core_str list<span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">stttac</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">params</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">interpret</span> <span class="main">=</span> 'a <span class="entity">params</span> <span class="main">-&gt;</span> <span class="entity">core_str</span> <span class="main">-&gt;</span> 'a <span class="entity">stttac</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> interpret <span class="main">:</span> 'a <span class="entity">interpret</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(*** mk_Monadic_Interpreter_Core: makes the core of PSL, abstracted to TMONAD_0PLUS. ***)</span>
<span class="keyword1"><span class="keyword">functor</span></span> <span class="entity">mk_Monadic_Interpreter_Core</span> <span class="main">(</span>Mt0p <span class="main">:</span> <span class="entity">TMONAD_0PLUS</span><span class="main">)</span> <span class="main">:</span> <span class="entity">MONADIC_INTERPRETER_CORE</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>
  <span class="keyword3"><span class="keyword">open</span></span> <span class="entity">Mt0p</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">csubtool</span> <span class="main">=</span>  <span class="entity">CQuickcheck</span> <span class="main">|</span> <span class="entity">CNitpick</span> <span class="main">|</span> <span class="entity">CHammer</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">cspecial</span> <span class="main">=</span>  <span class="entity">CIsSolved</span> <span class="main">|</span> <span class="entity">CDefer</span> <span class="main">|</span> <span class="entity">CIntroClasses</span> <span class="main">|</span> <span class="entity">CTransfer</span> <span class="main">|</span> <span class="entity">CNormalization</span>
                     <span class="main">|</span> <span class="entity">CSubgoal</span><span class="main">;</span>
  <span class="comment1">(*default tactics*)</span>
  <span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">cprim_str</span> <span class="main">=</span> <span class="entity">CClarsimp</span> <span class="main">|</span> <span class="entity">CSimp</span> <span class="main">|</span> <span class="entity">CBlast</span> <span class="main">|</span> <span class="entity">CFastforce</span> <span class="main">|</span> <span class="entity">CAuto</span> <span class="main">|</span> <span class="entity">CInduct</span>
                     <span class="main">|</span> <span class="entity">CInductTac</span> <span class="main">|</span> <span class="entity">CCoinduction</span> <span class="main">|</span> <span class="entity">CCases</span> <span class="main">|</span> <span class="entity">CCaseTac</span> <span class="main">|</span> <span class="entity">CRule</span> <span class="main">|</span> <span class="entity">CErule</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">combine</span> <span class="main">=</span> <span class="entity">Unique</span> <span class="main">|</span> <span class="entity">First</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">cstatic</span> <span class="main">=</span> <span class="entity">CPrim</span> <span class="keyword2"><span class="keyword">of</span></span> cprim_str <span class="main">|</span> <span class="entity">CSpec</span> <span class="keyword2"><span class="keyword">of</span></span> cspecial <span class="main">|</span> <span class="entity">CSubt</span> <span class="keyword2"><span class="keyword">of</span></span> csubtool <span class="main">|</span> <span class="entity">CUser</span> <span class="keyword2"><span class="keyword">of</span></span> string<span class="main">;</span>
  <span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">catom_str</span> <span class="main">=</span> <span class="entity">CSttc</span> <span class="keyword2"><span class="keyword">of</span></span> cstatic <span class="main">|</span> <span class="entity">CDyn</span> <span class="keyword2"><span class="keyword">of</span></span> cprim_str<span class="main">;</span>
  <span class="comment1">(*atom_strategic with less-monadic interpretation.*)</span>
  <span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">cstrategic</span> <span class="main">=</span> <span class="entity">CSolve1</span> <span class="main">|</span> <span class="entity">CRepeatN</span> <span class="main">|</span> <span class="entity">CCut</span> <span class="keyword2"><span class="keyword">of</span></span> int <span class="main">|</span> <span class="entity">CPSeq</span> <span class="main">|</span> <span class="entity">CPSeq1</span> <span class="main">|</span> <span class="entity">CPOr</span> <span class="main">|</span> <span class="entity">CPAlt</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">infix</span></span> <span class="inner_numeral">0</span> CSeq CAlt  COr CPAlt<span class="main">;</span>
  <span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">core_str</span> <span class="main">=</span>
    <span class="entity">CAtom</span> <span class="keyword2"><span class="keyword">of</span></span> catom_str
  <span class="main">|</span> <span class="entity">CSkip</span>
  <span class="main">|</span> <span class="entity">CFail</span>
  <span class="main">|</span> <span class="entity">COr</span>       <span class="keyword2"><span class="keyword">of</span></span> <span class="main">(</span>core_str * core_str<span class="main">)</span>
  <span class="main">|</span> <span class="entity">CSeq</span>      <span class="keyword2"><span class="keyword">of</span></span> <span class="main">(</span>core_str * core_str<span class="main">)</span>
  <span class="main">|</span> <span class="entity">CAlt</span>      <span class="keyword2"><span class="keyword">of</span></span> <span class="main">(</span>core_str * core_str<span class="main">)</span>
  <span class="main">|</span> <span class="entity">CRepBT</span>    <span class="keyword2"><span class="keyword">of</span></span> core_str
  <span class="main">|</span> <span class="entity">CRepNB</span>    <span class="keyword2"><span class="keyword">of</span></span> core_str
  <span class="main">|</span> <span class="entity">CFails</span>    <span class="keyword2"><span class="keyword">of</span></span> core_str <span class="comment1">(*I cannot Fails as a syntactic sugar as the definition involves goal.*)</span>
  <span class="main">|</span> <span class="entity">CStrategic</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="main">(</span>cstrategic * core_str list<span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">stttac</span>         <span class="main">=</span> 'a <span class="main">-&gt;</span> 'a <span class="entity">monad</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">eval_prim</span>      <span class="main">=</span> <span class="entity">cstatic</span> <span class="main">-&gt;</span> 'a <span class="entity">stttac</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">eval_para</span>      <span class="main">=</span> <span class="entity">cprim_str</span> <span class="main">-&gt;</span> 'a <span class="main">-&gt;</span> 'a <span class="entity">stttac</span> Seq.seq<span class="main">;</span>
  <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">eval_strategic</span> <span class="main">=</span> <span class="entity">cstrategic</span> * 'a <span class="entity">stttac</span> list <span class="main">-&gt;</span> 'a <span class="entity">stttac</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">equal</span>          <span class="main">=</span> 'a <span class="entity">monad</span> <span class="main">-&gt;</span> 'a <span class="entity">monad</span> <span class="main">-&gt;</span> bool<span class="main">;</span>
  <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">iddfc</span>          <span class="main">=</span> int <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">catom_str</span> <span class="main">-&gt;</span> 'a <span class="entity">stttac</span><span class="main">)</span> <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">catom_str</span> <span class="main">-&gt;</span> 'a <span class="entity">stttac</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">depths</span>            <span class="main">=</span> <span class="main">(</span>int * int<span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">params</span>         <span class="main">=</span> <span class="main">(</span>'a <span class="entity">eval_prim</span> * 'a <span class="entity">eval_para</span> * 'a <span class="entity">eval_strategic</span> * 'a <span class="entity">equal</span> * 'a <span class="entity">iddfc</span> * <span class="entity">depths</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">interpret</span>      <span class="main">=</span> 'a <span class="entity">params</span> <span class="main">-&gt;</span> <span class="entity">core_str</span> <span class="main">-&gt;</span> 'a <span class="entity">stttac</span><span class="main">;</span>

  <span class="comment1">(*Interpret function similar to that of "A Monadic Interpretation of Tactics" by A. Martin et. al.*)</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">interpret</span> <span class="main">(</span><span class="entity">eval_prim</span><span class="main">,</span> <span class="entity">eval_para</span><span class="main">,</span> <span class="entity">eval_strategic</span><span class="main">,</span> <span class="entity">m_equal</span><span class="main">,</span> <span class="entity">iddfc</span><span class="main">,</span> <span class="main">(</span><span class="entity">n_deepenings</span><span class="main">,</span> <span class="entity">n_steps_each</span><span class="main">)</span><span class="main">)</span>
                <span class="main">(</span><span class="entity">strategy</span><span class="main">:</span><span class="entity">core_str</span><span class="main">)</span> <span class="entity">goal</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
       <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_mzero</span> <span class="entity">monad</span>        <span class="main">=</span> <span class="entity">m_equal</span> <span class="entity">monad</span> <span class="entity">mzero</span><span class="main">;</span>
       <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">eval</span> <span class="main">(</span><span class="entity">CSttc</span> <span class="entity">str</span><span class="main">)</span> <span class="entity">goal</span> <span class="main">=</span> <span class="entity">Utils.try_with</span> <span class="entity">mzero</span> <span class="main">(</span><span class="entity">eval_prim</span> <span class="entity">str</span><span class="main">)</span> <span class="entity">goal</span>
         <span class="main">|</span> <span class="entity">eval</span> <span class="main">(</span><span class="entity">CDyn</span> <span class="entity">str</span><span class="main">)</span> <span class="entity">goal</span> <span class="main">=</span>
           <span class="keyword2"><span class="keyword">let</span></span>
             <span class="comment1">(*Should I factor this out to Monadic_Interpreter_Params?*)</span>
             <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">how_to_combine_results</span> <span class="entity">CClarsimp</span>    <span class="main">=</span> <span class="entity">Unique</span>
              <span class="main">|</span>  <span class="entity">how_to_combine_results</span> <span class="entity">CSimp</span>        <span class="main">=</span> <span class="entity">Unique</span>
              <span class="main">|</span>  <span class="entity">how_to_combine_results</span> <span class="entity">CBlast</span>       <span class="main">=</span> <span class="entity">Unique</span>
              <span class="main">|</span>  <span class="entity">how_to_combine_results</span> <span class="entity">CFastforce</span>   <span class="main">=</span> <span class="entity">First</span>
              <span class="main">|</span>  <span class="entity">how_to_combine_results</span> <span class="entity">CAuto</span>        <span class="main">=</span> <span class="entity">Unique</span>
              <span class="main">|</span>  <span class="entity">how_to_combine_results</span> <span class="entity">CInduct</span>      <span class="main">=</span> <span class="entity">Unique</span>
              <span class="main">|</span>  <span class="entity">how_to_combine_results</span> <span class="entity">CInductTac</span>   <span class="main">=</span> <span class="entity">Unique</span>
              <span class="main">|</span>  <span class="entity">how_to_combine_results</span> <span class="entity">CCoinduction</span> <span class="main">=</span> <span class="entity">Unique</span>
              <span class="main">|</span>  <span class="entity">how_to_combine_results</span> <span class="entity">CCases</span>       <span class="main">=</span> <span class="entity">Unique</span>
              <span class="main">|</span>  <span class="entity">how_to_combine_results</span> <span class="entity">CCaseTac</span>     <span class="main">=</span> <span class="entity">Unique</span>
              <span class="main">|</span>  <span class="entity">how_to_combine_results</span> <span class="entity">CRule</span>        <span class="main">=</span> <span class="entity">Unique</span>
              <span class="main">|</span>  <span class="entity">how_to_combine_results</span> <span class="entity">CErule</span>       <span class="main">=</span> <span class="entity">Unique</span><span class="main">;</span>
             <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rm_useless</span> <span class="entity">First</span>  <span class="entity">results</span> <span class="main">=</span>
                 <span class="main">(</span>Seq.filter <span class="main">(</span>not o <span class="entity">is_mzero</span><span class="main">)</span> <span class="entity">results</span> |&gt; Seq.hd <span class="keyword3"><span class="keyword">handle</span></span> Option.Option <span class="main">=&gt;</span> <span class="entity">mzero</span><span class="main">)</span>
              <span class="main">|</span>  <span class="entity">rm_useless</span> <span class="entity">Unique</span> <span class="entity">results</span> <span class="main">=</span>
                 <span class="main">(</span>distinct <span class="main">(</span>uncurry <span class="entity">m_equal</span><span class="main">)</span> <span class="main">(</span>Seq.list_of <span class="entity">results</span><span class="main">)</span>
                  |&gt; Seq.of_list |&gt; <span class="entity">msum</span> <span class="keyword3"><span class="keyword">handle</span></span> Empty <span class="main">=&gt;</span> <span class="entity">mzero</span> <span class="main">|</span> ERROR <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">mzero</span><span class="main">)</span><span class="main">;</span>
             <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">combination</span>          <span class="main">=</span> <span class="entity">how_to_combine_results</span> <span class="entity">str</span><span class="main">;</span>
             <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tactics</span>              <span class="main">=</span> <span class="entity">Seq2.try_seq</span> <span class="main">(</span><span class="entity">eval_para</span> <span class="entity">str</span><span class="main">)</span> <span class="entity">goal</span><span class="main">;</span>
             <span class="comment1">(*Sometimes, Isabelle does not have appropriate rules.*)</span>
             <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tactics_with_handler</span> <span class="main">=</span> Seq.map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">tactic</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">goal</span> <span class="main">=&gt;</span>
                                        <span class="entity">Utils.try_with</span> <span class="entity">mzero</span> <span class="entity">tactic</span> <span class="entity">goal</span><span class="main">)</span> <span class="entity">tactics</span><span class="main">;</span>
             <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_results</span>          <span class="main">=</span> <span class="entity">Seq2.try_seq</span> <span class="main">(</span><span class="entity">Seq2.map_arg</span> <span class="entity">goal</span><span class="main">)</span> <span class="entity">tactics_with_handler</span><span class="main">;</span>
             <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">results</span>              <span class="main">=</span> <span class="entity">rm_useless</span> <span class="entity">combination</span> <span class="entity">all_results</span><span class="main">;</span>
            <span class="keyword2"><span class="keyword">in</span></span>
              <span class="entity">results</span>
            <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">inter_with_limit</span> <span class="entity">limit</span> <span class="main">=</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">inter</span> <span class="main">(</span><span class="entity">CAtom</span> <span class="entity">atom</span><span class="main">)</span> <span class="entity">goal</span>     <span class="main">=</span> <span class="entity">iddfc</span> <span class="entity">limit</span> <span class="entity">eval</span> <span class="entity">atom</span> <span class="entity">goal</span>
            <span class="main">|</span> <span class="entity">inter</span> <span class="entity">CSkip</span>        <span class="entity">goal</span>     <span class="main">=</span> <span class="entity">return</span> <span class="entity">goal</span>
            <span class="main">|</span> <span class="entity">inter</span> <span class="entity">CFail</span>        <span class="main">_</span>        <span class="main">=</span> <span class="entity">mzero</span>
            <span class="main">|</span> <span class="entity">inter</span> <span class="main">(</span><span class="entity">str1</span> <span class="entity">COr</span> <span class="entity">str2</span><span class="main">)</span>  <span class="entity">goal</span> <span class="main">=</span>
              <span class="comment1">(*similar to the implementation of ORELSE*)</span>
              <span class="keyword2"><span class="keyword">let</span></span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">res1</span>   <span class="main">=</span> <span class="entity">inter</span> <span class="entity">str1</span> <span class="entity">goal</span><span class="main">;</span>
                <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">res2</span> <span class="main">_</span> <span class="main">=</span> <span class="entity">inter</span> <span class="entity">str2</span> <span class="entity">goal</span><span class="main">;</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">result</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_mzero</span> <span class="entity">res1</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">res2</span> <span class="main">(</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">res1</span><span class="main">;</span>
              <span class="keyword2"><span class="keyword">in</span></span>
                <span class="entity">result</span>
              <span class="keyword2"><span class="keyword">end</span></span>
            <span class="main">|</span> <span class="entity">inter</span> <span class="main">(</span><span class="entity">str1</span> <span class="entity">CSeq</span> <span class="entity">str2</span><span class="main">)</span> <span class="entity">goal</span>  <span class="main">=</span> <span class="entity">bind</span> <span class="main">(</span><span class="entity">inter</span> <span class="entity">str1</span> <span class="entity">goal</span><span class="main">)</span> <span class="main">(</span><span class="entity">inter</span> <span class="entity">str2</span><span class="main">)</span>
            <span class="main">|</span> <span class="entity">inter</span> <span class="main">(</span><span class="entity">str1</span> <span class="entity">CAlt</span> <span class="entity">str2</span><span class="main">)</span> <span class="entity">goal</span>  <span class="main">=</span> <span class="entity">mplus</span> <span class="main">(</span><span class="entity">inter</span> <span class="entity">str1</span> <span class="entity">goal</span><span class="main">,</span> <span class="entity">inter</span> <span class="entity">str2</span> <span class="entity">goal</span><span class="main">)</span>
            <span class="main">|</span> <span class="entity">inter</span> <span class="main">(</span><span class="entity">CRepBT</span> <span class="entity">str</span><span class="main">)</span> <span class="entity">goal</span> <span class="main">=</span> <span class="comment1">(*idea: CRepBT str = (str CSeq (CRepBT str)) CAlt CSkip*)</span>
              <span class="keyword2"><span class="keyword">let</span></span>
                <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">inter_CRepBT</span> <span class="entity">res0</span> <span class="main">=</span>
                  <span class="keyword2"><span class="keyword">let</span></span>
                    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">res1</span>             <span class="main">=</span> <span class="entity">inter</span> <span class="entity">str</span> <span class="entity">res0</span><span class="main">;</span>
                    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_next</span> <span class="entity">current</span> <span class="main">=</span> <span class="entity">bind</span> <span class="entity">current</span> <span class="entity">inter_CRepBT</span><span class="main">;</span>
                    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">result</span>           <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_mzero</span> <span class="entity">res1</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">return</span> <span class="entity">res0</span> 
                                                            <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">mplus</span> <span class="main">(</span><span class="entity">get_next</span> <span class="entity">res1</span><span class="main">,</span> <span class="entity">return</span> <span class="entity">res0</span><span class="main">)</span>
                  <span class="keyword2"><span class="keyword">in</span></span>
                    <span class="entity">result</span>
                  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
              <span class="keyword2"><span class="keyword">in</span></span>
                <span class="entity">inter_CRepBT</span> <span class="entity">goal</span>
              <span class="keyword2"><span class="keyword">end</span></span>
            <span class="main">|</span> <span class="entity">inter</span> <span class="main">(</span><span class="entity">CRepNB</span> <span class="entity">str</span><span class="main">)</span> <span class="entity">goal</span> <span class="main">=</span> <span class="comment1">(*idea: CRepNB str = (str CSeq (CRepNB str)) COr CSkip*)</span>
              <span class="keyword2"><span class="keyword">let</span></span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">first_failed_result</span> <span class="main">=</span> <span class="entity">inter</span> <span class="entity">str</span> <span class="entity">goal</span><span class="main">;</span>
                <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">inter_CRepNB</span> <span class="entity">res0</span> <span class="main">=</span>
                  <span class="keyword2"><span class="keyword">let</span></span>
                    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">res1</span>             <span class="main">=</span> <span class="entity">inter</span> <span class="entity">str</span> <span class="entity">res0</span><span class="main">;</span>
                    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_next</span> <span class="entity">current</span> <span class="main">=</span> <span class="entity">bind</span> <span class="entity">current</span> <span class="entity">inter_CRepNB</span><span class="main">;</span>
                    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">result</span>           <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_mzero</span> <span class="entity">res1</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">return</span> <span class="entity">res0</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">get_next</span> <span class="entity">res1</span><span class="main">;</span>
                  <span class="keyword2"><span class="keyword">in</span></span>
                    <span class="entity">result</span>
                  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
              <span class="keyword2"><span class="keyword">in</span></span>
                <span class="entity">bind</span> <span class="entity">first_failed_result</span> <span class="entity">inter_CRepNB</span>
              <span class="keyword2"><span class="keyword">end</span></span>
            <span class="comment1">(*Note that it's not possible to treat Rep as a syntactic sugar. Desugaring gets stuck.*)</span>
            <span class="main">|</span> <span class="entity">inter</span> <span class="main">(</span><span class="entity">CFails</span> <span class="entity">str</span><span class="main">)</span> <span class="entity">goal</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_mzero</span> <span class="main">(</span><span class="entity">inter</span> <span class="entity">str</span> <span class="entity">goal</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">return</span> <span class="entity">goal</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">mzero</span>
            <span class="main">|</span> <span class="entity">inter</span> <span class="main">(</span><span class="entity">CStrategic</span> <span class="main">(</span><span class="entity">sttgic</span><span class="main">,</span> <span class="entity">strs</span><span class="main">)</span><span class="main">)</span> <span class="entity">goal</span> <span class="main">=</span> <span class="entity">eval_strategic</span> <span class="main">(</span><span class="entity">sttgic</span><span class="main">,</span> map <span class="entity">inter</span> <span class="entity">strs</span><span class="main">)</span> <span class="entity">goal</span><span class="main">;</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="entity">inter</span> <span class="entity">strategy</span> <span class="entity">goal</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">results'</span> <span class="inner_numeral">0</span> <span class="main">=</span> <span class="entity">mzero</span>
      <span class="main">|</span> <span class="entity">results'</span> <span class="entity">m</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">current_result</span> <span class="main">=</span> <span class="entity">inter_with_limit</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">n_deepenings</span> - <span class="entity">m</span><span class="main">)</span> + <span class="inner_numeral">1</span><span class="main">)</span> * <span class="entity">n_steps_each</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">not_solved</span> <span class="main">=</span> <span class="entity">m_equal</span> <span class="entity">current_result</span> <span class="entity">mzero</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">not_solved</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">results'</span> <span class="main">(</span><span class="entity">m</span> - <span class="inner_numeral">1</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">current_result</span>
          <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">results</span> <span class="main">=</span> <span class="entity">results'</span> <span class="entity">n_deepenings</span>
  <span class="keyword2"><span class="keyword">in</span></span> 
    <span class="entity">results</span>
  <span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(*** Monadic_Interpreter_Core: The core of PSL. ***)</span>
<span class="comment1">(** mk_Monadic_Interpreter_Core_from_Monad_0plus_Min: makes the core of PSL from a monoid and a
 monad with a zero and plus **)</span>
<span class="keyword1"><span class="keyword">functor</span></span> <span class="entity">mk_Monadic_Interpreter_Core_from_Monad_0plus_Min</span>
 <span class="main">(</span><span class="keyword1"><span class="keyword">structure</span></span> Log <span class="main">:</span> <span class="entity">MONOID</span><span class="main">;</span> <span class="keyword1"><span class="keyword">structure</span></span> M0P_Min <span class="main">:</span> <span class="entity">MONAD_0PLUS_MIN</span><span class="main">)</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">MT0Plus</span> <span class="main">=</span> <span class="entity">mk_state_M0PT</span><span class="main">(</span><span class="keyword2"><span class="keyword">struct</span></span> <span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Log</span> <span class="main">=</span> <span class="entity">Log</span><span class="main">;</span> <span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Base</span> <span class="main">=</span> <span class="entity">M0P_Min</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Monadic_Interpreter</span> <span class="main">=</span> <span class="entity">mk_Monadic_Interpreter_Core</span><span class="main">(</span><span class="entity">MT0Plus</span><span class="main">)</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">in</span></span>
  <span class="entity">Monadic_Interpreter</span> <span class="main">:</span> <span class="entity">MONADIC_INTERPRETER_CORE</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(** Log_Min and Log: The "state" of PSL, which is used to produce efficient proof scripts. **)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Log_Min</span> <span class="main">:</span> <span class="entity">MONOID_MIN</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">monoid_min</span> <span class="main">=</span> <span class="entity">Dynamic_Utils.log</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mempty</span> <span class="main">=</span> <span class="main">[</span><span class="main">]</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mappend</span> <span class="entity">src1</span> <span class="entity">src2</span> <span class="main">=</span> <span class="entity">src1</span> @ <span class="entity">src2</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Log</span> <span class="main">=</span> <span class="entity">mk_Monoid</span> <span class="main">(</span>Log_Min<span class="main">)</span> <span class="main">:</span> <span class="entity">MONOID</span><span class="main">;</span>

<span class="comment1">(** Monadic_Interpreter_Core: The core of PSL. **)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Monadic_Interpreter_Core</span> <span class="main">:</span> <span class="entity">MONADIC_INTERPRETER_CORE</span> <span class="main">=</span>
 <span class="entity">mk_Monadic_Interpreter_Core_from_Monad_0plus_Min</span>
 <span class="main">(</span><span class="keyword2"><span class="keyword">struct</span></span> <span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Log</span> <span class="main">=</span> Log<span class="main">;</span> <span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">M0P_Min</span> <span class="main">=</span> Seq_M0P_Min <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span><span class="main">;</span>

<span class="comment1">(*** MONADIC_INTERPRETER: The surface-syntax of PSL with de-sugaring. ***)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">MONADIC_INTERPRETER</span> <span class="main">=</span>

<span class="keyword2"><span class="keyword">sig</span></span>

<span class="comment1">(* str *)</span>
<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">str</span> <span class="main">=</span>
<span class="comment1">(*prim_str*)</span>
  <span class="entity">Clarsimp</span>
<span class="main">|</span> <span class="entity">Simp</span>
<span class="main">|</span> <span class="entity">Blast</span>
<span class="main">|</span> <span class="entity">Fastforce</span>
<span class="main">|</span> <span class="entity">Auto</span>
<span class="main">|</span> <span class="entity">Induct</span>
<span class="main">|</span> <span class="entity">InductTac</span>
<span class="main">|</span> <span class="entity">Coinduction</span>
<span class="main">|</span> <span class="entity">Cases</span>
<span class="main">|</span> <span class="entity">CaseTac</span>
<span class="main">|</span> <span class="entity">Rule</span>
<span class="main">|</span> <span class="entity">Erule</span>
<span class="comment1">(*diagnostic command*)</span>
<span class="main">|</span> <span class="entity">Hammer</span>
<span class="comment1">(*assertion strategy / diagnostic command*)</span>
<span class="main">|</span> <span class="entity">IsSolved</span>
<span class="main">|</span> <span class="entity">Quickcheck</span>
<span class="main">|</span> <span class="entity">Nitpick</span>
<span class="comment1">(*special purpose*)</span>
<span class="main">|</span> <span class="entity">Defer</span>
<span class="main">|</span> <span class="entity">Subgoal</span>
<span class="main">|</span> <span class="entity">IntroClasses</span>
<span class="main">|</span> <span class="entity">Transfer</span>
<span class="main">|</span> <span class="entity">Normalization</span>
<span class="main">|</span> <span class="entity">User</span> <span class="keyword2"><span class="keyword">of</span></span> string
<span class="comment1">(*para_str*)</span>
<span class="main">|</span> <span class="entity">ParaClarsimp</span>
<span class="main">|</span> <span class="entity">ParaSimp</span>
<span class="main">|</span> <span class="entity">ParaBlast</span>
<span class="main">|</span> <span class="entity">ParaFastforce</span>
<span class="main">|</span> <span class="entity">ParaAuto</span>
<span class="main">|</span> <span class="entity">ParaInduct</span>
<span class="main">|</span> <span class="entity">ParaInductTac</span>
<span class="main">|</span> <span class="entity">ParaCoinduction</span>
<span class="main">|</span> <span class="entity">ParaCases</span>
<span class="main">|</span> <span class="entity">ParaCaseTac</span>
<span class="main">|</span> <span class="entity">ParaRule</span>
<span class="main">|</span> <span class="entity">ParaErule</span>
<span class="comment1">(*monadic strategic*)</span>
<span class="main">|</span> <span class="entity">Skip</span>
<span class="main">|</span> <span class="entity">Fail</span>
<span class="main">|</span> <span class="entity">Seq</span> <span class="keyword2"><span class="keyword">of</span></span> str Seq.seq
<span class="main">|</span> <span class="entity">Alt</span> <span class="keyword2"><span class="keyword">of</span></span> str Seq.seq
<span class="comment1">(*non-monadic strategics that have dedicated clauses in "inter".*)</span>
<span class="main">|</span> <span class="entity">RepBT</span> <span class="keyword2"><span class="keyword">of</span></span> str
<span class="main">|</span> <span class="entity">RepNB</span> <span class="keyword2"><span class="keyword">of</span></span> str
<span class="main">|</span> <span class="entity">Fails</span> <span class="keyword2"><span class="keyword">of</span></span> str
<span class="comment1">(*non-monadic strategics that are syntactic sugar.*)</span>
<span class="main">|</span> <span class="entity">Or</span> <span class="keyword2"><span class="keyword">of</span></span> str Seq.seq
<span class="main">|</span> <span class="entity">Try</span> <span class="keyword2"><span class="keyword">of</span></span> str
<span class="comment1">(*non-monadic strategics that are handled by "eval_strategic".*)</span>
<span class="main">|</span> <span class="entity">Solve1</span> <span class="keyword2"><span class="keyword">of</span></span> str
<span class="main">|</span> <span class="entity">RepNT</span>  <span class="keyword2"><span class="keyword">of</span></span> str
<span class="main">|</span> <span class="entity">Cut</span>    <span class="keyword2"><span class="keyword">of</span></span> <span class="main">(</span>int * str<span class="main">)</span>
<span class="main">|</span> <span class="entity">PSeq</span>   <span class="keyword2"><span class="keyword">of</span></span> str Seq.seq
<span class="main">|</span> <span class="entity">PSeq1</span>  <span class="keyword2"><span class="keyword">of</span></span> str Seq.seq
<span class="main">|</span> <span class="entity">POr</span>    <span class="keyword2"><span class="keyword">of</span></span> str Seq.seq
<span class="main">|</span> <span class="entity">PAlt</span>   <span class="keyword2"><span class="keyword">of</span></span> str Seq.seq<span class="main">;</span>

<span class="comment1">(* desugar *)</span>
<span class="keyword1"><span class="keyword">val</span></span> desugar <span class="main">:</span> <span class="entity">str</span> <span class="main">-&gt;</span> <span class="entity">Monadic_Interpreter_Core.core_str</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(*** Monadic_Interpreter: The surface-syntax of PSL with de-sugaring. ***)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Monadic_Interpreter</span> <span class="main">:</span> <span class="entity">MONADIC_INTERPRETER</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword3"><span class="keyword">open</span></span> Monadic_Interpreter_Core<span class="main">;</span>

<span class="comment1">(* str *)</span>
<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">str</span> <span class="main">=</span>
<span class="comment1">(*prim_str*)</span>
  <span class="entity">Clarsimp</span>
<span class="main">|</span> <span class="entity">Simp</span>
<span class="main">|</span> <span class="entity">Blast</span>
<span class="main">|</span> <span class="entity">Fastforce</span>
<span class="main">|</span> <span class="entity">Auto</span>
<span class="main">|</span> <span class="entity">Induct</span>
<span class="main">|</span> <span class="entity">InductTac</span>
<span class="main">|</span> <span class="entity">Coinduction</span>
<span class="main">|</span> <span class="entity">Cases</span>
<span class="main">|</span> <span class="entity">CaseTac</span>
<span class="main">|</span> <span class="entity">Rule</span>
<span class="main">|</span> <span class="entity">Erule</span>
<span class="comment1">(*diagnostic command*)</span>
<span class="main">|</span> <span class="entity">Hammer</span>
<span class="comment1">(*assertion strategy / diagnostic command*)</span>
<span class="main">|</span> <span class="entity">IsSolved</span>
<span class="main">|</span> <span class="entity">Quickcheck</span>
<span class="main">|</span> <span class="entity">Nitpick</span>
<span class="comment1">(*special purpose*)</span>
<span class="main">|</span> <span class="entity">Defer</span>
<span class="main">|</span> <span class="entity">Subgoal</span>
<span class="main">|</span> <span class="entity">IntroClasses</span>
<span class="main">|</span> <span class="entity">Transfer</span>
<span class="main">|</span> <span class="entity">Normalization</span>
<span class="main">|</span> <span class="entity">User</span> <span class="keyword2"><span class="keyword">of</span></span> string
<span class="comment1">(*para_str*)</span>
<span class="main">|</span> <span class="entity">ParaClarsimp</span>
<span class="main">|</span> <span class="entity">ParaSimp</span>
<span class="main">|</span> <span class="entity">ParaBlast</span>
<span class="main">|</span> <span class="entity">ParaFastforce</span>
<span class="main">|</span> <span class="entity">ParaAuto</span>
<span class="main">|</span> <span class="entity">ParaInduct</span>
<span class="main">|</span> <span class="entity">ParaInductTac</span>
<span class="main">|</span> <span class="entity">ParaCoinduction</span>
<span class="main">|</span> <span class="entity">ParaCases</span>
<span class="main">|</span> <span class="entity">ParaCaseTac</span>
<span class="main">|</span> <span class="entity">ParaRule</span>
<span class="main">|</span> <span class="entity">ParaErule</span>
<span class="comment1">(*monadic strategic*)</span>
<span class="main">|</span> <span class="entity">Skip</span>
<span class="main">|</span> <span class="entity">Fail</span>
<span class="main">|</span> <span class="entity">Seq</span> <span class="keyword2"><span class="keyword">of</span></span> str Seq.seq
<span class="main">|</span> <span class="entity">Alt</span> <span class="keyword2"><span class="keyword">of</span></span> str Seq.seq
<span class="comment1">(*non-monadic strategics that have dedicated clauses in "inter".*)</span>
<span class="main">|</span> <span class="entity">RepBT</span> <span class="keyword2"><span class="keyword">of</span></span> str
<span class="main">|</span> <span class="entity">RepNB</span> <span class="keyword2"><span class="keyword">of</span></span> str
<span class="main">|</span> <span class="entity">Fails</span> <span class="keyword2"><span class="keyword">of</span></span> str
<span class="comment1">(*non-monadic strategics that are syntactic sugar.*)</span>
<span class="main">|</span> <span class="entity">Or</span> <span class="keyword2"><span class="keyword">of</span></span> str Seq.seq
<span class="main">|</span> <span class="entity">Try</span> <span class="keyword2"><span class="keyword">of</span></span> str
<span class="comment1">(*non-monadic strategics that are handled by "eval_strategic".*)</span>
<span class="main">|</span> <span class="entity">Solve1</span> <span class="keyword2"><span class="keyword">of</span></span> str
<span class="main">|</span> <span class="entity">RepNT</span>  <span class="keyword2"><span class="keyword">of</span></span> str
<span class="main">|</span> <span class="entity">Cut</span>    <span class="keyword2"><span class="keyword">of</span></span> <span class="main">(</span>int * str<span class="main">)</span>
<span class="main">|</span> <span class="entity">PSeq</span>   <span class="keyword2"><span class="keyword">of</span></span> str Seq.seq
<span class="main">|</span> <span class="entity">PSeq1</span>  <span class="keyword2"><span class="keyword">of</span></span> str Seq.seq
<span class="main">|</span> <span class="entity">POr</span>    <span class="keyword2"><span class="keyword">of</span></span> str Seq.seq
<span class="main">|</span> <span class="entity">PAlt</span>   <span class="keyword2"><span class="keyword">of</span></span> str Seq.seq<span class="main">;</span>

<span class="keyword1"><span class="keyword">infix</span></span> <span class="inner_numeral">0</span> CSeq CAlt  COr<span class="main">;</span>

<span class="keyword2"><span class="keyword">local</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prim</span> <span class="main">=</span> <span class="entity">CAtom</span> o <span class="entity">CSttc</span> o <span class="entity">CPrim</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dyna</span> <span class="main">=</span> <span class="entity">CAtom</span> o <span class="entity">CDyn</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">subt</span> <span class="main">=</span> <span class="entity">CAtom</span> o <span class="entity">CSttc</span> o <span class="entity">CSubt</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">spec</span> <span class="main">=</span> <span class="entity">CAtom</span> o <span class="entity">CSttc</span> o <span class="entity">CSpec</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">user</span> <span class="main">=</span> <span class="entity">CAtom</span> o <span class="entity">CSttc</span> o <span class="entity">CUser</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">in</span></span>

<span class="comment1">(* desugar *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">desugar</span> <span class="entity">Clarsimp</span>        <span class="main">=</span> <span class="entity">prim</span> <span class="entity">CClarsimp</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="entity">Blast</span>           <span class="main">=</span> <span class="entity">prim</span> <span class="entity">CBlast</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="entity">Fastforce</span>       <span class="main">=</span> <span class="entity">prim</span> <span class="entity">CFastforce</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="entity">Simp</span>            <span class="main">=</span> <span class="entity">prim</span> <span class="entity">CSimp</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="entity">Auto</span>            <span class="main">=</span> <span class="entity">prim</span> <span class="entity">CAuto</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="entity">Induct</span>          <span class="main">=</span> <span class="entity">prim</span> <span class="entity">CInduct</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="entity">InductTac</span>       <span class="main">=</span> <span class="entity">prim</span> <span class="entity">CInductTac</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="entity">Coinduction</span>     <span class="main">=</span> <span class="entity">prim</span> <span class="entity">CCoinduction</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="entity">Cases</span>           <span class="main">=</span> <span class="entity">prim</span> <span class="entity">CCases</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="entity">CaseTac</span>         <span class="main">=</span> <span class="entity">prim</span> <span class="entity">CCaseTac</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="entity">Rule</span>            <span class="main">=</span> <span class="entity">prim</span> <span class="entity">CRule</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="entity">Erule</span>           <span class="main">=</span> <span class="entity">prim</span> <span class="entity">CErule</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="entity">Hammer</span>          <span class="main">=</span> <span class="entity">subt</span> <span class="entity">CHammer</span>
    <span class="comment1">(*assertion strategy*)</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="entity">IsSolved</span>        <span class="main">=</span> <span class="entity">spec</span> <span class="entity">CIsSolved</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="entity">Quickcheck</span>      <span class="main">=</span> <span class="entity">subt</span> <span class="entity">CQuickcheck</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="entity">Nitpick</span>         <span class="main">=</span> <span class="entity">subt</span> <span class="entity">CNitpick</span>
    <span class="comment1">(*special purpose*)</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="entity">Defer</span>           <span class="main">=</span> <span class="entity">spec</span> <span class="entity">CDefer</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="entity">Subgoal</span>         <span class="main">=</span> <span class="entity">spec</span> <span class="entity">CSubgoal</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="entity">IntroClasses</span>    <span class="main">=</span> <span class="entity">spec</span> <span class="entity">CIntroClasses</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="entity">Transfer</span>        <span class="main">=</span> <span class="entity">spec</span> <span class="entity">CTransfer</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="entity">Normalization</span>   <span class="main">=</span> <span class="entity">spec</span> <span class="entity">CNormalization</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="main">(</span><span class="entity">User</span> <span class="entity">tac_name</span><span class="main">)</span> <span class="main">=</span> <span class="entity">user</span> <span class="entity">tac_name</span>
    <span class="comment1">(*para_str*)</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="entity">ParaSimp</span>        <span class="main">=</span> <span class="entity">dyna</span> <span class="entity">CSimp</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="entity">ParaBlast</span>       <span class="main">=</span> <span class="entity">dyna</span> <span class="entity">CBlast</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="entity">ParaClarsimp</span>    <span class="main">=</span> <span class="entity">dyna</span> <span class="entity">CClarsimp</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="entity">ParaFastforce</span>   <span class="main">=</span> <span class="entity">dyna</span> <span class="entity">CFastforce</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="entity">ParaAuto</span>        <span class="main">=</span> <span class="entity">dyna</span> <span class="entity">CAuto</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="entity">ParaInduct</span>      <span class="main">=</span> <span class="entity">dyna</span> <span class="entity">CInduct</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="entity">ParaInductTac</span>   <span class="main">=</span> <span class="entity">dyna</span> <span class="entity">CInductTac</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="entity">ParaCoinduction</span> <span class="main">=</span> <span class="entity">dyna</span> <span class="entity">CCoinduction</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="entity">ParaCases</span>       <span class="main">=</span> <span class="entity">dyna</span> <span class="entity">CCases</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="entity">ParaCaseTac</span>     <span class="main">=</span> <span class="entity">dyna</span> <span class="entity">CCaseTac</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="entity">ParaRule</span>        <span class="main">=</span> <span class="entity">dyna</span> <span class="entity">CRule</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="entity">ParaErule</span>       <span class="main">=</span> <span class="entity">dyna</span> <span class="entity">CErule</span>
    <span class="comment1">(*monadic strategic*)</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="entity">Skip</span>            <span class="main">=</span> <span class="entity">CSkip</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="entity">Fail</span>            <span class="main">=</span> <span class="entity">CFail</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="main">(</span><span class="entity">Seq</span> <span class="entity">strs1</span><span class="main">)</span>     <span class="main">=</span> <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> Seq.pull <span class="entity">strs1</span> <span class="keyword2"><span class="keyword">of</span></span>
     NONE               <span class="main">=&gt;</span> error <span class="inner_quoted">"Seq needs at least one arguement."</span>
   <span class="main">|</span> SOME <span class="main">(</span><span class="entity">str1</span><span class="main">,</span> <span class="entity">strs2</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">case</span></span> Seq.pull <span class="entity">strs2</span> <span class="keyword2"><span class="keyword">of</span></span>
       NONE   <span class="main">=&gt;</span> <span class="entity">desugar</span> <span class="entity">str1</span>
     <span class="main">|</span> SOME <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">desugar</span> <span class="entity">str1</span> <span class="entity">CSeq</span> <span class="main">(</span><span class="entity">desugar</span> <span class="main">(</span><span class="entity">Seq</span> <span class="entity">strs2</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="main">(</span><span class="entity">Alt</span> <span class="entity">strs1</span><span class="main">)</span>     <span class="main">=</span> <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> Seq.pull <span class="entity">strs1</span> <span class="keyword2"><span class="keyword">of</span></span>
     NONE               <span class="main">=&gt;</span> error <span class="inner_quoted">"Alt needs at least one arguement."</span>
   <span class="main">|</span> SOME <span class="main">(</span><span class="entity">str1</span><span class="main">,</span> <span class="entity">strs2</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">case</span></span> Seq.pull <span class="entity">strs2</span> <span class="keyword2"><span class="keyword">of</span></span>
       NONE   <span class="main">=&gt;</span> <span class="entity">desugar</span> <span class="entity">str1</span>
     <span class="main">|</span> SOME <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">desugar</span> <span class="entity">str1</span> <span class="entity">CAlt</span> <span class="main">(</span><span class="entity">desugar</span> <span class="main">(</span><span class="entity">Alt</span> <span class="entity">strs2</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="comment1">(*non-monadic strategics that have dedicated clauses in "inter".*)</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="main">(</span><span class="entity">RepBT</span> <span class="entity">str</span><span class="main">)</span>     <span class="main">=</span> <span class="entity">CRepBT</span> <span class="main">(</span><span class="entity">desugar</span> <span class="entity">str</span><span class="main">)</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="main">(</span><span class="entity">RepNB</span> <span class="entity">str</span><span class="main">)</span>     <span class="main">=</span> <span class="entity">CRepNB</span> <span class="main">(</span><span class="entity">desugar</span> <span class="entity">str</span><span class="main">)</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="main">(</span><span class="entity">Fails</span> <span class="entity">str</span><span class="main">)</span>     <span class="main">=</span> <span class="entity">CFails</span> <span class="main">(</span><span class="entity">desugar</span> <span class="entity">str</span><span class="main">)</span>
    <span class="comment1">(*non-monadic strategics that are syntactic sugar.*)</span>
    <span class="comment1">(*desugar (str1 Or str2) = desugar (str1 Alt (Fails str1 Seq str2)) is very inefficient.*)</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="main">(</span><span class="entity">Or</span> <span class="entity">strs1</span><span class="main">)</span>      <span class="main">=</span> <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> Seq.pull <span class="entity">strs1</span> <span class="keyword2"><span class="keyword">of</span></span>
     NONE               <span class="main">=&gt;</span> error <span class="inner_quoted">"Alt needs at least one arguement."</span>
   <span class="main">|</span> SOME <span class="main">(</span><span class="entity">str1</span><span class="main">,</span> <span class="entity">strs2</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">case</span></span> Seq.pull <span class="entity">strs2</span> <span class="keyword2"><span class="keyword">of</span></span>
       NONE   <span class="main">=&gt;</span> <span class="entity">desugar</span> <span class="entity">str1</span>
     <span class="main">|</span> SOME <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">desugar</span> <span class="entity">str1</span> <span class="entity">COr</span> <span class="main">(</span><span class="entity">desugar</span> <span class="main">(</span><span class="entity">Or</span> <span class="entity">strs2</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="comment1">(*desugar (Try str) = desugar (str Or Skip) is very inefficient.*)</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="main">(</span><span class="entity">Try</span> <span class="entity">str</span><span class="main">)</span>       <span class="main">=</span> <span class="entity">desugar</span> <span class="entity">str</span> <span class="entity">COr</span> <span class="entity">CSkip</span>
    <span class="comment1">(*non-monadic strategics that are handled by "eval_strategic".*)</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="main">(</span><span class="entity">Solve1</span> <span class="entity">str</span><span class="main">)</span>    <span class="main">=</span> <span class="entity">CStrategic</span> <span class="main">(</span><span class="entity">CSolve1</span><span class="main">,</span> <span class="main">[</span><span class="entity">desugar</span> <span class="entity">str</span><span class="main">]</span><span class="main">)</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="main">(</span><span class="entity">RepNT</span> <span class="entity">str</span><span class="main">)</span>     <span class="main">=</span> <span class="entity">CStrategic</span> <span class="main">(</span><span class="entity">CRepeatN</span><span class="main">,</span> <span class="main">[</span><span class="entity">desugar</span> <span class="entity">str</span><span class="main">]</span><span class="main">)</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="main">(</span><span class="entity">Cut</span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span> <span class="entity">str</span><span class="main">)</span><span class="main">)</span>  <span class="main">=</span> <span class="entity">CStrategic</span> <span class="main">(</span><span class="entity">CCut</span> <span class="entity">i</span><span class="main">,</span> <span class="main">[</span><span class="entity">desugar</span> <span class="entity">str</span><span class="main">]</span><span class="main">)</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="main">(</span><span class="entity">PSeq</span> <span class="entity">strs</span><span class="main">)</span>     <span class="main">=</span> <span class="entity">CStrategic</span> <span class="main">(</span><span class="entity">CPSeq</span><span class="main">,</span> <span class="main">(</span>Seq.map <span class="entity">desugar</span> <span class="entity">strs</span> |&gt; Seq.list_of<span class="main">)</span><span class="main">)</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="main">(</span><span class="entity">PSeq1</span> <span class="entity">strs</span><span class="main">)</span>    <span class="main">=</span> <span class="entity">CStrategic</span> <span class="main">(</span><span class="entity">CPSeq1</span><span class="main">,</span><span class="main">(</span>Seq.map <span class="entity">desugar</span> <span class="entity">strs</span> |&gt; Seq.list_of<span class="main">)</span><span class="main">)</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="main">(</span><span class="entity">POr</span>   <span class="entity">strs</span><span class="main">)</span>    <span class="main">=</span> <span class="entity">CStrategic</span> <span class="main">(</span><span class="entity">CPOr</span><span class="main">,</span>  <span class="main">(</span>Seq.map <span class="entity">desugar</span> <span class="entity">strs</span> |&gt; Seq.list_of<span class="main">)</span><span class="main">)</span>
 <span class="main">|</span>  <span class="entity">desugar</span> <span class="main">(</span><span class="entity">PAlt</span>  <span class="entity">strs</span><span class="main">)</span>    <span class="main">=</span> <span class="entity">CStrategic</span> <span class="main">(</span><span class="entity">CPAlt</span><span class="main">,</span> <span class="main">(</span>Seq.map <span class="entity">desugar</span> <span class="entity">strs</span> |&gt; Seq.list_of<span class="main">)</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(*** MONADIC_INTERPRETER_PARAMS: fleshes out MONADIC_INTERPRETER with evaluation functions. ***)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">MONADIC_INTERPRETER_PARAMS</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">eval_prim</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">eval_para</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">eval_strategic</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">m_equal</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">iddfc</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> eval_prim      <span class="main">:</span> <span class="entity">eval_prim</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> eval_para      <span class="main">:</span> <span class="entity">eval_para</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> eval_strategic <span class="main">:</span> <span class="entity">eval_strategic</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> m_equal        <span class="main">:</span> <span class="entity">m_equal</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> iddfc          <span class="main">:</span> <span class="entity">iddfc</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(*** Monadic_Interpreter_Params: fleshes out Monadic_Interpreter with evaluation functions. ***)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Monadic_Interpreter_Params</span> <span class="main">:</span> <span class="entity">MONADIC_INTERPRETER_PARAMS</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">MIC</span> <span class="main">=</span> Monadic_Interpreter_Core<span class="main">;</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">DU</span>         <span class="main">=</span> Dynamic_Utils<span class="main">;</span>
<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">state</span>           <span class="main">=</span> <span class="entity">Proof.state</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">seq</span>          <span class="main">=</span> 'a Seq.seq<span class="main">;</span>
<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">ctxt</span>            <span class="main">=</span> <span class="entity">Proof.context</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">thms</span>            <span class="main">=</span> thm list<span class="main">;</span>
<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">strings</span>         <span class="main">=</span> string list<span class="main">;</span>
<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">eval_prim</span>       <span class="main">=</span> <span class="entity">MIC.cstatic</span> <span class="main">-&gt;</span> <span class="entity">state</span> <span class="entity">MIC.stttac</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">eval_para</span>       <span class="main">=</span> <span class="entity">MIC.cprim_str</span> <span class="main">-&gt;</span> <span class="entity">state</span> <span class="main">-&gt;</span> <span class="entity">state</span> <span class="entity">MIC.stttac</span> Seq.seq<span class="main">;</span>
<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">eval_strategic</span>  <span class="main">=</span> <span class="entity">MIC.cstrategic</span> * <span class="entity">state</span> <span class="entity">MIC.stttac</span> list <span class="main">-&gt;</span> <span class="entity">state</span> <span class="entity">MIC.stttac</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">m_equal</span>         <span class="main">=</span> <span class="entity">state</span> <span class="entity">MIC.monad</span> <span class="main">-&gt;</span> <span class="entity">state</span> <span class="entity">MIC.monad</span> <span class="main">-&gt;</span> bool<span class="main">;</span>
<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">iddfc</span>           <span class="main">=</span> int <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">MIC.catom_str</span> <span class="main">-&gt;</span> <span class="entity">state</span> <span class="entity">MIC.stttac</span><span class="main">)</span> <span class="main">-&gt;</span> <span class="entity">MIC.catom_str</span> <span class="main">-&gt;</span> <span class="entity">state</span> <span class="entity">MIC.stttac</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">log</span>             <span class="main">=</span> <span class="entity">Dynamic_Utils.log</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">monad</span>           <span class="main">=</span> <span class="entity">state</span> <span class="entity">Dynamic_Utils.st_monad</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">monad_tac</span>       <span class="main">=</span> <span class="entity">state</span> <span class="entity">Dynamic_Utils.stttac</span><span class="main">;</span>
<span class="comment1">(*do_trace and show_trace are for debugging only.*)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">do_trace</span>         <span class="main">=</span> false<span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">show_trace</span> <span class="entity">text</span>  <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">do_trace</span> <span class="keyword2"><span class="keyword">then</span></span> tracing <span class="entity">text</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="main">)</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">local</span></span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">User_Seed</span> <span class="main">:</span> <span class="entity">DYNAMIC_TACTIC_GENERATOR_SEED</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">modifier</span>           <span class="main">=</span> string<span class="main">;</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">modifiers</span>          <span class="main">=</span> string list<span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_all_modifiers</span> <span class="main">_</span> <span class="main">=</span> <span class="main">[</span><span class="main">]</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mods_to_string</span> <span class="entity">mods</span> <span class="main">=</span> String.concatWith <span class="inner_quoted">" "</span> <span class="entity">mods</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">reordered_mods</span>      <span class="main">=</span> single o I<span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">User_Tactic_Generator</span> <span class="main">:</span> <span class="entity">DYNAMIC_TACTIC_GENERATOR</span> <span class="main">=</span>
  <span class="entity">mk_Dynamic_Tactic_Generator</span> <span class="main">(</span><span class="entity">User_Seed</span><span class="main">)</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">in</span></span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">user_stttac</span> <span class="main">(</span><span class="entity">meth</span><span class="main">:</span>string<span class="main">)</span> <span class="main">=</span>
  <span class="entity">User_Tactic_Generator.meth_name_n_modifiers_to_stttac_on_state</span> <span class="entity">meth</span> <span class="main">[</span><span class="comment1">(* ignores log *)</span><span class="main">]</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(* eval_prim *)</span>
<span class="comment1">(*I cannot move the definition of "eval_prim" into mk_Monadic_Interpreter,
  because its type signature is too specific.*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">eval_prim</span> <span class="main">(</span><span class="entity">prim</span><span class="main">:</span><span class="entity">MIC.cstatic</span><span class="main">)</span> <span class="main">(</span><span class="entity">goal_state</span><span class="main">:</span><span class="entity">state</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="comment1">(*For eval_prim.*)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">string_to_stttac</span> <span class="main">=</span> <span class="entity">Dynamic_Utils.string_to_stttac_on_pstate</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tac_on_proof_state</span> <span class="main">:</span> <span class="entity">state</span> <span class="entity">MIC.stttac</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">prim</span> <span class="keyword2"><span class="keyword">of</span></span>
      <span class="entity">MIC.CPrim</span> <span class="entity">MIC.CClarsimp</span> <span class="main">=&gt;</span>     <span class="main">(</span><span class="entity">show_trace</span> <span class="inner_quoted">"CClarsimp"</span><span class="main">;</span>      <span class="entity">string_to_stttac</span> <span class="inner_quoted">"clarsimp"</span><span class="main">)</span>
    <span class="main">|</span> <span class="entity">MIC.CPrim</span> <span class="entity">MIC.CSimp</span> <span class="main">=&gt;</span>         <span class="main">(</span><span class="entity">show_trace</span> <span class="inner_quoted">"CSimp"</span><span class="main">;</span>          <span class="entity">string_to_stttac</span> <span class="inner_quoted">"simp"</span><span class="main">)</span>
    <span class="main">|</span> <span class="entity">MIC.CPrim</span> <span class="entity">MIC.CBlast</span> <span class="main">=&gt;</span>        <span class="main">(</span><span class="entity">show_trace</span> <span class="inner_quoted">"CBlast"</span><span class="main">;</span>         <span class="entity">string_to_stttac</span> <span class="inner_quoted">"blast"</span><span class="main">)</span>
    <span class="main">|</span> <span class="entity">MIC.CPrim</span> <span class="entity">MIC.CFastforce</span> <span class="main">=&gt;</span>    <span class="main">(</span><span class="entity">show_trace</span> <span class="inner_quoted">"CFastforce"</span><span class="main">;</span>     <span class="entity">string_to_stttac</span> <span class="inner_quoted">"fastforce"</span><span class="main">)</span>
    <span class="main">|</span> <span class="entity">MIC.CPrim</span> <span class="entity">MIC.CAuto</span> <span class="main">=&gt;</span>         <span class="main">(</span><span class="entity">show_trace</span> <span class="inner_quoted">"CAuto"</span><span class="main">;</span>          <span class="entity">string_to_stttac</span> <span class="inner_quoted">"auto"</span><span class="main">)</span>
    <span class="main">|</span> <span class="entity">MIC.CPrim</span> <span class="entity">MIC.CInduct</span> <span class="main">=&gt;</span>       <span class="main">(</span><span class="entity">show_trace</span> <span class="inner_quoted">"CInduct"</span><span class="main">;</span>        <span class="entity">string_to_stttac</span> <span class="inner_quoted">"induct"</span><span class="main">)</span>
    <span class="main">|</span> <span class="entity">MIC.CPrim</span> <span class="entity">MIC.CInductTac</span> <span class="main">=&gt;</span>    <span class="main">(</span><span class="entity">show_trace</span> <span class="inner_quoted">"CInductTac"</span><span class="main">;</span>     <span class="entity">string_to_stttac</span> <span class="inner_quoted">"induct_tac"</span><span class="main">)</span>
    <span class="main">|</span> <span class="entity">MIC.CPrim</span> <span class="entity">MIC.CCoinduction</span> <span class="main">=&gt;</span>  <span class="main">(</span><span class="entity">show_trace</span> <span class="inner_quoted">"CCoinduct"</span><span class="main">;</span>      <span class="entity">string_to_stttac</span> <span class="inner_quoted">"coinduction"</span><span class="main">)</span>
    <span class="main">|</span> <span class="entity">MIC.CPrim</span> <span class="entity">MIC.CCases</span>  <span class="main">=&gt;</span>       <span class="main">(</span><span class="entity">show_trace</span> <span class="inner_quoted">"CCases"</span><span class="main">;</span>         <span class="entity">string_to_stttac</span> <span class="inner_quoted">"cases"</span><span class="main">)</span>
    <span class="main">|</span> <span class="entity">MIC.CPrim</span> <span class="entity">MIC.CCaseTac</span> <span class="main">=&gt;</span>      <span class="main">(</span><span class="entity">show_trace</span> <span class="inner_quoted">"CCaseTac"</span><span class="main">;</span>       <span class="entity">string_to_stttac</span> <span class="inner_quoted">"case_tac"</span><span class="main">)</span>
    <span class="main">|</span> <span class="entity">MIC.CPrim</span> <span class="entity">MIC.CRule</span>   <span class="main">=&gt;</span>       <span class="main">(</span><span class="entity">show_trace</span> <span class="inner_quoted">"CRule"</span><span class="main">;</span>          <span class="entity">string_to_stttac</span> <span class="inner_quoted">"rule"</span><span class="main">)</span>
    <span class="main">|</span> <span class="entity">MIC.CPrim</span> <span class="entity">MIC.CErule</span>  <span class="main">=&gt;</span>       <span class="main">(</span><span class="entity">show_trace</span> <span class="inner_quoted">"CErule"</span><span class="main">;</span>         <span class="entity">string_to_stttac</span> <span class="inner_quoted">"erule"</span><span class="main">)</span>
    <span class="main">|</span> <span class="entity">MIC.CSpec</span> <span class="entity">MIC.CIntroClasses</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">show_trace</span> <span class="inner_quoted">"CIntro_Classes"</span><span class="main">;</span> <span class="entity">string_to_stttac</span> <span class="inner_quoted">"intro_classes"</span><span class="main">)</span>
    <span class="main">|</span> <span class="entity">MIC.CSpec</span> <span class="entity">MIC.CTransfer</span> <span class="main">=&gt;</span>     <span class="main">(</span><span class="entity">show_trace</span> <span class="inner_quoted">"CTransfer"</span><span class="main">;</span>      <span class="entity">string_to_stttac</span> <span class="inner_quoted">"transfer"</span><span class="main">)</span>
    <span class="main">|</span> <span class="entity">MIC.CSpec</span> <span class="entity">MIC.CNormalization</span> <span class="main">=&gt;</span><span class="main">(</span><span class="entity">show_trace</span> <span class="inner_quoted">"CNormalization"</span><span class="main">;</span> <span class="entity">string_to_stttac</span> <span class="inner_quoted">"normalization"</span><span class="main">)</span>
    <span class="main">|</span> <span class="entity">MIC.CSpec</span> <span class="entity">MIC.CSubgoal</span> <span class="main">=&gt;</span>      <span class="main">(</span><span class="entity">show_trace</span> <span class="inner_quoted">"CSubgoal"</span><span class="main">;</span>       <span class="entity">Subtools.subgoal</span><span class="main">)</span>
    <span class="main">|</span> <span class="entity">MIC.CSubt</span> <span class="entity">MIC.CHammer</span> <span class="main">=&gt;</span>       <span class="main">(</span><span class="entity">show_trace</span> <span class="inner_quoted">"CHammer"</span><span class="main">;</span>        <span class="entity">Subtools.hammer</span><span class="main">)</span>
    <span class="main">|</span> <span class="entity">MIC.CSpec</span> <span class="entity">MIC.CIsSolved</span> <span class="main">=&gt;</span>     <span class="main">(</span><span class="entity">show_trace</span> <span class="inner_quoted">"CIs_Solved"</span><span class="main">;</span>     <span class="entity">Subtools.is_solved</span><span class="main">)</span>
    <span class="main">|</span> <span class="entity">MIC.CSubt</span> <span class="entity">MIC.CQuickcheck</span><span class="main">=&gt;</span>    <span class="main">(</span><span class="entity">show_trace</span> <span class="inner_quoted">"CQuickcheck"</span><span class="main">;</span>    <span class="entity">Subtools.quickcheck</span><span class="main">)</span>
    <span class="main">|</span> <span class="entity">MIC.CSubt</span> <span class="entity">MIC.CNitpick</span>   <span class="main">=&gt;</span>    <span class="main">(</span><span class="entity">show_trace</span> <span class="inner_quoted">"CNitpick"</span><span class="main">;</span>       <span class="entity">Subtools.nitpick</span><span class="main">)</span>
    <span class="main">|</span> <span class="entity">MIC.CSpec</span> <span class="entity">MIC.CDefer</span>     <span class="main">=&gt;</span>    <span class="main">(</span><span class="entity">show_trace</span> <span class="inner_quoted">"CDefer"</span><span class="main">;</span>         <span class="entity">Subtools.defer</span><span class="main">)</span>
    <span class="main">|</span> <span class="entity">MIC.CUser</span> <span class="entity">tac_name</span> <span class="main">=&gt;</span>          <span class="main">(</span><span class="entity">show_trace</span> <span class="entity">tac_name</span><span class="main">;</span>         <span class="entity">user_stttac</span> <span class="entity">tac_name</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
     <span class="entity">Utils.try_with</span> <span class="entity">MIC.mzero</span> <span class="entity">tac_on_proof_state</span> <span class="entity">goal_state</span> <span class="main">:</span> <span class="entity">state</span> <span class="entity">MIC.monad</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(* eval_para *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">eval_para</span> <span class="main">(</span><span class="entity">str</span><span class="main">:</span><span class="entity">MIC.cprim_str</span><span class="main">)</span> <span class="main">(</span><span class="entity">state</span><span class="main">:</span><span class="entity">Proof.state</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">get_state_stttacs</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">str</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="entity">MIC.CSimp</span> <span class="main">=&gt;</span>        <span class="main">(</span><span class="entity">show_trace</span> <span class="inner_quoted">"CPara_Simp"</span><span class="main">;</span>        <span class="entity">Dynamic_Tactic_Generation.simp</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">MIC.CBlast</span> <span class="main">=&gt;</span>       <span class="main">(</span><span class="entity">show_trace</span> <span class="inner_quoted">"CBlast"</span><span class="main">;</span>            <span class="entity">Dynamic_Tactic_Generation.blast</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">MIC.CInduct</span> <span class="main">=&gt;</span>      <span class="main">(</span><span class="entity">show_trace</span> <span class="inner_quoted">"CPara_Induct"</span><span class="main">;</span>      <span class="entity">Dynamic_Tactic_Generation.induct</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">MIC.CInductTac</span> <span class="main">=&gt;</span>   <span class="main">(</span><span class="entity">show_trace</span> <span class="inner_quoted">"CPara_InductTac"</span><span class="main">;</span>   <span class="entity">Dynamic_Tactic_Generation.induct_tac</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">MIC.CCoinduction</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">show_trace</span> <span class="inner_quoted">"CPara_Coinduction"</span><span class="main">;</span> <span class="entity">Dynamic_Tactic_Generation.coinduction</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">MIC.CCases</span> <span class="main">=&gt;</span>       <span class="main">(</span><span class="entity">show_trace</span> <span class="inner_quoted">"CPara_Cases"</span><span class="main">;</span>       <span class="entity">Dynamic_Tactic_Generation.cases</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">MIC.CCaseTac</span> <span class="main">=&gt;</span>     <span class="main">(</span><span class="entity">show_trace</span> <span class="inner_quoted">"CPara_CaseTac"</span><span class="main">;</span>     <span class="entity">Dynamic_Tactic_Generation.case_tac</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">MIC.CRule</span> <span class="main">=&gt;</span>        <span class="main">(</span><span class="entity">show_trace</span> <span class="inner_quoted">"CPara_Rule"</span><span class="main">;</span>        <span class="entity">Dynamic_Tactic_Generation.rule</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">MIC.CErule</span> <span class="main">=&gt;</span>       <span class="main">(</span><span class="entity">show_trace</span> <span class="inner_quoted">"CPara_Erule"</span><span class="main">;</span>       <span class="entity">Dynamic_Tactic_Generation.erule</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">MIC.CFastforce</span> <span class="main">=&gt;</span>   <span class="main">(</span><span class="entity">show_trace</span> <span class="inner_quoted">"CPara_Fastforce"</span><span class="main">;</span>   <span class="entity">Dynamic_Tactic_Generation.fastforce</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">MIC.CAuto</span> <span class="main">=&gt;</span>        <span class="main">(</span><span class="entity">show_trace</span> <span class="inner_quoted">"CPara_Auto"</span><span class="main">;</span>        <span class="entity">Dynamic_Tactic_Generation.auto</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">MIC.CClarsimp</span> <span class="main">=&gt;</span>    <span class="main">(</span><span class="entity">show_trace</span> <span class="inner_quoted">"CPara_Clarsimp"</span><span class="main">;</span>    <span class="entity">Dynamic_Tactic_Generation.clarsimp</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="comment1">(*It is okay to use the type list internally,
      as long as the overall monadic interpretation framework is instantiated to Seq.seq for
      monad with 0 and plus.*)</span>
    <span class="entity">Seq2.try_seq</span> <span class="entity">get_state_stttacs</span> <span class="entity">state</span> <span class="main">:</span> <span class="entity">monad_tac</span> <span class="entity">seq</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(* m_equal *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">m_equal</span> <span class="main">(</span><span class="entity">st_mona1</span><span class="main">:</span><span class="entity">monad</span><span class="main">)</span> <span class="main">(</span><span class="entity">st_mona2</span><span class="main">:</span><span class="entity">state</span> <span class="entity">MIC.monad</span><span class="main">)</span> <span class="main">=</span>
<span class="comment1">(*Probably, I do not have to check the entire sequence in most cases.
  As the length of sequences can be infinite in general, I prefer to test a subset of these.*)</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">lstt</span>   <span class="main">=</span> <span class="entity">Log_Min.monoid_min</span> * <span class="entity">state</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">lstts</span>  <span class="main">=</span> <span class="entity">lstt</span> <span class="entity">seq</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">are_same_one</span> <span class="main">(</span><span class="entity">x</span> <span class="main">:</span> <span class="entity">lstt</span><span class="main">,</span>  <span class="entity">y</span> <span class="main">:</span> <span class="entity">lstt</span><span class="main">)</span>  <span class="main">=</span> apply2 <span class="main">(</span><span class="main">#</span>goal o <span class="entity">Proof.goal</span> o snd<span class="main">)</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span>
                                           |&gt; Thm.eq_thm<span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">are_same_seq</span> <span class="main">(</span><span class="entity">xs</span><span class="main">:</span> <span class="entity">lstts</span><span class="main">,</span> <span class="entity">ys</span><span class="main">:</span> <span class="entity">lstts</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Seq2.same_seq</span> <span class="entity">are_same_one</span> <span class="main">(</span><span class="entity">xs</span><span class="main">,</span> <span class="entity">ys</span><span class="main">)</span> <span class="main">;</span>
    <span class="comment1">(*Note that the state representing log is not always []. This is only for equality check.*)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">xs_5</span> <span class="main">:</span> <span class="entity">lstts</span>                        <span class="main">=</span> <span class="entity">st_mona1</span> <span class="main">[</span><span class="main">]</span> |&gt; Seq.take <span class="inner_numeral">5</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ys_5</span> <span class="main">:</span> <span class="entity">lstts</span>                        <span class="main">=</span> <span class="entity">st_mona2</span> <span class="main">[</span><span class="main">]</span> |&gt; Seq.take <span class="inner_numeral">5</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">are_same_seq</span> <span class="main">(</span><span class="entity">xs_5</span><span class="main">,</span> <span class="entity">ys_5</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(* solve_1st_subg *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">solve_1st_subg</span> <span class="main">(</span><span class="entity">tac</span><span class="main">:</span><span class="entity">monad_tac</span><span class="main">)</span> <span class="main">(</span><span class="entity">goal</span><span class="main">:</span><span class="entity">state</span><span class="main">)</span> <span class="main">(</span><span class="entity">log</span><span class="main">:</span><span class="entity">log</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">get_thm</span> <span class="main">=</span> <span class="entity">Isabelle_Utils.proof_state_to_thm</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">same_except_for_fst_prem'</span> <span class="entity">x</span> <span class="entity">y</span> <span class="main">=</span> <span class="entity">Isabelle_Utils.same_except_for_fst_prem</span> <span class="main">(</span><span class="entity">get_thm</span> <span class="entity">x</span><span class="main">)</span> <span class="main">(</span><span class="entity">get_thm</span> <span class="entity">y</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">tac</span> <span class="entity">goal</span> <span class="entity">log</span>
    |&gt; Seq.filter <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">st'</span><span class="main">)</span>  <span class="main">=&gt;</span> <span class="entity">same_except_for_fst_prem'</span> <span class="entity">goal</span> <span class="entity">st'</span><span class="main">)</span><span class="main">:</span><span class="main">(</span><span class="entity">log</span> * <span class="entity">state</span><span class="main">)</span> Seq.seq
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(* repeat_n *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">repeat_n</span> <span class="main">(</span><span class="entity">tac</span> <span class="main">:</span> <span class="entity">monad_tac</span><span class="main">)</span> <span class="main">(</span><span class="entity">goal</span> <span class="main">:</span> <span class="entity">state</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">log</span><span class="main">:</span><span class="entity">log</span><span class="main">)</span> <span class="main">=&gt;</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">repeat_n'</span> <span class="main">(</span><span class="inner_numeral">0</span><span class="main">:</span>int<span class="main">)</span> <span class="main">(</span><span class="entity">g</span><span class="main">:</span><span class="entity">state</span><span class="main">)</span> <span class="main">=</span> <span class="entity">MIC.return</span> <span class="entity">g</span>
     <span class="main">|</span>  <span class="entity">repeat_n'</span> <span class="main">(</span><span class="entity">n</span><span class="main">:</span>int<span class="main">)</span> <span class="main">(</span><span class="entity">g</span><span class="main">:</span><span class="entity">state</span><span class="main">)</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">n</span> &lt; <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span> error <span class="inner_quoted">"repeat_n failed: n &lt; 0"</span> <span class="keyword2"><span class="keyword">else</span></span>
          <span class="entity">MIC.bind</span> <span class="main">(</span><span class="entity">tac</span> <span class="entity">g</span><span class="main">)</span> <span class="main">(</span><span class="entity">repeat_n'</span> <span class="main">(</span><span class="entity">n</span> - <span class="inner_numeral">1</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">subgoal_num</span> <span class="main">=</span> <span class="entity">Isabelle_Utils.proof_state_to_thm</span> <span class="entity">goal</span> |&gt; Thm.nprems_of<span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="comment1">(*We have to add 1 because of Isabelle's strange evaluation (parse-twice thingy).*)</span>
    <span class="entity">repeat_n'</span> <span class="entity">subgoal_num</span> <span class="entity">goal</span> <span class="entity">log</span> <span class="main">:</span> <span class="main">(</span><span class="entity">log</span> * <span class="entity">state</span><span class="main">)</span> Seq.seq
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span> <span class="main">:</span> <span class="entity">monad</span><span class="main">;</span>

<span class="comment1">(* cut *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">cut</span> <span class="main">(</span><span class="entity">limit</span><span class="main">:</span>int<span class="main">)</span> <span class="main">(</span><span class="entity">tac</span><span class="main">:</span><span class="entity">monad_tac</span><span class="main">)</span> <span class="main">(</span><span class="entity">goal</span><span class="main">:</span><span class="entity">state</span><span class="main">)</span> <span class="main">=</span> Seq.take <span class="entity">limit</span> o <span class="entity">tac</span> <span class="entity">goal</span> <span class="main">:</span> <span class="entity">monad</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">local</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">list_of</span> <span class="main">=</span> Seq.list_of<span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">of_list</span> <span class="main">=</span> Seq.of_list<span class="main">;</span>

<span class="keyword2"><span class="keyword">in</span></span>

<span class="comment1">(* pseq *)</span>
<span class="comment1">(*Note that pthen locally introduces strict evaluation.*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pseq</span> <span class="main">(</span><span class="entity">tac1</span>::<span class="main">[</span><span class="entity">tac2</span><span class="main">]</span><span class="main">:</span><span class="entity">monad_tac</span> list<span class="main">)</span> <span class="main">:</span> <span class="entity">monad_tac</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">goal</span><span class="main">:</span><span class="entity">state</span> <span class="main">=&gt;</span>
  <span class="keyword2"><span class="keyword">let</span></span>
     <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pmap</span> <span class="main">=</span> Par_List.map<span class="main">;</span>
     <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pbind</span> <span class="main">(</span><span class="entity">monad</span><span class="main">:</span><span class="entity">monad</span><span class="main">)</span> <span class="main">(</span><span class="entity">tactic</span><span class="main">:</span><span class="entity">monad_tac</span><span class="main">)</span> <span class="main">:</span> <span class="entity">monad</span> <span class="main">=</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">state0</span> <span class="main">:</span> <span class="entity">log</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">seq</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">func</span> <span class="main">=&gt;</span>
       <span class="entity">of_list</span> <span class="main">(</span>flat <span class="main">(</span><span class="entity">pmap</span> <span class="main">(</span><span class="entity">list_of</span> o <span class="entity">func</span><span class="main">)</span> <span class="main">(</span><span class="entity">list_of</span> <span class="entity">seq</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="entity">monad</span> <span class="entity">state0</span><span class="main">)</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">state1</span><span class="main">,</span> <span class="entity">result1</span><span class="main">)</span> <span class="main">=&gt;</span>
       <span class="entity">tactic</span> <span class="entity">result1</span> <span class="entity">state1</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">pbind</span> <span class="main">(</span><span class="entity">tac1</span> <span class="entity">goal</span><span class="main">)</span> <span class="entity">tac2</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span> <span class="main">:</span> <span class="entity">monad_tac</span>
 <span class="main">|</span>  <span class="entity">pseq</span> <span class="main">_</span> <span class="main">=</span> error <span class="inner_quoted">"pthen takes exactly two strategies."</span><span class="main">;</span>

<span class="comment1">(* pseq1 *)</span>
<span class="comment1">(*Note that pthen1 does not satisfy the monad law as a bind.*)</span>
<span class="comment1">(*Nevertheless, pthen1 is useful to exploit parallelism.*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pseq1</span> <span class="main">(</span><span class="entity">tac1</span>::<span class="main">[</span><span class="entity">tac2</span><span class="main">]</span><span class="main">:</span><span class="entity">monad_tac</span> list<span class="main">)</span> <span class="main">:</span> <span class="entity">monad_tac</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">goal</span><span class="main">:</span><span class="entity">state</span> <span class="main">=&gt;</span>
  <span class="keyword2"><span class="keyword">let</span></span>
     <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">get_some</span>   <span class="main">=</span> Par_List.get_some<span class="main">;</span>
     <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">seq_to_opt</span> <span class="main">=</span> <span class="entity">Seq2.seq_to_option</span><span class="main">;</span>
     <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pbind</span> <span class="main">(</span><span class="entity">monad</span><span class="main">:</span><span class="entity">monad</span><span class="main">)</span> <span class="main">(</span><span class="entity">tactic</span><span class="main">:</span><span class="entity">monad_tac</span><span class="main">)</span> <span class="main">:</span> <span class="entity">monad</span> <span class="main">=</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">state0</span> <span class="main">:</span> <span class="entity">log</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">seq</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">func</span> <span class="main">=&gt;</span>
       <span class="entity">of_list</span> <span class="main">(</span>the_list <span class="main">(</span><span class="entity">get_some</span> <span class="main">(</span><span class="entity">seq_to_opt</span> o <span class="entity">func</span><span class="main">)</span> <span class="main">(</span><span class="entity">list_of</span> <span class="entity">seq</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="entity">monad</span> <span class="entity">state0</span><span class="main">)</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">state1</span><span class="main">,</span> <span class="entity">result1</span><span class="main">)</span> <span class="main">=&gt;</span>
       <span class="entity">tactic</span> <span class="entity">result1</span> <span class="entity">state1</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">pbind</span> <span class="main">(</span><span class="entity">tac1</span> <span class="entity">goal</span><span class="main">)</span> <span class="entity">tac2</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span> <span class="main">:</span> <span class="entity">monad_tac</span>
 <span class="main">|</span>  <span class="entity">pseq1</span> <span class="main">_</span> <span class="main">=</span> error <span class="inner_quoted">"pthen1 takes exactly two strategies."</span><span class="main">;</span>


<span class="comment1">(* pors *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pors'</span> <span class="main">(</span><span class="entity">goal</span><span class="main">:</span><span class="entity">state</span><span class="main">,</span> <span class="entity">tactic</span><span class="main">:</span><span class="entity">monad_tac</span><span class="main">)</span> <span class="main">:</span> <span class="entity">monad</span> option <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">result</span>      <span class="main">=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">log</span><span class="main">:</span><span class="entity">log</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">tactic</span> <span class="entity">goal</span> <span class="entity">log</span><span class="main">)</span> <span class="main">:</span> <span class="entity">monad</span><span class="main">;</span>
    <span class="comment1">(*some_result forces evaluation to exploit parallelism.*)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">some_result</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">m_equal</span> <span class="entity">MIC.mzero</span> <span class="entity">result</span> <span class="keyword2"><span class="keyword">then</span></span> NONE <span class="keyword2"><span class="keyword">else</span></span> SOME <span class="entity">result</span> <span class="main">:</span> <span class="entity">monad</span> option<span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">some_result</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pors</span> <span class="main">(</span><span class="entity">tactics</span><span class="main">:</span><span class="entity">monad_tac</span> list<span class="main">)</span> <span class="main">:</span> <span class="entity">monad_tac</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">goal</span><span class="main">:</span><span class="entity">state</span> <span class="main">=&gt;</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">states</span> <span class="main">=</span> replicate <span class="main">(</span>length <span class="entity">tactics</span><span class="main">)</span> <span class="entity">goal</span> <span class="main">:</span> <span class="entity">state</span> list<span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">some_monad</span> <span class="main">=</span> Par_List.get_some <span class="entity">pors'</span> <span class="main">(</span>ListPair.zip <span class="main">(</span><span class="entity">states</span><span class="main">,</span> <span class="entity">tactics</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">result</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">some_monad</span> <span class="keyword2"><span class="keyword">of</span></span>
      NONE       <span class="main">=&gt;</span> <span class="entity">MIC.mzero</span>
    <span class="main">|</span> SOME <span class="entity">monad</span> <span class="main">=&gt;</span> <span class="entity">monad</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">result</span><span class="main">:</span><span class="entity">monad</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span><span class="main">;</span>

<span class="comment1">(* palts *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">palts</span> <span class="main">(</span><span class="entity">tactics</span><span class="main">:</span><span class="entity">monad_tac</span> list<span class="main">)</span> <span class="main">:</span> <span class="entity">monad_tac</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">goal</span><span class="main">:</span><span class="entity">state</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">log</span><span class="main">:</span><span class="entity">log</span> <span class="main">=&gt;</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goal_n_log</span>  <span class="main">=</span> replicate <span class="main">(</span>length <span class="entity">tactics</span><span class="main">)</span> <span class="main">(</span><span class="entity">log</span><span class="main">,</span> <span class="entity">goal</span><span class="main">)</span> <span class="main">:</span> <span class="main">(</span><span class="entity">log</span> * <span class="entity">state</span><span class="main">)</span> list<span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">get_result</span>  <span class="main">=</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">log</span><span class="main">:</span><span class="entity">log</span><span class="main">,</span> <span class="entity">goal</span><span class="main">:</span><span class="entity">state</span><span class="main">)</span><span class="main">,</span> <span class="entity">tactic</span><span class="main">:</span><span class="entity">monad_tac</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">tactic</span> <span class="entity">goal</span> <span class="entity">log</span> <span class="main">:</span> <span class="main">(</span><span class="entity">log</span> * <span class="entity">state</span><span class="main">)</span> <span class="entity">seq</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">result_list</span> <span class="main">=</span> Par_List.map <span class="entity">get_result</span> <span class="main">(</span>ListPair.zip <span class="main">(</span><span class="entity">goal_n_log</span><span class="main">,</span> <span class="entity">tactics</span><span class="main">)</span><span class="main">)</span>
                    <span class="main">:</span> <span class="main">(</span><span class="entity">log</span> * <span class="entity">state</span><span class="main">)</span> <span class="entity">seq</span> list<span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">result_seq</span>  <span class="main">=</span> <span class="entity">result_list</span> |&gt; <span class="entity">of_list</span> |&gt; Seq.flat <span class="main">:</span> <span class="main">(</span><span class="entity">log</span> * <span class="entity">state</span><span class="main">)</span> <span class="entity">seq</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">result_seq</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span> <span class="main">:</span> <span class="entity">monad</span><span class="main">)</span> <span class="main">:</span> <span class="entity">monad_tac</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(* eval_strategic *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">eval_strategic</span> <span class="main">(</span><span class="entity">MIC.CSolve1</span><span class="main">,</span> <span class="main">[</span><span class="entity">tac</span><span class="main">:</span><span class="entity">monad_tac</span><span class="main">]</span><span class="main">)</span>  <span class="main">=</span> <span class="entity">solve_1st_subg</span> <span class="entity">tac</span>
 <span class="main">|</span>  <span class="entity">eval_strategic</span> <span class="main">(</span><span class="entity">MIC.CSolve1</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span>  <span class="main">=</span> error <span class="inner_quoted">"eval_strategic failed. M.Solve1 needs exactly one tactic."</span>
 <span class="main">|</span>  <span class="entity">eval_strategic</span> <span class="main">(</span><span class="entity">MIC.CRepeatN</span><span class="main">,</span> <span class="main">[</span><span class="entity">tac</span><span class="main">:</span><span class="entity">monad_tac</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> <span class="entity">repeat_n</span> <span class="entity">tac</span>
 <span class="main">|</span>  <span class="entity">eval_strategic</span> <span class="main">(</span><span class="entity">MIC.CRepeatN</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> error <span class="inner_quoted">"eval_strategic failed. M.RepeatN needs exactly one tactic."</span>
 <span class="main">|</span>  <span class="entity">eval_strategic</span> <span class="main">(</span><span class="entity">MIC.CCut</span> <span class="entity">lim</span><span class="main">,</span> <span class="main">[</span><span class="entity">tac</span><span class="main">:</span><span class="entity">monad_tac</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">lim</span> &gt; <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">cut</span> <span class="entity">lim</span> <span class="entity">tac</span>
      <span class="keyword2"><span class="keyword">else</span></span> error <span class="inner_quoted">"eval_strategic failed. The limit for CCut has to be larger than 0."</span>
 <span class="main">|</span>  <span class="entity">eval_strategic</span> <span class="main">(</span><span class="entity">MIC.CCut</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span>   <span class="main">=</span> error <span class="inner_quoted">"eval strategic failed. M.CCut needs exactly one tactic."</span>
 <span class="main">|</span>  <span class="entity">eval_strategic</span> <span class="main">(</span><span class="entity">MIC.CPSeq1</span><span class="main">,</span> <span class="entity">tac1</span>::<span class="main">[</span><span class="entity">tac2</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> <span class="entity">pseq1</span> <span class="main">(</span><span class="entity">tac1</span>::<span class="main">[</span><span class="entity">tac2</span><span class="main">]</span><span class="main">)</span>
 <span class="main">|</span>  <span class="entity">eval_strategic</span> <span class="main">(</span><span class="entity">MIC.CPSeq1</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span>   <span class="main">=</span> error <span class="inner_quoted">"eval strategic failed. MIC.CPSeq1 needs exactly two tactics."</span>
 <span class="main">|</span>  <span class="entity">eval_strategic</span> <span class="main">(</span><span class="entity">MIC.CPSeq</span><span class="main">,</span> <span class="entity">tac1</span>::<span class="main">[</span><span class="entity">tac2</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> <span class="entity">pseq</span> <span class="main">(</span><span class="entity">tac1</span>::<span class="main">[</span><span class="entity">tac2</span><span class="main">]</span><span class="main">)</span>
 <span class="main">|</span>  <span class="entity">eval_strategic</span> <span class="main">(</span><span class="entity">MIC.CPSeq</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span>    <span class="main">=</span> error <span class="inner_quoted">"eval strategic failed. MIC.CPSeq needs exactly two tactics."</span>
 <span class="main">|</span>  <span class="entity">eval_strategic</span> <span class="main">(</span><span class="entity">MIC.CPOr</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>    <span class="main">=</span> error <span class="inner_quoted">"eval strategic failed. MIC.CPSeq needs at least one tactic."</span>
 <span class="main">|</span>  <span class="entity">eval_strategic</span> <span class="main">(</span><span class="entity">MIC.CPOr</span><span class="main">,</span> <span class="entity">tacs</span><span class="main">)</span>  <span class="main">=</span> <span class="entity">pors</span> <span class="entity">tacs</span>
 <span class="main">|</span>  <span class="entity">eval_strategic</span> <span class="main">(</span><span class="entity">MIC.CPAlt</span><span class="main">,</span><span class="main">[</span><span class="main">]</span><span class="main">)</span>    <span class="main">=</span> error <span class="inner_quoted">"eval strategic failed. M.PAlt needs at least one tactic."</span>
 <span class="main">|</span>  <span class="entity">eval_strategic</span> <span class="main">(</span><span class="entity">MIC.CPAlt</span><span class="main">,</span><span class="entity">tacs</span><span class="main">)</span>  <span class="main">=</span> <span class="entity">palts</span> <span class="entity">tacs</span><span class="main">;</span>

<span class="comment1">(* iddfc *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">iddfc</span> <span class="main">(</span><span class="entity">limit</span><span class="main">:</span>int<span class="main">)</span>
  <span class="main">(</span><span class="entity">smt_eval</span><span class="main">:</span>'atom_str <span class="main">-&gt;</span> 'state <span class="entity">MIC.stttac</span><span class="main">)</span> <span class="main">(</span><span class="entity">atac</span><span class="main">:</span>'atom_str<span class="main">)</span> <span class="main">(</span><span class="entity">goal</span><span class="main">:</span>'state<span class="main">)</span> <span class="main">(</span><span class="entity">trace</span><span class="main">:</span><span class="entity">log</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">wmt_eval_results</span> <span class="main">=</span> <span class="entity">Seq2.try_seq</span> <span class="main">(</span><span class="entity">smt_eval</span> <span class="entity">atac</span> <span class="entity">goal</span><span class="main">)</span> <span class="entity">trace</span> |&gt; Seq.pull<span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">trace_leng</span> <span class="main">=</span> <span class="entity">wmt_eval_results</span> |&gt; Option.map fst |&gt; Option.map fst |&gt; Option.map length<span class="main">;</span>
    <span class="keyword1"><span class="keyword">infix</span></span> is_maybe_less_than
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="main">(</span>NONE <span class="entity">is_maybe_less_than</span>   <span class="main">(</span><span class="main">_</span><span class="main">:</span>int<span class="main">)</span><span class="main">)</span> <span class="main">=</span> false
     <span class="main">|</span>  <span class="main">(</span>SOME <span class="entity">x</span> <span class="entity">is_maybe_less_than</span> <span class="main">(</span><span class="entity">y</span><span class="main">:</span>int<span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">x</span> &lt; <span class="entity">y</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">smt_eval_results</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> is_none <span class="entity">trace_leng</span> <span class="keyword1"><span class="keyword">orelse</span></span> <span class="entity">trace_leng</span> <span class="entity">is_maybe_less_than</span> <span class="entity">limit</span>
                          <span class="keyword2"><span class="keyword">then</span></span> Seq.make <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">wmt_eval_results</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> Seq.empty<span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">smt_eval_results</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(*** MONADIC_PROVER: Put skeleton and flesh together. ***)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">MONADIC_PROVER</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">include</span></span> <span class="entity">MONADIC_INTERPRETER_CORE</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">include</span></span> <span class="entity">MONADIC_INTERPRETER</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">include</span></span> <span class="entity">MONADIC_INTERPRETER_PARAMS</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(*** Monadic_Prover: Put skeleton and flesh together. ***)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Monadic_Prover</span> <span class="main">:</span> <span class="entity">MONADIC_PROVER</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>
  <span class="keyword3"><span class="keyword">open</span></span> Monadic_Interpreter_Core<span class="main">;</span>
  <span class="keyword3"><span class="keyword">open</span></span> Monadic_Interpreter<span class="main">;</span>
  <span class="keyword3"><span class="keyword">open</span></span> Monadic_Interpreter_Params<span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span></pre>
</div><div id="files/Parser_Combinator.ML">
<div class="head">
<h1>File ‹Parser_Combinator.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Parser_Combinator.ML
    Author:     Yutaka Nagashima, Data61, CSIRO

Monadic Parser Combinators described by Graham Hutton and Erik Meijer in 1996.
Note that the smallest textual unit in Isabelle is Symbol.symbol.
*)</span>

<span class="comment1">(*** PARSER_COMBINATOR: monadic parser combinators ***)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">PARSER_COMBINATOR</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">symbols</span> <span class="main">=</span> Symbol.symbol list<span class="main">;</span>
  <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">parser</span> <span class="main">=</span> <span class="entity">symbols</span> <span class="main">-&gt;</span> <span class="main">(</span>'a * <span class="entity">symbols</span><span class="main">)</span> Seq.seq<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> result <span class="main">:</span> 'a <span class="main">-&gt;</span> 'a <span class="entity">parser</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> zero   <span class="main">:</span> 'a <span class="entity">parser</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> bind   <span class="main">:</span> 'a <span class="entity">parser</span> <span class="main">-&gt;</span> <span class="main">(</span>'a <span class="main">-&gt;</span> 'b <span class="entity">parser</span><span class="main">)</span> <span class="main">-&gt;</span> 'b <span class="entity">parser</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> &gt;&gt;=    <span class="main">:</span> 'a <span class="entity">parser</span> * <span class="main">(</span>'a <span class="main">-&gt;</span> 'b <span class="entity">parser</span><span class="main">)</span> <span class="main">-&gt;</span> 'b <span class="entity">parser</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> item   <span class="main">:</span> Symbol.symbol <span class="entity">parser</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> sat    <span class="main">:</span> <span class="main">(</span>Symbol.symbol <span class="main">-&gt;</span> bool<span class="main">)</span> <span class="main">-&gt;</span> Symbol.symbol <span class="entity">parser</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> symbol <span class="main">:</span> Symbol.symbol <span class="main">-&gt;</span> Symbol.symbol <span class="entity">parser</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> digit  <span class="main">:</span> Symbol.symbol <span class="entity">parser</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> lower  <span class="main">:</span> Symbol.symbol <span class="entity">parser</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> upper  <span class="main">:</span> Symbol.symbol <span class="entity">parser</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> plus   <span class="main">:</span> <span class="main">(</span>'a <span class="entity">parser</span> * 'a <span class="entity">parser</span><span class="main">)</span> <span class="main">-&gt;</span> 'a <span class="entity">parser</span><span class="main">;</span>
  <span class="comment1">(*_ is considered as a letter following the Isabelle convention.*)</span>
  <span class="keyword1"><span class="keyword">val</span></span> letter <span class="main">:</span> Symbol.symbol <span class="entity">parser</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> alphanum <span class="main">:</span> Symbol.symbol <span class="entity">parser</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> word   <span class="main">:</span> string <span class="entity">parser</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> string <span class="main">:</span> string <span class="main">-&gt;</span> string <span class="entity">parser</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> many   <span class="main">:</span> 'a <span class="entity">parser</span> <span class="main">-&gt;</span> 'a Seq.seq <span class="entity">parser</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> ident  <span class="main">:</span> string <span class="entity">parser</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> many1  <span class="main">:</span> 'a <span class="entity">parser</span> <span class="main">-&gt;</span> 'a Seq.seq <span class="entity">parser</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> nat    <span class="main">:</span> int <span class="entity">parser</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> int    <span class="main">:</span> int <span class="entity">parser</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> sepby1 <span class="main">:</span> 'a <span class="entity">parser</span> * 'b <span class="entity">parser</span> <span class="main">-&gt;</span> 'a Seq.seq <span class="entity">parser</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> bracket<span class="main">:</span> 'a <span class="entity">parser</span> <span class="main">-&gt;</span> 'b <span class="entity">parser</span> <span class="main">-&gt;</span> 'c <span class="entity">parser</span> <span class="main">-&gt;</span> 'b <span class="entity">parser</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> ints   <span class="main">:</span> int Seq.seq <span class="entity">parser</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> sepby  <span class="main">:</span> 'a <span class="entity">parser</span> * 'b <span class="entity">parser</span> <span class="main">-&gt;</span> 'a Seq.seq <span class="entity">parser</span><span class="main">;</span>
  
  <span class="keyword1"><span class="keyword">val</span></span> first  <span class="main">:</span> 'a <span class="entity">parser</span> <span class="main">-&gt;</span> 'a <span class="entity">parser</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> +++    <span class="main">:</span> 'a <span class="entity">parser</span> * 'a <span class="entity">parser</span> <span class="main">-&gt;</span> 'a <span class="entity">parser</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> spaces <span class="main">:</span> unit <span class="entity">parser</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> comment<span class="main">:</span> unit <span class="entity">parser</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> junk   <span class="main">:</span> unit <span class="entity">parser</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> parse  <span class="main">:</span> 'a <span class="entity">parser</span> <span class="main">-&gt;</span> 'a <span class="entity">parser</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> token  <span class="main">:</span> 'a <span class="entity">parser</span> <span class="main">-&gt;</span> 'a <span class="entity">parser</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(*** Parser_Combinator: monadic parser combinators ***)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Parser_Combinator</span> <span class="main">:</span> <span class="entity">PARSER_COMBINATOR</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">symbols</span>              <span class="main">=</span> Symbol.symbol list<span class="main">;</span>
  <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">parser</span>            <span class="main">=</span> <span class="entity">symbols</span> <span class="main">-&gt;</span> <span class="main">(</span>'a * <span class="entity">symbols</span><span class="main">)</span> Seq.seq<span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">result</span> <span class="entity">v</span>              <span class="main">=</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">inp</span> <span class="main">=&gt;</span> Seq.single <span class="main">(</span><span class="entity">v</span><span class="main">,</span> <span class="entity">inp</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">zero</span>                  <span class="main">=</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span>   <span class="main">=&gt;</span> Seq.empty<span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">bbind</span> <span class="entity">xs</span> <span class="entity">func</span>         <span class="main">=</span> Seq.flat <span class="main">(</span>Seq.map <span class="entity">func</span> <span class="entity">xs</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">bind</span> <span class="entity">p</span> <span class="entity">f</span> <span class="entity">inp</span>          <span class="main">=</span>  <span class="entity">bbind</span> <span class="main">(</span><span class="entity">p</span> <span class="entity">inp</span><span class="main">)</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">result1</span><span class="main">,</span> <span class="entity">state1</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">f</span> <span class="entity">result1</span> <span class="entity">state1</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">item</span> <span class="main">(</span><span class="entity">inp</span><span class="main">:</span><span class="entity">symbols</span><span class="main">)</span>     <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">inp</span> <span class="keyword2"><span class="keyword">of</span></span>
      <span class="main">[</span><span class="main">]</span>      <span class="main">=&gt;</span> Seq.empty
    <span class="main">|</span> <span class="main">(</span><span class="entity">x</span>::<span class="entity">xs</span><span class="main">)</span> <span class="main">=&gt;</span> Seq.single <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">xs</span><span class="main">:</span><span class="entity">symbols</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">sat</span> <span class="entity">p</span>    <span class="main">=</span> <span class="entity">bind</span> <span class="entity">item</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">p</span> <span class="entity">x</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">result</span> <span class="entity">x</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">zero</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">symbol</span> <span class="entity">x</span> <span class="main">=</span> <span class="entity">sat</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">y</span> <span class="main">=&gt;</span> <span class="entity">x</span> <span class="main">=</span> <span class="entity">y</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">digit</span>    <span class="main">=</span> <span class="entity">sat</span> Symbol.is_digit<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lower</span>    <span class="main">=</span> <span class="entity">sat</span> Symbol.is_ascii_lower<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">upper</span>    <span class="main">=</span> <span class="entity">sat</span> Symbol.is_ascii_upper<span class="main">;</span>
  <span class="keyword1"><span class="keyword">infix</span></span> plus<span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">p</span> <span class="entity">plus</span> <span class="entity">q</span> <span class="main">=</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">inp</span> <span class="main">=&gt;</span> Seq.append <span class="main">(</span><span class="entity">p</span> <span class="entity">inp</span><span class="main">)</span> <span class="main">(</span><span class="entity">q</span> <span class="entity">inp</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">letter</span>   <span class="main">=</span> <span class="entity">sat</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">sym</span> <span class="main">=&gt;</span> Symbol.is_ascii_letter <span class="entity">sym</span> <span class="keyword1"><span class="keyword">orelse</span></span> Symbol.is_ascii_quasi <span class="entity">sym</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">alphanum</span> <span class="main">=</span> <span class="entity">letter</span> <span class="entity">plus</span> <span class="entity">digit</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">infix</span></span> &gt;&gt;=<span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">m</span> <span class="entity">&gt;&gt;=</span> <span class="entity">f</span> <span class="main">=</span> <span class="entity">bind</span> <span class="entity">m</span> <span class="entity">f</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">word'</span> <span class="main">_</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="comment1">(*Unlike Hutton and Meijer, I think numerals constitute a word.*)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">neWord</span> <span class="main">=</span> <span class="entity">alphanum</span> <span class="entity">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span>
                   <span class="entity">word'</span> <span class="main">(</span><span class="main">)</span> <span class="entity">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">xs</span> <span class="main">=&gt;</span>
                   <span class="entity">result</span> <span class="main">(</span><span class="entity">x</span> ^ <span class="entity">xs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">neWord</span> <span class="entity">plus</span> <span class="entity">result</span> <span class="inner_quoted">""</span>
   <span class="keyword2"><span class="keyword">end</span></span> <span class="main">:</span> string <span class="entity">parser</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">word</span>       <span class="main">=</span> <span class="entity">word'</span> <span class="main">(</span><span class="main">)</span> <span class="entity">plus</span> <span class="entity">result</span> <span class="inner_quoted">""</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">string'</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> <span class="entity">result</span> <span class="inner_quoted">""</span>
   <span class="main">|</span>  <span class="entity">string'</span> <span class="main">(</span><span class="entity">x</span>::<span class="entity">xs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">symbol</span> <span class="entity">x</span>   <span class="entity">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span>
                        <span class="entity">string'</span> <span class="entity">xs</span> <span class="entity">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span>
                        <span class="main">(</span><span class="entity">x</span>::<span class="entity">xs</span><span class="main">)</span> |&gt; String.concat |&gt; <span class="entity">result</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">string</span> <span class="entity">xs</span> <span class="main">=</span> <span class="entity">xs</span> |&gt; Symbol.explode |&gt; <span class="entity">string'</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">succ_many</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">inp</span> <span class="main">=&gt;</span> Seq.single <span class="main">(</span>Seq.empty<span class="main">,</span> <span class="entity">inp</span><span class="main">)</span><span class="main">)</span> <span class="main">:</span> 'a Seq.seq <span class="entity">parser</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">many</span> <span class="entity">p</span>    <span class="main">=</span> <span class="entity">p</span> <span class="entity">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span> <span class="entity">many</span> <span class="entity">p</span> <span class="entity">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">xs</span> <span class="main">=&gt;</span> <span class="entity">result</span> <span class="main">(</span>Seq.cons <span class="entity">x</span> <span class="entity">xs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">plus</span> <span class="entity">succ_many</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ident</span>     <span class="main">=</span> <span class="entity">lower</span> <span class="entity">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span>
                  <span class="entity">many</span> <span class="entity">alphanum</span> <span class="entity">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">xs</span> <span class="main">=&gt;</span>
                  <span class="entity">result</span> <span class="main">(</span>Seq.cons <span class="entity">x</span> <span class="entity">xs</span> |&gt; Seq.list_of |&gt; String.concat<span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">many1</span> <span class="entity">p</span>   <span class="main">=</span> <span class="entity">p</span> <span class="entity">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span> <span class="entity">many</span> <span class="entity">p</span> <span class="entity">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">xs</span> <span class="main">=&gt;</span> <span class="entity">result</span> <span class="main">(</span>Seq.cons <span class="entity">x</span> <span class="entity">xs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">eval</span> <span class="entity">xs</span>   <span class="main">=</span> Int.fromString <span class="entity">xs</span> |&gt; the<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">nat</span>       <span class="main">=</span> <span class="entity">many1</span> <span class="entity">digit</span> <span class="entity">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">xs</span> <span class="main">=&gt;</span> <span class="entity">xs</span> |&gt; Seq.list_of |&gt; String.concat |&gt; <span class="entity">eval</span> |&gt; <span class="entity">result</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">int</span>       <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">id</span>  <span class="main">=</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">inp</span> <span class="main">=&gt;</span> Seq.single <span class="main">(</span>I<span class="main">,</span> <span class="entity">inp</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ope</span> <span class="main">=</span> <span class="entity">symbol</span> <span class="inner_quoted">"-"</span> <span class="entity">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">result</span> ~<span class="main">)</span> <span class="entity">plus</span> <span class="entity">id</span><span class="main">;</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">ope</span> <span class="entity">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">f</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">nat</span> <span class="entity">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">n</span> <span class="main">=&gt;</span> <span class="entity">f</span> <span class="entity">n</span> |&gt; <span class="entity">result</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">infix</span></span> sepby1<span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">p</span> <span class="entity">sepby1</span> <span class="entity">sep</span> <span class="main">=</span> <span class="entity">p</span> <span class="entity">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span>
                    <span class="main">(</span><span class="entity">many</span> <span class="main">(</span><span class="entity">sep</span> <span class="entity">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">p</span> <span class="entity">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">y</span> <span class="main">=&gt;</span> <span class="entity">result</span> <span class="entity">y</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">xs</span> <span class="main">=&gt;</span> 
                    <span class="entity">result</span> <span class="main">(</span>Seq.cons <span class="entity">x</span> <span class="entity">xs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">bracket</span> <span class="entity">openp</span> <span class="entity">p</span> <span class="entity">closep</span> <span class="main">=</span> <span class="entity">openp</span>  <span class="entity">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span>
                               <span class="entity">p</span>      <span class="entity">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span>
                               <span class="entity">closep</span> <span class="entity">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span>
                               <span class="entity">result</span> <span class="entity">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ints</span> <span class="main">=</span> <span class="entity">bracket</span> <span class="main">(</span><span class="entity">symbol</span> <span class="inner_quoted">"["</span><span class="main">)</span> <span class="main">(</span><span class="entity">int</span> <span class="entity">sepby1</span> <span class="entity">symbol</span> <span class="inner_quoted">","</span><span class="main">)</span> <span class="main">(</span><span class="entity">symbol</span> <span class="inner_quoted">"]"</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">infix</span></span> sepby<span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">p</span> <span class="entity">sepby</span> <span class="entity">sep</span> <span class="main">=</span> <span class="main">(</span><span class="entity">p</span> <span class="entity">sepby1</span> <span class="entity">sep</span><span class="main">)</span> <span class="entity">plus</span> <span class="entity">succ_many</span><span class="main">;</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">first</span> <span class="entity">p</span> <span class="entity">inp</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> Seq.pull <span class="main">(</span><span class="entity">p</span> <span class="entity">inp</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
    NONE        <span class="main">=&gt;</span> Seq.empty
  <span class="main">|</span> SOME <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> Seq.single <span class="entity">x</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">infix</span></span> +++<span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">p</span> <span class="entity">+++</span> <span class="entity">q</span> <span class="main">=</span> <span class="entity">first</span> <span class="main">(</span><span class="entity">p</span> <span class="entity">plus</span> <span class="entity">q</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">spaces</span>  <span class="main">=</span> <span class="entity">many1</span> <span class="main">(</span><span class="entity">sat</span> Symbol.is_space<span class="main">)</span> <span class="entity">&gt;&gt;=</span> K <span class="main">(</span><span class="entity">result</span> <span class="main">(</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">comment</span> <span class="main">=</span> <span class="entity">string</span> <span class="inner_quoted">"(*"</span> <span class="entity">&gt;&gt;=</span> <span class="main">(</span>K <span class="main">(</span>
                <span class="entity">many</span> <span class="main">(</span><span class="entity">sat</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span> <span class="entity">x</span> <span class="main">=</span> <span class="inner_quoted">")"</span> |&gt; not<span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="entity">&gt;&gt;=</span> K <span class="main">(</span><span class="entity">string</span> <span class="inner_quoted">")"</span><span class="main">)</span>
    <span class="entity">&gt;&gt;=</span> K <span class="main">(</span><span class="entity">result</span> <span class="main">(</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
  <span class="comment1">(*bracket (string "(*") (result ()) (string "*)");*)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">junk</span>    <span class="main">=</span> <span class="entity">many</span> <span class="main">(</span><span class="entity">spaces</span> <span class="entity">+++</span> <span class="entity">comment</span><span class="main">)</span> <span class="entity">&gt;&gt;=</span> K <span class="main">(</span><span class="entity">result</span> <span class="main">(</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">parse</span> <span class="entity">p</span> <span class="main">=</span> <span class="entity">junk</span> <span class="entity">&gt;&gt;=</span> K <span class="entity">p</span> <span class="entity">&gt;&gt;=</span> <span class="entity">result</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">token</span> <span class="entity">p</span> <span class="main">=</span> <span class="entity">p</span>    <span class="entity">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">v</span> <span class="main">=&gt;</span>
                <span class="entity">junk</span> <span class="entity">&gt;&gt;=</span> <span class="main">(</span>K <span class="main">(</span>
                <span class="entity">result</span> <span class="entity">v</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span></pre>
</div><div id="files/PSL_Parser.ML">
<div class="head">
<h1>File ‹PSL_Parser.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      PSL_Parser.ML
    Author:     Yutaka Nagashima, Data61, CSIRO

This file provides the monadic parser of PSL.
*)</span>

<span class="comment1">(*** PSL_PARSER: The PSL parser. ***)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">PSL_PARSER</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> strategy_parser   <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="main">(</span>string * <span class="entity">Monadic_Interpreter.str</span><span class="main">)</span> <span class="entity">Parser_Combinator.parser</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> invocation_parser <span class="main">:</span> string <span class="entity">Parser_Combinator.parser</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">LOOKUP</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> get_str <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string <span class="main">-&gt;</span> <span class="entity">Monadic_Prover.str</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(*** PSL_Parser: The PSL parser. ***)</span>
<span class="keyword1"><span class="keyword">functor</span></span> <span class="entity">mk_PSL_Parser</span> <span class="main">(</span>Lookup<span class="main">:</span><span class="entity">LOOKUP</span><span class="main">)</span> <span class="main">:</span> <span class="entity">PSL_PARSER</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="comment1">(*As PSL_Parser uses several functions from Parser_Combinator many times, "opening" that module
  improves the readability significantly.*)</span>
<span class="keyword3"><span class="keyword">open</span></span> Parser_Combinator<span class="main">;</span>
<span class="keyword1"><span class="keyword">infix</span></span> &gt;&gt;=<span class="main">;</span> <span class="comment1">(*from Parser_Combinator*)</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Mi</span> <span class="main">=</span> Monadic_Interpreter<span class="main">;</span>

<span class="comment1">(** strategy_parser **)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">strategy_parser</span> <span class="main">(</span><span class="entity">ctxt</span><span class="main">:</span><span class="entity">Proof.context</span><span class="main">)</span> <span class="main">=</span>

<span class="keyword2"><span class="keyword">let</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">parse_atomic</span> <span class="main">(</span><span class="entity">str</span><span class="main">:</span><span class="entity">Mi.str</span><span class="main">)</span> <span class="main">(</span><span class="entity">name</span><span class="main">:</span>string<span class="main">)</span> <span class="main">=</span> <span class="entity">string</span> <span class="entity">name</span> <span class="entity">&gt;&gt;=</span> <span class="main">(</span>K <span class="main">(</span><span class="entity">result</span> <span class="entity">str</span><span class="main">)</span><span class="main">)</span> <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span><span class="main">;</span>
<span class="comment1">(* prim_str *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parse_clarsimp</span>      <span class="main">=</span> <span class="entity">parse_atomic</span> <span class="entity">Mi.Clarsimp</span>     <span class="inner_quoted">"Clarsimp"</span>     <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parse_simp</span>          <span class="main">=</span> <span class="entity">parse_atomic</span> <span class="entity">Mi.Simp</span>         <span class="inner_quoted">"Simp"</span>         <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parse_blast</span>         <span class="main">=</span> <span class="entity">parse_atomic</span> <span class="entity">Mi.Blast</span>        <span class="inner_quoted">"Blast"</span>        <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parse_fastforce</span>     <span class="main">=</span> <span class="entity">parse_atomic</span> <span class="entity">Mi.Fastforce</span>    <span class="inner_quoted">"Fastforce"</span>    <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parse_auto</span>          <span class="main">=</span> <span class="entity">parse_atomic</span> <span class="entity">Mi.Auto</span>         <span class="inner_quoted">"Auto"</span>         <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parse_induct</span>        <span class="main">=</span> <span class="entity">parse_atomic</span> <span class="entity">Mi.Induct</span>       <span class="inner_quoted">"Induct"</span>       <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parse_induct_tac</span>    <span class="main">=</span> <span class="entity">parse_atomic</span> <span class="entity">Mi.InductTac</span>    <span class="inner_quoted">"InductTac"</span>    <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parse_coinduction</span>   <span class="main">=</span> <span class="entity">parse_atomic</span> <span class="entity">Mi.Coinduction</span>  <span class="inner_quoted">"Coinduction"</span>  <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parse_case</span>          <span class="main">=</span> <span class="entity">parse_atomic</span> <span class="entity">Mi.Cases</span>        <span class="inner_quoted">"Cases"</span>        <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parse_case_tac</span>      <span class="main">=</span> <span class="entity">parse_atomic</span> <span class="entity">Mi.CaseTac</span>      <span class="inner_quoted">"CaseTac"</span>      <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parse_rule</span>          <span class="main">=</span> <span class="entity">parse_atomic</span> <span class="entity">Mi.Rule</span>         <span class="inner_quoted">"Rule"</span>         <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parse_erule</span>         <span class="main">=</span> <span class="entity">parse_atomic</span> <span class="entity">Mi.Erule</span>        <span class="inner_quoted">"Erule"</span>        <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span><span class="main">;</span>
<span class="comment1">(* diagnostic command *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parse_hammer</span>        <span class="main">=</span> <span class="entity">parse_atomic</span> <span class="entity">Mi.Hammer</span>       <span class="inner_quoted">"Hammer"</span>       <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span><span class="main">;</span>
<span class="comment1">(* assertion strategy / diagnostic command *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parse_is_solved</span>     <span class="main">=</span> <span class="entity">parse_atomic</span> <span class="entity">Mi.IsSolved</span>     <span class="inner_quoted">"IsSolved"</span>     <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parse_quickcheck</span>    <span class="main">=</span> <span class="entity">parse_atomic</span> <span class="entity">Mi.Quickcheck</span>   <span class="inner_quoted">"Quickcheck"</span>   <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parse_nitpick</span>       <span class="main">=</span> <span class="entity">parse_atomic</span> <span class="entity">Mi.Nitpick</span>      <span class="inner_quoted">"Nitpick"</span>      <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span><span class="main">;</span>
<span class="comment1">(* special purpose *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parse_defer</span>         <span class="main">=</span> <span class="entity">parse_atomic</span> <span class="entity">Mi.Defer</span>        <span class="inner_quoted">"Defer"</span>        <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parse_subgoal</span>       <span class="main">=</span> <span class="entity">parse_atomic</span> <span class="entity">Mi.Subgoal</span>      <span class="inner_quoted">"Subgoal"</span>      <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parse_intro_classes</span> <span class="main">=</span> <span class="entity">parse_atomic</span> <span class="entity">Mi.IntroClasses</span> <span class="inner_quoted">"IntroClasses"</span> <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parse_transfer</span>      <span class="main">=</span> <span class="entity">parse_atomic</span> <span class="entity">Mi.Transfer</span>     <span class="inner_quoted">"Transfer"</span>     <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parse_normalization</span> <span class="main">=</span> <span class="entity">parse_atomic</span> <span class="entity">Mi.Normalization</span><span class="inner_quoted">"Normalization"</span><span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span><span class="main">;</span>
<span class="comment1">(* monadic strategic *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parse_skip</span>          <span class="main">=</span> <span class="entity">parse_atomic</span> <span class="entity">Mi.Skip</span>         <span class="inner_quoted">"Skip"</span>         <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parse_fail</span>          <span class="main">=</span> <span class="entity">parse_atomic</span> <span class="entity">Mi.Fail</span>         <span class="inner_quoted">"Fail"</span>         <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span><span class="main">;</span>

<span class="comment1">(* user-defined strategy *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">parse_str</span> <span class="main">(</span><span class="main">)</span>        <span class="main">=</span> <span class="entity">token</span> <span class="entity">word</span> <span class="entity">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">str_name</span> <span class="main">=&gt;</span> <span class="entity">Lookup.get_str</span> <span class="entity">ctxt</span> <span class="entity">str_name</span> |&gt; <span class="entity">result</span><span class="main">)</span>
                        <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">msum</span> <span class="main">=</span> List.foldr <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="entity">plus</span><span class="main">)</span> <span class="entity">zero</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">parse_strategy</span> <span class="main">(</span><span class="main">)</span> <span class="main">=</span>
  <span class="entity">msum</span>
    <span class="main">[</span><span class="entity">parse_clarsimp</span><span class="main">,</span>
     <span class="entity">parse_simp</span><span class="main">,</span>
     <span class="entity">parse_blast</span><span class="main">,</span>
     <span class="entity">parse_fastforce</span><span class="main">,</span>
     <span class="entity">parse_auto</span><span class="main">,</span>
     <span class="entity">parse_induct</span><span class="main">,</span>
     <span class="entity">parse_induct_tac</span><span class="main">,</span>
     <span class="entity">parse_coinduction</span><span class="main">,</span>
     <span class="entity">parse_case</span><span class="main">,</span>
     <span class="entity">parse_case_tac</span><span class="main">,</span>
     <span class="entity">parse_rule</span><span class="main">,</span>
     <span class="entity">parse_erule</span><span class="main">,</span>
     <span class="entity">parse_hammer</span><span class="main">,</span>
     <span class="entity">parse_is_solved</span><span class="main">,</span>
     <span class="entity">parse_quickcheck</span><span class="main">,</span>
     <span class="entity">parse_nitpick</span><span class="main">,</span>
     <span class="entity">parse_defer</span><span class="main">,</span>
     <span class="entity">parse_subgoal</span><span class="main">,</span>
     <span class="entity">parse_intro_classes</span><span class="main">,</span>
     <span class="entity">parse_transfer</span><span class="main">,</span>
     <span class="entity">parse_normalization</span><span class="main">,</span>
     <span class="entity">parse_dclarsimp</span> <span class="main">(</span><span class="main">)</span><span class="main">,</span>
     <span class="entity">parse_dsimp</span> <span class="main">(</span><span class="main">)</span><span class="main">,</span>
     <span class="entity">parse_dblast</span> <span class="main">(</span><span class="main">)</span><span class="main">,</span>
     <span class="entity">parse_dfastforce</span> <span class="main">(</span><span class="main">)</span><span class="main">,</span>
     <span class="entity">parse_dauto</span> <span class="main">(</span><span class="main">)</span><span class="main">,</span>
     <span class="entity">parse_dinduct</span> <span class="main">(</span><span class="main">)</span><span class="main">,</span>
     <span class="entity">parse_dinduct_tac</span> <span class="main">(</span><span class="main">)</span><span class="main">,</span>
     <span class="entity">parse_dcoinduction</span> <span class="main">(</span><span class="main">)</span><span class="main">,</span>
     <span class="entity">parse_dcases</span> <span class="main">(</span><span class="main">)</span><span class="main">,</span>
     <span class="entity">parse_dcase_tac</span> <span class="main">(</span><span class="main">)</span><span class="main">,</span>
     <span class="entity">parse_drule</span> <span class="main">(</span><span class="main">)</span><span class="main">,</span>
     <span class="entity">parse_derule</span> <span class="main">(</span><span class="main">)</span><span class="main">,</span>
     <span class="entity">parse_skip</span><span class="main">,</span>
     <span class="entity">parse_fail</span><span class="main">,</span>
     <span class="entity">parse_seq</span> <span class="main">(</span><span class="main">)</span><span class="main">,</span>
     <span class="entity">parse_alt</span> <span class="main">(</span><span class="main">)</span><span class="main">,</span>
     <span class="entity">parse_or</span> <span class="main">(</span><span class="main">)</span><span class="main">,</span>
     <span class="entity">parse_pseq</span> <span class="main">(</span><span class="main">)</span><span class="main">,</span>
     <span class="entity">parse_pseq1</span> <span class="main">(</span><span class="main">)</span><span class="main">,</span>
     <span class="entity">parse_por</span> <span class="main">(</span><span class="main">)</span><span class="main">,</span>
     <span class="entity">parse_palt</span> <span class="main">(</span><span class="main">)</span><span class="main">,</span>
     <span class="entity">parse_repeat</span> <span class="main">(</span><span class="main">)</span><span class="main">,</span>
     <span class="entity">parse_repeat_n</span> <span class="main">(</span><span class="main">)</span><span class="main">,</span>
     <span class="entity">parse_solve1</span> <span class="main">(</span><span class="main">)</span><span class="main">,</span>
     <span class="entity">parse_cut</span> <span class="main">(</span><span class="main">)</span><span class="main">,</span>
     <span class="entity">parse_user</span> <span class="main">(</span><span class="main">)</span><span class="main">,</span>
     <span class="entity">parse_str</span> <span class="main">(</span><span class="main">)</span><span class="main">]</span> <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span>

<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">parse_a_strategy_in_paren</span> <span class="main">(</span><span class="main">_</span><span class="main">)</span> <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span> <span class="main">=</span>
  <span class="entity">bracket</span>
    <span class="main">(</span><span class="entity">string</span> <span class="inner_quoted">"("</span> |&gt; <span class="entity">token</span><span class="main">)</span>
    <span class="main">(</span><span class="entity">parse_strategy</span> <span class="main">(</span><span class="main">)</span> |&gt; <span class="entity">token</span><span class="main">)</span>
    <span class="main">(</span><span class="entity">string</span> <span class="inner_quoted">")"</span> |&gt; <span class="entity">token</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">parse_strategic1</span> <span class="entity">constr</span> <span class="entity">name</span> <span class="main">=</span>
  <span class="entity">string</span> <span class="entity">name</span> |&gt; <span class="entity">token</span>                       <span class="entity">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">delayer</span><span class="main">:</span>string <span class="main">=&gt;</span>
  <span class="entity">parse_a_strategy_in_paren</span> <span class="entity">delayer</span> |&gt; <span class="entity">token</span> <span class="entity">&gt;&gt;=</span> <span class="main">(</span>
  <span class="entity">result</span> o <span class="entity">constr</span><span class="main">)</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">parse_repeat</span> <span class="main">(</span><span class="main">)</span>     <span class="main">=</span> <span class="entity">parse_strategic1</span> <span class="entity">Mi.RepNB</span>  <span class="inner_quoted">"Repeat"</span>  <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">parse_repeat_n</span> <span class="main">(</span><span class="main">)</span>   <span class="main">=</span> <span class="entity">parse_strategic1</span> <span class="entity">Mi.RepNT</span>  <span class="inner_quoted">"RepeatN"</span> <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">parse_solve1</span> <span class="main">(</span><span class="main">)</span>     <span class="main">=</span> <span class="entity">parse_strategic1</span> <span class="entity">Mi.Solve1</span> <span class="inner_quoted">"Solve1"</span>  <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">parse_cut</span> <span class="main">(</span><span class="main">)</span>        <span class="main">=</span>
  <span class="entity">string</span> <span class="inner_quoted">"Cut"</span> |&gt; <span class="entity">token</span> <span class="entity">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">delayer</span><span class="main">:</span>string <span class="main">=&gt;</span>
  <span class="entity">nat</span>          |&gt; <span class="entity">token</span> <span class="entity">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">limit</span><span class="main">:</span>int <span class="main">=&gt;</span>
  <span class="entity">parse_a_strategy_in_paren</span> <span class="entity">delayer</span> |&gt; <span class="entity">token</span> <span class="entity">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">str</span> <span class="main">=&gt;</span>
  <span class="main">(</span><span class="entity">limit</span><span class="main">,</span> <span class="entity">str</span><span class="main">)</span> |&gt; <span class="entity">Mi.Cut</span> |&gt; <span class="entity">result</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">parse_words_in_paren</span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">token</span>
  <span class="main">(</span><span class="entity">bracket</span>
    <span class="main">(</span><span class="entity">string</span> <span class="inner_quoted">"&lt;"</span> |&gt; <span class="entity">token</span><span class="main">)</span>
    <span class="main">(</span><span class="entity">many</span> <span class="main">(</span><span class="entity">sat</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span> <span class="entity">x</span> &lt;&gt; <span class="inner_quoted">"&gt;"</span> <span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="main">(</span><span class="entity">string</span> <span class="inner_quoted">"&gt;"</span> |&gt; <span class="entity">token</span><span class="main">)</span> <span class="entity">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">symbols</span> <span class="main">=&gt;</span>
  <span class="entity">symbols</span> |&gt; Seq.list_of |&gt; String.concat |&gt; <span class="entity">result</span><span class="main">)</span><span class="main">)</span><span class="main">:</span> string <span class="entity">parser</span>

<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">parse_user</span> <span class="main">(</span><span class="main">)</span> <span class="main">=</span>
  <span class="entity">string</span> <span class="inner_quoted">"User"</span>|&gt; <span class="entity">token</span>        <span class="entity">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">delayer</span> <span class="main">=&gt;</span>
  <span class="entity">parse_words_in_paren</span> <span class="entity">delayer</span> <span class="entity">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">tac_names</span> <span class="main">:</span> string <span class="main">=&gt;</span>
  <span class="entity">tac_names</span> |&gt; <span class="entity">Mi.User</span> |&gt; <span class="entity">result</span><span class="main">)</span><span class="main">)</span> <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span>

<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">parse_dynamic</span> <span class="entity">constr</span> <span class="entity">name</span> <span class="main">=</span>
  <span class="entity">token</span> <span class="main">(</span><span class="entity">string</span> <span class="inner_quoted">"Dynamic"</span><span class="main">)</span> <span class="entity">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span>
  <span class="entity">token</span> <span class="main">(</span><span class="entity">bracket</span> <span class="main">(</span><span class="entity">string</span> <span class="inner_quoted">"("</span> |&gt; <span class="entity">token</span><span class="main">)</span>
                 <span class="main">(</span><span class="entity">parse_atomic</span> <span class="entity">constr</span> <span class="entity">name</span> |&gt; <span class="entity">token</span><span class="main">)</span>
                 <span class="main">(</span><span class="entity">string</span> <span class="inner_quoted">")"</span> |&gt; <span class="entity">token</span><span class="main">)</span><span class="main">)</span> <span class="entity">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span>
  <span class="entity">result</span> <span class="entity">constr</span><span class="main">)</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">parse_dclarsimp</span> <span class="main">(</span><span class="main">)</span>    <span class="main">=</span> <span class="entity">parse_dynamic</span> <span class="entity">Mi.ParaClarsimp</span>    <span class="inner_quoted">"Clarsimp"</span>    <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">parse_dsimp</span> <span class="main">(</span><span class="main">)</span>        <span class="main">=</span> <span class="entity">parse_dynamic</span> <span class="entity">Mi.ParaSimp</span>        <span class="inner_quoted">"Simp"</span>        <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">parse_dblast</span> <span class="main">(</span><span class="main">)</span>       <span class="main">=</span> <span class="entity">parse_dynamic</span> <span class="entity">Mi.ParaBlast</span>       <span class="inner_quoted">"Blast"</span>       <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">parse_dfastforce</span> <span class="main">(</span><span class="main">)</span>   <span class="main">=</span> <span class="entity">parse_dynamic</span> <span class="entity">Mi.ParaFastforce</span>   <span class="inner_quoted">"Fastforce"</span>   <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">parse_dauto</span> <span class="main">(</span><span class="main">)</span>        <span class="main">=</span> <span class="entity">parse_dynamic</span> <span class="entity">Mi.ParaAuto</span>        <span class="inner_quoted">"Auto"</span>        <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">parse_dinduct</span> <span class="main">(</span><span class="main">)</span>      <span class="main">=</span> <span class="entity">parse_dynamic</span> <span class="entity">Mi.ParaInduct</span>      <span class="inner_quoted">"Induct"</span>      <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">parse_dinduct_tac</span> <span class="main">(</span><span class="main">)</span>  <span class="main">=</span> <span class="entity">parse_dynamic</span> <span class="entity">Mi.ParaInductTac</span>   <span class="inner_quoted">"InductTac"</span>   <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">parse_dcoinduction</span> <span class="main">(</span><span class="main">)</span> <span class="main">=</span> <span class="entity">parse_dynamic</span> <span class="entity">Mi.ParaCoinduction</span> <span class="inner_quoted">"Coinduction"</span> <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">parse_dcases</span> <span class="main">(</span><span class="main">)</span>       <span class="main">=</span> <span class="entity">parse_dynamic</span> <span class="entity">Mi.ParaCases</span>       <span class="inner_quoted">"Cases"</span>       <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">parse_dcase_tac</span> <span class="main">(</span><span class="main">)</span>    <span class="main">=</span> <span class="entity">parse_dynamic</span> <span class="entity">Mi.ParaCaseTac</span>     <span class="inner_quoted">"CaseTac"</span>     <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">parse_drule</span> <span class="main">(</span><span class="main">)</span>        <span class="main">=</span> <span class="entity">parse_dynamic</span> <span class="entity">Mi.ParaRule</span>        <span class="inner_quoted">"Rule"</span>        <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">parse_derule</span> <span class="main">(</span><span class="main">)</span>       <span class="main">=</span> <span class="entity">parse_dynamic</span> <span class="entity">Mi.ParaErule</span>       <span class="inner_quoted">"ERule"</span>       <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span>

<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">parse_strategies</span> <span class="main">_</span> <span class="main">:</span> <span class="entity">Mi.str</span> Seq.seq <span class="entity">parser</span> <span class="main">=</span>
  <span class="entity">bracket</span>
    <span class="main">(</span><span class="entity">string</span> <span class="inner_quoted">"["</span> |&gt; <span class="entity">token</span><span class="main">)</span>
    <span class="main">(</span><span class="entity">sepby1</span> <span class="main">(</span><span class="entity">parse_strategy</span> <span class="main">(</span><span class="main">)</span> |&gt; <span class="entity">token</span><span class="main">,</span> <span class="main">(</span><span class="entity">string</span> <span class="inner_quoted">","</span> |&gt; <span class="entity">token</span><span class="main">)</span><span class="main">)</span> |&gt; <span class="entity">token</span><span class="main">)</span>
    <span class="main">(</span><span class="entity">string</span> <span class="inner_quoted">"]"</span> |&gt; <span class="entity">token</span><span class="main">)</span> |&gt; <span class="entity">token</span>

<span class="comment1">(* Do not remove "delayer", or you get stuck in a loop. *)</span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">parse_strategic</span> <span class="entity">constr</span> <span class="entity">name</span> <span class="main">=</span>
  <span class="entity">token</span>
  <span class="main">(</span><span class="entity">string</span> <span class="entity">name</span> |&gt; <span class="entity">token</span>     <span class="entity">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">delayer</span> <span class="main">=&gt;</span>
   <span class="entity">parse_strategies</span> <span class="entity">delayer</span> <span class="entity">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">strategies</span> <span class="main">:</span> <span class="entity">Mi.str</span> Seq.seq <span class="main">=&gt;</span>
   <span class="entity">strategies</span> |&gt; <span class="entity">constr</span> |&gt; <span class="entity">result</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">parse_2_strategies</span> <span class="main">_</span> <span class="main">:</span> <span class="entity">Mi.str</span> Seq.seq <span class="entity">parser</span> <span class="main">=</span>
  <span class="entity">bracket</span>
    <span class="main">(</span><span class="entity">string</span> <span class="inner_quoted">"["</span> |&gt; <span class="entity">token</span><span class="main">)</span>
    <span class="main">(</span><span class="entity">parse_strategy</span> <span class="main">(</span><span class="main">)</span> |&gt; <span class="entity">token</span> <span class="entity">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span>
     <span class="entity">string</span> <span class="inner_quoted">","</span>        |&gt; <span class="entity">token</span> <span class="entity">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span>
     <span class="entity">parse_strategy</span> <span class="main">(</span><span class="main">)</span> |&gt; <span class="entity">token</span> <span class="entity">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">y</span> <span class="main">=&gt;</span>
     <span class="main">(</span><span class="entity">result</span> <span class="main">(</span>Seq.cons <span class="entity">x</span> <span class="main">(</span>Seq.single <span class="entity">y</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="main">(</span><span class="entity">string</span> <span class="inner_quoted">"]"</span> |&gt; <span class="entity">token</span><span class="main">)</span> |&gt; <span class="entity">token</span>

<span class="comment1">(* Do not remove "delayer", or you get stuck in a loop. *)</span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">parse_strategic_2</span> <span class="entity">constr</span> <span class="entity">name</span> <span class="main">=</span>
  <span class="entity">token</span>
  <span class="main">(</span><span class="entity">string</span> <span class="entity">name</span> |&gt; <span class="entity">token</span>       <span class="entity">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">delayer</span> <span class="main">=&gt;</span>
   <span class="entity">parse_2_strategies</span> <span class="entity">delayer</span> <span class="entity">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">strategies</span> <span class="main">:</span> <span class="entity">Mi.str</span> Seq.seq <span class="main">=&gt;</span>
   <span class="entity">strategies</span> |&gt; <span class="entity">constr</span> |&gt; <span class="entity">result</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">parse_or</span> <span class="main">(</span><span class="main">)</span>    <span class="main">=</span> <span class="entity">parse_strategic</span>   <span class="entity">Mi.Or</span>    <span class="inner_quoted">"Ors"</span>    <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">parse_alt</span> <span class="main">(</span><span class="main">)</span>   <span class="main">=</span> <span class="entity">parse_strategic</span>   <span class="entity">Mi.Alt</span>   <span class="inner_quoted">"Alts"</span>   <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">parse_seq</span> <span class="main">(</span><span class="main">)</span>   <span class="main">=</span> <span class="entity">parse_strategic</span>   <span class="entity">Mi.Seq</span>   <span class="inner_quoted">"Thens"</span>  <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">parse_por</span> <span class="main">(</span><span class="main">)</span>   <span class="main">=</span> <span class="entity">parse_strategic</span>   <span class="entity">Mi.POr</span>   <span class="inner_quoted">"POrs"</span>   <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">parse_palt</span> <span class="main">(</span><span class="main">)</span>  <span class="main">=</span> <span class="entity">parse_strategic</span>   <span class="entity">Mi.PAlt</span>  <span class="inner_quoted">"PAlts"</span>  <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">parse_pseq</span> <span class="main">(</span><span class="main">)</span>  <span class="main">=</span> <span class="entity">parse_strategic_2</span> <span class="entity">Mi.PSeq</span>  <span class="inner_quoted">"PThenAll"</span> <span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">parse_pseq1</span> <span class="main">(</span><span class="main">)</span> <span class="main">=</span> <span class="entity">parse_strategic_2</span> <span class="entity">Mi.PSeq1</span> <span class="inner_quoted">"PThenOne"</span><span class="main">:</span> <span class="entity">Mi.str</span> <span class="entity">parser</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parse_equality</span> <span class="main">=</span> <span class="entity">string</span> <span class="inner_quoted">"="</span> |&gt; <span class="entity">token</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parse_strategy_name</span> <span class="main">=</span> <span class="entity">token</span> <span class="entity">word</span>     <span class="entity">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">str_name</span> <span class="main">=&gt;</span>
                          <span class="entity">parse_equality</span> <span class="entity">&gt;&gt;=</span> K <span class="main">(</span>
                          <span class="entity">result</span> <span class="entity">str_name</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">in</span></span>

  <span class="entity">parse_strategy_name</span> <span class="entity">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">name</span><span class="main">:</span>string <span class="main">=&gt;</span>
  <span class="entity">parse_strategy</span> <span class="main">(</span><span class="main">)</span>   <span class="entity">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">strategy</span> <span class="main">=&gt;</span>
  <span class="entity">result</span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">strategy</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">invocation_parser</span> <span class="main">=</span> <span class="entity">token</span> <span class="entity">word</span> <span class="entity">&gt;&gt;=</span> <span class="entity">result</span> <span class="main">:</span> string <span class="entity">parser</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span></pre>
</div><div id="files/Isar_Interface.ML">
<div class="head">
<h1>File ‹Isar_Interface.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Isar_Interface.ML
    Author:     Yutaka Nagashima, Data61, CSIRO

This file provides the Isar-level interface of PSL.
One can activate the interfaces by calling the function, "PSL_Interface.activate_isar_interface ()".
*)</span>

<span class="comment1">(*** PSL_INTERFACE: One can define new strategies only through the Isar interface. ***)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">PSL_INTERFACE</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> activate_isar_interface <span class="main">:</span> unit <span class="main">-&gt;</span> unit<span class="main">;</span>
  <span class="comment1">(* "strategy" and "try_hard_strategy" have to be exposed,
   *  so that Mirabelle can use it without exposing "lookup". *)</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">strategy</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> try_hard_strategy       <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">strategy</span> option<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> try_parallel_strategy   <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">strategy</span> option<span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(*** PSL_Interface: One can define new strategies only through the Isar interface. ***)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">PSL_Interface</span> <span class="main">:</span> <span class="entity">PSL_INTERFACE</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Mp</span> <span class="main">=</span> Monadic_Prover<span class="main">;</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Pc</span>  <span class="main">=</span> Parser_Combinator<span class="main">;</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">strategy</span> <span class="main">=</span> <span class="entity">Mp.str</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Data</span> <span class="main">=</span> Generic_Data
<span class="main">(</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">strategy</span> Symtab.table<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">empty</span>  <span class="main">=</span> Symtab.empty <span class="main">:</span> <span class="entity">T</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">extend</span> <span class="main">=</span> I<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">merge</span>  <span class="main">=</span> Symtab.merge <span class="main">(</span>K true<span class="main">)</span><span class="main">;</span>
<span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">lookup</span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="main">(</span>Symtab.lookup o Data.get<span class="main">)</span> <span class="main">(</span>Context.Proof <span class="entity">ctxt</span><span class="main">)</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">update</span> <span class="entity">k</span> <span class="entity">v</span>  <span class="main">=</span> Data.map <span class="main">(</span>Symtab.update_new <span class="main">(</span><span class="entity">k</span><span class="main">,</span> <span class="entity">v</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Lookup</span> <span class="main">:</span> <span class="entity">LOOKUP</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_str</span> <span class="entity">ctxt</span> <span class="entity">name</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">some_str</span> <span class="main">=</span> <span class="entity">lookup</span> <span class="entity">ctxt</span> <span class="entity">name</span> <span class="main">:</span> <span class="entity">Mp.str</span> option<span class="main">;</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">strategy</span> <span class="main">=</span> <span class="entity">Utils.the'</span> <span class="main">(</span><span class="entity">name</span> ^ <span class="inner_quoted">"?\nDid you really define such a strategy?\n"</span>
        ^ <span class="inner_quoted">"Also, you should not forget that PThenOne and PThenAll take *exactly* two sub-strategies!"</span><span class="main">)</span>
        <span class="entity">some_str</span> <span class="main">:</span> <span class="entity">Mp.str</span><span class="main">;</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">strategy</span>
    <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">PSL_Parser</span> <span class="main">=</span> <span class="entity">mk_PSL_Parser</span><span class="main">(</span><span class="entity">Lookup</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">put_strategy</span> <span class="main">(</span><span class="entity">name</span><span class="main">:</span>string<span class="main">,</span> <span class="entity">str</span><span class="main">:</span><span class="entity">strategy</span><span class="main">)</span> <span class="main">=</span> <span class="entity">update</span> <span class="entity">name</span> <span class="entity">str</span>
  |&gt; Context.theory_map
  |&gt; Local_Theory.background_theory<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tokens_to_string</span> <span class="entity">tokens</span> <span class="main">=</span> <span class="entity">tokens</span> |&gt; map Token.unparse |&gt; String.concatWith <span class="inner_quoted">" "</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">string_parser_to_token_parser</span> <span class="main">(</span><span class="entity">symbols_parser</span><span class="main">:</span>'a <span class="entity">Pc.parser</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">tokens</span><span class="main">:</span>Token.T list<span class="main">)</span> <span class="main">=&gt;</span>
  <span class="entity">tokens</span>
  |&gt; <span class="entity">tokens_to_string</span>
  |&gt; Symbol.explode
  |&gt; <span class="entity">symbols_parser</span>
  |&gt; Seq.hd
  <span class="comment1">(*This function assumes that the string_parser consumes the entire string.*)</span>
  |&gt; apsnd <span class="main">(</span>K <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">:</span> 'a Token.parser<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">parse_strategy_def_tokens</span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="entity">string_parser_to_token_parser</span> <span class="main">(</span><span class="entity">PSL_Parser.strategy_parser</span> <span class="entity">ctxt</span><span class="main">)</span>
  <span class="main">:</span> <span class="main">(</span>string * <span class="entity">Mp.str</span><span class="main">)</span> Token.parser<span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parse_and_put_strategy_def</span> <span class="main">:</span> <span class="main">(</span>local_theory <span class="main">-&gt;</span> local_theory<span class="main">)</span> Token.parser <span class="main">=</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">tokens</span> <span class="main">=&gt;</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_token_parser</span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="entity">parse_strategy_def_tokens</span> <span class="entity">ctxt</span> <span class="main">:</span> <span class="main">(</span>string * <span class="entity">Mp.str</span><span class="main">)</span> Token.parser<span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_token_p_result</span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="entity">get_token_parser</span> <span class="entity">ctxt</span> <span class="entity">tokens</span> |&gt; fst <span class="main">:</span> string * <span class="entity">Mp.str</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">put_str_in_lthy</span> <span class="main">(</span><span class="entity">lthy</span><span class="main">:</span>local_theory<span class="main">)</span> <span class="main">=</span> <span class="entity">put_strategy</span> <span class="main">(</span><span class="entity">get_token_p_result</span> <span class="entity">lthy</span><span class="main">)</span> <span class="entity">lthy</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
  <span class="main">(</span><span class="entity">put_str_in_lthy</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_monad_tactic</span> <span class="main">(</span><span class="entity">strategy</span><span class="main">:</span><span class="entity">strategy</span><span class="main">)</span> <span class="main">(</span><span class="entity">proof_state</span><span class="main">:</span><span class="entity">Proof.state</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">core_tac</span>  <span class="main">=</span> <span class="entity">Mp.desugar</span> <span class="entity">strategy</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">interpret</span> <span class="main">=</span> <span class="entity">Mp.interpret</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">hard_timeout_in</span> <span class="main">(</span><span class="entity">sec</span><span class="main">:</span>real<span class="main">)</span> <span class="main">=</span> Timeout.apply <span class="main">(</span>seconds <span class="entity">sec</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">hard_timeout_in</span> <span class="inner_numeral">60000.0</span>
    <span class="main">(</span><span class="entity">interpret</span> <span class="main">(</span><span class="entity">Mp.eval_prim</span><span class="main">,</span> <span class="entity">Mp.eval_para</span><span class="main">,</span> <span class="entity">Mp.eval_strategic</span><span class="main">,</span> <span class="entity">Mp.m_equal</span><span class="main">,</span> <span class="entity">Mp.iddfc</span><span class="main">,</span> <span class="main">(</span><span class="inner_numeral">5</span><span class="main">,</span><span class="inner_numeral">20</span><span class="main">)</span><span class="main">)</span>
                <span class="entity">core_tac</span><span class="main">)</span> <span class="entity">proof_state</span>
  <span class="keyword2"><span class="keyword">end</span></span> <span class="main">:</span> <span class="entity">Proof.state</span> <span class="entity">Mp.monad</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">trans_trans</span> <span class="main">=</span> <span class="entity">Toplevel.transition</span> <span class="main">-&gt;</span> <span class="entity">Toplevel.transition</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">strategy_invocation_parser</span> <span class="main">=</span> <span class="entity">PSL_Parser.invocation_parser</span> <span class="main">:</span> string <span class="entity">Pc.parser</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">local</span></span>

<span class="keyword1"><span class="keyword">infix</span></span> &gt;&gt;=<span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="keyword1"><span class="keyword">op</span></span> <span class="entity">&gt;&gt;=</span> <span class="main">=</span>  <span class="entity">Parser_Combinator.&gt;&gt;=</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">in</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">invocation_parser_to_trans_trans_parser</span> <span class="main">(</span><span class="entity">inv_p</span> <span class="main">:</span> string <span class="entity">Pc.parser</span><span class="main">)</span>
  <span class="main">(</span><span class="entity">get_trans_trans</span> <span class="main">:</span> string <span class="main">-&gt;</span> <span class="entity">trans_trans</span><span class="main">)</span> <span class="main">=</span>
  <span class="entity">string_parser_to_token_parser</span> <span class="main">(</span><span class="entity">inv_p</span> <span class="entity">&gt;&gt;=</span> <span class="main">(</span><span class="entity">Pc.result</span> o <span class="entity">get_trans_trans</span><span class="main">)</span><span class="main">)</span> <span class="main">:</span> <span class="entity">trans_trans</span> Token.parser<span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_trans_trans</span> <span class="main">(</span><span class="entity">strategy_name</span><span class="main">:</span>string<span class="main">)</span> <span class="main">=</span>
      <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">Toplevel.keep_proof</span><span class="main">:</span><span class="main">(</span><span class="entity">Toplevel.state</span> <span class="main">-&gt;</span> unit<span class="main">)</span> <span class="main">-&gt;</span> <span class="entity">trans_trans</span><span class="main">)</span>
        <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">top</span> <span class="main">=&gt;</span>
         <span class="keyword2"><span class="keyword">let</span></span>
           <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">log</span>          <span class="main">=</span> <span class="entity">Dynamic_Utils.log</span><span class="main">;</span>
           <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lmap</span>          <span class="main">=</span> Seq.map<span class="main">;</span>
           <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">context</span>       <span class="main">=</span> <span class="entity">Toplevel.context_of</span> <span class="entity">top</span> <span class="main">:</span> <span class="entity">Proof.context</span><span class="main">;</span>
           <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">some_strategy</span> <span class="main">=</span> <span class="entity">lookup</span> <span class="entity">context</span> <span class="entity">strategy_name</span><span class="main">;</span>
           <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">strategy</span>      <span class="main">=</span> <span class="entity">Utils.the'</span> <span class="main">(</span><span class="entity">strategy_name</span> ^ <span class="inner_quoted">"? You haven't defined such a strategy!"</span><span class="main">)</span>
                               <span class="entity">some_strategy</span><span class="main">;</span>
           <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tactic</span>        <span class="main">=</span> <span class="entity">get_monad_tactic</span> <span class="entity">strategy</span> <span class="main">:</span> <span class="entity">Proof.state</span> <span class="entity">Mp.stttac</span><span class="main">;</span>
           <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">proof_state</span>   <span class="main">=</span> <span class="entity">Toplevel.proof_of</span> <span class="entity">top</span><span class="main">;</span>
           <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">results'</span>      <span class="main">=</span> <span class="entity">tactic</span> <span class="entity">proof_state</span>     <span class="main">:</span> <span class="entity">Proof.state</span> <span class="entity">Mp.monad</span><span class="main">;</span>
           <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">results</span>       <span class="main">=</span> <span class="entity">results'</span> <span class="main">[</span><span class="main">]</span>            <span class="main">:</span> <span class="main">(</span><span class="entity">log</span> * <span class="entity">Proof.state</span><span class="main">)</span> Seq.seq<span class="main">;</span>
           <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">logs</span>          <span class="main">=</span> <span class="entity">lmap</span> fst <span class="entity">results</span>       <span class="main">:</span> <span class="entity">log</span> Seq.seq<span class="main">;</span>
           <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">applies</span>       <span class="main">=</span> <span class="entity">lmap</span> <span class="entity">Dynamic_Utils.mk_apply_script</span> <span class="entity">logs</span><span class="main">;</span>
           <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">print</span>         <span class="main">=</span> writeln <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> Seq.pull <span class="entity">applies</span> <span class="keyword2"><span class="keyword">of</span></span>
             NONE <span class="main">=&gt;</span> error <span class="inner_quoted">"empty sequence. no proof found."</span>
           <span class="main">|</span> SOME <span class="main">_</span> <span class="main">=&gt;</span> Seq.hd <span class="entity">applies</span><span class="main">)</span><span class="main">;</span>
         <span class="keyword2"><span class="keyword">in</span></span>
           <span class="entity">print</span>
         <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>
       <span class="main">)</span><span class="main">:</span><span class="entity">trans_trans</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">activate_isar_interface</span> <span class="main">_</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">Outer_Syntax.local_theory</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">command_keyword</span> <span class="keyword1">strategy</span><span class="antiquote">}</span></span></span> <span class="inner_quoted">"PSL strategy definition"</span>
      <span class="entity">parse_and_put_strategy_def</span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
      <span class="entity">Outer_Syntax.command</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">command_keyword</span> <span class="keyword1">find_proof</span><span class="antiquote">}</span></span></span>
        <span class="inner_quoted">"find_proof tries to find a proof based on high level strategies provided in advance.."</span>
        <span class="main">(</span><span class="entity">invocation_parser_to_trans_trans_parser</span> <span class="entity">strategy_invocation_parser</span> <span class="entity">get_trans_trans</span><span class="main">)</span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
      <span class="entity">Outer_Syntax.command</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">command_keyword</span> <span class="keyword1">try_hard</span><span class="antiquote">}</span></span></span>
       <span class="inner_quoted">"try_hard to find efficient proof-scripts."</span>
       <span class="main">(</span>Scan.succeed <span class="main">(</span><span class="entity">get_trans_trans</span> <span class="inner_quoted">"Try_Hard"</span><span class="main">)</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
      <span class="entity">Outer_Syntax.command</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">command_keyword</span> <span class="keyword1">try_hard_one</span><span class="antiquote">}</span></span></span>
       <span class="inner_quoted">"try_hard to find efficient proof-scripts."</span>
       <span class="main">(</span>Scan.succeed <span class="main">(</span><span class="entity">get_trans_trans</span> <span class="inner_quoted">"Try_Hard_One"</span><span class="main">)</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
      <span class="entity">Outer_Syntax.command</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">command_keyword</span> <span class="keyword1">try_hard_all</span><span class="antiquote">}</span></span></span>
       <span class="inner_quoted">"try_hard to find efficient proof-scripts."</span>
       <span class="main">(</span>Scan.succeed <span class="main">(</span><span class="entity">get_trans_trans</span> <span class="inner_quoted">"Try_Hard_All"</span><span class="main">)</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
      <span class="entity">Outer_Syntax.command</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">command_keyword</span> <span class="keyword1">try_parallel</span><span class="antiquote">}</span></span></span>
       <span class="inner_quoted">"try_hard to find efficient proof-scripts."</span>
       <span class="main">(</span>Scan.succeed <span class="main">(</span><span class="entity">get_trans_trans</span> <span class="inner_quoted">"Try_Parallel"</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">try_hard_strategy</span>     <span class="main">(</span><span class="entity">ctxt</span><span class="main">:</span><span class="entity">Proof.context</span><span class="main">)</span> <span class="main">=</span> <span class="entity">lookup</span> <span class="entity">ctxt</span> <span class="inner_quoted">"Try_Hard"</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">try_parallel_strategy</span> <span class="main">(</span><span class="entity">ctxt</span><span class="main">:</span><span class="entity">Proof.context</span><span class="main">)</span> <span class="main">=</span> <span class="entity">lookup</span> <span class="entity">ctxt</span> <span class="inner_quoted">"Try_Parallel"</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(*** activate the Isar interface of PSL. ***)</span>
<span class="entity">PSL_Interface.activate_isar_interface</span> <span class="main">(</span><span class="main">)</span><span class="main">;</span></pre>
</div><div id="PSL">
<div class="head">
<h1>Theory PSL</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      PSL.thy
    Author:     Yutaka Nagashima, Data61, CSIRO

Import this file to install PSL. That is all you need to do to install PSL.
See ./Example.thy for examples.
*)</span>

<span class="keyword1"><span class="command">theory</span></span> PSL
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Try_Hard.html">Try_Hard</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Uncomment the following to unleash the power parallelism.›</span></span>

<span class="comment1">(*
ML{* Multithreading.max_threads_update 28 *}
ML{* Goal.parallel_proofs := 0 *}
*)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Example">
<div class="head">
<h1>Theory Example</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      PSL.ML
    Author:     Yutaka Nagashima, Data61, CSIRO

This file contains small examples showing how to use PSL and its default strategy try-hard.
These examples are kept intentionally simple for illustration purposes.
See other files from AFP for more involved examples.
*)</span>

<span class="keyword1"><span class="command">theory</span></span> Example
<span class="keyword2"><span class="keyword">imports</span></span> <a href="PSL.html">PSL</a> <span class="quoted">"<a href="../../HOL/HOL-Eisbach/Eisbach.html">HOL-Eisbach.Eisbach</a>"</span> 
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(* The "Hammer" strategy invokes sledgehammer as a sub-tool. *)</span>
<span class="keyword1"><span class="command">strategy</span></span> Hammer1 <span class="main">=</span> Hammer
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"True <span class="main">∨</span> False"</span></span>
<span class="keyword1"><span class="command">find_proof</span></span> Hammer1
<span class="keyword1"><span class="command">oops</span></span>

<span class="comment1">(* Previously defined strategies can be used to define new strategies. *)</span>
<span class="keyword1"><span class="command">strategy</span></span> Hammer2 <span class="main">=</span> Hammer1
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"True <span class="main">∨</span> False"</span></span>
<span class="keyword1"><span class="command">find_proof</span></span> Hammer2
<span class="keyword1"><span class="command">oops</span></span>

<span class="comment1">(* The "POrs" and "PAlts" combinators exploit parallelism.*)</span>
<span class="keyword1"><span class="command">strategy</span></span> Test_POrs <span class="main">=</span> POrs <span class="main">[</span>Fastforce<span class="main">,</span> Hammer<span class="main">]</span>
<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span>"</span></span>
<span class="keyword1"><span class="command">find_proof</span></span> Test_POrs
<span class="keyword1"><span class="command">oops</span></span>
<span class="keyword1"><span class="command">strategy</span></span> Test_PAlts <span class="main">=</span> Thens <span class="main">[</span>PAlts <span class="main">[</span>Fastforce<span class="main">,</span> Hammer<span class="main">]</span><span class="main">,</span> IsSolved<span class="main">]</span>
<span class="keyword1"><span class="command">lemma</span></span>
 <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span>"</span></span>
<span class="keyword1"><span class="command">find_proof</span></span> Test_PAlts
<span class="keyword1"><span class="command">oops</span></span>

<span class="comment1">(* The "User &lt; &gt;" syntax allows PSL to employ proof-methods defined by users via Eisbach inside
 * a proof strategy. *)</span>
<span class="keyword1"><span class="command">method</span></span> my_simp <span class="main">=</span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">strategy</span></span> UserSimp <span class="main">=</span> User <span class="main">&lt;</span>my_simp&gt;
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"True <span class="main">∧</span> True <span class="main">∨</span> False"</span></span>
<span class="keyword1"><span class="command">find_proof</span></span> UserSimp
<span class="keyword1"><span class="command">oops</span></span>

<span class="comment1">(* By combining Eisbach and "User &lt; &gt;", we can use Eisbach methods as conditions to apply strategies.*)</span>
<span class="keyword1"><span class="command">method</span></span> if_match <span class="main">=</span> <span class="main">(</span><span class="operator">match</span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">conclusion</span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">P</span><span class="main">::</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">Q</span><span class="main">::</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">for</span></span></span> <span class="free">P</span> <span class="free">Q</span> <span class="main"><span class="main">⇒</span></span> <span class="quoted">‹<span class="operator">succeed</span>›</span><span class="main">)</span>
<span class="keyword1"><span class="command">strategy</span></span> IfMatchRuleExt <span class="main">=</span> Thens <span class="main">[</span>User <span class="main">&lt;</span>if_match&gt;<span class="main">,</span> User <span class="main">&lt;</span>rule ext&gt;<span class="main">]</span>

<span class="keyword1"><span class="command">consts</span></span> <span class="quoted">"QQ"</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span>"</span></span>
<span class="keyword1"><span class="command">consts</span></span> <span class="quoted">"PP"</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"QQ <span class="main">=</span> PP"</span></span>
<span class="keyword1"><span class="command">find_proof</span></span> IfMatchRuleExt
<span class="keyword1"><span class="command">oops</span></span>

<span class="comment1">(* One can also call the default proof methods via the "User" strategy. *)</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">my_foo</span> <span class="main">≡</span> True"</span></span>
<span class="keyword1"><span class="command">strategy</span></span> UserSimp2 <span class="main">=</span> Thens <span class="main">[</span>User <span class="main">&lt;</span> simp add<span class="main">:</span> my_foo_def<span class="main">(</span>1<span class="main">)</span> &gt;<span class="main">,</span> IsSolved<span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"my_foo"</span></span>
<span class="keyword1"><span class="command">find_proof</span></span> UserSimp2
<span class="keyword1"><span class="command">oops</span></span>

<span class="comment1">(* When having meta-quantified variables, "CaseTac" tends to be more useful than "Cases".*)</span>
<span class="keyword1"><span class="command">strategy</span></span> CaseTac <span class="main">=</span> Thens <span class="main">[</span>Dynamic <span class="main">(</span>CaseTac<span class="main">)</span><span class="main">,</span> Auto<span class="main">,</span> IsSolved<span class="main">]</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span> <span class="main">.</span><span class="main">(</span><span class="main">(</span><span class="keyword1">case</span> <span class="bound">xs</span> <span class="keyword1">of</span> <span class="main">[]</span> <span class="main">⇒</span> <span class="main">[]</span> <span class="main">|</span> <span class="bound">y</span><span class="main">#</span><span class="bound">ys</span> <span class="main">⇒</span> <span class="bound">xs</span><span class="main">)</span> <span class="main">=</span> <span class="bound">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">find_proof</span></span> CaseTac
<span class="keyword1"><span class="command">oops</span></span>

<span class="comment1">(* The "IsSolved" strategy creates the "done" Isar-command upon success. *)</span>
<span class="keyword1"><span class="command">strategy</span></span> MultiFF <span class="main">=</span> Thens <span class="main">[</span>Fastforce<span class="main">,</span> IsSolved<span class="main">,</span> Fastforce<span class="main">,</span> IsSolved<span class="main">]</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"True"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"True"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
<span class="keyword1"><span class="command">find_proof</span></span> MultiFF
<span class="keyword1"><span class="command">oops</span></span>

<span class="comment1">(* The "Subgoal" strategy narrow the scope to the first sub-goal. *)</span>
<span class="keyword1"><span class="command">strategy</span></span> Auto2 <span class="main">=</span> Thens <span class="main">[</span>Subgoal<span class="main">,</span> Auto<span class="main">,</span> IsSolved<span class="main">,</span> Subgoal<span class="main">,</span> Auto<span class="main">,</span> IsSolved<span class="main">]</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"True"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"True"</span></span>
<span class="keyword1"><span class="command">find_proof</span></span> Auto2
<span class="keyword1"><span class="command">oops</span></span>

<span class="comment1">(* Users can employ the default strategy with a single command "try_hard".*)</span>
<span class="keyword1"><span class="command">inductive</span></span> <span class="entity">foo</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">foo</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span>"</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"foo <span class="numeral">8</span> <span class="numeral">90</span>"</span></span>
<span class="keyword1"><span class="command">find_proof</span></span> Hammer1
<span class="keyword1"><span class="command">try_hard</span></span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="free">D</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="main">⟶</span> <span class="free">B</span> <span class="main">∨</span> <span class="free">C</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">D</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">D</span>"</span></span>
<span class="keyword1"><span class="command">try_hard</span></span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="comment1">(* The "Skip" strategy always succeeds, while the "Fail" strategy always returns an empty sequence. *)</span>
<span class="keyword1"><span class="command">strategy</span></span> my_strategy <span class="main">=</span> Thens <span class="main">[</span>Skip<span class="main">,</span> Alts <span class="main">[</span>Fail<span class="main">,</span> Ors <span class="main">[</span>Fail<span class="main">,</span> Hammer<span class="main">]</span><span class="main">]</span><span class="main">]</span>
<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">B</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="main">∧</span> <span class="main">(</span>True <span class="main">∨</span> False<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">find_proof</span></span> my_strategy
<span class="keyword1"><span class="command">oops</span></span>

<span class="comment1">(* The "Defer" combinator send the first sub-goal to the end of the list of sub-goals.*)</span>
<span class="comment1">(* By deferring difficult sub-goals using the "Defer" combinator while discharging easy ones
 * automatically, human engineers can focus on meaningful parts of their problems. *)</span>
<span class="keyword1"><span class="command">strategy</span></span> Simps <span class="main">=</span>  RepeatN <span class="main">(</span> Ors <span class="main">[</span>Simp<span class="main">,</span> Defer<span class="main">]</span> <span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"True"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"False"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"True"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"True"</span></span>
<span class="keyword1"><span class="command">find_proof</span></span> Simps
<span class="keyword1"><span class="command">oops</span></span>

<span class="comment1">(* By combining "Defer" and "Hammer", we can discharge some proof obligations automatically with
 * sledgehammer, while deferring "difficult" problems.  *)</span>
<span class="keyword1"><span class="command">strategy</span></span> Hammer_Or_Defer <span class="main">=</span>  RepeatN <span class="main">(</span> Ors <span class="main">[</span>Hammer<span class="main">,</span> Thens<span class="main">[</span>Quickcheck<span class="main">,</span> Defer<span class="main">]</span><span class="main">]</span><span class="main">)</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">safe_state</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">≡</span> True"</span></span>
<span class="keyword1"><span class="command">lemma</span></span> state_safety<span class="main">:</span><span class="quoted"><span class="quoted">"safe_state <span class="main">(</span><span class="free">x</span><span class="main">::</span>bool<span class="main">)</span> <span class="main">(</span><span class="free">y</span><span class="main">::</span>bool<span class="main">)</span> <span class="main">=</span> True"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">normalization</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">ps_safe</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">::</span>bool<span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">::</span>bool<span class="main">)</span> <span class="main">≡</span> safe_state True True"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">valid_trans</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">s'</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≡</span> undefined"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> cnjct2<span class="main">:</span>
<span class="keyword2"><span class="keyword">shows</span></span> 1<span class="main">:</span><span class="quoted"><span class="quoted">"ps_safe <span class="free">p</span> <span class="free">s</span>"</span></span>
 <span class="keyword2"><span class="keyword">and</span></span>  2<span class="main">:</span><span class="quoted"><span class="quoted">"valid_trans <span class="free">p</span> <span class="free">s</span> <span class="free">s'</span> <span class="free">x</span>"</span></span>
 <span class="keyword2"><span class="keyword">and</span></span>  3<span class="main">:</span><span class="quoted"><span class="quoted">"ps_safe <span class="free">p</span> <span class="free">s'</span>"</span></span>
<span class="keyword1"><span class="command">find_proof</span></span> Hammer_Or_Defer <span class="comment1">(* very slow *)</span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="comment1">(* The "Cut" combinator restricts non-determinism by pruning branches. *)</span>
<span class="keyword1"><span class="command">strategy</span></span> testCut <span class="main">=</span> Thens <span class="main">[</span>Repeat <span class="main">(</span>Cut 10 <span class="main">(</span>Dynamic <span class="main">(</span>Rule<span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> IsSolved<span class="main">]</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"True <span class="main">∧</span> True"</span></span>
<span class="keyword1"><span class="command">find_proof</span></span> testCut
<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div>