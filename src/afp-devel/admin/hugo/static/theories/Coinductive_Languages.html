<div id="Coinductive_Language">
<div class="head"><h1>Theory Coinductive_Language</h1>
<span class="command">theory</span> <span class="name">Coinductive_Language</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Author: Dmitriy Traytel *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A Codatatype of Formal Languages›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Coinductive_Language</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">hide_const</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="delimiter">)</span><span> </span><span>Inter</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Introduction›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
We define formal languages as a codataype of infinite trees branching over the
alphabet @{typ 'a}. Each node in such a tree indicates whether the path to this
node constitutes a word inside or outside of the language.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">codatatype</span></span><span> </span><span class="tfree">'a</span><span> </span><span>language</span><span> </span><span class="delimiter">=</span><span> </span><span>Lang</span><span> </span><span class="delimiter">(</span><span>𝔬</span><span class="delimiter">:</span><span> </span><span>bool</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>𝔡</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a language"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
This codatatype is isormorphic to the set of lists representation of languages,
but caters for definitions by corecursion and proofs by coinduction.

Regular operations on languages are then defined by primitive corecursion.
A difficulty arises here, since the standard definitions of concatenation and
iteration from the coalgebraic literature are not primitively corecursive---they
require guardedness up-to union/concatenation. Without support for up-to corecursion,
these operation must be defined as a composition of primitive ones (and proved being
equal to the standard definitions). As an exercise in coinduction we also prove the
axioms of Kleene algebra for the defined regular operations.

Furthermore, a language for context-free grammars given by productions in Greibach
normal form and an initial nonterminal is constructed by primitive corecursion,
yielding an executable decision procedure for the word problem without further ado.
›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* custom coinduction theorem (getting rid of rel_fun) *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>language.coinduct_strong</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>rel_fun_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">,</span><span> </span><span>case_names</span><span> </span><span>Lang</span><span class="delimiter">,</span><span> </span><span>coinduct</span><span> </span><span>pred</span><span class="delimiter">]</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Regular Languages›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primcorec</span></span><span> </span><span>Zero</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a language"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"𝔬 Zero = False"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔡 Zero = (λ_. Zero)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primcorec</span></span><span> </span><span>One</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a language"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"𝔬 One = True"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔡 One = (λ_. Zero)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primcorec</span></span><span> </span><span>Atom</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a language"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"𝔬 (Atom a) = False"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔡 (Atom a) = (λb. if a = b then One else Zero)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primcorec</span></span><span> </span><span>Plus</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a language ⇒ 'a language ⇒ 'a language"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"𝔬 (Plus r s) = (𝔬 r ∨ 𝔬 s)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔡 (Plus r s) = (λa. Plus (𝔡 r a) (𝔡 s a))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>Plus_ZeroL</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Plus Zero r = r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>Plus_ZeroR</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Plus r Zero = r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>Plus_assoc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Plus (Plus r s) t = Plus r (Plus s t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span> </span><span>s</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>Plus_comm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Plus r s = Plus s r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Plus_rotate</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Plus r (Plus s t) = Plus s (Plus r t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Plus_assoc</span><span> </span><span>Plus_comm</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>Plus_idem</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Plus r r = r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Plus_idem_assoc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Plus r (Plus r s) = Plus r s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Plus_assoc</span><span> </span><span>Plus_idem</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>Plus_ACI</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>Plus_rotate</span><span> </span><span>Plus_comm</span><span> </span><span>Plus_assoc</span><span> </span><span>Plus_idem_assoc</span><span> </span><span>Plus_idem</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Plus_OneL</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔬 r ⟹ Plus One r = r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Plus_OneR</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔬 r ⟹ Plus r One = r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Concatenation is not primitively corecursive---the corecursive call of its derivative is
  guarded by @{term Plus}. However, it can be defined as a composition of two primitively
  corecursive functions.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primcorec</span></span><span> </span><span>TimesLR</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a language ⇒ 'a language ⇒ ('a × bool) language"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"𝔬 (TimesLR r s) = (𝔬 r ∧ 𝔬 s)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔡 (TimesLR r s) = (λ(a, b).
   if b then TimesLR (𝔡 r a) s else if 𝔬 r then TimesLR (𝔡 s a) One else Zero)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primcorec</span></span><span> </span><span>Times_Plus</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a × bool) language ⇒ 'a language"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"𝔬 (Times_Plus r) = 𝔬 r"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔡 (Times_Plus r) = (λa. Times_Plus (Plus (𝔡 r (a, True)) (𝔡 r (a, False))))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>TimesLR_ZeroL</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"TimesLR Zero r = Zero"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>TimesLR_ZeroR</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"TimesLR r Zero = Zero"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>Zero</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>TimesLR_PlusL</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"TimesLR (Plus r s) t = Plus (TimesLR r t) (TimesLR s t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span> </span><span>s</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>TimesLR_PlusR</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"TimesLR r (Plus s t) = Plus (TimesLR r s) (TimesLR r t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span> </span><span>s</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Times_Plus_Zero</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Times_Plus Zero = Zero"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>coinduction</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Times_Plus_Plus</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Times_Plus (Plus r s) = Plus (Times_Plus r) (Times_Plus s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Lang</span><span> </span><span>r</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Times_Plus.sel</span><span> </span><span>Plus.sel</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>refl</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Plus_comm</span><span> </span><span>Plus_rotate</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Times_Plus_TimesLR_One</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Times_Plus (TimesLR r One) = r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Times_Plus_TimesLR_PlusL</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Times_Plus (TimesLR (Plus r s) t) = Plus (Times_Plus (TimesLR r t)) (Times_Plus (TimesLR s t))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span> </span><span>s</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Times_Plus_TimesLR_PlusR</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Times_Plus (TimesLR r (Plus s t)) = Plus (Times_Plus (TimesLR r s)) (Times_Plus (TimesLR r t))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span> </span><span>s</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Times</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a language ⇒ 'a language ⇒ 'a language"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Times r s = Times_Plus (TimesLR r s)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>𝔬_Times</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"𝔬 (Times r s) = (𝔬 r ∧ 𝔬 s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Times_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>𝔡_Times</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"𝔡 (Times r s) = (λa. if 𝔬 r then Plus (Times (𝔡 r a) s) (𝔡 s a) else Times (𝔡 r a) s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Times_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>Times_ZeroL</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Times Zero r = Zero"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>coinduction</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>Times_ZeroR</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Times r Zero = Zero"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>Times_OneL</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Times One r = r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>language.coinduct_strong</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_fun_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>Times_OneR</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Times r One = r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Coinduction up-to @{term Plus}--congruence relaxes the coinduction hypothesis by requiring
  membership in the congruence closure of the bisimulation rather than in the bisimulation itself.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>Plus_cong</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>R</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>Refl</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x = y ⟹ Plus_cong R x y"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>Base</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"R x y ⟹ Plus_cong R x y"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>Sym</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Plus_cong R x y ⟹ Plus_cong R y x"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>Trans</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Plus_cong R x y ⟹ Plus_cong R y z ⟹ Plus_cong R x z"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>Plus</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦Plus_cong R x y; Plus_cong R x' y'⟧ ⟹ Plus_cong R (Plus x x') (Plus y y')"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>language_coinduct_upto_Plus</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>rel_fun_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">,</span><span> </span><span>case_names</span><span> </span><span>Lang</span><span class="delimiter">,</span><span> </span><span>consumes</span><span> </span><span>1</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>R</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"R L K"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hyp</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(⋀L K. R L K ⟹ 𝔬 L = 𝔬 K ∧ rel_fun (=) (Plus_cong R) (𝔡 L) (𝔡 K))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"L = K"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>coinduct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>language.coinduct</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Plus_cong R"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>L</span><span> </span><span>K</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Plus_cong R L K"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔬 L = 𝔬 K ∧ rel_fun (=) (Plus_cong R) (𝔡 L) (𝔡 K)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>Plus_cong.induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>rel_fun_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Sym</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>hyp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>Base</span><span> </span><span>R</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>Times_PlusL</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Times (Plus r s) t = Plus (Times r t) (Times s t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span> </span><span>s</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>language_coinduct_upto_Plus</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>Times_PlusR</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Times r (Plus s t) = Plus (Times r s) (Times r t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span> </span><span>s</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>language_coinduct_upto_Plus</span><span class="delimiter">)</span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>Times_assoc</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Times (Times r s) t = Times r (Times s t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>language_coinduct_upto_Plus</span><span class="delimiter">)</span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Similarly to @{term Times}, iteration is not primitively corecursive (guardedness by
  @{term Times} is required). We apply a similar trick to obtain its definition.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primcorec</span></span><span> </span><span>StarLR</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a language ⇒ 'a language ⇒ 'a language"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"𝔬 (StarLR r s) = 𝔬 r"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔡 (StarLR r s) = (λa. StarLR (𝔡 (Times r (Plus One s)) a) s)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>StarLR_Zero</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"StarLR Zero r = Zero"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>coinduction</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>StarLR_Plus</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"StarLR (Plus r s) t = Plus (StarLR r t) (StarLR s t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>Plus_ACI</span><span> </span><span>Times_PlusR</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>StarLR_Times_Plus_One</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"StarLR (Times r (Plus One s)) s = StarLR r s"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Lang</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>L</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>R</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"L = Plus (𝔡 r a) (Plus (Times (𝔡 r a) s) (𝔡 s a))"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"R = Times (Plus (𝔡 r a) (Plus (Times (𝔡 r a) s) (𝔡 s a))) s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Plus L (Plus R (𝔡 s a)) = Plus (Plus L (𝔡 s a)) R"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Plus_assoc</span><span> </span><span>Plus_comm</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Plus L (𝔡 s a) = L"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>L_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Plus L (Plus R (𝔡 s a)) = Plus L R"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>StarLR_Plus</span><span> </span><span>Plus_assoc</span><span> </span><span>Times_PlusL</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>StarLR_Times</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"StarLR (Times r s) t = Times r (StarLR s t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>language_coinduct_upto_Plus</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>Plus_ACI</span><span> </span><span>Times_PlusR</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Star</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a language ⇒ 'a language"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Star r = StarLR One r"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>𝔬_Star</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔬 (Star r)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Star_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>𝔡_Star</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔡 (Star r) = (λa. Times (𝔡 r a) (Star r))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Star_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Star_def</span><span> </span><span>StarLR_Times</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Star_Zero</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Star Zero = One"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>coinduction</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Star_One</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Star One = One"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>coinduction</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Star_unfoldL</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Star r = Plus One (Times r (Star r))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>coinduction</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">primcorec</span></span><span> </span><span>Inter</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a language ⇒ 'a language ⇒ 'a language"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"𝔬 (Inter r s) = (𝔬 r ∧ 𝔬 s)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔡 (Inter r s) = (λa. Inter (𝔡 r a) (𝔡 s a))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primcorec</span></span><span> </span><span>Not</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a language ⇒ 'a language"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"𝔬 (Not r) = (¬ 𝔬 r)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔡 (Not r) = (λa. Not (𝔡 r a))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primcorec</span></span><span> </span><span>Full</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a language"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"Σ<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"𝔬 Full = True"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔡 Full = (λ_. Full)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Shuffle product is not primitively corecursive---the corecursive call of its derivative is
  guarded by @{term Plus}. However, it can be defined as a composition of two primitively
  corecursive functions.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primcorec</span></span><span> </span><span>ShuffleLR</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a language ⇒ 'a language ⇒ ('a × bool) language"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"𝔬 (ShuffleLR r s) = (𝔬 r ∧ 𝔬 s)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔡 (ShuffleLR r s) = (λ(a, b). if b then ShuffleLR (𝔡 r a) s else ShuffleLR r (𝔡 s a))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ShuffleLR_ZeroL</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ShuffleLR Zero r = Zero"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ShuffleLR_ZeroR</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ShuffleLR r Zero = Zero"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>Zero</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ShuffleLR_PlusL</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ShuffleLR (Plus r s) t = Plus (ShuffleLR r t) (ShuffleLR s t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span> </span><span>s</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ShuffleLR_PlusR</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ShuffleLR r (Plus s t) = Plus (ShuffleLR r s) (ShuffleLR r t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span> </span><span>s</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Shuffle_Plus_ShuffleLR_One</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Times_Plus (ShuffleLR r One) = r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Shuffle_Plus_ShuffleLR_PlusL</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Times_Plus (ShuffleLR (Plus r s) t) = Plus (Times_Plus (ShuffleLR r t)) (Times_Plus (ShuffleLR s t))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span> </span><span>s</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Shuffle_Plus_ShuffleLR_PlusR</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Times_Plus (ShuffleLR r (Plus s t)) = Plus (Times_Plus (ShuffleLR r s)) (Times_Plus (ShuffleLR r t))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span> </span><span>s</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Shuffle</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a language ⇒ 'a language ⇒ 'a language"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Shuffle r s = Times_Plus (ShuffleLR r s)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>𝔬_Shuffle</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"𝔬 (Shuffle r s) = (𝔬 r ∧ 𝔬 s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Shuffle_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>𝔡_Shuffle</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"𝔡 (Shuffle r s) = (λa. Plus (Shuffle (𝔡 r a) s) (Shuffle r (𝔡 s a)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Shuffle_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>Shuffle_ZeroL</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Shuffle Zero r = Zero"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>language_coinduct_upto_Plus</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>0</span><span> </span><span>4</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>Shuffle_ZeroR</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Shuffle r Zero = Zero"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>language_coinduct_upto_Plus</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>0</span><span> </span><span>4</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>Shuffle_OneL</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Shuffle One r = r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>Shuffle_OneR</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Shuffle r One = r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>Shuffle_PlusL</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Shuffle (Plus r s) t = Plus (Shuffle r t) (Shuffle s t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>language_coinduct_upto_Plus</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>Trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Plus</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Base</span><span> </span><span>Base</span><span class="delimiter">]</span><span> </span><span>Refl</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>Shuffle_PlusR</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Shuffle r (Plus s t) = Plus (Shuffle r s) (Shuffle r t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>language_coinduct_upto_Plus</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>Trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Plus</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Base</span><span> </span><span>Base</span><span class="delimiter">]</span><span> </span><span>Refl</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>Shuffle_assoc</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Shuffle (Shuffle r s) t = Shuffle r (Shuffle s t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>language_coinduct_upto_Plus</span><span class="delimiter">)</span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>Shuffle_comm</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Shuffle r s = Shuffle s r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span> </span><span>s</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>language_coinduct_upto_Plus</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>Trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Plus</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Base</span><span> </span><span>Base</span><span class="delimiter">]</span><span> </span><span>Refl</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  We generalize coinduction up-to @{term Plus} to coinduction up-to all previously defined concepts.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>regular_cong</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>R</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>Refl</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x = y ⟹ regular_cong R x y"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>Sym</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"regular_cong R x y ⟹ regular_cong R y x"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>Trans</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦regular_cong R x y; regular_cong R y z⟧ ⟹ regular_cong R x z"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>Base</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"R x y ⟹ regular_cong R x y"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>Plus</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦regular_cong R x y; regular_cong R x' y'⟧ ⟹
    regular_cong R (Plus x x') (Plus y y')"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>Times</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦regular_cong R x y; regular_cong R x' y'⟧ ⟹
    regular_cong R (Times x x') (Times y y')"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>Star</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦regular_cong R x y⟧ ⟹
    regular_cong R (Star x) (Star y)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>Inter</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦regular_cong R x y; regular_cong R x' y'⟧ ⟹
    regular_cong R (Inter x x') (Inter y y')"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>Not</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦regular_cong R x y⟧ ⟹
    regular_cong R (Not x) (Not y)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>Shuffle</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦regular_cong R x y; regular_cong R x' y'⟧ ⟹
    regular_cong R (Shuffle x x') (Shuffle y y')"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>language_coinduct_upto_regular</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>rel_fun_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">,</span><span> </span><span>case_names</span><span> </span><span>Lang</span><span class="delimiter">,</span><span> </span><span>consumes</span><span> </span><span>1</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>R</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"R L K"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hyp</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(⋀L K. R L K ⟹ 𝔬 L = 𝔬 K ∧ rel_fun (=) (regular_cong R) (𝔡 L) (𝔡 K))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"L = K"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>coinduct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>language.coinduct</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"regular_cong R"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>L</span><span> </span><span>K</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"regular_cong R L K"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔬 L = 𝔬 K ∧ rel_fun (=) (regular_cong R) (𝔡 L) (𝔡 K)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>regular_cong.induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>hyp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>rel_fun_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>Base</span><span> </span><span>R</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Star_unfoldR</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Star r = Plus One (Times (Star r) r)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>language_coinduct_upto_regular</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Lang</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Plus (Times (𝔡 r a) (Times (Star r) r)) (𝔡 r a) =
      Times (𝔡 r a) (Plus One (Times (Star r) r))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>Times_PlusR</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Star_Star</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Star (Star r) = Star r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>Star_unfoldL</span><span class="delimiter">,</span><span> </span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>language_coinduct_upto_regular</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Times_Star</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Times (Star r) (Star r) = Star r"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>language_coinduct_upto_regular</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Lang</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀r s. Plus (Times r s) r = Times r (Plus s One)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>Times_PlusR</span><span> </span><span>Plus_ACI</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Times_PlusR</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>*</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>language</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>type</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"{semiring_1, order}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Zero_One</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Zero ≠ One"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Zero.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"zero_language = Zero"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"one_language = One"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"plus_language = Plus"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"times_language = Times"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"less_eq_language r s = (Plus r s = s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"less_language r s = (Plus r s = s ∧ r ≠ s)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>language_defs</span><span> </span><span class="delimiter">=</span><span> </span><span>zero_language_def</span><span> </span><span>one_language_def</span><span> </span><span>plus_language_def</span><span> </span><span>times_language_def</span><span>
</span><span>  </span><span>less_eq_language_def</span><span> </span><span>less_language_def</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>intro_classes</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a language"</span></span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≤ y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ≤ z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≤ z"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>language_defs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Plus_assoc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a language"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x + y + z = x + (y + z)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>language_defs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Plus_assoc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>language_defs</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>𝔬_mono</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r ≤ s ⟹ 𝔬 r ⟹ 𝔬 s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>less_eq_language_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>𝔬</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>𝔡_mono</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r ≤ s ⟹ 𝔡 r a ≤ 𝔡 s a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>less_eq_language_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Plus.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  For reasoning about @{term "(≤)"}, we prove a coinduction principle and generalize it
  to support up-to reasoning.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>language_simulation_coinduction</span><span class="delimiter">[</span><span>consumes</span><span> </span><span>1</span><span class="delimiter">,</span><span> </span><span>case_names</span><span> </span><span>Lang</span><span class="delimiter">,</span><span> </span><span>coinduct</span><span> </span><span>pred</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"R L K"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀L K. R L K ⟹ 𝔬 L ≤ 𝔬 K ∧ (∀x. R (𝔡 L x) (𝔡 K x)))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"L ≤ K"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹R L K›</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>less_eq_language_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>L</span><span> </span><span>K</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>le_PlusL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r ≤ Plus r s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>le_PlusR</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ≤ Plus r s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>Plus_Times_pre_cong</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>R</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>pre_Less</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≤ y ⟹ Plus_Times_pre_cong R x y"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>pre_Trans</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦Plus_Times_pre_cong R x y; Plus_Times_pre_cong R y z⟧ ⟹ Plus_Times_pre_cong R x z"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>pre_Base</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"R x y ⟹ Plus_Times_pre_cong R x y"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>pre_Plus</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦Plus_Times_pre_cong R x y; Plus_Times_pre_cong R x' y'⟧ ⟹
    Plus_Times_pre_cong R (Plus x x') (Plus y y')"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>pre_Times</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦Plus_Times_pre_cong R x y; Plus_Times_pre_cong R x' y'⟧ ⟹
    Plus_Times_pre_cong R (Times x x') (Times y y')"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>language_simulation_coinduction_upto_Plus_Times</span><span class="delimiter">[</span><span>consumes</span><span> </span><span>1</span><span class="delimiter">,</span><span> </span><span>case_names</span><span> </span><span>Lang</span><span class="delimiter">,</span><span> </span><span>coinduct</span><span> </span><span>pred</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>R</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"R L K"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hyp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀L K. R L K ⟹ 𝔬 L ≤ 𝔬 K ∧ (∀x. Plus_Times_pre_cong R (𝔡 L x) (𝔡 K x)))"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"L ≤ K"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>coinduct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>language_simulation_coinduction</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Plus_Times_pre_cong R"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>L</span><span> </span><span>K</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Plus_Times_pre_cong R L K"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔬 L ≤ 𝔬 K ∧ (∀x. Plus_Times_pre_cong R (𝔡 L x) (𝔡 K x))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>Plus_Times_pre_cong.induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>hyp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>pre_Base</span><span> </span><span>R</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ge_One</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"One ≤ r ⟷ 𝔬 r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>less_eq_language_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Plus.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Plus_OneL</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Plus_mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦r1 ≤ s1; r2 ≤ s2⟧ ⟹ Plus r1 r2 ≤ Plus s1 s2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r1</span><span> </span><span>r2</span><span> </span><span>s1</span><span> </span><span>s2</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>𝔡_mono</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Plus_upper</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦r1 ≤ s; r2 ≤ s⟧ ⟹ Plus r1 r2 ≤ s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r1</span><span> </span><span>r2</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Inter_mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦r1 ≤ s1; r2 ≤ s2⟧ ⟹ Inter r1 r2 ≤ Inter s1 s2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r1</span><span> </span><span>r2</span><span> </span><span>s1</span><span> </span><span>s2</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>𝔡_mono</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Times_mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦r1 ≤ s1; r2 ≤ s2⟧ ⟹ Times r1 r2 ≤ Times s1 s2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r1</span><span> </span><span>r2</span><span> </span><span>s1</span><span> </span><span>s2</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>0</span><span> </span><span>3</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>𝔡_mono</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  We prove the missing axioms of Kleene Algebras about @{term Star}, as well as monotonicity
  properties and three standard interesting rules: bisimulation, sliding, and denesting.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>le_StarL</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Plus One (Times r (Star r)) ≤ Star r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>coinduction</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>le_StarR</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Plus One (Times (Star r) r) ≤ Star r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_eq_refl</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Star_unfoldR</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>le_TimesL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔬 s ⟹ r ≤ Times r s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>le_TimesR</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔬 r ⟹ s ≤ Times r s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>coinduction</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Plus_le_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Plus r s ≤ t ⟷ r ≤ t ∧ s ≤ t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>less_eq_language_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Plus_assoc</span><span> </span><span>Plus_idem_assoc</span><span> </span><span>Plus_rotate</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Plus_Times_pre_cong_mono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"L' ≤ L ⟹ K ≤ K' ⟹ Plus_Times_pre_cong R L K ⟹ Plus_Times_pre_cong R L' K'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>pre_Trans</span><span> </span><span>pre_Less</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>ardenL</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Plus r (Times s x) ≤ x ⟹ Times (Star s) r ≤ x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span> </span><span>s</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Lang</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>Plus_Times_pre_cong_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>order_refl</span><span> </span><span>𝔡_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Lang</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>ardenR</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Plus r (Times x s) ≤ x ⟹ Times r (Star s) ≤ x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span> </span><span>s</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Lang</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Plus_Times_pre_cong (λL K. ∃r s. L = Times r (Star s) ∧ Plus r (Times K s) ≤ K)
    (𝔡 (Times r (Star s)) a) (𝔡 x a)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>𝔡_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Lang</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>a</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>0</span><span> </span><span>4</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>Times_PlusL</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Times_PlusL</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>Plus_le_iff</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Lang</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>le_Star</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ≤ Star s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>coinduction</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Star_mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r ≤ s ⟹ Star r ≤ Star s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>coinduction</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Not_antimono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r ≤ s ⟹ Not s ≤ Not r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Not_Plus</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Not (Plus r s) = Inter (Not r) (Not s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Not_Inter</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Not (Inter r s) = Plus (Not r) (Not s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Inter_assoc</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Inter (Inter r s) t = Inter r (Inter s t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span> </span><span>s</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Inter_comm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Inter r s = Inter s r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Inter_idem</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Inter r r = r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Inter_ZeroL</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Inter Zero r = Zero"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Inter_ZeroR</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Inter r Zero = Zero"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Inter_FullL</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Inter Full r = r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Inter_FullR</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Inter r Full = r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Plus_FullL</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Plus Full r = Full"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Plus_FullR</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Plus r Full = Full"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Not_Not</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Not (Not r) = r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>r</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Not_Zero</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Not Zero = Full"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>coinduction</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Not_Full</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Not Full = Zero"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>coinduction</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bisimulation</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Times r s = Times s t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Times (Star r) s = Times s (Star t)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>antisym</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ardenL</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Plus_upper</span><span class="delimiter">[</span><span>OF</span><span> </span><span>le_TimesL</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>ardenR</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Plus_upper</span><span class="delimiter">[</span><span>OF</span><span> </span><span>le_TimesR</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Times r (Times s (Star t)) ≤ Times s (Star t)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span>
</span><span>        </span><span>Times_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>order_refl</span><span> </span><span>ord_le_eq_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>le_PlusR</span><span> </span><span>Star_unfoldL</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>Times_assoc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Times (Times (Star r) s) t ≤ Times (Star r) s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span>
</span><span>        </span><span>Times_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ord_le_eq_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>le_PlusR</span><span> </span><span>Star_unfoldR</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>order_refl</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>Times_assoc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sliding</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Times (Star (Times r s)) r = Times r (Star (Times s r))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>antisym</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ardenL</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Plus_upper</span><span class="delimiter">[</span><span>OF</span><span> </span><span>le_TimesL</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>ardenR</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Plus_upper</span><span class="delimiter">[</span><span>OF</span><span> </span><span>le_TimesR</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Times (Times r s) (Times r (Star (Times s r))) ≤ Times r (Star (Times s r))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span>
</span><span>        </span><span>Times_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>order_refl</span><span> </span><span>ord_le_eq_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>le_PlusR</span><span> </span><span>Star_unfoldL</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Times (Times (Star (Times r s)) r) (Times s r) ≤ Times (Star (Times r s)) r"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span>
</span><span>        </span><span>Times_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ord_le_eq_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>le_PlusR</span><span> </span><span>Star_unfoldR</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>order_refl</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>denesting</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Star (Plus r s) = Times (Star r) (Star (Times s (Star r)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>antisym</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ord_eq_le_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Times_OneR</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>ardenL</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Plus_upper</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>   </span><span>ardenR</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Plus_upper</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Star_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>le_PlusL</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Times (Plus r s) (Times (Star r) (Star (Times s (Star r))))
    ≤ Times (Star r) (Star (Times s (Star r)))"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Times _ ?L ≤ ?R"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Times_PlusL</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Plus_upper</span><span class="delimiter">,</span><span>
</span><span>      </span><span>metis</span><span> </span><span>Star_unfoldL</span><span> </span><span>Times_assoc</span><span> </span><span>Times_mono</span><span> </span><span>le_PlusR</span><span> </span><span>order_refl</span><span class="delimiter">,</span><span>
</span><span>      </span><span>metis</span><span> </span><span>Star_unfoldL</span><span> </span><span>Times_assoc</span><span> </span><span>𝔬_Star</span><span> </span><span>le_PlusR</span><span> </span><span>le_TimesR</span><span> </span><span>order_trans</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Times (Star (Plus r s)) (Times s (Star r)) ≤ Star (Plus r s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Plus_comm</span><span> </span><span>Star_unfoldL</span><span> </span><span>Times_PlusR</span><span> </span><span>Times_assoc</span><span> </span><span>ardenR</span><span> </span><span>bisimulation</span><span> </span><span>le_PlusR</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
It is useful to lift binary operators @{term Plus} and @{term Times}
to $n$-ary operators (that take a list as input).
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>PLUS</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a language list ⇒ 'a language"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"PLUS xs ≡ foldr Plus xs Zero"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>𝔬_foldr_Plus</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔬 (foldr Plus xs s) = (∃x∈set (s # xs). 𝔬 x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>𝔡_foldr_Plus</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔡 (foldr Plus xs s) a = foldr Plus (map (λr. 𝔡 r a) xs) (𝔡 s a)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>𝔬_PLUS</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔬 (PLUS xs) = (∃x∈set xs. 𝔬 x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PLUS_def</span><span> </span><span>𝔬_foldr_Plus</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>𝔡_PLUS</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔡 (PLUS xs) a = PLUS (map (λr. 𝔡 r a) xs)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PLUS_def</span><span> </span><span>𝔡_foldr_Plus</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>TIMES</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a language list ⇒ 'a language"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"TIMES xs ≡ foldr Times xs One"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>𝔬_foldr_Times</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔬 (foldr Times xs s) = (∀x∈set (s # xs). 𝔬 x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>PLUS_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>tails</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tails [] = [[]]"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"tails (x # xs) = (x # xs) # tails xs"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tails_snoc</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tails (xs @ [x]) = map (λys. ys @ [x]) (tails xs) @ [[]]"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>length_tails</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length (tails xs) = Suc (length xs)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>𝔡_foldr_Times</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔡 (foldr Times xs s) a =
  (let n = length (takeWhile 𝔬 xs)
  in PLUS (map (λzs. TIMES (𝔡 (hd zs) a # tl zs)) (take (Suc n) (tails (xs @ [s])))))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>TIMES_def</span><span> </span><span>PLUS_def</span><span> </span><span>Let_def</span><span> </span><span>foldr_map</span><span> </span><span>o_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>𝔬_TIMES</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔬 (TIMES xs) = (∀x∈set xs. 𝔬 x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>TIMES_def</span><span> </span><span>𝔬_foldr_Times</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>TIMES_snoc_One</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"TIMES (xs @ [One]) = TIMES xs"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>TIMES_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>𝔡_TIMES</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔡 (TIMES xs) a = (let n = length (takeWhile 𝔬 xs)
  in PLUS (map (λzs. TIMES (𝔡 (hd zs) a # tl zs)) (take (Suc n) (tails (xs @ [One])))))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>TIMES_def</span><span> </span><span>𝔡_foldr_Times</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Word-theoretic Semantics of Languages›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
We show our @{type language} codatatype being isomorphic to the standard
language representation as a set of lists.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>in_language</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a language ⇒ 'a list ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"in_language L [] = 𝔬 L"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"in_language L (x # xs) = in_language (𝔡 L x) xs"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primcorec</span></span><span> </span><span>to_language</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list set ⇒ 'a language"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"𝔬 (to_language L) = ([] ∈ L)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔡 (to_language L) = (λa. to_language {w. a # w ∈ L})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_language_to_language</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Collect (in_language (to_language L)) = L"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>set_eqI</span><span class="delimiter">,</span><span> </span><span>unfold</span><span> </span><span>mem_Collect_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>w</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"in_language (to_language L) w = (w ∈ L)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>w</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>L</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>to_language_in_language</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"to_language (Collect (in_language L)) = L"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>L</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_language_bij</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bij (Collect o in_language)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>bijI'</span><span class="delimiter">,</span><span> </span><span>unfold</span><span> </span><span>o_apply</span><span class="delimiter">,</span><span> </span><span>safe</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>L</span><span> </span><span>R</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a language"</span></span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Collect (in_language L) = Collect (in_language R)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"L = R"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>set_eq_iff</span><span> </span><span>mem_Collect_eq</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>L</span><span> </span><span>R</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>in_language.simps</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>L</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list set"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"L = Collect (in_language (to_language L))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃K. L = Collect (in_language K)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>to_language_bij</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bij to_language"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>o_bij</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Collect o in_language"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">hide_const</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="delimiter">)</span><span> </span><span>TimesLR</span><span> </span><span>Times_Plus</span><span> </span><span>StarLR</span><span> </span><span>ShuffleLR</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div><div id="Coinductive_Regular_Set">
<div class="head"><h1>Theory Coinductive_Regular_Set</h1>
<span class="command">theory</span> <span class="name">Coinductive_Regular_Set</span><br/>
<span class="keyword">imports</span> <a href="Regular_Set.html"><span class="name">Regular_Set</span></a> <a href="Coinductive_Language.html"><span class="name">Coinductive_Language</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Coinductively Defined Operations Are Standard›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Coinductive_Regular_Set</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Regular-Sets.Regular_Set"</span></span></span><span> </span><span>Coinductive_Language</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>to_language_empty</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"to_language {} = Zero"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_language_Zero</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ in_language Zero xs"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_language_One</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"in_language One xs ⟹ xs = []"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_language_Atom</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"in_language (Atom a) xs ⟹ xs = [a]"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>to_language_eps</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"to_language {[]} = One"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>bij_is_inj</span><span class="delimiter">[</span><span>OF</span><span> </span><span>in_language_bij</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>injD</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>to_language_singleton</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"to_language {[a]} = (Atom a)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>bij_is_inj</span><span class="delimiter">[</span><span>OF</span><span> </span><span>in_language_bij</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>injD</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>to_language_Un</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"to_language (A ∪ B) = Plus (to_language A) (to_language B)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>A</span><span> </span><span>B</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Collect_disj_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>to_language_Int</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"to_language (A ∩ B) = Inter (to_language A) (to_language B)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>A</span><span> </span><span>B</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Collect_conj_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>to_language_Neg</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"to_language (- A) = Not (to_language A)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>A</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Collect_neg_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>to_language_Diff</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"to_language (A - B) = Inter (to_language A) (Not (to_language B))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Diff_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>to_language_conc</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"to_language (A @@ B) = Times (to_language A) (to_language B)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>A</span><span> </span><span>B</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>language_coinduct_upto_Plus</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Deriv_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>to_language_star</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"to_language (star A) = Star (to_language A)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>A</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>language_coinduct_upto_regular</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Deriv_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>to_language_shuffle</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"to_language (A ∥ B) = Shuffle (to_language A) (to_language B)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>A</span><span> </span><span>B</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>language_coinduct_upto_Plus</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Deriv_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div><div id="Context_Free_Grammar">
<div class="head"><h1>Theory Context_Free_Grammar</h1>
<span class="command">theory</span> <span class="name">Context_Free_Grammar</span><br/>
<span class="keyword">imports</span> <a href="Coinductive_Language.html"><span class="name">Coinductive_Language</span></a> <a href="FSet.html"><span class="name">FSet</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Word Problem for Context-Free Grammars›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Context_Free_Grammar</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Coinductive_Language</span><span> </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.FSet"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Context Free Languages›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
A context-free grammar consists of a list of productions for every nonterminal
and an initial nonterminal. The productions are required to be in weak Greibach
normal form, i.e. each right hand side of a production must either be empty or
start with a terminal.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wgreibach α ≡ (case α of (Inr N # _) ⇒ False | _ ⇒ True)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">record</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'t</span><span class="delimiter">,</span><span> </span><span class="tfree">'n</span><span class="delimiter">)</span><span> </span><span>cfg</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>init</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'n :: finite"</span></span></span><span>
</span><span>  </span><span>prod</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'n ⇒ ('t + 'n) list fset"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>G</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('t, 'n :: finite) cfg"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>in_cfl</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"in_cfl [] []"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"in_cfl α w ⟹ in_cfl (Inl a # α) (a # w)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"fBex (prod G N) (λβ. in_cfl (β @ α) w) ⟹ in_cfl (Inr N # α) w"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>lang_trad</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"lang_trad ≡ {w. in_cfl [Inr (init G)] w}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>𝔬<span class="hidden">⇩</span><sub>P</sub></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"𝔬<span class="hidden">⇩</span><sub>P</sub> [] = True"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔬<span class="hidden">⇩</span><sub>P</sub> (Inl _ # _) = False"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔬<span class="hidden">⇩</span><sub>P</sub> (Inr N # α) = ([] |∈| prod G N ∧ 𝔬<span class="hidden">⇩</span><sub>P</sub> α)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>𝔡<span class="hidden">⇩</span><sub>P</sub></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"𝔡<span class="hidden">⇩</span><sub>P</sub> [] a = {||}"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔡<span class="hidden">⇩</span><sub>P</sub> (Inl b # α) a = (if a = b then {|α|} else {||})"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔡<span class="hidden">⇩</span><sub>P</sub> (Inr N # α) a =
    (λβ. tl β @ α) |`| ffilter (λβ. β ≠ [] ∧ hd β = Inl a) (prod G N) |∪|
    (if [] |∈| prod G N then 𝔡<span class="hidden">⇩</span><sub>P</sub> α a else {||})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primcorec</span></span><span> </span><span>subst</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('t + 'n) list fset ⇒ 't language"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"subst P = Lang (fBex P 𝔬<span class="hidden">⇩</span><sub>P</sub>) (λa. subst (ffUnion ((λr. 𝔡<span class="hidden">⇩</span><sub>P</sub> r a) |`| P)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>in_cfls</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fBex P 𝔬<span class="hidden">⇩</span><sub>P</sub> ⟹ in_cfls P []"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"in_cfls (ffUnion ((λα. 𝔡<span class="hidden">⇩</span><sub>P</sub> α a) |`| P)) w ⟹ in_cfls P (a # w)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span class="delimiter">[</span><span>elim</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"in_cfls P []"</span></span></span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span class="delimiter">[</span><span>elim</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"in_cfls P (a # w)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>inj_eq</span><span class="delimiter">[</span><span>OF</span><span> </span><span>bij_is_inj</span><span class="delimiter">[</span><span>OF</span><span> </span><span>to_language_bij</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subst_in_cfls</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"subst P = to_language {w. in_cfls P w}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>P</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>in_cfls.intros</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>𝔬<span class="hidden">⇩</span><sub>P</sub>_in_cfl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔬<span class="hidden">⇩</span><sub>P</sub> α ⟹ in_cfl α []"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>α</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>𝔬<span class="hidden">⇩</span><sub>P</sub>.induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>in_cfl.intros</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>fBexI</span><span class="delimiter">[</span><span>rotated</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>𝔡<span class="hidden">⇩</span><sub>P</sub>_in_cfl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"β |∈| 𝔡<span class="hidden">⇩</span><sub>P</sub> α a ⟹ in_cfl β w ⟹ in_cfl α (a # w)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>α</span><span> </span><span>a</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>β</span><span> </span><span>w</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>𝔡<span class="hidden">⇩</span><sub>P</sub>.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>3</span><span> </span><span>N</span><span> </span><span>α</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>rev_fBexI</span><span> </span><span>neq_Nil_conv</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span>
</span><span>      </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>in_cfl.intros</span><span>  </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rev_fBexI</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"_ # _"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>in_cfl.intros</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_cfls_in_cfl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"in_cfls P w ⟹ fBex P (λα. in_cfl α w)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>P</span><span> </span><span>w</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>in_cfls.induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>𝔬<span class="hidden">⇩</span><sub>P</sub>_in_cfl</span><span> </span><span>𝔡<span class="hidden">⇩</span><sub>P</sub>_in_cfl</span><span> </span><span>ffUnion.rep_eq</span><span> </span><span>fmember.rep_eq</span><span> </span><span>fBex.rep_eq</span><span> </span><span>fBall.rep_eq</span><span>
</span><span>      </span><span>intro</span><span class="delimiter">:</span><span> </span><span>in_cfl.intros</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>rev_bexI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_cfls_mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"in_cfls P w ⟹ P |⊆| Q ⟹ in_cfls Q w"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>P</span><span> </span><span>w</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>Q</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>in_cfls.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>a</span><span> </span><span>P</span><span> </span><span>w</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>2</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>2</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"ffUnion ((λα. local.𝔡<span class="hidden">⇩</span><sub>P</sub> α a) |`| Q)"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ffunion_mono</span><span> </span><span>in_cfls.intros</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>in_cfls.intros</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>cfg_wgreibach</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>G</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('t, 'n :: finite) cfg"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>weakGreibach</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀N α. α |∈| prod G N ⟹ wgreibach α"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_cfl_in_cfls</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"in_cfl G α w ⟹ in_cfls G {|α|} w"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>α</span><span> </span><span>w</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>in_cfl.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>3</span><span> </span><span>N</span><span> </span><span>α</span><span> </span><span>w</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>β</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>β</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"β |∈| prod G N"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>in_cfl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"in_cfl G (β @ α) w"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>in_cfls</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"in_cfls G {|β @ α|} w"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>β</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span>Nil</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>β</span><span> </span><span>in_cfls</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>w</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>in_cfls.intros</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>in_cfls_mono</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>γ</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>weakGreibach</span><span class="delimiter">[</span><span>OF</span><span> </span><span>β</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x = Inl a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>β</span><span> </span><span>in_cfls</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span>  </span><span>in_cfl.cases</span><span class="delimiter">[</span><span>OF</span><span> </span><span>in_cfl</span><span class="delimiter">]</span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>in_cfls.intros</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>in_cfls_mono</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>in_cfls.intros</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>lang</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"lang ≡ subst G {|[Inr (init G)]|}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lang_lang_trad</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lang = to_language (lang_trad G)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"in_cfls G {|[Inr (init G)]|} w ⟷ in_cfl G [Inr (init G)] w"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>w</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>in_cfls_in_cfl</span><span> </span><span>in_cfl_in_cfls</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>subst_in_cfls</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The function @{term in_language} decides the word problem for a given language.
Since we can construct the language of a CFG using @{const cfg_wgreibach.lang} we obtain an
executable (but not very efficient) decision procedure for CFGs for free.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔞 ≡ Inl True"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔟 ≡ Inl False"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S ≡ Inr ()"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>palindromes</span><span class="delimiter">:</span><span> </span><span>cfg_wgreibach</span><span> </span><span class="string"><span class="delete"><span class="delete">"⦇init = (), prod = λ_. {|[], [𝔞], [𝔟], [𝔞, S, 𝔞], [𝔟, S, 𝔟]|}⦈"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"in_language palindromes.lang []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>normalization</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"in_language palindromes.lang [True]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>normalization</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"in_language palindromes.lang [False]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>normalization</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"in_language palindromes.lang [True, True]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>normalization</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"in_language palindromes.lang [True, False, True]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>normalization</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ in_language palindromes.lang [True, False]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>normalization</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ in_language palindromes.lang [True, False, True, False]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>normalization</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"in_language palindromes.lang [True, False, True, True, False, True]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>normalization</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ in_language palindromes.lang [True, False, True, False, False, True]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>normalization</span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>Dyck</span><span class="delimiter">:</span><span> </span><span>cfg_wgreibach</span><span> </span><span class="string"><span class="delete"><span class="delete">"⦇init = (), prod = λ_. {|[], [𝔞, S, 𝔟, S]|}⦈"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"in_language Dyck.lang []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>normalization</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ in_language Dyck.lang [True]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>normalization</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ in_language Dyck.lang [False]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>normalization</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"in_language Dyck.lang [True, False, True, False]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>normalization</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"in_language Dyck.lang [True, True, False, False]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>normalization</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"in_language Dyck.lang [True, False, True, False]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>normalization</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"in_language Dyck.lang [True, False, True, False, True, True, False, False]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>normalization</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ in_language Dyck.lang [True, False, True, True, False]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>normalization</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ in_language Dyck.lang [True, True, False, False, False, True]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>normalization</span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>abSSa</span><span class="delimiter">:</span><span> </span><span>cfg_wgreibach</span><span> </span><span class="string"><span class="delete"><span class="delete">"⦇init = (), prod = λ_. {|[], [𝔞, 𝔟, S, S, 𝔞]|}⦈"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"in_language abSSa.lang []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>normalization</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ in_language abSSa.lang [True]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>normalization</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ in_language abSSa.lang [False]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>normalization</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"in_language abSSa.lang [True, False, True]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>normalization</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"in_language abSSa.lang [True, False, True, False, True, True, False, True, True]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>normalization</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"in_language abSSa.lang [True, False, True, False, True, True]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>normalization</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ in_language abSSa.lang [True, False, True, True, False]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>normalization</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ in_language abSSa.lang [True, True, False, False, False, True]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>normalization</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span></pre>
</div>
</div>