<div id="Derive_Aux">
<div class="head">
<h1>Theory Derive_Aux</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> Derive_Aux
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="../Deriving/Derive_Manager.html">Deriving.Derive_Manager</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹derive_aux.ML›</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/derive_aux.ML">
<div class="head">
<h1>File ‹derive_aux.ML›</h1>
</div>
<pre class="source"><span class="comment1">(* auxiliary functions which might be useful when deriving something for
   datatypes via recursors *)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">DERIVE_AUX</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="comment1">(* split_last [a,...,z] -&gt; ([a,...,y],z) *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> split_last <span class="main">:</span> 'a list <span class="main">-&gt;</span> 'a list * 'a

  <span class="comment1">(* p1 ⟶ p2 ⟶ … ⟶ p_n ⟶ r *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> HOLogic_list_implies <span class="main">:</span> term list * term <span class="main">-&gt;</span> term

  <span class="comment1">(* p1 /\ ... /\ pn *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> HOLogic_list_conj <span class="main">:</span> term list <span class="main">-&gt;</span> term

  <span class="comment1">(* ∀ x1 ... xn . p *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> HOLogic_list_all <span class="main">:</span> term list * term <span class="main">-&gt;</span> term

  <span class="comment1">(* rulifys P1 .. Pn in a thm P1 ==&gt; ... ==&gt; Pn ==&gt; Q *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> rulify_only_asm <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm

<span class="comment1">(* takes a list of implications, an induction theorem, and a tactic to handle each case,
   and delivers the major implication.
   Example: if imp_list is [([p1 x y, q1 x y], [x,y]), ([p2 x' y', q2 x' y'], [x',y'])]
            and ind_thm is ... ==&gt; P1 x /\ P2 x'
            then it encodes p1 x y ==&gt; q1 x y &amp;&amp;&amp; p2 x' y' ==&gt; q2 x' y'
            which is converted to HOL (! y. p1 x y --&gt; q1 x y) /\ (! y'. p2 x' y' --&gt; q2 x' y')
            which is proven by the instantiated ind_thm where, e.g. P1 = % x. (! y. p1 x y --&gt; q1 x y)
            and where in the IH all HOL-constructs are rulified again.
            As a result, only the first implication is returned: "p1 x y ==&gt; q1 x y"
   Purpose: encountered problems with induct-tac
     - P1 and P2 are two large for internal unification, so they must be provided
     - if P1 and P2 are provided, then one has to use HOL-constructs (for arbitrary choice of y and y')
     - in induct_tac, then the IH are not converted to nice meta-implications/quantifications
*)</span>
  <span class="keyword1"><span class="keyword">val</span></span> inductive_thm <span class="main">:</span> theory <span class="main">-&gt;</span> <span class="main">(</span>term list * term list<span class="main">)</span> list <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> sort <span class="main">-&gt;</span>
      <span class="comment1">(*                idx    ih_hyps     ih_prems    case_vars    arbi_vars *)</span>
      <span class="main">(</span><span class="entity">Proof.context</span> <span class="main">-&gt;</span> int <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> tactic<span class="main">)</span> <span class="main">-&gt;</span> thm

<span class="comment1">(* delivers a typ substitution which constrains all free type variables in datatype by sort *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> typ_subst_for_sort <span class="main">:</span> theory <span class="main">-&gt;</span> <span class="entity">Old_Datatype_Aux.info</span> <span class="main">-&gt;</span> sort <span class="main">-&gt;</span> typ <span class="main">-&gt;</span> typ

<span class="comment1">(* delivers a full type from a type name by instantiating the type-variables of that
   type with different variables of a given sort, also returns the chosen variables
   as second component *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> typ_and_vs_of_typname <span class="main">:</span> theory <span class="main">-&gt;</span> string <span class="main">-&gt;</span> sort <span class="main">-&gt;</span> typ * <span class="main">(</span>string * sort<span class="main">)</span> list

<span class="comment1">(* identity and number recursive occurrences of datatypes *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> dt_number_recs <span class="main">:</span> <span class="entity">Old_Datatype_Aux.dtyp</span> list <span class="main">-&gt;</span> int * <span class="main">(</span>int * int<span class="main">)</span> list

<span class="comment1">(* like print_tac, but is turned off by default to not exceed tracing limit *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> my_print_tac <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string <span class="main">-&gt;</span> tactic

<span class="comment1">(* generates a theorem over two variables, where induction over the first one performed,
   and then in every case one performs immediately a case analysis on the second variable.
   It is assumed that if the constructors are different, then the goal is proven by some
   standard tactic, whereas for same constructors, one has to provide a tactic *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> mk_binary_thm <span class="main">:</span>
    <span class="main">(</span>theory <span class="main">-&gt;</span> <span class="entity">Old_Datatype_Aux.info</span> <span class="main">-&gt;</span> sort <span class="main">-&gt;</span> 'a <span class="main">-&gt;</span> <span class="main">(</span>term list * term list<span class="main">)</span> list<span class="main">)</span> <span class="main">-&gt;</span> <span class="comment1">(* mk_prop_trm *)</span>
    <span class="main">(</span>theory <span class="main">-&gt;</span> <span class="entity">Old_Datatype_Aux.info</span> <span class="main">-&gt;</span> sort <span class="main">-&gt;</span> <span class="main">(</span>int <span class="main">-&gt;</span> term<span class="main">)</span> * <span class="main">(</span>'b * int * int<span class="main">)</span> list<span class="main">)</span> <span class="main">-&gt;</span> <span class="comment1">(* mk_bin_idx *)</span>
    string <span class="main">-&gt;</span> <span class="comment1">(* bin_const_name *)</span>
    theory <span class="main">-&gt;</span>
    <span class="entity">Old_Datatype_Aux.info</span> <span class="main">-&gt;</span>
    'a <span class="main">-&gt;</span> <span class="comment1">(* property_generator *)</span>
    sort <span class="main">-&gt;</span>
    <span class="comment1">(* same_constructor_tac *)</span>
    <span class="main">(</span><span class="entity">Proof.context</span> <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">Proof.context</span> <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> tactic<span class="main">)</span> <span class="main">-&gt;</span> int <span class="main">-&gt;</span> term list <span class="main">-&gt;</span>
     term list <span class="main">-&gt;</span> string * <span class="entity">Old_Datatype_Aux.dtyp</span> list <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">Old_Datatype_Aux.dtyp</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term<span class="main">)</span> <span class="main">-&gt;</span> tactic<span class="main">)</span>
    <span class="main">-&gt;</span> thm

  <span class="keyword1"><span class="keyword">val</span></span> mk_case_tac <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span>
    term option list list <span class="main">-&gt;</span> <span class="comment1">(* usually [[SOME term_to_perform_the_case]] *)</span>
    thm <span class="main">-&gt;</span> <span class="comment1">(* exhaust theorem *)</span>
    <span class="comment1">(*               i-th case, prems, newly obtained arguments *)</span>
    <span class="main">(</span><span class="entity">Proof.context</span> * int * thm list * <span class="main">(</span>string * cterm<span class="main">)</span> list <span class="main">-&gt;</span> tactic<span class="main">)</span>
    <span class="main">-&gt;</span> tactic

  <span class="keyword1"><span class="keyword">val</span></span> prop_trm_to_major_imp <span class="main">:</span> <span class="main">(</span>term list * 'a<span class="main">)</span> list <span class="main">-&gt;</span> term * 'a

<span class="comment1">(* delivers "x_i" of corresponding datatype of idx-th type for datatype *)</span>
<span class="comment1">(*                                                 idx    i *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> mk_xs <span class="main">:</span> theory <span class="main">-&gt;</span> <span class="entity">Old_Datatype_Aux.info</span> <span class="main">-&gt;</span> sort <span class="main">-&gt;</span> int <span class="main">-&gt;</span> int <span class="main">-&gt;</span> term

<span class="comment1">(* create Some t *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> mk_Some <span class="main">:</span> term <span class="main">-&gt;</span> term

<span class="comment1">(* my_simp_set should be HOL_ss + the other simplification stuff for orders like simprocs, ... *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> my_simp_set <span class="main">:</span> simpset

  <span class="keyword1"><span class="keyword">val</span></span> mk_solve_with_tac <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> tactic <span class="main">-&gt;</span> tactic

  <span class="keyword1"><span class="keyword">val</span></span> define_overloaded <span class="main">:</span> <span class="main">(</span>string * term<span class="main">)</span> <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span> thm * local_theory

  <span class="keyword1"><span class="keyword">val</span></span> define_overloaded_generic <span class="main">:</span> <span class="main">(</span><span class="entity">Attrib.binding</span> * term<span class="main">)</span> <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span> thm * local_theory

  <span class="keyword1"><span class="keyword">val</span></span> mk_def <span class="main">:</span> typ <span class="main">-&gt;</span> string <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Derive_Aux</span> <span class="main">:</span> <span class="entity">DERIVE_AUX</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">printing</span> <span class="main">=</span> false
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">my_print_tac</span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">printing</span> <span class="keyword2"><span class="keyword">then</span></span> print_tac <span class="entity">ctxt</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> Seq.single<span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">split_last</span> <span class="entity">xs</span> <span class="main">=</span> <span class="main">(</span>take <span class="main">(</span>length <span class="entity">xs</span> - <span class="inner_numeral">1</span><span class="main">)</span> <span class="entity">xs</span><span class="main">,</span> List.last <span class="entity">xs</span><span class="main">)</span>

<span class="comment1">(* FIXME: reconsolidate with similar functions in the Isabelle repository and move to HOLogic *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">HOLogic_list_implies</span> <span class="main">(</span><span class="entity">prems</span><span class="main">,</span><span class="entity">r</span><span class="main">)</span> <span class="main">=</span> fold_rev <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">r</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">p</span> <span class="main">=&gt;</span> <span class="entity">HOLogic.mk_imp</span> <span class="main">(</span><span class="entity">r</span><span class="main">,</span><span class="entity">p</span><span class="main">)</span><span class="main">)</span> <span class="entity">prems</span> <span class="entity">r</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">HOLogic_list_conj</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted"><span class="free">true</span></span><span class="antiquote">}</span></span>
  <span class="main">|</span> <span class="entity">HOLogic_list_conj</span> <span class="main">[</span><span class="entity">x</span><span class="main">]</span> <span class="main">=</span> <span class="entity">x</span>
  <span class="main">|</span> <span class="entity">HOLogic_list_conj</span> <span class="main">(</span><span class="entity">x</span> :: <span class="entity">xs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">HOLogic.mk_conj</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">HOLogic_list_conj</span> <span class="entity">xs</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">HOLogic_list_all</span> <span class="main">(</span><span class="entity">xs</span><span class="main">,</span><span class="entity">p</span><span class="main">)</span> <span class="main">=</span> fold_rev <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span><span class="entity">ty</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">p</span> <span class="main">=&gt;</span> <span class="entity">HOLogic.mk_all</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span><span class="entity">ty</span><span class="main">,</span><span class="entity">p</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>map dest_Free <span class="entity">xs</span><span class="main">)</span> <span class="entity">p</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_Some</span> <span class="entity">t</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty</span> <span class="main">=</span> fastype_of <span class="entity">t</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Some<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">ty</span> --&gt; Type <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_name</span> option<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">[</span><span class="entity">ty</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> $ <span class="entity">t</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rulify_only_asm</span> <span class="entity">ctxt</span> <span class="entity">thm</span> <span class="main">=</span>
  <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> conjI<span class="main">[</span><span class="operator">OF</span> TrueI<span class="main">]</span><span class="antiquote">}</span></span></span> OF <span class="main">[</span><span class="entity">thm</span><span class="main">]</span><span class="main">)</span> <span class="comment1">(* add conj to prohibit rulify in conclusion *)</span>
  |&gt; Object_Logic.rulify <span class="entity">ctxt</span> <span class="comment1">(* rulify everything, i.e., by preprocessing only the assms *)</span>
  |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">conj</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> conjunct2<span class="antiquote">}</span></span></span> OF <span class="main">[</span><span class="entity">conj</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="comment1">(* drop conjunction again *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">permute_for_ind_thm</span> <span class="entity">ps</span> <span class="entity">xs</span> <span class="entity">ind_thm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">n</span> <span class="main">=</span> length <span class="entity">ps</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">vs_p</span> <span class="main">=</span> Thm.prop_of <span class="entity">ind_thm</span> |&gt; Term.add_vars |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">f</span> <span class="main">=&gt;</span> <span class="entity">f</span> <span class="main">[</span><span class="main">]</span> |&gt; rev<span class="main">)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">number_ih_vars</span> <span class="main">_</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="main">]</span>
      <span class="main">|</span> <span class="entity">number_ih_vars</span> <span class="entity">i</span> <span class="main">(</span><span class="entity">P</span> :: <span class="entity">x</span> :: <span class="entity">pxs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="entity">P</span><span class="main">,</span><span class="entity">i</span><span class="main">)</span> :: <span class="main">(</span><span class="entity">x</span><span class="main">,</span><span class="entity">i</span>+<span class="entity">n</span><span class="main">)</span> :: <span class="entity">number_ih_vars</span> <span class="main">(</span><span class="entity">i</span>+<span class="inner_numeral">1</span><span class="main">)</span> <span class="entity">pxs</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">number_ih_vars</span> <span class="main">_</span> <span class="main">_</span> <span class="main">=</span> error <span class="inner_quoted">"odd number of vars in ind-thm"</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">vs_c</span> <span class="main">=</span> Thm.concl_of <span class="entity">ind_thm</span> |&gt; Term.add_vars |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">f</span> <span class="main">=&gt;</span> <span class="entity">f</span> <span class="main">[</span><span class="main">]</span> |&gt; rev<span class="main">)</span> |&gt; <span class="entity">number_ih_vars</span> <span class="inner_numeral">0</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">permutation</span> <span class="main">=</span> map <span class="main">(</span>AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">vs_c</span> #&gt; the<span class="main">)</span> <span class="entity">vs_p</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    map <span class="main">(</span>nth <span class="main">(</span><span class="entity">ps</span> @ <span class="entity">xs</span><span class="main">)</span><span class="main">)</span> <span class="entity">permutation</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">inductive_thm</span> <span class="entity">thy</span> <span class="main">(</span><span class="entity">imp_list</span> <span class="main">:</span> <span class="main">(</span>term list * term list<span class="main">)</span> list<span class="main">)</span> <span class="entity">ind_thm</span> <span class="entity">sort</span> <span class="entity">ind_tac</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">imps</span> <span class="main">=</span> map
      <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">imps</span><span class="main">,</span><span class="entity">xs</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">HOLogic_list_all</span> <span class="main">(</span>tl <span class="entity">xs</span><span class="main">,</span> <span class="entity">HOLogic_list_implies</span> <span class="main">(</span><span class="entity">split_last</span> <span class="entity">imps</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
      <span class="entity">imp_list</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ind_term</span> <span class="main">=</span>
      <span class="entity">HOLogic_list_conj</span> <span class="entity">imps</span>
      |&gt; <span class="entity">HOLogic.mk_Trueprop</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">nr_prems</span> <span class="main">=</span> length <span class="main">(</span>hd <span class="entity">imp_list</span> |&gt; fst<span class="main">)</span> - <span class="inner_numeral">1</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">nr_arbi</span> <span class="main">=</span> length <span class="main">(</span>hd <span class="entity">imp_list</span> |&gt; snd<span class="main">)</span> - <span class="inner_numeral">1</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">xs</span> <span class="main">=</span> map <span class="main">(</span>snd #&gt; hd<span class="main">)</span> <span class="entity">imp_list</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ps</span> <span class="main">=</span> <span class="entity">xs</span> ~~ <span class="entity">imps</span>
      |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span><span class="entity">imp</span><span class="main">)</span> <span class="main">=&gt;</span> lambda <span class="entity">x</span> <span class="entity">imp</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">insts</span> <span class="main">=</span> <span class="entity">permute_for_ind_thm</span> <span class="entity">ps</span> <span class="entity">xs</span> <span class="entity">ind_thm</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">xs_strings</span> <span class="main">=</span> map <span class="main">(</span>dest_Free #&gt; fst<span class="main">)</span> <span class="entity">xs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">conjunctive_thm</span> <span class="main">=</span> Goal.prove_global_future <span class="entity">thy</span> <span class="entity">xs_strings</span> <span class="main">[</span><span class="main">]</span> <span class="entity">ind_term</span>
      <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ind_thm_inst</span> <span class="main">=</span> infer_instantiate' <span class="entity">ctxt</span> <span class="main">(</span>map <span class="main">(</span>SOME o Thm.cterm_of <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">insts</span><span class="main">)</span> <span class="entity">ind_thm</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ind_thm'</span> <span class="main">=</span> <span class="entity">rulify_only_asm</span> <span class="main">(</span>Proof_Context.init_global <span class="entity">thy</span><span class="main">)</span> <span class="entity">ind_thm_inst</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="main">(</span>DETERM o <span class="entity">Induct.induct_tac</span> <span class="entity">ctxt</span> false <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span>SOME <span class="main">[</span><span class="entity">ind_thm'</span><span class="main">]</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
          THEN_ALL_NEW
          <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">i</span> <span class="main">=&gt;</span> <span class="entity">Subgoal.SUBPROOF</span>
            <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> prems <span class="main">=</span> <span class="entity">prems</span><span class="main">,</span> params <span class="main">=</span> <span class="entity">iparams</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
              <span class="keyword2"><span class="keyword">let</span></span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">m</span> <span class="main">=</span> length <span class="entity">prems</span> - <span class="entity">nr_prems</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ih_prems</span> <span class="main">=</span> drop <span class="entity">m</span> <span class="entity">prems</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ih_hyps</span> <span class="main">=</span> take <span class="entity">m</span> <span class="entity">prems</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tparams</span> <span class="main">=</span> map <span class="main">(</span>snd #&gt; Thm.term_of<span class="main">)</span> <span class="entity">iparams</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">m'</span> <span class="main">=</span> length <span class="entity">tparams</span> - <span class="entity">nr_arbi</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arbi_vars</span> <span class="main">=</span> drop <span class="entity">m'</span> <span class="entity">tparams</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">case_vars</span> <span class="main">=</span> take <span class="entity">m'</span> <span class="entity">tparams</span>
              <span class="keyword2"><span class="keyword">in</span></span>
                <span class="entity">ind_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">i</span>-<span class="inner_numeral">1</span><span class="main">)</span> <span class="entity">ih_hyps</span> <span class="entity">ih_prems</span> <span class="entity">case_vars</span> <span class="entity">arbi_vars</span>
              <span class="keyword2"><span class="keyword">end</span></span>
            <span class="main">)</span> <span class="entity">ctxt</span> <span class="entity">i</span>
          <span class="main">)</span>
        <span class="keyword2"><span class="keyword">end</span></span> <span class="inner_numeral">1</span>
      <span class="main">)</span>
    <span class="comment1">(* extract first conjunct *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">first_conj</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> length <span class="entity">imp_list</span> &gt; <span class="inner_numeral">1</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> conjunct1<span class="antiquote">}</span></span></span> OF <span class="main">[</span><span class="entity">conjunctive_thm</span><span class="main">]</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">conjunctive_thm</span>
    <span class="comment1">(* and replace ⟶ and ∀ by meta-logic (for those ⟶ and ∀ which have been constructed) *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">elim_spec</span> <span class="main">=</span> funpow <span class="entity">nr_arbi</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">thm</span> <span class="main">=&gt;</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> spec<span class="antiquote">}</span></span></span> OF <span class="main">[</span><span class="entity">thm</span><span class="main">]</span><span class="main">)</span> <span class="entity">first_conj</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">elim_imp</span> <span class="main">=</span> funpow <span class="entity">nr_prems</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">thm</span> <span class="main">=&gt;</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> mp<span class="antiquote">}</span></span></span> OF <span class="main">[</span><span class="entity">thm</span><span class="main">]</span><span class="main">)</span> <span class="entity">elim_spec</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">elim_imp</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">typ_subst_for_sort</span> <span class="entity">thy</span> <span class="entity">info</span> <span class="entity">sort</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">spec</span> <span class="main">=</span> <span class="entity">BNF_LFP_Compat.the_spec</span> <span class="entity">thy</span> <span class="main">(</span><span class="main">#</span>descr <span class="entity">info</span> |&gt; hd |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="main">(</span><span class="entity">dty_name</span><span class="main">,</span><span class="main">_</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">dty_name</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">typ_subst</span> <span class="main">=</span> Term.typ_subst_atomic <span class="main">(</span><span class="entity">spec</span> |&gt; fst |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">n</span><span class="main">,</span><span class="entity">s</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span>TFree <span class="main">(</span><span class="entity">n</span><span class="main">,</span><span class="entity">s</span><span class="main">)</span><span class="main">,</span> TFree <span class="main">(</span><span class="entity">n</span><span class="main">,</span><span class="entity">sort</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">typ_subst</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">typ_and_vs_of_typname</span> <span class="entity">thy</span> <span class="entity">typ_name</span> <span class="entity">sort</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ar</span> <span class="main">=</span> Sign.arity_number <span class="entity">thy</span> <span class="entity">typ_name</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sorts</span> <span class="main">=</span> map <span class="main">(</span>K <span class="entity">sort</span><span class="main">)</span> <span class="main">(</span><span class="inner_numeral">1</span> upto <span class="entity">ar</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty_vars</span> <span class="main">=</span> Name.invent_names <span class="main">(</span>Name.make_context <span class="main">[</span><span class="entity">typ_name</span><span class="main">]</span><span class="main">)</span> <span class="inner_quoted">"a"</span> <span class="entity">sorts</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty</span> <span class="main">=</span> Type <span class="main">(</span><span class="entity">typ_name</span><span class="main">,</span>map TFree <span class="entity">ty_vars</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">ty</span><span class="main">,</span><span class="entity">ty_vars</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dt_number_recs</span> <span class="entity">dtys</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dtrecs</span> <span class="main">[</span><span class="main">]</span> <span class="entity">j</span> <span class="main">=</span> <span class="main">(</span><span class="entity">j</span><span class="main">,</span><span class="main">[</span><span class="main">]</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">dtrecs</span> <span class="main">(</span><span class="entity">Old_Datatype_Aux.DtTFree</span> <span class="main">_</span> :: <span class="entity">dtys</span><span class="main">)</span> <span class="entity">j</span> <span class="main">=</span> <span class="entity">dtrecs</span> <span class="entity">dtys</span> <span class="entity">j</span>
      <span class="main">|</span> <span class="entity">dtrecs</span> <span class="main">(</span><span class="entity">Old_Datatype_Aux.DtRec</span> <span class="entity">i</span> :: <span class="entity">dtys</span><span class="main">)</span> <span class="entity">j</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">j'</span><span class="main">,</span><span class="entity">ijs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dtrecs</span> <span class="entity">dtys</span> <span class="main">(</span><span class="entity">j</span>+<span class="inner_numeral">1</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">j'</span><span class="main">,</span><span class="main">(</span><span class="entity">i</span><span class="main">,</span><span class="entity">j</span><span class="main">)</span> :: <span class="entity">ijs</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>
      <span class="main">|</span> <span class="entity">dtrecs</span> <span class="main">(</span><span class="entity">Old_Datatype_Aux.DtType</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="entity">dtys1</span><span class="main">)</span> :: <span class="entity">dtys2</span><span class="main">)</span> <span class="entity">j</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">j'</span><span class="main">,</span><span class="entity">ijs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dtrecs</span> <span class="entity">dtys1</span> <span class="entity">j</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">j''</span><span class="main">,</span><span class="entity">ijs'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dtrecs</span> <span class="entity">dtys2</span> <span class="entity">j'</span>
          <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">j''</span><span class="main">,</span><span class="entity">ijs</span> @ <span class="entity">ijs'</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">dtrecs</span> <span class="entity">dtys</span> <span class="inner_numeral">0</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* code copied from HOL/SPARK/TOOLS *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">define_overloaded_generic</span> <span class="main">(</span><span class="entity">binding</span><span class="main">,</span><span class="entity">eq</span><span class="main">)</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">eq</span> |&gt; Syntax.check_term <span class="entity">lthy</span> |&gt;
      Logic.dest_equals |&gt;&gt; dest_Free<span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">thm</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span> Local_Theory.define
      <span class="main">(</span><span class="main">(</span>Binding.name <span class="entity">c</span><span class="main">,</span> NoSyn<span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">binding</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span><span class="main">)</span> <span class="entity">lthy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt_thy</span> <span class="main">=</span> Proof_Context.init_global <span class="main">(</span>Proof_Context.theory_of <span class="entity">lthy'</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm'</span> <span class="main">=</span> singleton <span class="main">(</span>Proof_Context.export <span class="entity">lthy'</span> <span class="entity">ctxt_thy</span><span class="main">)</span> <span class="entity">thm</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">thm'</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">define_overloaded</span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span><span class="entity">eq</span><span class="main">)</span> <span class="main">=</span> <span class="entity">define_overloaded_generic</span> <span class="main">(</span><span class="main">(</span>Binding.name <span class="entity">name</span><span class="main">,</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">attributes</span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">,</span><span class="entity">eq</span><span class="main">)</span>


<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_def</span> <span class="entity">T</span> <span class="entity">c</span> <span class="entity">rhs</span> <span class="main">=</span> Logic.mk_equals <span class="main">(</span>Const <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span>

<span class="comment1">(* construct free variable x_i *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_free_tysubst_i</span> <span class="entity">typ_subst</span> <span class="entity">x</span> <span class="entity">i</span> <span class="entity">ty</span> <span class="main">=</span> Free <span class="main">(</span><span class="entity">x</span> ^ string_of_int <span class="entity">i</span><span class="main">,</span> <span class="entity">ty</span> |&gt; <span class="entity">typ_subst</span><span class="main">)</span>


<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_xs</span> <span class="entity">thy</span> <span class="entity">info</span> <span class="entity">sort</span> <span class="entity">idx</span> <span class="entity">i</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">descr</span> <span class="main">=</span> <span class="main">#</span>descr <span class="entity">info</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">typ_subst</span> <span class="main">=</span> <span class="entity">typ_subst_for_sort</span> <span class="entity">thy</span> <span class="entity">info</span> <span class="entity">sort</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">typ_of</span> <span class="entity">dty</span> <span class="main">=</span> <span class="entity">Old_Datatype_Aux.typ_of_dtyp</span> <span class="entity">descr</span> <span class="entity">dty</span> |&gt; <span class="entity">typ_subst</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mk_free_i</span> <span class="main">=</span> <span class="entity">mk_free_tysubst_i</span> <span class="entity">typ_subst</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">mk_free_i</span> <span class="main">(</span><span class="inner_quoted">"x_"</span> ^ string_of_int <span class="entity">idx</span> ^ <span class="inner_quoted">"_"</span><span class="main">)</span> <span class="entity">i</span> <span class="main">(</span><span class="entity">typ_of</span> <span class="main">(</span><span class="entity">Old_Datatype_Aux.DtRec</span> <span class="entity">idx</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prop_trm_to_major_imp</span> <span class="entity">prop</span> <span class="main">=</span>
  hd <span class="entity">prop</span>
  |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">p</span><span class="main">,</span><span class="entity">v</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span>
    map <span class="main">(</span><span class="entity">HOLogic.mk_Trueprop</span><span class="main">)</span> <span class="entity">p</span>
    |&gt; <span class="entity">split_last</span>
    |&gt; Logic.list_implies<span class="main">,</span>
    <span class="entity">v</span><span class="main">)</span><span class="main">)</span>


<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_case_tac</span> <span class="main">(</span><span class="entity">ctxt</span> <span class="main">:</span> <span class="entity">Proof.context</span><span class="main">)</span>
  <span class="main">(</span><span class="entity">insts</span> <span class="main">:</span> term option list list<span class="main">)</span>
  <span class="main">(</span><span class="entity">thm</span> <span class="main">:</span> thm<span class="main">)</span>
  <span class="main">(</span><span class="entity">sub_case_tac</span> <span class="main">:</span> <span class="entity">Proof.context</span> * int * thm list * <span class="main">(</span>string * cterm<span class="main">)</span> list <span class="main">-&gt;</span> tactic<span class="main">)</span> <span class="main">=</span>
    <span class="main">(</span>
      DETERM o <span class="entity">Induct.cases_tac</span> <span class="entity">ctxt</span> false <span class="entity">insts</span> <span class="main">(</span>SOME <span class="entity">thm</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span>
      THEN_ALL_NEW <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">i</span> <span class="main">=&gt;</span> <span class="entity">Subgoal.SUBPROOF</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> prems <span class="main">=</span> <span class="entity">hyps</span><span class="main">,</span> params <span class="main">=</span> <span class="entity">params</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span>
        <span class="main">=&gt;</span> <span class="entity">sub_case_tac</span> <span class="main">(</span><span class="entity">ctxt</span><span class="main">,</span> <span class="entity">i</span>-<span class="inner_numeral">1</span><span class="main">,</span> <span class="entity">hyps</span><span class="main">,</span> <span class="entity">params</span><span class="main">)</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="entity">i</span><span class="main">)</span>
    <span class="main">)</span>
    <span class="inner_numeral">1</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_solve_with_tac</span> <span class="entity">ctxt</span> <span class="entity">thms</span> <span class="entity">solver_tac</span> <span class="main">=</span>
  SOLVE <span class="main">(</span><span class="entity">Method.insert_tac</span> <span class="entity">ctxt</span> <span class="entity">thms</span> <span class="inner_numeral">1</span> THEN <span class="entity">solver_tac</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">simps_of_info</span> <span class="entity">info</span> <span class="main">=</span> <span class="main">#</span>case_rewrites <span class="entity">info</span> @ <span class="main">#</span>rec_rewrites <span class="entity">info</span> @ <span class="main">#</span>inject <span class="entity">info</span> @ <span class="main">#</span>distinct <span class="entity">info</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">my_simp_set</span> <span class="main">=</span>
  simpset_of <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span>
    delsimps <span class="main">(</span>simpset_of <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> |&gt; dest_ss |&gt; <span class="main">#</span>simps |&gt; map snd<span class="main">)</span>
    addsimps <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> HOL.simp_thms<span class="antiquote">}</span></span></span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_binary_thm</span> <span class="entity">mk_prop_trm</span> <span class="entity">mk_bin_idx</span> <span class="entity">bin_const_name</span> <span class="entity">thy</span> <span class="main">(</span><span class="entity">info</span> <span class="main">:</span> <span class="entity">Old_Datatype_Aux.info</span><span class="main">)</span> <span class="entity">prop_gen</span> <span class="entity">sort</span> <span class="entity">same_constructor_tac</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">bin_const</span> <span class="entity">ty</span> <span class="main">=</span> Const <span class="main">(</span><span class="entity">bin_const_name</span><span class="main">,</span> <span class="entity">ty</span> --&gt; <span class="entity">ty</span> --&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">bool</span><span class="antiquote">}</span></span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prop_props</span> <span class="main">=</span> <span class="entity">mk_prop_trm</span> <span class="entity">thy</span> <span class="entity">info</span> <span class="entity">sort</span> <span class="entity">prop_gen</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">mk_rec</span><span class="main">,</span><span class="entity">nrec_args</span><span class="main">)</span> <span class="main">=</span> <span class="entity">mk_bin_idx</span> <span class="entity">thy</span> <span class="entity">info</span> <span class="entity">sort</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">typ_subst</span> <span class="main">=</span> <span class="entity">typ_subst_for_sort</span> <span class="entity">thy</span> <span class="entity">info</span> <span class="entity">sort</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">descr</span> <span class="main">=</span> <span class="main">#</span>descr <span class="entity">info</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">typ_of</span> <span class="entity">dty</span> <span class="main">=</span> <span class="entity">Old_Datatype_Aux.typ_of_dtyp</span> <span class="entity">descr</span> <span class="entity">dty</span> |&gt; <span class="entity">typ_subst</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_binary_term</span> <span class="main">(</span><span class="entity">Old_Datatype_Aux.DtRec</span> <span class="entity">i</span><span class="main">)</span> <span class="main">=</span> <span class="entity">mk_rec</span> <span class="entity">i</span>
      <span class="main">|</span> <span class="entity">mk_binary_term</span> <span class="entity">dty</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty</span> <span class="main">=</span> <span class="entity">typ_of</span> <span class="entity">dty</span>
          <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">bin_const</span> <span class="entity">ty</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_binary</span> <span class="entity">dty</span> <span class="entity">x</span> <span class="entity">y</span> <span class="main">=</span> <span class="entity">mk_binary_term</span> <span class="entity">dty</span> $ <span class="entity">x</span> $ <span class="entity">y</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ind_thm</span> <span class="main">=</span> <span class="main">#</span>induct <span class="entity">info</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prop_thm_of_tac</span> <span class="main">=</span> <span class="entity">inductive_thm</span> <span class="entity">thy</span> <span class="entity">prop_props</span> <span class="entity">ind_thm</span> <span class="entity">sort</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ind_case_tac</span> <span class="entity">ctxt</span> <span class="entity">i</span> <span class="entity">hyps</span> <span class="entity">ihprems</span> <span class="entity">params_x</span> <span class="entity">ys</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">y</span> <span class="main">=</span> hd <span class="entity">ys</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">j</span><span class="main">,</span><span class="entity">idx</span><span class="main">)</span> <span class="main">=</span> nth <span class="entity">nrec_args</span> <span class="entity">i</span> |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="entity">j</span><span class="main">,</span><span class="entity">idx</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">j</span><span class="main">,</span><span class="entity">idx</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">linfo</span> <span class="main">=</span> nth <span class="entity">descr</span> <span class="entity">idx</span> |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="main">(</span><span class="entity">ty_name</span><span class="main">,</span><span class="main">_</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">ty_name</span><span class="main">)</span>
          |&gt; <span class="entity">BNF_LFP_Compat.the_info</span> <span class="entity">thy</span> <span class="main">[</span><span class="main">]</span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">solve_with_tac</span> <span class="entity">ctxt</span> <span class="entity">thms</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simp_ctxt</span> <span class="main">=</span>
            <span class="main">(</span><span class="entity">ctxt</span>
              |&gt; Context_Position.set_visible false
              |&gt; put_simpset <span class="entity">my_simp_set</span><span class="main">)</span>
              addsimps <span class="main">(</span><span class="entity">simps_of_info</span> <span class="entity">info</span> @ <span class="entity">simps_of_info</span> <span class="entity">linfo</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">mk_solve_with_tac</span> <span class="entity">ctxt</span> <span class="entity">thms</span> <span class="main">(</span><span class="entity">force_tac</span> <span class="entity">simp_ctxt</span> <span class="inner_numeral">1</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">case_tac</span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="entity">mk_case_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">[</span>SOME <span class="entity">y</span><span class="main">]</span><span class="main">]</span> <span class="main">(</span><span class="main">#</span>exhaust <span class="entity">linfo</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">sub_case_tac</span> <span class="main">(</span><span class="entity">ctxt</span><span class="main">,</span><span class="entity">k</span><span class="main">,</span><span class="entity">prems</span><span class="main">,</span><span class="entity">iparams_y</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">case_hyp_y</span> <span class="main">=</span> hd <span class="entity">prems</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">j</span> <span class="main">=</span> <span class="entity">k</span><span class="main">)</span>
            <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">my_print_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="inner_quoted">"different constructors "</span><span class="main">)</span> THEN <span class="entity">solve_with_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">case_hyp_y</span> :: <span class="entity">ihprems</span><span class="main">)</span> <span class="comment1">(* different constructor *)</span>
            <span class="keyword2"><span class="keyword">else</span></span>
              <span class="keyword2"><span class="keyword">let</span></span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">params_y</span> <span class="main">=</span> map <span class="main">(</span>snd #&gt; Thm.term_of<span class="main">)</span> <span class="entity">iparams_y</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">c_info</span> <span class="main">=</span> nth <span class="entity">descr</span> <span class="entity">idx</span> |&gt; snd |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="main">_</span><span class="main">,</span><span class="entity">info</span><span class="main">)</span> <span class="main">=&gt;</span> nth <span class="entity">info</span> <span class="entity">j</span><span class="main">)</span>
              <span class="keyword2"><span class="keyword">in</span></span>
                <span class="entity">my_print_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="inner_quoted">"consider constructor "</span> ^ string_of_int <span class="entity">k</span><span class="main">)</span>
                THEN <span class="entity">same_constructor_tac</span> <span class="entity">ctxt</span> <span class="entity">hyps</span> <span class="entity">ihprems</span> <span class="entity">case_hyp_y</span> <span class="entity">solve_with_tac</span> <span class="entity">j</span> <span class="entity">params_x</span> <span class="entity">params_y</span> <span class="entity">c_info</span> <span class="entity">mk_binary</span>
              <span class="keyword2"><span class="keyword">end</span></span>
          <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">my_print_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="inner_quoted">"start induct "</span> ^ string_of_int <span class="entity">i</span><span class="main">)</span> THEN <span class="entity">case_tac</span> <span class="entity">ctxt</span> <span class="entity">sub_case_tac</span> <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prop_thm</span> <span class="main">=</span> <span class="entity">prop_thm_of_tac</span> <span class="entity">ind_case_tac</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">prop_thm</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_case_tac</span> <span class="entity">ctxt</span>
  <span class="main">(</span><span class="entity">insts</span> <span class="main">:</span> term option list list<span class="main">)</span>
  <span class="main">(</span><span class="entity">thm</span> <span class="main">:</span> thm<span class="main">)</span>
  <span class="main">(</span><span class="entity">sub_case_tac</span> <span class="main">:</span> <span class="entity">Proof.context</span> * int * thm list * <span class="main">(</span>string * cterm<span class="main">)</span> list <span class="main">-&gt;</span> tactic<span class="main">)</span> <span class="main">=</span>
    <span class="main">(</span>
      DETERM o <span class="entity">Induct.cases_tac</span> <span class="entity">ctxt</span> false <span class="entity">insts</span> <span class="main">(</span>SOME <span class="entity">thm</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span>
      THEN_ALL_NEW <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">i</span> <span class="main">=&gt;</span> <span class="entity">Subgoal.SUBPROOF</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> prems <span class="main">=</span> <span class="entity">hyps</span><span class="main">,</span> params <span class="main">=</span> <span class="entity">params</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span>
        <span class="main">=&gt;</span> <span class="entity">sub_case_tac</span> <span class="main">(</span><span class="entity">ctxt</span><span class="main">,</span> <span class="entity">i</span>-<span class="inner_numeral">1</span><span class="main">,</span> <span class="entity">hyps</span><span class="main">,</span> <span class="entity">params</span><span class="main">)</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="entity">i</span><span class="main">)</span>
    <span class="main">)</span>
    <span class="inner_numeral">1</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Order_Generator">
<div class="head">
<h1>Theory Order_Generator</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Deriving class instances for datatypes
    Author:      René Thiemann       &lt;rene.thiemann@uibk.ac.at&gt;
    Maintainer:  René Thiemann
    License:     LGPL
*)</span>

<span class="comment1">(*
Copyright 2013 René Thiemann

This file is part of IsaFoR/CeTA.

IsaFoR/CeTA is free software: you can redistribute it and/or modify it under the
terms of the GNU Lesser General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

IsaFoR/CeTA is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along
with IsaFoR/CeTA. If not, see &lt;http://www.gnu.org/licenses/&gt;.
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Generating linear orders for datatypes›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Order_Generator
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="Derive_Aux.html">Derive_Aux</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="plain_text">Introduction</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹

The order generator registers itself at the derive-manager for the classes <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> ord<span class="antiquote"><span class="antiquote">}</span></span></span></span>,
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> order<span class="antiquote"><span class="antiquote">}</span></span></span></span>, and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> linorder<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
To be more precise,
it automatically generates the two functions <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(≤)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(&lt;)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> for some datatype 
\texttt{dtype} and
proves the following instantiations.

\begin{itemize}
\item \texttt{instantiation dtype :: (ord,\ldots,ord) ord}
\item \texttt{instantiation dtype :: (order,\ldots,order) order}
\item \texttt{instantiation dtype :: (linorder,\ldots,linorder) linorder}
\end{itemize}

All the non-recursive types that are used in the datatype must have similar instantiations.
For recursive type-dependencies this is automatically generated.

For example, for the \texttt{datatype tree = Leaf nat | Node "tree list"} we require that
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> nat<span class="antiquote"><span class="antiquote">}</span></span></span></span> is already in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> linorder<span class="antiquote"><span class="antiquote">}</span></span></span></span>, whereas for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> list<span class="antiquote"><span class="antiquote">}</span></span></span></span> nothing is required, since for the 
\texttt{tree}
datatype the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> list<span class="antiquote"><span class="antiquote">}</span></span></span></span> is only used recursively.

However, if we define \texttt{datatype tree = Leaf "nat list" | Node tree tree} then 
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> list<span class="antiquote"><span class="antiquote">}</span></span></span></span> must
provide the above instantiations.

Note that when calling the generator for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> linorder<span class="antiquote"><span class="antiquote">}</span></span></span></span>, it will automatically also derive the instantiations 
for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> order<span class="antiquote"><span class="antiquote">}</span></span></span></span>, which in turn invokes the generator for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> ord<span class="antiquote"><span class="antiquote">}</span></span></span></span>. 
A later invokation of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> linorder<span class="antiquote"><span class="antiquote">}</span></span></span></span>
after <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> order<span class="antiquote"><span class="antiquote">}</span></span></span></span> or <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> ord<span class="antiquote"><span class="antiquote">}</span></span></span></span> is not possible.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Implementation Notes"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
The generator uses the recursors from the datatype package to define a lexicographic order.
E.g., for a declaration 
\texttt{datatype 'a tree = Empty | Node "'a tree" 'a "'a tree"}
this will semantically result in
\begin{verbatim}
(Empty &lt; Node _ _ _) = True
(Node l1 l2 l3 &lt; Node r1 r2 r3) = 
  (l1 &lt; r1 || l1 = r1 &amp;&amp; (l2 &lt; r2 || l2 = r2 &amp;&amp; l3 &lt; r3))
(_ &lt; _) = False
(l &lt;= r) = (l &lt; r || l = r)
\end{verbatim}

The desired properties (like <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">x</span></span> <span class="main"><span class="main">&lt;</span></span> <span class="free"><span class="free">y</span></span> <span class="main"><span class="main">⟹</span></span> <span class="free"><span class="free">y</span></span> <span class="main"><span class="main">&lt;</span></span> <span class="free"><span class="free">z</span></span> <span class="main"><span class="main">⟹</span></span> <span class="free"><span class="free">x</span></span> <span class="main"><span class="main">&lt;</span></span> <span class="free"><span class="free">z</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>) 
of the orders are all proven using induction (with the induction theorem from the datatype on <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">x</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>),
and afterwards there is a case distinction on the remaining variables, i.e., here <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">y</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">z</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
If the constructors of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">x</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">y</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">z</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> are different always some basic tactic is invoked. 
In the other case (identical constructors) for each property a dedicated tactic was designed.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Features and Limitations"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
The order generator has been developed mainly for datatypes without explicit mutual recursion. 
For mutual recursive datatypes---like
\texttt{datatype a = C b and b = D a a}---only
for the first mentioned datatype---here \texttt{a}---the instantiations of the order-classes are
derived.

Indirect recursion like in \texttt{datatype tree = Leaf nat | Node "tree list"} should work 
without problems.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Installing the generator"</span></span>

<span class="keyword1" id="Order_Generator-linear_cases"><span class="command">lemma</span></span> linear_cases<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">::</span> <span class="tfree">'a</span> <span class="main">::</span> linorder<span class="main">)</span> <span class="main">=</span> <span class="free">y</span> <span class="main">∨</span> <span class="free">x</span> <span class="main">&lt;</span> <span class="free">y</span> <span class="main">∨</span> <span class="free">y</span> <span class="main">&lt;</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹order_generator.ML›</span> 

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/order_generator.ML">
<div class="head">
<h1>File ‹order_generator.ML›</h1>
</div>
<pre class="source"><span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">ORDER_GENERATOR</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="comment1">(* 1. pair of result creates the rhs for the &lt; operator, idx 0 results in &lt; *)</span>
  <span class="comment1">(* 2. pair of result contains list of arguments for recursor, each indexed by
        first the constructor number
        second the index number
  *)</span>
  <span class="comment1">(*                          dtyp_info            order   idx        *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> mk_less_idx <span class="main">:</span> theory <span class="main">-&gt;</span> <span class="entity">Old_Datatype_Aux.info</span> <span class="main">-&gt;</span> sort <span class="main">-&gt;</span> <span class="main">(</span>int <span class="main">-&gt;</span> term<span class="main">)</span> * <span class="main">(</span>term * int * int<span class="main">)</span> list<span class="main">;</span>

  <span class="comment1">(* given an idx, x, and y, it creates x &lt;= y *)</span>
  <span class="comment1">(*                             dtyp_info            order   idx     x       y   *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> mk_less_eq_idx <span class="main">:</span> theory <span class="main">-&gt;</span> <span class="entity">Old_Datatype_Aux.info</span> <span class="main">-&gt;</span> sort <span class="main">-&gt;</span> <span class="main">(</span>int <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term<span class="main">)</span><span class="main">;</span>

  <span class="comment1">(* proves the transitivity theorems (for ≤ and &lt; ) *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> mk_transitivity_thms <span class="main">:</span> theory <span class="main">-&gt;</span> <span class="entity">Old_Datatype_Aux.info</span> <span class="main">-&gt;</span> thm * thm<span class="main">;</span>

  <span class="comment1">(* proves the theorem (x &lt; y) = (x ≤ y ∧ ¬ y ≤ x) *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> mk_less_le_not_le_thm <span class="main">:</span> theory <span class="main">-&gt;</span> <span class="entity">Old_Datatype_Aux.info</span> <span class="main">-&gt;</span> thm

  <span class="comment1">(* proves the theorem (x ≤ x) *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> mk_le_refl_thm <span class="main">:</span> theory <span class="main">-&gt;</span> <span class="entity">Old_Datatype_Aux.info</span> <span class="main">-&gt;</span> thm

  <span class="comment1">(* proves the theorem (x ≤ y ⟹ y ≤ x ⟹ x = y) *)</span>
  <span class="comment1">(* takes as input the transitivity thm for &lt; and the less_le_not_le thm *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> mk_antisym_thm <span class="main">:</span> theory <span class="main">-&gt;</span> <span class="entity">Old_Datatype_Aux.info</span> <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm

  <span class="comment1">(* proves the theorem (x ≤ y ∨ y ≤ x) *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> mk_linear_thm <span class="main">:</span> theory <span class="main">-&gt;</span> <span class="entity">Old_Datatype_Aux.info</span> <span class="main">-&gt;</span> thm

  <span class="comment1">(* proves all four theorems which are required for orders: trans, refl, antisym, less_le_not_le *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> mk_order_thms <span class="main">:</span> theory <span class="main">-&gt;</span> <span class="entity">Old_Datatype_Aux.info</span> <span class="main">-&gt;</span> thm list

  <span class="comment1">(* creates and registers (0 = ord, 1 = order, 2 = linear-order) for datatype *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> derive <span class="main">:</span> int <span class="main">-&gt;</span> string <span class="main">-&gt;</span> string <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Order_Generator</span> <span class="main">:</span> <span class="entity">ORDER_GENERATOR</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword3"><span class="keyword">open</span></span> Derive_Aux

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">less_name</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "Orderings.less"<span class="antiquote">}</span></span>

<span class="comment1">(* construct free variable x_i *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_free_tysubst_i</span> <span class="entity">typ_subst</span> <span class="entity">x</span> <span class="entity">i</span> <span class="entity">ty</span> <span class="main">=</span> Free <span class="main">(</span><span class="entity">x</span> ^ string_of_int <span class="entity">i</span><span class="main">,</span> <span class="entity">ty</span> |&gt; <span class="entity">typ_subst</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_less_idx</span> <span class="entity">thy</span> <span class="entity">info</span> <span class="entity">sort</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">typ_subst</span> <span class="main">=</span> <span class="entity">typ_subst_for_sort</span> <span class="entity">thy</span> <span class="entity">info</span> <span class="entity">sort</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">descr</span> <span class="main">=</span> <span class="main">#</span>descr <span class="entity">info</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">typ_of</span> <span class="entity">dty</span> <span class="main">=</span> <span class="entity">Old_Datatype_Aux.typ_of_dtyp</span> <span class="entity">descr</span> <span class="entity">dty</span> |&gt; <span class="entity">typ_subst</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rec_names</span> <span class="main">=</span> <span class="main">#</span>rec_names <span class="entity">info</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mk_free_i</span> <span class="main">=</span> <span class="entity">mk_free_tysubst_i</span> <span class="entity">typ_subst</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rec_idx</span> <span class="entity">i</span> <span class="entity">dtys</span> <span class="main">=</span> <span class="entity">dt_number_recs</span> <span class="main">(</span>take <span class="entity">i</span> <span class="entity">dtys</span><span class="main">)</span> |&gt; fst
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_rhss</span> <span class="main">(</span><span class="entity">idx</span><span class="main">,</span><span class="main">(</span><span class="entity">ty_name</span><span class="main">,</span><span class="main">_</span><span class="main">,</span><span class="entity">cons</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty</span> <span class="main">=</span> <span class="entity">typ_of</span> <span class="main">(</span><span class="entity">Old_Datatype_Aux.DtRec</span> <span class="entity">idx</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">linfo</span> <span class="main">=</span> <span class="entity">BNF_LFP_Compat.the_info</span> <span class="entity">thy</span> <span class="main">[</span><span class="main">]</span> <span class="entity">ty_name</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">case_name</span> <span class="main">=</span> <span class="main">#</span>case_name <span class="entity">linfo</span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_rhs</span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span><span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="entity">dtysi</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lvars</span> <span class="main">=</span> map_index <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span><span class="entity">dty</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">mk_free_i</span> <span class="inner_quoted">"x_"</span> <span class="entity">i</span> <span class="main">(</span><span class="entity">typ_of</span> <span class="entity">dty</span><span class="main">)</span><span class="main">)</span> <span class="entity">dtysi</span>
            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">res_var</span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span><span class="entity">oc</span><span class="main">)</span> <span class="main">=</span> <span class="entity">mk_free_i</span> <span class="inner_quoted">"res_"</span> <span class="entity">oc</span> <span class="main">(</span><span class="entity">typ_of</span> <span class="main">(</span><span class="entity">Old_Datatype_Aux.DtRec</span> <span class="entity">i</span><span class="main">)</span> --&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">bool</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">;</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">res_vars</span> <span class="main">=</span> <span class="entity">dt_number_recs</span> <span class="entity">dtysi</span>
                     |&gt; snd
                     |&gt; map <span class="entity">res_var</span>
            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_case</span> <span class="main">(</span><span class="entity">j</span><span class="main">,</span><span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="entity">dtysj</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
              <span class="keyword2"><span class="keyword">let</span></span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rvars</span> <span class="main">=</span> map_index <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span><span class="entity">dty</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">mk_free_i</span> <span class="inner_quoted">"y_"</span> <span class="entity">i</span> <span class="main">(</span><span class="entity">typ_of</span> <span class="entity">dty</span><span class="main">)</span><span class="main">)</span> <span class="entity">dtysj</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">x</span> <span class="main">=</span> nth <span class="entity">lvars</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">y</span> <span class="main">=</span> nth <span class="entity">rvars</span>
                <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">combine_dts</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">False</span><span class="antiquote">}</span></span>
                  <span class="main">|</span> <span class="entity">combine_dts</span> <span class="main">(</span><span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="entity">c</span><span class="main">)</span> :: <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> <span class="entity">c</span>
                  <span class="main">|</span> <span class="entity">combine_dts</span> <span class="main">(</span><span class="main">(</span><span class="entity">i</span><span class="main">,</span><span class="entity">c</span><span class="main">)</span> :: <span class="entity">ics</span><span class="main">)</span> <span class="main">=</span> <span class="entity">HOLogic.mk_disj</span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">HOLogic.mk_conj</span> <span class="main">(</span><span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">x</span> <span class="entity">i</span><span class="main">,</span> <span class="entity">y</span> <span class="entity">i</span><span class="main">)</span><span class="main">,</span> <span class="entity">combine_dts</span> <span class="entity">ics</span><span class="main">)</span><span class="main">)</span>
                <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">less_of_dty</span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span><span class="entity">Old_Datatype_Aux.DtRec</span> <span class="entity">j</span><span class="main">)</span> <span class="main">=</span> <span class="entity">res_var</span> <span class="main">(</span><span class="entity">j</span><span class="main">,</span><span class="entity">rec_idx</span> <span class="entity">i</span> <span class="entity">dtysj</span><span class="main">)</span> $ <span class="entity">y</span> <span class="entity">i</span>
                  <span class="main">|</span> <span class="entity">less_of_dty</span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span><span class="main">_</span><span class="main">)</span> <span class="main">=</span>
                      <span class="keyword2"><span class="keyword">let</span></span>
                        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">xi</span> <span class="main">=</span> <span class="entity">x</span> <span class="entity">i</span>
                        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty</span> <span class="main">=</span> Term.type_of <span class="entity">xi</span>
                        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">less</span> <span class="main">=</span> Const <span class="main">(</span><span class="entity">less_name</span><span class="main">,</span> <span class="entity">ty</span> --&gt; <span class="entity">ty</span> --&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">bool</span><span class="antiquote">}</span></span><span class="main">)</span>
                      <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">less</span> $ <span class="entity">xi</span> $ <span class="entity">y</span> <span class="entity">i</span> <span class="keyword2"><span class="keyword">end</span></span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span>
                  <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">i</span> &lt; <span class="entity">j</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">True</span><span class="antiquote">}</span></span>
                  <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">i</span> &gt; <span class="entity">j</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">False</span><span class="antiquote">}</span></span>
                  <span class="keyword2"><span class="keyword">else</span></span> map_index <span class="entity">less_of_dty</span> <span class="entity">dtysi</span>
                    |&gt; map_index I
                    |&gt; <span class="entity">combine_dts</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lam_rhs</span> <span class="main">=</span> fold lambda <span class="main">(</span>rev <span class="entity">rvars</span><span class="main">)</span> <span class="entity">rhs</span>
              <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">lam_rhs</span> <span class="keyword2"><span class="keyword">end</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cases</span> <span class="main">=</span> map_index <span class="entity">mk_case</span> <span class="entity">cons</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">case_ty</span> <span class="main">=</span> <span class="main">(</span>map type_of <span class="entity">cases</span> @ <span class="main">[</span><span class="entity">ty</span><span class="main">]</span><span class="main">)</span> ---&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">bool</span><span class="antiquote">}</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs_case</span> <span class="main">=</span> list_comb <span class="main">(</span>Const <span class="main">(</span><span class="entity">case_name</span><span class="main">,</span> <span class="entity">case_ty</span><span class="main">)</span><span class="main">,</span> <span class="entity">cases</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span> fold lambda <span class="main">(</span>rev <span class="main">(</span><span class="entity">lvars</span> @ <span class="entity">res_vars</span><span class="main">)</span><span class="main">)</span> <span class="entity">rhs_case</span>
          <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">rhs</span> <span class="keyword2"><span class="keyword">end</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rec_args</span> <span class="main">=</span> map_index <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span><span class="entity">c</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">mk_rhs</span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span><span class="entity">c</span><span class="main">)</span><span class="main">,</span><span class="entity">i</span><span class="main">,</span><span class="entity">idx</span><span class="main">)</span><span class="main">)</span> <span class="entity">cons</span>
      <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">rec_args</span> <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">nrec_args</span> <span class="main">=</span> maps <span class="entity">mk_rhss</span> <span class="entity">descr</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rec_args</span> <span class="main">=</span> map <span class="main">#</span><span class="inner_numeral">1</span> <span class="entity">nrec_args</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_rec</span> <span class="entity">i</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty</span> <span class="main">=</span> <span class="entity">typ_of</span> <span class="main">(</span><span class="entity">Old_Datatype_Aux.DtRec</span> <span class="entity">i</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rec_ty</span> <span class="main">=</span> map type_of <span class="entity">rec_args</span> @ <span class="main">[</span><span class="entity">ty</span><span class="main">,</span><span class="entity">ty</span><span class="main">]</span> ---&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">bool</span><span class="antiquote">}</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rec_name</span> <span class="main">=</span> nth <span class="entity">rec_names</span> <span class="entity">i</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span> list_comb <span class="main">(</span>Const <span class="main">(</span><span class="entity">rec_name</span><span class="main">,</span> <span class="entity">rec_ty</span><span class="main">)</span><span class="main">,</span> <span class="entity">rec_args</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">rhs</span> <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">mk_rec</span><span class="main">,</span><span class="entity">nrec_args</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_less_eq_idx</span> <span class="entity">thy</span> <span class="entity">info</span> <span class="entity">sort</span> <span class="entity">idx</span> <span class="entity">x</span> <span class="entity">y</span> <span class="main">=</span>
  <span class="entity">mk_less_idx</span> <span class="entity">thy</span> <span class="entity">info</span> <span class="entity">sort</span>
  |&gt; fst
  |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">less</span> <span class="main">=&gt;</span> <span class="entity">HOLogic.mk_disj</span> <span class="main">(</span><span class="entity">less</span> <span class="entity">idx</span> $ <span class="entity">x</span> $ <span class="entity">y</span><span class="main">,</span> <span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span><span class="entity">y</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_prop_trm</span> <span class="entity">thy</span> <span class="entity">info</span> <span class="entity">sort</span>
  <span class="main">(</span><span class="entity">gen</span> <span class="main">:</span> <span class="main">(</span>int <span class="main">-&gt;</span> term<span class="main">)</span> <span class="main">-&gt;</span> <span class="main">(</span>term <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term<span class="main">)</span>list <span class="main">-&gt;</span> term list * term list<span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">main</span> <span class="entity">idx</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">xs</span> <span class="main">=</span> <span class="entity">mk_xs</span> <span class="entity">thy</span> <span class="entity">info</span> <span class="entity">sort</span> <span class="entity">idx</span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">less</span> <span class="entity">a</span> <span class="entity">b</span> <span class="main">=</span> <span class="main">(</span><span class="entity">mk_less_idx</span> <span class="entity">thy</span> <span class="entity">info</span> <span class="entity">sort</span> |&gt; fst<span class="main">)</span> <span class="entity">idx</span> $ <span class="entity">a</span> $ <span class="entity">b</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">less_eq</span> <span class="main">=</span> <span class="entity">mk_less_eq_idx</span> <span class="entity">thy</span> <span class="entity">info</span> <span class="entity">sort</span> <span class="entity">idx</span>
      <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">gen</span> <span class="entity">xs</span> <span class="main">[</span><span class="entity">less</span><span class="main">,</span> <span class="entity">less_eq</span><span class="main">]</span> <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">#</span>descr <span class="entity">info</span>
    |&gt; map <span class="main">(</span>fst #&gt; <span class="entity">main</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_prop_major_trm</span> <span class="entity">thy</span> <span class="entity">info</span> <span class="entity">sort</span> <span class="entity">gen</span> <span class="main">=</span>
  <span class="entity">mk_prop_trm</span> <span class="entity">thy</span> <span class="entity">info</span> <span class="entity">sort</span> <span class="entity">gen</span> |&gt; <span class="entity">prop_trm_to_major_imp</span>


<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_trans_thm_trm</span> <span class="entity">thy</span> <span class="entity">info</span> <span class="main">=</span>
  <span class="entity">mk_prop_trm</span> <span class="entity">thy</span> <span class="entity">info</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">"order"</span><span class="antiquote">}</span></span>
  <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">xs</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">[</span><span class="entity">less</span><span class="main">,</span><span class="main">_</span><span class="main">]</span> <span class="main">=&gt;</span>
    <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span><span class="entity">y</span><span class="main">,</span><span class="entity">z</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">xs</span> <span class="inner_numeral">1</span><span class="main">,</span> <span class="entity">xs</span> <span class="inner_numeral">2</span><span class="main">,</span> <span class="entity">xs</span> <span class="inner_numeral">3</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="main">[</span><span class="entity">less</span> <span class="entity">x</span> <span class="entity">y</span><span class="main">,</span> <span class="entity">less</span> <span class="entity">y</span> <span class="entity">z</span><span class="main">,</span> <span class="entity">less</span> <span class="entity">x</span> <span class="entity">z</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="entity">x</span><span class="main">,</span><span class="entity">y</span><span class="main">,</span><span class="entity">z</span><span class="main">]</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_trans_eq_thm_trm</span> <span class="entity">thy</span> <span class="entity">info</span> <span class="main">=</span>
  <span class="entity">mk_prop_major_trm</span> <span class="entity">thy</span> <span class="entity">info</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">"order"</span><span class="antiquote">}</span></span>
  <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">xs</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">[</span><span class="main">_</span><span class="main">,</span> <span class="entity">lesseq</span><span class="main">]</span> <span class="main">=&gt;</span>
    <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span><span class="entity">y</span><span class="main">,</span><span class="entity">z</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">xs</span> <span class="inner_numeral">1</span><span class="main">,</span> <span class="entity">xs</span> <span class="inner_numeral">2</span><span class="main">,</span> <span class="entity">xs</span> <span class="inner_numeral">3</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="main">[</span><span class="entity">lesseq</span> <span class="entity">x</span> <span class="entity">y</span><span class="main">,</span> <span class="entity">lesseq</span> <span class="entity">y</span> <span class="entity">z</span><span class="main">,</span> <span class="entity">lesseq</span> <span class="entity">x</span> <span class="entity">z</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="entity">x</span><span class="main">,</span><span class="entity">y</span><span class="main">,</span><span class="entity">z</span><span class="main">]</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_less_disj</span> <span class="entity">mk_less</span> <span class="entity">px</span> <span class="entity">py</span> <span class="entity">dtys</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">build_disj</span> <span class="main">[</span><span class="main">]</span> <span class="main">_</span> <span class="main">_</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">False</span><span class="antiquote">}</span></span>
      <span class="main">|</span> <span class="entity">build_disj</span> <span class="main">(</span><span class="entity">px</span> :: <span class="entity">xs</span><span class="main">)</span> <span class="main">(</span><span class="entity">py</span> :: <span class="entity">ys</span><span class="main">)</span> <span class="main">(</span><span class="entity">dty</span> :: <span class="entity">dtys</span><span class="main">)</span> <span class="main">=</span>
          <span class="entity">HOLogic.mk_disj</span> <span class="main">(</span><span class="entity">mk_less</span> <span class="entity">dty</span> <span class="entity">px</span> <span class="entity">py</span><span class="main">,</span> <span class="entity">HOLogic.mk_conj</span> <span class="main">(</span><span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">px</span><span class="main">,</span><span class="entity">py</span><span class="main">)</span><span class="main">,</span><span class="entity">build_disj</span> <span class="entity">xs</span> <span class="entity">ys</span> <span class="entity">dtys</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">build_disj</span> <span class="entity">px</span> <span class="entity">py</span> <span class="entity">dtys</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">simps_of_info</span> <span class="entity">info</span> <span class="main">=</span> <span class="main">#</span>case_rewrites <span class="entity">info</span> @ <span class="main">#</span>rec_rewrites <span class="entity">info</span> @ <span class="main">#</span>inject <span class="entity">info</span> @ <span class="main">#</span>distinct <span class="entity">info</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_transitivity_thms</span> <span class="entity">thy</span> <span class="main">(</span><span class="entity">info</span> <span class="main">:</span> <span class="entity">Old_Datatype_Aux.info</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt</span> <span class="main">=</span> Proof_Context.init_global <span class="entity">thy</span>
    <span class="comment1">(* first prove transitivity of &lt; *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">trans_props</span> <span class="main">=</span> <span class="entity">mk_trans_thm_trm</span> <span class="entity">thy</span> <span class="entity">info</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sort</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">"order"</span><span class="antiquote">}</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">mk_rec</span><span class="main">,</span><span class="entity">nrec_args</span><span class="main">)</span> <span class="main">=</span> <span class="entity">mk_less_idx</span> <span class="entity">thy</span> <span class="entity">info</span> <span class="entity">sort</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">typ_subst</span> <span class="main">=</span> <span class="entity">typ_subst_for_sort</span> <span class="entity">thy</span> <span class="entity">info</span> <span class="entity">sort</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">descr</span> <span class="main">=</span> <span class="main">#</span>descr <span class="entity">info</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">typ_of</span> <span class="entity">dty</span> <span class="main">=</span> <span class="entity">Old_Datatype_Aux.typ_of_dtyp</span> <span class="entity">descr</span> <span class="entity">dty</span> |&gt; <span class="entity">typ_subst</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_less_term</span> <span class="main">(</span><span class="entity">Old_Datatype_Aux.DtRec</span> <span class="entity">i</span><span class="main">)</span> <span class="main">=</span> <span class="entity">mk_rec</span> <span class="entity">i</span>
      <span class="main">|</span> <span class="entity">mk_less_term</span> <span class="entity">dty</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty</span> <span class="main">=</span> <span class="entity">typ_of</span> <span class="entity">dty</span>
          <span class="keyword2"><span class="keyword">in</span></span> Const <span class="main">(</span><span class="entity">less_name</span><span class="main">,</span> <span class="entity">ty</span> --&gt; <span class="entity">ty</span> --&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">bool</span><span class="antiquote">}</span></span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_less</span> <span class="entity">dty</span> <span class="entity">x</span> <span class="entity">y</span> <span class="main">=</span> <span class="entity">mk_less_term</span> <span class="entity">dty</span> $ <span class="entity">x</span> $ <span class="entity">y</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ind_thm</span> <span class="main">=</span> <span class="main">#</span>induct <span class="entity">info</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">trans_thm_of_tac</span> <span class="main">=</span> <span class="entity">inductive_thm</span> <span class="entity">thy</span> <span class="entity">trans_props</span> <span class="entity">ind_thm</span> <span class="entity">sort</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ind_case_tac</span> <span class="entity">ctxt</span> <span class="entity">i</span> <span class="entity">hyps</span> <span class="main">[</span><span class="entity">xy</span><span class="main">,</span><span class="entity">yz</span><span class="main">]</span> <span class="entity">params_x</span> <span class="main">[</span><span class="entity">y</span><span class="main">,</span><span class="entity">z</span><span class="main">]</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">j</span><span class="main">,</span><span class="entity">idx</span><span class="main">)</span> <span class="main">=</span> nth <span class="entity">nrec_args</span> <span class="entity">i</span> |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="entity">j</span><span class="main">,</span><span class="entity">idx</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">j</span><span class="main">,</span><span class="entity">idx</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">linfo</span> <span class="main">=</span> nth <span class="entity">descr</span> <span class="entity">idx</span> |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="main">(</span><span class="entity">ty_name</span><span class="main">,</span><span class="main">_</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">ty_name</span><span class="main">)</span>
          |&gt; <span class="entity">BNF_LFP_Compat.the_info</span> <span class="entity">thy</span> <span class="main">[</span><span class="main">]</span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">solve_with_tac</span> <span class="entity">ctxt</span> <span class="entity">thms</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simp_ctxt</span> <span class="main">=</span>
              <span class="main">(</span><span class="entity">ctxt</span>
                |&gt; Context_Position.set_visible false
                |&gt; put_simpset <span class="entity">my_simp_set</span><span class="main">)</span>
                addsimps <span class="main">(</span><span class="entity">simps_of_info</span> <span class="entity">info</span> @ <span class="entity">simps_of_info</span> <span class="entity">linfo</span> @ <span class="entity">thms</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">mk_solve_with_tac</span> <span class="entity">simp_ctxt</span> <span class="entity">thms</span> <span class="main">(</span><span class="entity">asm_full_simp_tac</span> <span class="entity">simp_ctxt</span> <span class="inner_numeral">1</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>

        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">case_tac</span> <span class="entity">ctxt</span> <span class="entity">y_z</span> <span class="main">=</span> <span class="entity">mk_case_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">[</span>SOME <span class="entity">y_z</span><span class="main">]</span><span class="main">]</span> <span class="main">(</span><span class="main">#</span>exhaust <span class="entity">linfo</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">sub_case_tac</span> <span class="main">(</span><span class="entity">ctxt</span><span class="main">,</span><span class="entity">k</span><span class="main">,</span><span class="entity">prems</span><span class="main">,</span><span class="entity">iparams_y</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">case_hyp_y</span> <span class="main">=</span> hd <span class="entity">prems</span>
            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">sub_sub_case_tac</span> <span class="main">(</span><span class="entity">ctxt</span><span class="main">,</span><span class="entity">l</span><span class="main">,</span><span class="entity">prems</span><span class="main">,</span><span class="entity">iparams_z</span><span class="main">)</span> <span class="main">=</span>
              <span class="keyword2"><span class="keyword">let</span></span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">case_hyp_z</span> <span class="main">=</span> hd <span class="entity">prems</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">comp_eq</span> <span class="main">=</span> <span class="main">[</span><span class="entity">case_hyp_z</span><span class="main">,</span> <span class="entity">case_hyp_y</span><span class="main">,</span> <span class="entity">xy</span><span class="main">,</span> <span class="entity">yz</span><span class="main">]</span>
              <span class="keyword2"><span class="keyword">in</span></span>
                <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">j</span> <span class="main">=</span> <span class="entity">l</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">l</span> <span class="main">=</span> <span class="entity">k</span><span class="main">)</span>
                <span class="keyword2"><span class="keyword">then</span></span>
                  K <span class="main">(</span><span class="entity">solve_with_tac</span> <span class="entity">ctxt</span> <span class="entity">comp_eq</span><span class="main">)</span>
                <span class="keyword2"><span class="keyword">else</span></span>
                  <span class="keyword2"><span class="keyword">let</span></span>
                    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">params_y</span> <span class="main">=</span> map <span class="main">(</span>snd #&gt; Thm.term_of<span class="main">)</span> <span class="entity">iparams_y</span>
                    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">params_z</span> <span class="main">=</span> map <span class="main">(</span>snd #&gt; Thm.term_of<span class="main">)</span> <span class="entity">iparams_z</span>
                    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">c_info</span> <span class="main">=</span> nth <span class="entity">descr</span> <span class="entity">idx</span> |&gt; snd |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="main">_</span><span class="main">,</span><span class="entity">info</span><span class="main">)</span> <span class="main">=&gt;</span> nth <span class="entity">info</span> <span class="entity">j</span><span class="main">)</span>
                    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pdtys</span> <span class="main">=</span> snd <span class="entity">c_info</span>
                    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">build_disj</span> <span class="main">=</span> <span class="entity">mk_less_disj</span> <span class="entity">mk_less</span>
                    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">xy'</span> <span class="main">=</span> <span class="entity">build_disj</span> <span class="entity">params_x</span> <span class="entity">params_y</span> <span class="entity">pdtys</span>
                    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">yz'</span> <span class="main">=</span> <span class="entity">build_disj</span> <span class="entity">params_y</span> <span class="entity">params_z</span> <span class="entity">pdtys</span>
                    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">disj_thm</span> <span class="entity">t</span> <span class="main">=</span> Goal.prove_future <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">t</span> <span class="main">(</span>K <span class="main">(</span><span class="entity">solve_with_tac</span> <span class="entity">ctxt</span> <span class="entity">comp_eq</span><span class="main">)</span><span class="main">)</span>
                    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">xy_disj</span> <span class="main">=</span> <span class="entity">disj_thm</span> <span class="entity">xy'</span>
                    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">yz_disj</span> <span class="main">=</span> <span class="entity">disj_thm</span> <span class="entity">yz'</span>
                    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">solve_tac</span> <span class="entity">xy</span> <span class="main">_</span> <span class="main">[</span><span class="main">]</span> <span class="main">_</span> <span class="main">_</span> <span class="main">_</span> <span class="main">_</span> <span class="main">_</span> <span class="main">=</span> K <span class="main">(</span><span class="entity">solve_with_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">xy</span><span class="main">]</span><span class="main">)</span>
                      <span class="main">|</span> <span class="entity">solve_tac</span> <span class="entity">xy</span> <span class="entity">yz</span> <span class="main">(</span><span class="entity">px</span> :: <span class="entity">pxs</span><span class="main">)</span> <span class="main">(</span><span class="entity">py</span> :: <span class="entity">pys</span><span class="main">)</span> <span class="main">(</span><span class="entity">pz</span> :: <span class="entity">pzs</span><span class="main">)</span> <span class="main">(</span><span class="entity">dty</span> :: <span class="entity">dtys</span><span class="main">)</span> <span class="entity">eqs</span> <span class="entity">ihyps</span> <span class="main">=</span>
                          <span class="keyword2"><span class="keyword">let</span></span>
                            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">case_tac_disj</span> <span class="entity">ctxt</span> <span class="entity">disj</span> <span class="entity">tac</span> <span class="main">=</span>
                              <span class="entity">mk_case_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> disjE<span class="antiquote">}</span></span></span> OF <span class="main">[</span><span class="entity">disj</span><span class="main">]</span><span class="main">)</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">ctxt</span><span class="main">,</span><span class="entity">ii</span><span class="main">,</span><span class="entity">hyps</span><span class="main">,</span><span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">tac</span> <span class="entity">ii</span> <span class="entity">ctxt</span> <span class="main">(</span>List.last <span class="entity">hyps</span><span class="main">)</span><span class="main">)</span>
                            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">yz_case_tac</span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="entity">case_tac_disj</span> <span class="entity">ctxt</span> <span class="entity">yz</span>
                            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rec_type</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">Old_Datatype_Aux.DtRec</span> <span class="main">_</span> <span class="main">=&gt;</span> true <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false<span class="main">)</span> <span class="entity">dty</span>
                            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">xy_tac</span> <span class="entity">ii</span> <span class="entity">ctxt</span> <span class="entity">hyp_xy</span> <span class="main">=</span>
                              <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">ii</span> <span class="main">=</span> <span class="inner_numeral">1</span> <span class="comment1">(* right branch, px = py and pxs &lt; pys *)</span>
                              <span class="keyword2"><span class="keyword">then</span></span>
                                <span class="keyword2"><span class="keyword">let</span></span>
                                  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq_term</span> <span class="main">=</span> <span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">px</span><span class="main">,</span><span class="entity">py</span><span class="main">)</span> |&gt; <span class="entity">HOLogic.mk_Trueprop</span>
                                  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq_xy_thm</span> <span class="main">=</span> Goal.prove_future <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">eq_term</span> <span class="main">(</span>K <span class="main">(</span><span class="entity">solve_with_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">hyp_xy</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
                                  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">xy'_thm</span> <span class="main">=</span> Goal.prove_future <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span><span class="entity">build_disj</span> <span class="entity">pxs</span> <span class="entity">pys</span> <span class="entity">dtys</span><span class="main">)</span> <span class="main">(</span>K <span class="main">(</span><span class="entity">solve_with_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">hyp_xy</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
                                  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">yz_tac</span> <span class="entity">jj</span> <span class="entity">ctxt</span> <span class="entity">hyp_yz</span> <span class="main">=</span>
                                  <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">jj</span> <span class="main">=</span> <span class="inner_numeral">1</span> <span class="comment1">(* right branch, py = pz and pys &lt; pzs *)</span>
                                    <span class="comment1">(* = and = *)</span>
                                  <span class="keyword2"><span class="keyword">then</span></span>
                                    <span class="keyword2"><span class="keyword">let</span></span>
                                      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq_term</span> <span class="main">=</span> <span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">px</span><span class="main">,</span><span class="entity">pz</span><span class="main">)</span> |&gt; <span class="entity">HOLogic.mk_Trueprop</span>
                                      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq_thm</span>  <span class="main">=</span> Goal.prove_future <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">eq_term</span> <span class="main">(</span>K <span class="main">(</span><span class="entity">solve_with_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">eq_xy_thm</span><span class="main">,</span><span class="entity">hyp_yz</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
                                      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">yz'_thm</span> <span class="main">=</span> Goal.prove_future <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span><span class="entity">build_disj</span> <span class="entity">pys</span> <span class="entity">pzs</span> <span class="entity">dtys</span><span class="main">)</span> <span class="main">(</span>K <span class="main">(</span><span class="entity">solve_with_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">hyp_yz</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
                                      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">drop_hyps</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">rec_type</span> <span class="keyword2"><span class="keyword">then</span></span> tl <span class="keyword2"><span class="keyword">else</span></span> I
                                    <span class="keyword2"><span class="keyword">in</span></span>
                                      <span class="entity">solve_tac</span> <span class="entity">xy'_thm</span> <span class="entity">yz'_thm</span> <span class="entity">pxs</span> <span class="entity">pys</span> <span class="entity">pzs</span> <span class="entity">dtys</span> <span class="main">(</span><span class="entity">eq_thm</span> :: <span class="entity">eqs</span><span class="main">)</span> <span class="main">(</span><span class="entity">drop_hyps</span> <span class="entity">ihyps</span><span class="main">)</span> <span class="inner_numeral">1</span>
                                    <span class="keyword2"><span class="keyword">end</span></span>
                                  <span class="keyword2"><span class="keyword">else</span></span> <span class="comment1">(* left branch, py &lt; pz *)</span>
                                    <span class="comment1">(* = and &lt; *)</span>
                                    <span class="keyword2"><span class="keyword">let</span></span>
                                      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">xz_term</span> <span class="main">=</span> <span class="entity">mk_less</span> <span class="entity">dty</span> <span class="entity">px</span> <span class="entity">pz</span> |&gt; <span class="entity">HOLogic.mk_Trueprop</span>
                                      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">xz_thm</span>  <span class="main">=</span> Goal.prove_future <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">xz_term</span> <span class="main">(</span>K <span class="main">(</span><span class="entity">solve_with_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">hyp_xy</span><span class="main">,</span><span class="entity">hyp_yz</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
                                    <span class="keyword2"><span class="keyword">in</span></span>
                                      <span class="entity">solve_with_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">xz_thm</span> :: <span class="entity">case_hyp_z</span> :: <span class="entity">eqs</span><span class="main">)</span>
                                    <span class="keyword2"><span class="keyword">end</span></span>
                                <span class="keyword2"><span class="keyword">in</span></span>
                                  <span class="entity">yz_case_tac</span> <span class="entity">ctxt</span> <span class="entity">yz_tac</span>
                                <span class="keyword2"><span class="keyword">end</span></span>
                              <span class="keyword2"><span class="keyword">else</span></span> <span class="comment1">(* left branch, px &lt; py *)</span>
                                <span class="keyword2"><span class="keyword">let</span></span>
                                  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">xz_term</span> <span class="main">=</span> <span class="entity">mk_less</span> <span class="entity">dty</span> <span class="entity">px</span> <span class="entity">pz</span> |&gt; <span class="entity">HOLogic.mk_Trueprop</span>
                                  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">yz_tac</span> <span class="entity">jj</span> <span class="entity">ctxt</span> <span class="entity">hyp_yz</span> <span class="main">=</span>
                                    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">jj</span> <span class="main">=</span> <span class="inner_numeral">1</span> <span class="comment1">(* right branch, py = pz *)</span>
                                      <span class="comment1">(* &lt; and = *)</span>
                                    <span class="keyword2"><span class="keyword">then</span></span>
                                      <span class="keyword2"><span class="keyword">let</span></span>
                                        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">xz_thm</span> <span class="main">=</span> Goal.prove_future <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">xz_term</span> <span class="main">(</span>K <span class="main">(</span><span class="entity">solve_with_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">hyp_xy</span><span class="main">,</span><span class="entity">hyp_yz</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
                                      <span class="keyword2"><span class="keyword">in</span></span>
                                        <span class="entity">solve_with_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">xz_thm</span> :: <span class="entity">case_hyp_z</span> :: <span class="entity">eqs</span><span class="main">)</span>
                                      <span class="keyword2"><span class="keyword">end</span></span>
                                    <span class="keyword2"><span class="keyword">else</span></span> <span class="comment1">(* left branch, py &lt; pz *)</span>
                                      <span class="comment1">(* &lt; and &lt; *)</span>
                                      <span class="keyword2"><span class="keyword">let</span></span>
                                        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">trans_thm</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">rec_type</span> <span class="keyword2"><span class="keyword">then</span></span> hd <span class="entity">ihyps</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> less_trans<span class="antiquote">}</span></span></span>
                                        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tac</span> <span class="main">=</span> resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">trans_thm</span> OF <span class="main">[</span><span class="entity">hyp_xy</span><span class="main">,</span><span class="entity">hyp_yz</span><span class="main">]</span><span class="main">]</span> <span class="inner_numeral">1</span>
                                        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">xz_thm</span> <span class="main">=</span> Goal.prove_future <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">xz_term</span> <span class="main">(</span>K <span class="entity">tac</span><span class="main">)</span>
                                      <span class="keyword2"><span class="keyword">in</span></span>
                                        <span class="entity">solve_with_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">xz_thm</span> :: <span class="entity">case_hyp_z</span> :: <span class="entity">eqs</span><span class="main">)</span>
                                      <span class="keyword2"><span class="keyword">end</span></span>
                                <span class="keyword2"><span class="keyword">in</span></span>
                                  <span class="entity">yz_case_tac</span> <span class="entity">ctxt</span> <span class="entity">yz_tac</span>
                                <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
                            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">xy_case_tac</span> <span class="main">=</span> <span class="entity">case_tac_disj</span> <span class="entity">ctxt</span> <span class="entity">xy</span> <span class="entity">xy_tac</span>
                          <span class="keyword2"><span class="keyword">in</span></span>
                            K <span class="main">(</span><span class="entity">my_print_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="inner_quoted">"another case: "</span><span class="main">)</span> THEN <span class="entity">xy_case_tac</span><span class="main">)</span>
                          <span class="keyword2"><span class="keyword">end</span></span>
                  <span class="keyword2"><span class="keyword">in</span></span>
                    K <span class="main">(</span><span class="entity">my_print_tac</span> <span class="entity">ctxt</span> <span class="inner_quoted">"recursive case: "</span><span class="main">)</span>
                    THEN' <span class="entity">solve_tac</span> <span class="entity">xy_disj</span> <span class="entity">yz_disj</span> <span class="entity">params_x</span> <span class="entity">params_y</span> <span class="entity">params_z</span> <span class="entity">pdtys</span> <span class="main">[</span><span class="main">]</span> <span class="entity">hyps</span>
                  <span class="keyword2"><span class="keyword">end</span></span>
                <span class="main">)</span> <span class="inner_numeral">1</span>
              <span class="keyword2"><span class="keyword">end</span></span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="entity">my_print_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="inner_quoted">"consider constructor "</span> ^ string_of_int <span class="entity">k</span><span class="main">)</span> THEN
            <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">k</span> &gt;= <span class="entity">j</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">case_tac</span> <span class="entity">ctxt</span> <span class="entity">z</span> <span class="entity">sub_sub_case_tac</span> <span class="keyword2"><span class="keyword">else</span></span>
               <span class="entity">solve_with_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">case_hyp_y</span><span class="main">,</span><span class="entity">xy</span><span class="main">]</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* end sub_case tac *)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="entity">my_print_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="inner_quoted">"start induct "</span> ^ string_of_int <span class="entity">i</span><span class="main">)</span> THEN <span class="entity">case_tac</span> <span class="entity">ctxt</span> <span class="entity">y</span> <span class="entity">sub_case_tac</span>
      <span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* end ind_case tac *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">trans_thm</span> <span class="main">=</span>  <span class="entity">trans_thm_of_tac</span> <span class="entity">ind_case_tac</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">trans_eq_trm</span><span class="main">,</span><span class="entity">vars</span><span class="main">)</span> <span class="main">=</span> <span class="entity">mk_trans_eq_thm_trm</span> <span class="entity">thy</span> <span class="entity">info</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inst_trans</span> <span class="main">=</span> infer_instantiate' <span class="entity">ctxt</span> <span class="main">(</span>map <span class="main">(</span>SOME o Thm.cterm_of <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">vars</span><span class="main">)</span> <span class="entity">trans_thm</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">trans_eq_vars_string</span> <span class="main">=</span> map <span class="main">(</span>dest_Free #&gt; fst<span class="main">)</span> <span class="entity">vars</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tac_to_eq_thm</span> <span class="entity">tac</span> <span class="main">=</span> Goal.prove_global_future <span class="entity">thy</span> <span class="entity">trans_eq_vars_string</span> <span class="main">[</span><span class="main">]</span> <span class="entity">trans_eq_trm</span> <span class="main">(</span>K <span class="entity">tac</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq_tac</span> <span class="main">=</span> <span class="entity">mk_solve_with_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">inst_trans</span><span class="main">]</span> <span class="main">(</span><span class="entity">blast_tac</span> <span class="entity">ctxt</span> <span class="inner_numeral">1</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">trans_eq_thm</span> <span class="main">=</span> <span class="entity">tac_to_eq_thm</span> <span class="entity">eq_tac</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="entity">trans_thm</span><span class="main">,</span><span class="entity">trans_eq_thm</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mk_binary_less_thm</span> <span class="main">=</span> <span class="entity">mk_binary_thm</span> <span class="entity">mk_prop_trm</span> <span class="entity">mk_less_idx</span> <span class="entity">less_name</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_less_le_not_le_thm</span> <span class="entity">thy</span> <span class="entity">info</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sort</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">"order"</span><span class="antiquote">}</span></span>
    <span class="comment1">(* main property: x &lt; y ⟹ ¬ y ≤ x *)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prop_gen</span> <span class="entity">xs</span> <span class="main">[</span><span class="entity">less</span><span class="main">,</span><span class="entity">lesseq</span><span class="main">]</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span><span class="entity">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">xs</span> <span class="inner_numeral">1</span><span class="main">,</span> <span class="entity">xs</span> <span class="inner_numeral">2</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="main">[</span><span class="entity">less</span> <span class="entity">x</span> <span class="entity">y</span><span class="main">,</span> <span class="entity">lesseq</span> <span class="entity">y</span> <span class="entity">x</span> |&gt; <span class="entity">HOLogic.mk_not</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="entity">x</span><span class="main">,</span><span class="entity">y</span><span class="main">]</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">main_tac</span> <span class="entity">ctxt</span> <span class="entity">ih_hyps</span> <span class="entity">ih_prems</span> <span class="entity">y_prem</span> <span class="entity">solve_with_tac</span> <span class="main">_</span> <span class="entity">params_x</span> <span class="entity">params_y</span> <span class="entity">c_info</span> <span class="entity">mk_less</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pdtys</span> <span class="main">=</span> snd <span class="entity">c_info</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">comp_eq</span> <span class="main">=</span> <span class="entity">y_prem</span> :: <span class="entity">ih_prems</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">build_disj</span> <span class="main">=</span> <span class="entity">mk_less_disj</span> <span class="entity">mk_less</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">xy'</span> <span class="main">=</span> <span class="entity">build_disj</span> <span class="entity">params_x</span> <span class="entity">params_y</span> <span class="entity">pdtys</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">xy_disj</span> <span class="main">=</span> Goal.prove_future <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">xy'</span> <span class="main">(</span>K <span class="main">(</span><span class="entity">solve_with_tac</span> <span class="entity">ctxt</span> <span class="entity">comp_eq</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">solve_tac</span> <span class="entity">ctxt</span> <span class="entity">xy</span> <span class="main">[</span><span class="main">]</span> <span class="main">_</span> <span class="main">_</span> <span class="main">_</span> <span class="main">_</span> <span class="main">=</span> <span class="entity">solve_with_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">xy</span><span class="main">]</span>
          <span class="main">|</span> <span class="entity">solve_tac</span> <span class="entity">ctxt</span> <span class="entity">xy</span> <span class="main">(</span><span class="entity">px</span> :: <span class="entity">pxs</span><span class="main">)</span> <span class="main">(</span><span class="entity">py</span> :: <span class="entity">pys</span><span class="main">)</span> <span class="main">(</span><span class="entity">dty</span> :: <span class="entity">dtys</span><span class="main">)</span> <span class="entity">eqs</span> <span class="entity">ihyps</span> <span class="main">=</span>
              <span class="keyword2"><span class="keyword">let</span></span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">xs_ys</span> <span class="main">=</span> <span class="entity">build_disj</span> <span class="entity">pxs</span> <span class="entity">pys</span> <span class="entity">dtys</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">x_eq_y</span> <span class="main">=</span> <span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">px</span><span class="main">,</span><span class="entity">py</span><span class="main">)</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">x_less_y</span> <span class="main">=</span> <span class="entity">mk_less</span> <span class="entity">dty</span> <span class="entity">px</span> <span class="entity">py</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">disj2</span> <span class="main">=</span>
                  <span class="entity">HOLogic.mk_disj</span> <span class="main">(</span><span class="entity">x_less_y</span><span class="main">,</span> <span class="entity">HOLogic.mk_conj</span> <span class="main">(</span><span class="entity">HOLogic.mk_not</span> <span class="entity">x_less_y</span><span class="main">,</span> <span class="entity">HOLogic.mk_conj</span><span class="main">(</span> <span class="entity">x_eq_y</span><span class="main">,</span> <span class="entity">HOLogic.dest_Trueprop</span> <span class="entity">xs_ys</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                  |&gt; <span class="entity">HOLogic.mk_Trueprop</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">disj2_thm</span> <span class="main">=</span> Goal.prove_future <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">disj2</span> <span class="main">(</span>K <span class="main">(</span><span class="entity">Method.insert_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">xy</span><span class="main">]</span> <span class="inner_numeral">1</span> THEN <span class="entity">blast_tac</span> <span class="entity">ctxt</span> <span class="inner_numeral">1</span><span class="main">)</span><span class="main">)</span>
                <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">case_tac_disj</span> <span class="entity">disj</span> <span class="entity">tac</span> <span class="main">=</span>
                  <span class="entity">mk_case_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> disjE<span class="antiquote">}</span></span></span> OF <span class="main">[</span><span class="entity">disj</span><span class="main">]</span><span class="main">)</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">ctxt</span><span class="main">,</span><span class="entity">ii</span><span class="main">,</span><span class="entity">hyps</span><span class="main">,</span><span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">tac</span> <span class="entity">ii</span> <span class="entity">ctxt</span> <span class="main">(</span>List.last <span class="entity">hyps</span><span class="main">)</span><span class="main">)</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rec_type</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">Old_Datatype_Aux.DtRec</span> <span class="main">_</span> <span class="main">=&gt;</span> true <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false<span class="main">)</span> <span class="entity">dty</span>
                <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">xy_tac</span> <span class="entity">ii</span> <span class="entity">ctxt</span> <span class="entity">hyp_xy</span> <span class="main">=</span>
                  <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">ii</span> <span class="main">=</span> <span class="inner_numeral">1</span>
                  <span class="keyword2"><span class="keyword">then</span></span> <span class="comment1">(* right branch, px = py and ¬ px &lt; py and pxs &lt; pys *)</span>
                    <span class="keyword2"><span class="keyword">let</span></span>
                      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq_term</span> <span class="main">=</span> <span class="entity">x_eq_y</span> |&gt; <span class="entity">HOLogic.mk_Trueprop</span>
                      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq_xy_thm</span> <span class="main">=</span> Goal.prove_future <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">eq_term</span> <span class="main">(</span>K <span class="main">(</span><span class="entity">solve_with_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">hyp_xy</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
                      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">xy'_thm</span> <span class="main">=</span> Goal.prove_future <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">xs_ys</span> <span class="main">(</span>K <span class="main">(</span><span class="entity">solve_with_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">hyp_xy</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
                      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">yx_thm</span> <span class="main">=</span>
                        Goal.prove_future <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span><span class="entity">mk_less</span> <span class="entity">dty</span> <span class="entity">py</span> <span class="entity">px</span> |&gt; <span class="entity">HOLogic.mk_not</span> |&gt; <span class="entity">HOLogic.mk_Trueprop</span><span class="main">)</span>
                        <span class="main">(</span>K <span class="main">(</span><span class="entity">solve_with_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">hyp_xy</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
                      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ihyps'</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">rec_type</span> <span class="keyword2"><span class="keyword">then</span></span> tl <span class="entity">ihyps</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">ihyps</span>
                      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">solve_rec</span> <span class="main">=</span> <span class="entity">solve_tac</span> <span class="entity">ctxt</span> <span class="entity">xy'_thm</span> <span class="entity">pxs</span> <span class="entity">pys</span> <span class="entity">dtys</span> <span class="main">(</span><span class="entity">eq_xy_thm</span> :: <span class="entity">yx_thm</span> :: <span class="entity">eqs</span><span class="main">)</span> <span class="entity">ihyps'</span>
                    <span class="keyword2"><span class="keyword">in</span></span>
                      <span class="entity">solve_rec</span>
                    <span class="keyword2"><span class="keyword">end</span></span>
                  <span class="keyword2"><span class="keyword">else</span></span> <span class="comment1">(* left branch, px &lt; py *)</span>
                       <span class="comment1">(* hence ¬ py ≤ px (yx_thm) *)</span>
                    <span class="keyword2"><span class="keyword">let</span></span>
                      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">yx</span> <span class="main">=</span> <span class="entity">HOLogic.mk_disj</span> <span class="main">(</span><span class="entity">mk_less</span> <span class="entity">dty</span> <span class="entity">py</span> <span class="entity">px</span><span class="main">,</span> <span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">py</span><span class="main">,</span><span class="entity">px</span><span class="main">)</span><span class="main">)</span> |&gt; <span class="entity">HOLogic.mk_not</span> |&gt; <span class="entity">HOLogic.mk_Trueprop</span>
                      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tac</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">rec_type</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">solve_with_tac</span> <span class="entity">ctxt</span> <span class="main">[</span>hd <span class="entity">ihyps</span> OF <span class="main">[</span><span class="entity">hyp_xy</span><span class="main">]</span><span class="main">]</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">solve_with_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">hyp_xy</span><span class="main">]</span>
                      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">yx_thm</span> <span class="main">=</span> Goal.prove_future <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">yx</span> <span class="main">(</span>K <span class="entity">tac</span><span class="main">)</span>
                    <span class="keyword2"><span class="keyword">in</span></span>
                      <span class="entity">solve_with_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">yx_thm</span> :: <span class="entity">y_prem</span> :: <span class="entity">eqs</span><span class="main">)</span>
                    <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
              <span class="keyword2"><span class="keyword">in</span></span>
                <span class="entity">case_tac_disj</span> <span class="entity">disj2_thm</span> <span class="entity">xy_tac</span>
              <span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* end solve tac *)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="entity">solve_tac</span> <span class="entity">ctxt</span> <span class="entity">xy_disj</span> <span class="entity">params_x</span> <span class="entity">params_y</span> <span class="entity">pdtys</span> <span class="main">[</span><span class="main">]</span> <span class="entity">ih_hyps</span> <span class="main">:</span> tactic<span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* end main_tac *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">main_thm</span> <span class="main">=</span> <span class="entity">mk_binary_less_thm</span> <span class="entity">thy</span> <span class="entity">info</span> <span class="entity">prop_gen</span> <span class="entity">sort</span> <span class="entity">main_tac</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt</span> <span class="main">=</span> Proof_Context.init_global <span class="entity">thy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">thm_trm</span><span class="main">,</span><span class="entity">vars</span><span class="main">)</span> <span class="main">=</span> <span class="entity">mk_prop_major_trm</span> <span class="entity">thy</span> <span class="entity">info</span> <span class="entity">sort</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">xs</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">[</span><span class="entity">less</span><span class="main">,</span><span class="entity">lesseq</span><span class="main">]</span> <span class="main">=&gt;</span>
      <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span><span class="entity">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">xs</span> <span class="inner_numeral">1</span><span class="main">,</span> <span class="entity">xs</span> <span class="inner_numeral">2</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="main">[</span><span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">less</span> <span class="entity">x</span> <span class="entity">y</span><span class="main">,</span><span class="entity">HOLogic.mk_conj</span> <span class="main">(</span><span class="entity">lesseq</span> <span class="entity">x</span> <span class="entity">y</span><span class="main">,</span> <span class="entity">lesseq</span> <span class="entity">y</span> <span class="entity">x</span> |&gt; <span class="entity">HOLogic.mk_not</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="entity">x</span><span class="main">,</span><span class="entity">y</span><span class="main">]</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inst_thm</span> <span class="main">=</span> infer_instantiate' <span class="entity">ctxt</span> <span class="main">(</span>map <span class="main">(</span>SOME o Thm.cterm_of <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">vars</span><span class="main">)</span> <span class="entity">main_thm</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">vars_strings</span> <span class="main">=</span> map <span class="main">(</span>dest_Free #&gt; fst<span class="main">)</span> <span class="entity">vars</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm</span> <span class="main">=</span>
      Goal.prove_future <span class="entity">ctxt</span> <span class="entity">vars_strings</span> <span class="main">[</span><span class="main">]</span> <span class="entity">thm_trm</span>
        <span class="main">(</span>K <span class="main">(</span><span class="entity">Method.insert_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">inst_thm</span><span class="main">]</span> <span class="inner_numeral">1</span> THEN <span class="entity">blast_tac</span> <span class="entity">ctxt</span> <span class="inner_numeral">1</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">thm</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_le_refl_thm</span> <span class="entity">thy</span> <span class="entity">info</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sort</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">"order"</span><span class="antiquote">}</span></span>
    <span class="comment1">(* x ≤ x *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt</span> <span class="main">=</span> Proof_Context.init_global <span class="entity">thy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">thm_trm</span><span class="main">,</span><span class="entity">vars</span><span class="main">)</span> <span class="main">=</span> <span class="entity">mk_prop_major_trm</span> <span class="entity">thy</span> <span class="entity">info</span> <span class="entity">sort</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">xs</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">[</span><span class="main">_</span><span class="main">,</span><span class="entity">lesseq</span><span class="main">]</span> <span class="main">=&gt;</span>
      <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">x</span> <span class="main">=</span> <span class="entity">xs</span> <span class="inner_numeral">1</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="main">[</span><span class="entity">lesseq</span> <span class="entity">x</span> <span class="entity">x</span><span class="main">]</span><span class="main">,</span><span class="main">[</span><span class="entity">x</span><span class="main">]</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">vars_strings</span> <span class="main">=</span> map <span class="main">(</span>dest_Free #&gt; fst<span class="main">)</span> <span class="entity">vars</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Goal.prove_future <span class="entity">ctxt</span> <span class="entity">vars_strings</span> <span class="main">[</span><span class="main">]</span> <span class="entity">thm_trm</span> <span class="main">(</span>K <span class="main">(</span><span class="entity">blast_tac</span> <span class="entity">ctxt</span> <span class="inner_numeral">1</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_antisym_thm</span> <span class="entity">thy</span> <span class="entity">info</span> <span class="entity">trans_thm</span> <span class="entity">less_thm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sort</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">"order"</span><span class="antiquote">}</span></span>
    <span class="comment1">(* x ≤ y ⟹ y ≤ x ⟹ x = y *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt</span> <span class="main">=</span> Proof_Context.init_global <span class="entity">thy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">thm_trm</span><span class="main">,</span><span class="entity">vars</span><span class="main">)</span> <span class="main">=</span> <span class="entity">mk_prop_major_trm</span> <span class="entity">thy</span> <span class="entity">info</span> <span class="entity">sort</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">xs</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">[</span><span class="main">_</span><span class="main">,</span><span class="entity">lesseq</span><span class="main">]</span> <span class="main">=&gt;</span>
      <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span><span class="entity">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">xs</span> <span class="inner_numeral">1</span><span class="main">,</span> <span class="entity">xs</span> <span class="inner_numeral">2</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="main">[</span><span class="entity">lesseq</span> <span class="entity">x</span> <span class="entity">y</span><span class="main">,</span> <span class="entity">lesseq</span> <span class="entity">y</span> <span class="entity">x</span><span class="main">,</span> <span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span><span class="entity">y</span><span class="main">)</span><span class="main">]</span><span class="main">,</span><span class="main">[</span><span class="entity">x</span><span class="main">,</span><span class="entity">y</span><span class="main">]</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">vars_strings</span> <span class="main">=</span> map <span class="main">(</span>dest_Free #&gt; fst<span class="main">)</span> <span class="entity">vars</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tvars</span> <span class="main">=</span> <span class="entity">vars</span> @ <span class="main">[</span>hd <span class="entity">vars</span><span class="main">]</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lvars</span> <span class="main">=</span> <span class="main">[</span>hd <span class="entity">vars</span><span class="main">,</span>hd <span class="entity">vars</span><span class="main">]</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">inst_thm</span> <span class="entity">vars</span> <span class="entity">thm</span> <span class="main">=</span> infer_instantiate' <span class="entity">ctxt</span> <span class="main">(</span>map <span class="main">(</span>SOME o Thm.cterm_of <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">vars</span><span class="main">)</span> <span class="entity">thm</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inst_trans</span> <span class="main">=</span> <span class="entity">inst_thm</span> <span class="entity">tvars</span> <span class="entity">trans_thm</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inst_less</span> <span class="main">=</span> <span class="entity">inst_thm</span> <span class="entity">lvars</span> <span class="entity">less_thm</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">res</span> <span class="main">=</span>
      Goal.prove_future <span class="entity">ctxt</span> <span class="entity">vars_strings</span> <span class="main">[</span><span class="main">]</span> <span class="entity">thm_trm</span>
        <span class="main">(</span>K <span class="main">(</span><span class="entity">Method.insert_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">inst_trans</span><span class="main">,</span><span class="entity">inst_less</span><span class="main">]</span> <span class="inner_numeral">1</span> THEN <span class="entity">blast_tac</span> <span class="entity">ctxt</span> <span class="inner_numeral">1</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">res</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_order_thms</span> <span class="entity">thy</span> <span class="entity">info</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">trans</span><span class="main">,</span><span class="entity">trans_eq</span><span class="main">)</span> <span class="main">=</span> <span class="entity">mk_transitivity_thms</span> <span class="entity">thy</span> <span class="entity">info</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">less</span> <span class="main">=</span> <span class="entity">mk_less_le_not_le_thm</span> <span class="entity">thy</span> <span class="entity">info</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">refl</span> <span class="main">=</span> <span class="entity">mk_le_refl_thm</span> <span class="entity">thy</span> <span class="entity">info</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">antisym</span> <span class="main">=</span> <span class="entity">mk_antisym_thm</span> <span class="entity">thy</span> <span class="entity">info</span> <span class="entity">trans</span> <span class="entity">less</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">[</span><span class="entity">trans_eq</span><span class="main">,</span><span class="entity">less</span><span class="main">,</span><span class="entity">refl</span><span class="main">,</span><span class="entity">antisym</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_linear_thm</span> <span class="entity">thy</span> <span class="entity">info</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sort</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">"linorder"</span><span class="antiquote">}</span></span>
    <span class="comment1">(* main property: x = y ∨ x &lt; y ∨ y &lt; x *)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prop_gen</span> <span class="entity">xs</span> <span class="main">[</span><span class="entity">less</span><span class="main">,</span><span class="main">_</span><span class="main">]</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span><span class="entity">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">xs</span> <span class="inner_numeral">1</span><span class="main">,</span> <span class="entity">xs</span> <span class="inner_numeral">2</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="main">[</span><span class="entity">HOLogic.mk_disj</span> <span class="main">(</span><span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span><span class="entity">y</span><span class="main">)</span><span class="main">,</span><span class="entity">HOLogic.mk_disj</span><span class="main">(</span><span class="entity">less</span> <span class="entity">x</span> <span class="entity">y</span><span class="main">,</span> <span class="entity">less</span> <span class="entity">y</span> <span class="entity">x</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">,</span><span class="main">[</span><span class="entity">x</span><span class="main">,</span><span class="entity">y</span><span class="main">]</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">main_tac</span> <span class="entity">ctxt</span> <span class="entity">ih_hyps</span> <span class="main">_</span> <span class="entity">y_prem</span> <span class="entity">solve_with_tac</span> <span class="main">_</span> <span class="entity">params_x</span> <span class="entity">params_y</span> <span class="entity">c_info</span> <span class="entity">mk_less</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pdtys</span> <span class="main">=</span> snd <span class="entity">c_info</span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">solve_tac</span> <span class="main">[</span><span class="main">]</span> <span class="main">_</span> <span class="main">_</span> <span class="entity">eqs</span> <span class="main">_</span> <span class="main">=</span> <span class="entity">solve_with_tac</span> <span class="entity">ctxt</span> <span class="entity">eqs</span>
          <span class="main">|</span> <span class="entity">solve_tac</span> <span class="main">(</span><span class="entity">px</span> :: <span class="entity">pxs</span><span class="main">)</span> <span class="main">(</span><span class="entity">py</span> :: <span class="entity">pys</span><span class="main">)</span> <span class="main">(</span><span class="entity">dty</span> :: <span class="entity">dtys</span><span class="main">)</span> <span class="entity">eqs</span> <span class="entity">ihyps</span> <span class="main">=</span>
              <span class="keyword2"><span class="keyword">let</span></span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">less</span> <span class="main">=</span> <span class="entity">mk_less</span> <span class="entity">dty</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">x_eq_y</span> <span class="main">=</span> <span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">px</span><span class="main">,</span><span class="entity">py</span><span class="main">)</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">disj_trm</span> <span class="main">=</span> <span class="entity">HOLogic.mk_disj</span> <span class="main">(</span><span class="entity">x_eq_y</span><span class="main">,</span><span class="entity">HOLogic.mk_disj</span><span class="main">(</span><span class="entity">less</span> <span class="entity">px</span> <span class="entity">py</span><span class="main">,</span> <span class="entity">less</span> <span class="entity">py</span> <span class="entity">px</span><span class="main">)</span><span class="main">)</span> |&gt; <span class="entity">HOLogic.mk_Trueprop</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rec_type</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">Old_Datatype_Aux.DtRec</span> <span class="main">_</span> <span class="main">=&gt;</span> true <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false<span class="main">)</span> <span class="entity">dty</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">disj_thm'</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">rec_type</span> <span class="keyword2"><span class="keyword">then</span></span> hd <span class="entity">ihyps</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> linear_cases<span class="antiquote">}</span></span></span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">disj_tac</span> <span class="main">=</span> resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">disj_thm'</span><span class="main">]</span> <span class="inner_numeral">1</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">disj_thm</span> <span class="main">=</span> Goal.prove_future <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">disj_trm</span> <span class="main">(</span>K <span class="main">(</span><span class="entity">disj_tac</span><span class="main">)</span><span class="main">)</span>
                <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">case_tac_disj</span> <span class="entity">disj</span> <span class="entity">tac</span> <span class="main">=</span>
                  <span class="entity">mk_case_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> disjE<span class="antiquote">}</span></span></span> OF <span class="main">[</span><span class="entity">disj</span><span class="main">]</span><span class="main">)</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">ctxt</span><span class="main">,</span><span class="entity">ii</span><span class="main">,</span><span class="entity">hyps</span><span class="main">,</span><span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">tac</span> <span class="entity">ii</span> <span class="entity">ctxt</span> <span class="main">(</span>List.last <span class="entity">hyps</span><span class="main">)</span><span class="main">)</span>
                <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">eq_less_less_tac</span> <span class="entity">ii</span> <span class="main">_</span> <span class="entity">eq_less</span> <span class="main">=</span>
                  <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">ii</span> <span class="main">=</span> <span class="inner_numeral">0</span>
                  <span class="keyword2"><span class="keyword">then</span></span> <span class="comment1">(* left branch, px = py *)</span>
                    <span class="keyword2"><span class="keyword">let</span></span>
                      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ihyps'</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">rec_type</span> <span class="keyword2"><span class="keyword">then</span></span> tl <span class="entity">ihyps</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">ihyps</span>
                      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">solve_rec</span> <span class="main">=</span> <span class="entity">solve_tac</span> <span class="entity">pxs</span> <span class="entity">pys</span> <span class="entity">dtys</span> <span class="main">(</span><span class="entity">eq_less</span> :: <span class="entity">eqs</span><span class="main">)</span> <span class="entity">ihyps'</span>
                    <span class="keyword2"><span class="keyword">in</span></span>
                      <span class="entity">solve_rec</span>
                    <span class="keyword2"><span class="keyword">end</span></span>
                  <span class="keyword2"><span class="keyword">else</span></span> <span class="comment1">(* right branch, px &lt; py ∨ py &lt; px *)</span>
                    <span class="keyword2"><span class="keyword">let</span></span>
                      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">less_tac</span> <span class="main">_</span> <span class="main">_</span> <span class="entity">less</span> <span class="main">=</span> <span class="entity">solve_with_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">less</span> :: <span class="entity">eqs</span><span class="main">)</span>
                    <span class="keyword2"><span class="keyword">in</span></span>
                      <span class="entity">case_tac_disj</span> <span class="entity">eq_less</span> <span class="entity">less_tac</span>
                    <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
              <span class="keyword2"><span class="keyword">in</span></span>
                <span class="entity">case_tac_disj</span> <span class="entity">disj_thm</span> <span class="entity">eq_less_less_tac</span>
              <span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* end solve tac *)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="entity">solve_tac</span> <span class="entity">params_x</span> <span class="entity">params_y</span> <span class="entity">pdtys</span> <span class="main">[</span><span class="entity">y_prem</span><span class="main">]</span> <span class="entity">ih_hyps</span> <span class="main">:</span> tactic<span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* end main tac *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">main_thm</span> <span class="main">=</span> <span class="entity">mk_binary_less_thm</span> <span class="entity">thy</span> <span class="entity">info</span> <span class="entity">prop_gen</span> <span class="entity">sort</span> <span class="entity">main_tac</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt</span> <span class="main">=</span> Proof_Context.init_global <span class="entity">thy</span>
    <span class="comment1">(* x ≤ y ∨ y ≤ x *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">thm_trm</span><span class="main">,</span><span class="entity">vars</span><span class="main">)</span> <span class="main">=</span> <span class="entity">mk_prop_major_trm</span> <span class="entity">thy</span> <span class="entity">info</span> <span class="entity">sort</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">xs</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">[</span><span class="main">_</span><span class="main">,</span><span class="entity">lesseq</span><span class="main">]</span> <span class="main">=&gt;</span>
      <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span><span class="entity">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">xs</span> <span class="inner_numeral">1</span><span class="main">,</span> <span class="entity">xs</span> <span class="inner_numeral">2</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="main">[</span><span class="entity">HOLogic.mk_disj</span> <span class="main">(</span><span class="entity">lesseq</span> <span class="entity">x</span> <span class="entity">y</span><span class="main">,</span><span class="entity">lesseq</span> <span class="entity">y</span> <span class="entity">x</span><span class="main">)</span><span class="main">]</span><span class="main">,</span><span class="main">[</span><span class="entity">x</span><span class="main">,</span><span class="entity">y</span><span class="main">]</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inst_thm</span> <span class="main">=</span> infer_instantiate' <span class="entity">ctxt</span> <span class="main">(</span>map <span class="main">(</span>SOME o Thm.cterm_of <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">vars</span><span class="main">)</span> <span class="entity">main_thm</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">vars_strings</span> <span class="main">=</span> map <span class="main">(</span>dest_Free #&gt; fst<span class="main">)</span> <span class="entity">vars</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm</span> <span class="main">=</span>
      Goal.prove_future <span class="entity">ctxt</span> <span class="entity">vars_strings</span> <span class="main">[</span><span class="main">]</span> <span class="entity">thm_trm</span>
        <span class="main">(</span>K <span class="main">(</span><span class="entity">Method.insert_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">inst_thm</span><span class="main">]</span> <span class="inner_numeral">1</span> THEN <span class="entity">blast_tac</span> <span class="entity">ctxt</span> <span class="inner_numeral">1</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">thm</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">derive</span> <span class="entity">kind</span> <span class="entity">dtyp_name</span> <span class="main">_</span> <span class="entity">thy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tyco</span> <span class="main">=</span> <span class="entity">dtyp_name</span>

    <span class="comment1">(* first register in class ord *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">base_name</span> <span class="main">=</span> Long_Name.base_name <span class="entity">tyco</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> writeln <span class="main">(</span><span class="inner_quoted">"creating orders for datatype "</span> ^ <span class="entity">base_name</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sort</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">ord</span><span class="antiquote">}</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">info</span> <span class="main">=</span> <span class="entity">BNF_LFP_Compat.the_info</span> <span class="entity">thy</span> <span class="main">[</span><span class="main">]</span> <span class="entity">tyco</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">vs_of_sort</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">i</span> <span class="main">=</span> <span class="entity">BNF_LFP_Compat.the_spec</span> <span class="entity">thy</span> <span class="entity">tyco</span> |&gt; <span class="main">#</span><span class="inner_numeral">1</span>
      <span class="keyword2"><span class="keyword">in</span></span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">sort</span> <span class="main">=&gt;</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">n</span><span class="main">,</span><span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">n</span><span class="main">,</span> <span class="entity">sort</span><span class="main">)</span><span class="main">)</span> <span class="entity">i</span> <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">vs</span> <span class="main">=</span> <span class="entity">vs_of_sort</span> <span class="entity">sort</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">less_rhs</span> <span class="main">=</span> <span class="entity">mk_less_idx</span> <span class="entity">thy</span> <span class="entity">info</span> <span class="entity">sort</span> |&gt; fst |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span> <span class="entity">x</span> <span class="inner_numeral">0</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty</span> <span class="main">=</span> Term.fastype_of <span class="entity">less_rhs</span> |&gt; Term.dest_Type |&gt; snd |&gt; hd
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_binrel_def</span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">mk_def</span> <span class="main">(</span><span class="entity">T</span> --&gt; <span class="entity">T</span> --&gt; <span class="entity">HOLogic.boolT</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">less_def</span> <span class="main">=</span> <span class="entity">mk_binrel_def</span> <span class="entity">ty</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> less<span class="antiquote">}</span></span> <span class="entity">less_rhs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">x</span> <span class="main">=</span> Free <span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span><span class="entity">ty</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">y</span> <span class="main">=</span> Free <span class="main">(</span><span class="inner_quoted">"y"</span><span class="main">,</span><span class="entity">ty</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">less_eq_rhs</span> <span class="main">=</span> lambda <span class="entity">x</span> <span class="main">(</span>lambda <span class="entity">y</span> <span class="main">(</span><span class="entity">HOLogic.mk_disj</span> <span class="main">(</span><span class="entity">less_rhs</span> $ <span class="entity">x</span> $ <span class="entity">y</span><span class="main">,</span> <span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span><span class="entity">y</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">less_eq_def</span> <span class="main">=</span> <span class="entity">mk_binrel_def</span> <span class="entity">ty</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> less_eq<span class="antiquote">}</span></span> <span class="entity">less_eq_rhs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">less_thm</span><span class="main">,</span><span class="entity">less_eq_thm</span><span class="main">)</span><span class="main">,</span><span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Class.instantiation</span> <span class="main">(</span><span class="main">[</span><span class="entity">tyco</span><span class="main">]</span><span class="main">,</span><span class="entity">vs</span><span class="main">,</span><span class="entity">sort</span><span class="main">)</span> <span class="entity">thy</span>
      |&gt; <span class="entity">define_overloaded</span> <span class="main">(</span><span class="inner_quoted">"less_"</span> ^ <span class="entity">base_name</span> ^ <span class="inner_quoted">"_def"</span><span class="main">,</span> <span class="entity">less_def</span><span class="main">)</span>
      ||&gt;&gt; <span class="entity">define_overloaded</span> <span class="main">(</span><span class="inner_quoted">"less_eq_"</span> ^ <span class="entity">base_name</span> ^ <span class="inner_quoted">"_def"</span><span class="main">,</span> <span class="entity">less_eq_def</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">less_thms</span> <span class="main">=</span> <span class="main">[</span><span class="entity">less_thm</span><span class="main">,</span> <span class="entity">less_eq_thm</span><span class="main">]</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy'</span> <span class="main">=</span> <span class="entity">Class.prove_instantiation_exit</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> <span class="entity">Class.intro_classes_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="entity">lthy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> writeln <span class="main">(</span><span class="inner_quoted">"registered "</span> ^ <span class="entity">base_name</span> ^ <span class="inner_quoted">" in class ord"</span><span class="main">)</span>

    <span class="comment1">(* next register in class order *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy''</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">kind</span> &lt; <span class="inner_numeral">1</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">thy'</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sort</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">order</span><span class="antiquote">}</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">vs</span> <span class="main">=</span> <span class="entity">vs_of_sort</span> <span class="entity">sort</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">[</span><span class="entity">trans_eq</span><span class="main">,</span><span class="entity">less</span><span class="main">,</span><span class="entity">refl</span><span class="main">,</span><span class="entity">antisym</span><span class="main">]</span> <span class="main">=</span> <span class="entity">mk_order_thms</span> <span class="entity">thy</span> <span class="entity">info</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lthy</span> <span class="main">=</span> <span class="entity">Class.instantiation</span> <span class="main">(</span><span class="main">[</span><span class="entity">tyco</span><span class="main">]</span><span class="main">,</span><span class="entity">vs</span><span class="main">,</span><span class="entity">sort</span><span class="main">)</span> <span class="entity">thy'</span>

          <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">order_tac</span> <span class="entity">ctxt</span> <span class="main">=</span>
            <span class="entity">my_print_tac</span> <span class="entity">ctxt</span> <span class="inner_quoted">"enter order"</span> THEN
            <span class="entity">unfold_tac</span> <span class="entity">ctxt</span> <span class="entity">less_thms</span> THEN
            <span class="entity">my_print_tac</span> <span class="entity">ctxt</span> <span class="inner_quoted">"after unfolding"</span> THEN
            resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">less</span><span class="main">]</span> <span class="inner_numeral">1</span> THEN
            <span class="entity">my_print_tac</span> <span class="entity">ctxt</span> <span class="inner_quoted">"after less"</span> THEN
            resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">refl</span><span class="main">]</span> <span class="inner_numeral">1</span> THEN
            <span class="entity">my_print_tac</span> <span class="entity">ctxt</span> <span class="inner_quoted">"after refl"</span> THEN
            resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">trans_eq</span><span class="main">]</span> <span class="inner_numeral">1</span> THEN assume_tac <span class="entity">ctxt</span> <span class="inner_numeral">1</span> THEN assume_tac <span class="entity">ctxt</span> <span class="inner_numeral">1</span> THEN
            <span class="entity">my_print_tac</span> <span class="entity">ctxt</span> <span class="inner_quoted">"after trans"</span> THEN
            resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">antisym</span><span class="main">]</span> <span class="inner_numeral">1</span> THEN assume_tac <span class="entity">ctxt</span> <span class="inner_numeral">1</span> THEN assume_tac <span class="entity">ctxt</span> <span class="inner_numeral">1</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy''</span> <span class="main">=</span>
            <span class="entity">Class.prove_instantiation_exit</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> <span class="entity">Class.intro_classes_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> THEN <span class="entity">order_tac</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">lthy</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> writeln <span class="main">(</span><span class="inner_quoted">"registered "</span> ^ <span class="entity">base_name</span> ^ <span class="inner_quoted">" in class order"</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">thy''</span> <span class="keyword2"><span class="keyword">end</span></span>

    <span class="comment1">(* next register in class linorder *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy'''</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">kind</span> &lt; <span class="inner_numeral">2</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">thy''</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sort</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">linorder</span><span class="antiquote">}</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">vs</span> <span class="main">=</span> <span class="entity">vs_of_sort</span> <span class="entity">sort</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lthy</span> <span class="main">=</span> <span class="entity">Class.instantiation</span> <span class="main">(</span><span class="main">[</span><span class="entity">tyco</span><span class="main">]</span><span class="main">,</span><span class="entity">vs</span><span class="main">,</span><span class="entity">sort</span><span class="main">)</span> <span class="entity">thy''</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">linear</span> <span class="main">=</span> <span class="entity">mk_linear_thm</span> <span class="entity">thy</span> <span class="entity">info</span>
          <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">order_tac</span> <span class="entity">ctxt</span> <span class="main">=</span>
            <span class="entity">unfold_tac</span> <span class="entity">ctxt</span> <span class="entity">less_thms</span> THEN
            resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">linear</span><span class="main">]</span> <span class="inner_numeral">1</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy'''</span> <span class="main">=</span> <span class="entity">Class.prove_instantiation_exit</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> <span class="entity">Class.intro_classes_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> THEN <span class="entity">order_tac</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">lthy</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> writeln <span class="main">(</span><span class="inner_quoted">"registered "</span> ^ <span class="entity">base_name</span> ^ <span class="inner_quoted">" in class linorder"</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">thy'''</span> <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">thy'''</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  Theory.setup
   <span class="main">(</span><span class="entity">Derive_Manager.register_derive</span> <span class="inner_quoted">"ord"</span> <span class="inner_quoted">"derives ord for a datatype"</span> <span class="main">(</span><span class="entity">derive</span> <span class="inner_numeral">0</span><span class="main">)</span> #&gt;
    <span class="entity">Derive_Manager.register_derive</span> <span class="inner_quoted">"order"</span> <span class="inner_quoted">"derives an order for a datatype"</span> <span class="main">(</span><span class="entity">derive</span> <span class="inner_numeral">1</span><span class="main">)</span> #&gt;
    <span class="entity">Derive_Manager.register_derive</span> <span class="inner_quoted">"linorder"</span> <span class="inner_quoted">"derives a linear order for a datatype"</span> <span class="main">(</span><span class="entity">derive</span> <span class="inner_numeral">2</span><span class="main">)</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Hash_Generator">
<div class="head">
<h1>Theory Hash_Generator</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Deriving class instances for datatypes
    Author:      René Thiemann       &lt;rene.thiemann@uibk.ac.at&gt;
    Maintainer:  René Thiemann
    License:     LGPL
*)</span>

<span class="comment1">(*
Copyright 2013 René Thiemann

This file is part of IsaFoR/CeTA.

IsaFoR/CeTA is free software: you can redistribute it and/or modify it under the
terms of the GNU Lesser General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

IsaFoR/CeTA is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along
with IsaFoR/CeTA. If not, see &lt;http://www.gnu.org/licenses/&gt;.
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Hash functions›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Hash_Generator
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="../Collections/HashCode.html">Collections.HashCode</a>
  <a href="Derive_Aux.html">Derive_Aux</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Introduction"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
The interface for hash-functions is defined in the class <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> hashable<span class="antiquote"><span class="antiquote">}</span></span></span></span> which has been developed
as part of the Isabelle Collection Framework \cite{rbt}. It requires a hash-function
(<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> hashcode<span class="antiquote"><span class="antiquote">}</span></span></span></span>), a bounded hash-function (<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> bounded_hashcode<span class="antiquote"><span class="antiquote">}</span></span></span></span>),
and a default hash-table size (<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> def_hashmap_size<span class="antiquote"><span class="antiquote">}</span></span></span></span>).

The <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> hashcode<span class="antiquote"><span class="antiquote">}</span></span></span></span> function for each datatype are created by instantiating the recursors of that 
datatype appropriately. E.g., for \texttt{datatype 'a test = C1 'a 'a | C2 "'a test list"} 
we get a hash-function which is equivalent to 
\begin{verbatim}
hashcode (C1 a b) = c1 * hashcode a + c2 * hashcode b
hashcode (C2 Nil) = c3
hashcode (C2 (a # as)) = c4 * hashcode a + c5 * hashcode as
\end{verbatim}
where each \texttt{c$_{i}$} is a non-negative 32-bit number which is dependent on the
datatype name, the constructor name, and the occurrence of the argument (i.e., 
in the example \texttt{c1} and \texttt{c2} will usually be different numbers.)
These parameters are used in linear combination with prime numbers to hopefully
get some useful hash-function.

The <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> bounded_hashcode<span class="antiquote"><span class="antiquote">}</span></span></span></span> functions are constructed in the same way, except that after each
arithmetic operation a modulo operation is performed.

Finally, the default hash-table size is just set to 10, following Java's default
hash-table constructor.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Features and Limitations"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
We get same limitation as for the order generator. 
For mutual recursive datatypes, only
for the first mentioned datatype the instantiations of the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> hashable<span class="antiquote"><span class="antiquote">}</span></span></span></span>-class are
derived.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Installing the generator"</span></span>

<span class="keyword1" id="Hash_Generator-hash_mod_lemma"><span class="command">lemma</span></span> hash_mod_lemma<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;</span> <span class="main">(</span><span class="free">n</span> <span class="main">::</span> nat<span class="main">)</span> <span class="main">⟹</span> <span class="free">x</span> <span class="keyword1">mod</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="free">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹hash_generator.ML›</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/hash_generator.ML">
<div class="head">
<h1>File ‹hash_generator.ML›</h1>
</div>
<pre class="source"><span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">HASH_GENERATOR</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="comment1">(* creates the hash function (possible bounded by some parameter) *)</span>
  <span class="comment1">(*                          dtyp_info                *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> mk_hash <span class="main">:</span> theory <span class="main">-&gt;</span> <span class="entity">Old_Datatype_Aux.info</span> <span class="main">-&gt;</span> term<span class="main">;</span>

  <span class="comment1">(* creates and registers hash-functions for datatype *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> derive <span class="main">:</span> string <span class="main">-&gt;</span> string <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Hash_Generator</span> <span class="main">:</span> <span class="entity">HASH_GENERATOR</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword3"><span class="keyword">open</span></span> Derive_Aux

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">max_int</span> <span class="main">=</span> <span class="inner_numeral">2147483648</span> <span class="comment1">(* 2 ^^ 31 *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">int_of_string</span> <span class="entity">s</span> <span class="main">=</span> fold
  <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">c</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">i</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="inner_numeral">1792318057</span> * <span class="entity">i</span> + Char.ord <span class="entity">c</span><span class="main">)</span> mod <span class="entity">max_int</span><span class="main">)</span>
  <span class="main">(</span>String.explode <span class="entity">s</span><span class="main">)</span>
  <span class="inner_numeral">0</span>

<span class="comment1">(* all numbers in int_of_string and create_factors are primes (31-bit) *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">create_factor</span> <span class="entity">ty_name</span> <span class="entity">con_name</span> <span class="entity">idx</span> <span class="entity">i</span> <span class="entity">j</span> <span class="main">=</span>
  <span class="main">(</span><span class="inner_numeral">1444315237</span> * <span class="entity">int_of_string</span> <span class="entity">ty_name</span> +
  <span class="inner_numeral">1336760419</span> * <span class="entity">int_of_string</span> <span class="entity">con_name</span> +
  <span class="inner_numeral">2044890737</span> * <span class="main">(</span><span class="entity">idx</span> + <span class="inner_numeral">1</span><span class="main">)</span> +
  <span class="inner_numeral">1622892797</span> * <span class="main">(</span><span class="entity">i</span>+<span class="inner_numeral">1</span><span class="main">)</span> +
  <span class="inner_numeral">2140823281</span> * <span class="main">(</span><span class="entity">j</span>+<span class="inner_numeral">1</span><span class="main">)</span><span class="main">)</span> mod <span class="entity">max_int</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">create_def_size</span> <span class="main">_</span> <span class="main">=</span> <span class="inner_numeral">10</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">hash_name</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "hashcode"<span class="antiquote">}</span></span>

<span class="comment1">(* construct free variable x_i *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_free_tysubst_i</span> <span class="entity">typ_subst</span> <span class="entity">x</span> <span class="entity">i</span> <span class="entity">ty</span> <span class="main">=</span> Free <span class="main">(</span><span class="entity">x</span> ^ string_of_int <span class="entity">i</span><span class="main">,</span> <span class="entity">ty</span> |&gt; <span class="entity">typ_subst</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_hash</span> <span class="entity">thy</span> <span class="entity">info</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sort</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">hashable</span><span class="antiquote">}</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">typ_subst</span> <span class="main">=</span> <span class="entity">typ_subst_for_sort</span> <span class="entity">thy</span> <span class="entity">info</span> <span class="entity">sort</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">descr</span> <span class="main">=</span> <span class="main">#</span>descr <span class="entity">info</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty_name</span> <span class="main">=</span> <span class="entity">info</span> |&gt; <span class="main">#</span>descr |&gt; hd |&gt; snd |&gt; <span class="main">#</span><span class="inner_numeral">1</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cons_hash</span> <span class="main">=</span> <span class="entity">create_factor</span> <span class="entity">ty_name</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mk_num</span> <span class="main">=</span> <span class="entity">HOLogic.mk_number</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">hashcode</span><span class="antiquote">}</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">typ_of</span> <span class="entity">dty</span> <span class="main">=</span> <span class="entity">Old_Datatype_Aux.typ_of_dtyp</span> <span class="entity">descr</span> <span class="entity">dty</span> |&gt; <span class="entity">typ_subst</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rec_names</span> <span class="main">=</span> <span class="main">#</span>rec_names <span class="entity">info</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mk_free_i</span> <span class="main">=</span> <span class="entity">mk_free_tysubst_i</span> <span class="entity">typ_subst</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rec_idx</span> <span class="entity">i</span> <span class="entity">dtys</span> <span class="main">=</span> <span class="entity">dt_number_recs</span> <span class="main">(</span>take <span class="entity">i</span> <span class="entity">dtys</span><span class="main">)</span> |&gt; fst
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_rhss</span> <span class="main">(</span><span class="entity">idx</span><span class="main">,</span><span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="main">_</span><span class="main">,</span><span class="entity">cons</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_rhs</span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span><span class="main">(</span><span class="entity">cname</span><span class="main">,</span><span class="entity">dtysi</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lvars</span> <span class="main">=</span> map_index <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span><span class="entity">dty</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">mk_free_i</span> <span class="inner_quoted">"x_"</span> <span class="entity">i</span> <span class="main">(</span><span class="entity">typ_of</span> <span class="entity">dty</span><span class="main">)</span><span class="main">)</span> <span class="entity">dtysi</span>
            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">res_var</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="entity">oc</span><span class="main">)</span> <span class="main">=</span> <span class="entity">mk_free_i</span> <span class="inner_quoted">"res_"</span> <span class="entity">oc</span> <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">hashcode</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">;</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">res_vars</span> <span class="main">=</span> <span class="entity">dt_number_recs</span> <span class="entity">dtysi</span>
              |&gt; snd
              |&gt; map <span class="entity">res_var</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">x</span> <span class="main">=</span> nth <span class="entity">lvars</span>
            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">combine_dts</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> <span class="entity">mk_num</span> <span class="main">(</span><span class="entity">cons_hash</span> <span class="entity">cname</span> <span class="entity">idx</span> <span class="entity">i</span> <span class="inner_numeral">0</span><span class="main">)</span>
              <span class="main">|</span> <span class="entity">combine_dts</span> <span class="main">(</span><span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="entity">c</span><span class="main">)</span> :: <span class="entity">ics</span><span class="main">)</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="main">(+)</span> <span class="main">::</span> hashcode <span class="main">=&gt;</span> hashcode <span class="main">=&gt;</span> hashcode"</span><span class="antiquote">}</span></span> $ <span class="entity">c</span> $ <span class="entity">combine_dts</span> <span class="entity">ics</span>
            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">multiply</span> <span class="entity">j</span> <span class="entity">t</span> <span class="main">=</span>
              <span class="keyword2"><span class="keyword">let</span></span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mult</span> <span class="main">=</span> <span class="entity">mk_num</span> <span class="main">(</span><span class="entity">cons_hash</span> <span class="entity">cname</span> <span class="entity">idx</span> <span class="entity">i</span> <span class="main">(</span><span class="entity">j</span>+<span class="inner_numeral">1</span><span class="main">)</span><span class="main">)</span>
              <span class="keyword2"><span class="keyword">in</span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="main">(*)</span> <span class="main">::</span> hashcode <span class="main">=&gt;</span> hashcode <span class="main">=&gt;</span> hashcode"</span><span class="antiquote">}</span></span> $ <span class="entity">mult</span> $ <span class="entity">t</span> <span class="keyword2"><span class="keyword">end</span></span>
            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">hash_of_dty</span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span><span class="entity">Old_Datatype_Aux.DtRec</span> <span class="entity">j</span><span class="main">)</span> <span class="main">=</span> <span class="entity">res_var</span> <span class="main">(</span><span class="entity">j</span><span class="main">,</span><span class="entity">rec_idx</span> <span class="entity">i</span> <span class="entity">dtysi</span><span class="main">)</span> |&gt; <span class="entity">multiply</span> <span class="entity">i</span>
              <span class="main">|</span> <span class="entity">hash_of_dty</span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span><span class="main">_</span><span class="main">)</span> <span class="main">=</span>
                  <span class="keyword2"><span class="keyword">let</span></span>
                    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">xi</span> <span class="main">=</span> <span class="entity">x</span> <span class="entity">i</span>
                    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty</span> <span class="main">=</span> Term.type_of <span class="entity">xi</span>
                    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">hash</span> <span class="main">=</span> Const <span class="main">(</span><span class="entity">hash_name</span><span class="main">,</span> <span class="entity">ty</span> --&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">hashcode</span><span class="antiquote">}</span></span><span class="main">)</span> $ <span class="entity">xi</span>
                  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">hash</span> |&gt; <span class="entity">multiply</span> <span class="entity">i</span> <span class="keyword2"><span class="keyword">end</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pre_rhs</span> <span class="main">=</span> map_index <span class="entity">hash_of_dty</span> <span class="entity">dtysi</span>
              |&gt; map_index I
              |&gt; <span class="entity">combine_dts</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span> fold lambda <span class="main">(</span>rev <span class="main">(</span><span class="entity">lvars</span> @ <span class="entity">res_vars</span><span class="main">)</span><span class="main">)</span> <span class="entity">pre_rhs</span>
          <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">rhs</span> <span class="keyword2"><span class="keyword">end</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rec_args</span> <span class="main">=</span> map_index <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span><span class="entity">c</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">mk_rhs</span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span><span class="entity">c</span><span class="main">)</span><span class="main">,</span><span class="entity">i</span><span class="main">,</span><span class="entity">idx</span><span class="main">)</span><span class="main">)</span> <span class="entity">cons</span>
      <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">rec_args</span> <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">nrec_args</span> <span class="main">=</span> maps <span class="entity">mk_rhss</span> <span class="entity">descr</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rec_args</span> <span class="main">=</span> map <span class="main">#</span><span class="inner_numeral">1</span> <span class="entity">nrec_args</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_rec</span> <span class="entity">i</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty</span> <span class="main">=</span> <span class="entity">typ_of</span> <span class="main">(</span><span class="entity">Old_Datatype_Aux.DtRec</span> <span class="entity">i</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rec_ty</span> <span class="main">=</span> map type_of <span class="entity">rec_args</span> @ <span class="main">[</span><span class="entity">ty</span><span class="main">]</span> ---&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">hashcode</span><span class="antiquote">}</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rec_name</span> <span class="main">=</span> nth <span class="entity">rec_names</span> <span class="entity">i</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span> list_comb <span class="main">(</span>Const <span class="main">(</span><span class="entity">rec_name</span><span class="main">,</span> <span class="entity">rec_ty</span><span class="main">)</span><span class="main">,</span> <span class="entity">rec_args</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">rhs</span> <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">mk_rec</span> <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">derive</span> <span class="entity">dtyp_name</span> <span class="main">_</span> <span class="entity">thy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tyco</span> <span class="main">=</span> <span class="entity">dtyp_name</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">base_name</span> <span class="main">=</span> Long_Name.base_name <span class="entity">tyco</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> writeln <span class="main">(</span><span class="inner_quoted">"creating hashcode for datatype "</span> ^ <span class="entity">base_name</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sort</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">hashable</span><span class="antiquote">}</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">info</span> <span class="main">=</span> <span class="entity">BNF_LFP_Compat.the_info</span> <span class="entity">thy</span> <span class="main">[</span><span class="main">]</span> <span class="entity">tyco</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">vs_of_sort</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">i</span> <span class="main">=</span> <span class="entity">BNF_LFP_Compat.the_spec</span> <span class="entity">thy</span> <span class="entity">tyco</span> |&gt; <span class="main">#</span><span class="inner_numeral">1</span>
      <span class="keyword2"><span class="keyword">in</span></span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">sort</span> <span class="main">=&gt;</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">n</span><span class="main">,</span><span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">n</span><span class="main">,</span> <span class="entity">sort</span><span class="main">)</span><span class="main">)</span> <span class="entity">i</span> <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">vs</span> <span class="main">=</span> <span class="entity">vs_of_sort</span> <span class="entity">sort</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">hash_rhs</span> <span class="main">=</span> <span class="entity">mk_hash</span> <span class="entity">thy</span> <span class="entity">info</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty</span> <span class="main">=</span> Term.fastype_of <span class="entity">hash_rhs</span> |&gt; Term.dest_Type |&gt; snd |&gt; hd
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty_it</span> <span class="main">=</span> Type <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_name</span> itself<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">[</span><span class="entity">ty</span><span class="main">]</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">hashs_rhs</span> <span class="main">=</span> lambda <span class="main">(</span>Free <span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span><span class="entity">ty_it</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="entity">HOLogic.mk_number</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">nat</span><span class="antiquote">}</span></span> <span class="main">(</span><span class="entity">create_def_size</span> <span class="entity">ty</span><span class="main">)</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">hash_def</span> <span class="main">=</span> <span class="entity">mk_def</span> <span class="main">(</span><span class="entity">ty</span> --&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">hashcode</span><span class="antiquote">}</span></span><span class="main">)</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> hashcode<span class="antiquote">}</span></span> <span class="entity">hash_rhs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">hashs_def</span> <span class="main">=</span> <span class="entity">mk_def</span> <span class="main">(</span><span class="entity">ty_it</span> --&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">nat</span><span class="antiquote">}</span></span><span class="main">)</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> def_hashmap_size<span class="antiquote">}</span></span> <span class="entity">hashs_rhs</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">hash_thm</span> <span class="main">,</span> <span class="entity">hashs_thm</span><span class="main">)</span><span class="main">,</span><span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Class.instantiation</span> <span class="main">(</span><span class="main">[</span><span class="entity">tyco</span><span class="main">]</span><span class="main">,</span><span class="entity">vs</span><span class="main">,</span><span class="entity">sort</span><span class="main">)</span> <span class="entity">thy</span>
      |&gt; <span class="entity">define_overloaded</span> <span class="main">(</span><span class="inner_quoted">"hashcode_"</span> ^ <span class="entity">base_name</span> ^ <span class="inner_quoted">"_def"</span><span class="main">,</span> <span class="entity">hash_def</span><span class="main">)</span>
      ||&gt;&gt; <span class="entity">define_overloaded</span> <span class="main">(</span><span class="inner_quoted">"def_hashmap_size_"</span> ^ <span class="entity">base_name</span> ^ <span class="inner_quoted">"_def"</span><span class="main">,</span> <span class="entity">hashs_def</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">hash_thms</span> <span class="main">=</span> <span class="main">[</span><span class="entity">hash_thm</span><span class="main">,</span> <span class="entity">hashs_thm</span><span class="main">]</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">hash_tac</span> <span class="entity">ctxt</span> <span class="main">=</span>
      <span class="entity">my_print_tac</span> <span class="entity">ctxt</span> <span class="inner_quoted">"enter hash "</span> THEN
      <span class="entity">unfold_tac</span> <span class="entity">ctxt</span> <span class="entity">hash_thms</span> THEN
      <span class="entity">my_print_tac</span> <span class="entity">ctxt</span> <span class="inner_quoted">"after unfolding"</span> THEN
      <span class="entity">simp_tac</span> <span class="entity">ctxt</span> <span class="inner_numeral">1</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy'</span> <span class="main">=</span> <span class="entity">Class.prove_instantiation_exit</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> <span class="entity">Class.intro_classes_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> THEN <span class="entity">hash_tac</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">lthy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> writeln <span class="main">(</span><span class="inner_quoted">"registered "</span> ^ <span class="entity">base_name</span> ^ <span class="inner_quoted">" in class hashable"</span><span class="main">)</span>

  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">thy'</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  Theory.setup
    <span class="main">(</span><span class="entity">Derive_Manager.register_derive</span> <span class="inner_quoted">"hashable"</span> <span class="inner_quoted">"derives a hash function for a datatype"</span> <span class="entity">derive</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Derive">
<div class="head">
<h1>Theory Derive</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Deriving class instances for datatypes
    Author:      René Thiemann       &lt;rene.thiemann@uibk.ac.at&gt;
    Maintainer:  René Thiemann
    License:     LGPL
*)</span>

<span class="comment1">(*
Copyright 2013 René Thiemann

This file is part of IsaFoR/CeTA.

IsaFoR/CeTA is free software: you can redistribute it and/or modify it under the
terms of the GNU Lesser General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

IsaFoR/CeTA is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along
with IsaFoR/CeTA. If not, see &lt;http://www.gnu.org/licenses/&gt;.
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Loading derive-commands›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Derive
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="Order_Generator.html">Order_Generator</a>
  <a href="Hash_Generator.html">Hash_Generator</a>
  <a href="../Deriving/Countable_Generator.html">Deriving.Countable_Generator</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
We just load the commands to derive (linear) orders, hash-functions, and the
command to show that a datatype is countable, so that now all of them are available.
There are further generators available in the AFP entries of lightweight containers and Show.
›</span></span>

<span class="keyword1"><span class="command">print_derives</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Derive_Examples">
<div class="head">
<h1>Theory Derive_Examples</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Deriving class instances for datatypes
    Author:      René Thiemann       &lt;rene.thiemann@uibk.ac.at&gt;
    Maintainer:  René Thiemann
    License:     LGPL
*)</span>

<span class="comment1">(*
Copyright 2013 René Thiemann

This file is part of IsaFoR/CeTA.

IsaFoR/CeTA is free software: you can redistribute it and/or modify it under the
terms of the GNU Lesser General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

IsaFoR/CeTA is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along
with IsaFoR/CeTA. If not, see &lt;http://www.gnu.org/licenses/&gt;.
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="plain_text">Examples</span>

<span class="keyword1"><span class="command">theory</span></span> Derive_Examples
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="Derive.html">Derive</a>
  <a href="../../HOL/HOL/Rat.html">HOL.Rat</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Register standard existing types"</span></span>

<span class="keyword1"><span class="command">derive</span></span> linorder <span class="quoted">list</span> <span class="quoted">sum</span> <span class="quoted">prod</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Without nested recursion"</span></span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="tfree">'a</span> bintree <span class="main">=</span> BEmpty <span class="main">|</span> BNode <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> bintree"</span></span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> bintree"</span></span>

<span class="keyword1"><span class="command">derive</span></span> linorder <span class="quoted">bintree</span>
<span class="keyword1"><span class="command">derive</span></span> hashable <span class="quoted">bintree</span>
<span class="keyword1"><span class="command">derive</span></span> countable <span class="quoted">bintree</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Using other datatypes"</span></span>

<span class="keyword1"><span class="command">datatype</span></span> nat_list_list <span class="main">=</span> NNil <span class="main">|</span> CCons <span class="quoted"><span class="quoted">"nat list"</span></span> <span class="quoted">nat_list_list</span>

<span class="keyword1"><span class="command">derive</span></span> linorder <span class="quoted">nat_list_list</span>
<span class="keyword1"><span class="command">derive</span></span> hashable <span class="quoted">nat_list_list</span>
<span class="keyword1"><span class="command">derive</span></span> countable <span class="quoted">nat_list_list</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Explicit mutual recursion"</span></span>

<span class="keyword1"><span class="command">datatype</span></span>
  <span class="tfree">'a</span> mtree <span class="main">=</span> MEmpty <span class="main">|</span> MNode <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> mtree_list"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="tfree">'a</span> mtree_list <span class="main">=</span> MNil <span class="main">|</span> MCons <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> mtree"</span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> mtree_list"</span></span>

<span class="keyword1"><span class="command">derive</span></span> linorder <span class="quoted">mtree</span>
<span class="keyword1"><span class="command">derive</span></span> hashable <span class="quoted">mtree</span>
<span class="keyword1"><span class="command">derive</span></span> countable <span class="quoted">mtree</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Implicit mutual recursion"</span></span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="tfree">'a</span> tree <span class="main">=</span> Empty <span class="main">|</span> Node <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> tree list"</span></span>

<span class="keyword1"><span class="command">datatype_compat</span></span> tree

<span class="keyword1"><span class="command">derive</span></span> linorder <span class="quoted">tree</span>
<span class="keyword1"><span class="command">derive</span></span> hashable <span class="quoted">tree</span>
<span class="keyword1"><span class="command">derive</span></span> countable <span class="quoted">tree</span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="tfree">'a</span> ttree <span class="main">=</span> TEmpty <span class="main">|</span> TNode <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> ttree list tree"</span></span>

<span class="keyword1"><span class="command">datatype_compat</span></span> ttree

<span class="keyword1"><span class="command">derive</span></span> linorder <span class="quoted">ttree</span>
<span class="keyword1"><span class="command">derive</span></span> hashable <span class="quoted">ttree</span>
<span class="keyword1"><span class="command">derive</span></span> countable <span class="quoted">ttree</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Examples from IsaFoR"</span></span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="main">(</span><span class="tfree">'f</span><span class="main">,</span><span class="tfree">'v</span><span class="main">)</span> <span class="quoted">"term"</span> <span class="main">=</span> Var <span class="tfree"><span class="quoted"><span class="tfree">'v</span></span></span> <span class="main">|</span> Fun <span class="tfree"><span class="quoted"><span class="tfree">'f</span></span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'f</span><span class="main">,</span><span class="tfree">'v</span><span class="main">)</span> term list"</span></span>

<span class="keyword1"><span class="command">datatype_compat</span></span> <span class="quoted">"term"</span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="main">(</span><span class="tfree">'f</span><span class="main">,</span> <span class="tfree">'l</span><span class="main">)</span> lab <span class="main">=</span>
  Lab <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'f</span><span class="main">,</span> <span class="tfree">'l</span><span class="main">)</span> lab"</span></span> <span class="tfree"><span class="quoted"><span class="tfree">'l</span></span></span>
<span class="main">|</span> FunLab <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'f</span><span class="main">,</span> <span class="tfree">'l</span><span class="main">)</span> lab"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'f</span><span class="main">,</span> <span class="tfree">'l</span><span class="main">)</span> lab list"</span></span>
<span class="main">|</span> UnLab <span class="tfree"><span class="quoted"><span class="tfree">'f</span></span></span>
<span class="main">|</span> Sharp <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'f</span><span class="main">,</span> <span class="tfree">'l</span><span class="main">)</span> lab"</span></span>

<span class="keyword1"><span class="command">datatype_compat</span></span> lab

<span class="keyword1"><span class="command">derive</span></span> linorder <span class="quoted"><span class="quoted">"term"</span></span> <span class="quoted">lab</span>
<span class="keyword1"><span class="command">derive</span></span> countable <span class="quoted"><span class="quoted">"term"</span></span> <span class="quoted">lab</span>
<span class="keyword1"><span class="command">derive</span></span> hashable <span class="quoted"><span class="quoted">"term"</span></span> <span class="quoted">lab</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"A complex datatype"</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
The following datatype has nested indirect recursion, mutual recursion and
uses other datatypes.
›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> complex <span class="main">=</span> 
  C1 <span class="quoted">nat</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> ttree"</span></span> <span class="main">|</span>
  C2 <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> complex list tree tree"</span></span> <span class="tfree"><span class="quoted"><span class="tfree">'b</span></span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> complex"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> complex2 ttree list"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> complex2 <span class="main">=</span> D1 <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> complex ttree"</span></span>

<span class="keyword1"><span class="command">datatype_compat</span></span> complex complex2

<span class="keyword1"><span class="command">derive</span></span> linorder <span class="quoted">complex</span>
<span class="keyword1"><span class="command">derive</span></span> hashable <span class="quoted">complex</span>
<span class="keyword1"><span class="command">derive</span></span> countable <span class="quoted">complex</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div>