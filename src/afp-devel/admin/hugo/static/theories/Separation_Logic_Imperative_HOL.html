<div id="Imperative_HOL_Add">
<div class="head">
<h1>Theory Imperative_HOL_Add</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Additions to Imperative/HOL›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Imperative_HOL_Add
<span class="keyword2"><span class="keyword">imports</span></span> <span class="quoted">"<a href="../../HOL/HOL-Imperative_HOL/Imperative_HOL.html">HOL-Imperative_HOL.Imperative_HOL</a>"</span> 
<span class="keyword2"><span class="keyword">begin</span></span> 

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This theory loads the Imperative HOL framework and provides 
        some additional lemmas needed for the separation logic framework.›</span></span> 

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A stronger elimination rule for <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>ref›</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> effect_ref<span class="main">[</span><span class="operator">effect_elims</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"effect <span class="main">(</span>ref <span class="main">(</span><span class="free">x</span><span class="main">::</span><span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>heap<span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="free">h</span> <span class="free">h'</span> <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">=</span> fst <span class="main">(</span>Ref.alloc <span class="free">x</span> <span class="free">h</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">h'</span> <span class="main">=</span> snd <span class="main">(</span>Ref.alloc <span class="free">x</span> <span class="free">h</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"execute <span class="main">(</span>ref <span class="free">x</span><span class="main">)</span> <span class="free">h</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">r</span><span class="main">,</span> <span class="free">h'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> effect_def<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">=</span> fst <span class="main">(</span>Ref.alloc <span class="free">x</span> <span class="free">h</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">h'</span> <span class="main">=</span> snd <span class="main">(</span>Ref.alloc <span class="free">x</span> <span class="free">h</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">execute_simps</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="free">thesis</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Some lemmas about the evaluation of the limit for modifications on 
  a heap›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lim_Ref_alloc<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lim <span class="main">(</span>snd <span class="main">(</span>Ref.alloc <span class="free">x</span> <span class="free">h</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Suc <span class="main">(</span>lim <span class="free">h</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Ref.alloc_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> lim_Array_alloc<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lim <span class="main">(</span>snd <span class="main">(</span>Array.alloc <span class="free">x</span> <span class="free">h</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Suc <span class="main">(</span>lim <span class="free">h</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Array.alloc_def Array.set_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>


<span class="keyword1"><span class="command">lemma</span></span> lim_Array_set<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lim <span class="main">(</span>Array.set <span class="free">a</span> <span class="free">xs</span> <span class="free">h</span><span class="main">)</span> <span class="main">=</span> lim <span class="free">h</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Array.set_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>

<span class="keyword1"><span class="command">thm</span></span> Array.update_def
<span class="keyword1"><span class="command">lemma</span></span> lim_Array_update<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lim <span class="main">(</span>Array.update <span class="free">a</span> <span class="free">i</span> <span class="free">x</span> <span class="free">h</span><span class="main">)</span> <span class="main">=</span> lim <span class="free">h</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Array.update_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Simplification rules for the addresses of new allocated arrays and
  references›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> addr_of_ref_alloc<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"addr_of_ref <span class="main">(</span>fst <span class="main">(</span>Ref.alloc <span class="free">x</span> <span class="free">h</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> lim <span class="free">h</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Ref.alloc_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> addr_of_array_alloc<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"addr_of_array <span class="main">(</span>fst <span class="main">(</span>Array.alloc <span class="free">x</span> <span class="free">h</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> lim <span class="free">h</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Array.alloc_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Syntax_Match">
<div class="head">
<h1>Theory Syntax_Match</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Syntactic Matching in the Simplifier›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Syntax_Match
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Non-Matching›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We define the predicates <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>syntax_nomatch›</span></span></span></span> 
  and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>syntax_fo_nomatch›</span></span></span></span>. The expression 
  <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>syntax_nomatch pattern object›</span></span></span></span> is simplified to true only if 
  the term <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>pattern›</span></span></span></span> syntactically matches the term <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>object›</span></span></span></span>. 
  Note that, semantically, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>syntax_nomatch pattern object›</span></span></span></span> is always
  true. While <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>syntax_nomatch›</span></span></span></span> does higher-order matching, 
  <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>syntax_fo_nomatch›</span></span></span></span> does first-order matching.

  The intended application of these predicates are as guards for simplification
  rules, enforcing additional syntactic restrictions on the applicability of
  the simplification rule.
›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">syntax_nomatch</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> syntax_nomatch_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">syntax_nomatch</span> <span class="free"><span class="bound"><span class="entity">pat</span></span></span> <span class="free"><span class="bound"><span class="entity">obj</span></span></span> <span class="main">≡</span> True"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">syntax_fo_nomatch</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> syntax_fo_nomatch_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">syntax_fo_nomatch</span> <span class="free"><span class="bound"><span class="entity">pat</span></span></span> <span class="free"><span class="bound"><span class="entity">obj</span></span></span> <span class="main">≡</span> True"</span></span>

<span class="comment1">(* Prevent simplifier to simplify inside syntax_xx predicates *)</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">cong</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"syntax_fo_nomatch <span class="free">x</span> <span class="free">y</span> <span class="main">=</span> syntax_fo_nomatch <span class="free">x</span> <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">cong</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"syntax_nomatch <span class="free">x</span> <span class="free">y</span> <span class="main">=</span> syntax_nomatch <span class="free">x</span> <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Syntax_Match</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">struct</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">nomatch_thm</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> syntax_nomatch_def<span class="antiquote">}</span></span></span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fo_nomatch_thm</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> syntax_fo_nomatch_def<span class="antiquote">}</span></span></span><span class="main">;</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">fo_nomatch_simproc</span> <span class="entity">ctxt</span> <span class="entity">credex</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span>
    <span class="comment1">(*val ctxt = Simplifier.the_context ss;*)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">redex</span> <span class="main">=</span> Thm.term_of <span class="entity">credex</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="main">[</span><span class="entity">pat</span><span class="main">,</span><span class="entity">obj</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> strip_comb <span class="entity">redex</span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">fo_matches</span> <span class="entity">po</span> <span class="main">=</span> <span class="main">(</span>Pattern.first_order_match 
      <span class="entity">thy</span> <span class="entity">po</span> <span class="main">(</span>Vartab.empty<span class="main">,</span> Vartab.empty<span class="main">)</span><span class="main">;</span> true<span class="main">)</span> <span class="keyword3"><span class="keyword">handle</span></span> Pattern.MATCH <span class="main">=&gt;</span> false<span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">fo_matches</span> <span class="main">(</span><span class="entity">pat</span><span class="main">,</span><span class="entity">obj</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> NONE <span class="keyword2"><span class="keyword">else</span></span> SOME <span class="entity">fo_nomatch_thm</span>
  <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">nomatch_simproc</span> <span class="entity">ctxt</span> <span class="entity">credex</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span>
    <span class="comment1">(*val ctxt = Simplifier.the_context ss;*)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">redex</span> <span class="main">=</span> Thm.term_of <span class="entity">credex</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="main">[</span><span class="entity">pat</span><span class="main">,</span><span class="entity">obj</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> strip_comb <span class="entity">redex</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="keyword2"><span class="keyword">if</span></span> Pattern.matches <span class="entity">thy</span> <span class="main">(</span><span class="entity">pat</span><span class="main">,</span><span class="entity">obj</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> NONE <span class="keyword2"><span class="keyword">else</span></span> SOME <span class="entity">nomatch_thm</span>
  <span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword2"><span class="keyword">end</span></span>
›</span>
<span class="keyword1"><span class="command">simproc_setup</span></span> nomatch <span class="main">(</span><span class="quoted"><span class="quoted">"syntax_nomatch <span class="free">pat</span> <span class="free">obj</span>"</span></span><span class="main">)</span> 
  <span class="main">=</span> <span class="quoted">‹K <span class="entity">Syntax_Match.nomatch_simproc</span>›</span>
<span class="keyword1"><span class="command">simproc_setup</span></span> fo_nomatch <span class="main">(</span><span class="quoted"><span class="quoted">"syntax_fo_nomatch <span class="free">pat</span> <span class="free">obj</span>"</span></span><span class="main">)</span> 
  <span class="main">=</span> <span class="quoted">‹K <span class="entity">Syntax_Match.fo_nomatch_simproc</span>›</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Examples›</span></span>
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Ordering AC-structures›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Currently, the simplifier rules for ac-rewriting only work when
  associativity groups to the right. Here, we define rules that work for
  associativity grouping to the left. They are useful for operators where 
  syntax is parsed (and pretty-printed) left-associative.
›</span></span>

<span class="keyword1"><span class="command">locale</span></span> ac_operator <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> right_assoc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">(</span><span class="free">f</span> <span class="free">a</span> <span class="free">b</span><span class="main">)</span> <span class="free">c</span> <span class="main">=</span> <span class="free">f</span> <span class="free">a</span> <span class="main">(</span><span class="free">f</span> <span class="free">b</span> <span class="free">c</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> commute<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="free">a</span> <span class="free">b</span> <span class="main">=</span> <span class="free">f</span> <span class="free">b</span> <span class="free">a</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">lemmas</span></span> left_assoc <span class="main">=</span> right_assoc<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
  <span class="keyword1"><span class="command">lemma</span></span> left_commute<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="free">a</span> <span class="main">(</span><span class="free">f</span> <span class="free">b</span> <span class="free">c</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="free">b</span> <span class="main">(</span><span class="free">f</span> <span class="free">a</span> <span class="free">c</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> left_assoc<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> commute<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">lemmas</span></span> right_ac <span class="main">=</span> right_assoc left_commute commute

  <span class="keyword1"><span class="command">lemma</span></span> right_commute<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">(</span><span class="free">f</span> <span class="free">a</span> <span class="free">b</span><span class="main">)</span> <span class="free">c</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span><span class="free">f</span> <span class="free">a</span> <span class="free">c</span><span class="main">)</span> <span class="free">b</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> right_ac<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> safe_commute<span class="main">:</span> <span class="quoted"><span class="quoted">"syntax_fo_nomatch <span class="main">(</span><span class="free">f</span> <span class="free">x</span> <span class="free">y</span><span class="main">)</span> <span class="free">a</span> <span class="main">⟹</span> <span class="free">f</span> <span class="free">a</span> <span class="free">b</span> <span class="main">=</span> <span class="free">f</span> <span class="free">b</span> <span class="free">a</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> right_ac<span class="main">)</span>

  <span class="keyword1"><span class="command">lemmas</span></span> left_ac <span class="main">=</span> left_assoc right_commute safe_commute
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> mult<span class="main">:</span> ac_operator <span class="quoted"><span class="quoted">"<span class="main">(*)</span> <span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>ab_semigroup_mult <span class="main">⇒</span> <span class="main">_</span> <span class="main">⇒</span> <span class="main">_</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">ac_simps</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">interpretation</span></span> add<span class="main">:</span> ac_operator <span class="quoted"><span class="quoted">"<span class="main">(+)</span> <span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>ab_semigroup_add <span class="main">⇒</span> <span class="main">_</span> <span class="main">⇒</span> <span class="main">_</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">ac_simps</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Attention: <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>conj_assoc›</span></span></span></span> is in standard simpset, it has to be 
  removed when using <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>conj.left_ac›</span></span></span></span> !›</span></span>
<span class="keyword1"><span class="command">interpretation</span></span> conj<span class="main">:</span> ac_operator <span class="quoted"><span class="quoted">"<span class="main">(∧)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">interpretation</span></span> disj<span class="main">:</span> ac_operator <span class="quoted"><span class="quoted">"<span class="main">(∨)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">auto</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Run">
<div class="head">
<h1>Theory Run</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Exception-Aware Relational Framework›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Run
<span class="keyword2"><span class="keyword">imports</span></span> <span class="quoted">"<a href="../../HOL/HOL-Imperative_HOL/Imperative_HOL.html">HOL-Imperative_HOL.Imperative_HOL</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
    With Imperative HOL comes a relational framework. 
    However, this can only be used if exception freeness is already assumed.
    This results in some proof duplication, because exception freeness and 
    correctness need to be shown separately.

    In this theory, we develop a relational framework that is aware of 
    exceptions, and makes it possible to show correctness and exception 
    freeness in one run.
›</span></span>

  
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
    There are two types of states:
    \begin{enumerate}
      \item A normal (Some) state contains the current heap.
      \item An exception state is None
    \end{enumerate}
    The two states exactly correspond to the option monad in Imperative HOL.
›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> state <span class="main">=</span> <span class="quoted"><span class="quoted">"Heap.heap option"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">is_exn</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">is_exn</span> <span class="main">(</span>Some <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> False"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">is_exn</span> None <span class="main">=</span> True"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">the_state</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">the_state</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">h</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">h</span></span></span>"</span></span> 

<span class="comment1">― ‹The exception-aware, relational semantics›</span>

<span class="keyword1"><span class="command">inductive</span></span> <span class="entity">run</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> Heap <span class="main">⇒</span> state <span class="main">⇒</span> state <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  push_exn<span class="main">:</span> <span class="quoted"><span class="quoted">"is_exn <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main">⟹</span> <span class="free">run</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> "</span></span> <span class="main">|</span>
  new_exn<span class="main">:</span>  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">¬</span> is_exn <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">;</span> execute <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">(</span>the_state <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">)</span> <span class="main">=</span> None<span class="main">⟧</span> 
    <span class="main">⟹</span> <span class="free">run</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> None <span class="free"><span class="bound"><span class="entity">r</span></span></span>"</span></span> <span class="main">|</span>
  regular<span class="main">:</span>  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">¬</span> is_exn <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">;</span> execute <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">(</span>the_state <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">)</span> <span class="main">=</span> Some <span class="main">(</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">h'</span></span></span><span class="main">)</span><span class="main">⟧</span> 
    <span class="main">⟹</span> <span class="free">run</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">h'</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span>"</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">"Link with <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>effect›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>success›</span></span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> run_effectE<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"run <span class="free">c</span> <span class="free">σ</span> <span class="free">σ'</span> <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>is_exn <span class="free">σ'</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">h</span> <span class="free">h'</span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">σ</span><span class="main">=</span>Some <span class="free">h</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">σ'</span> <span class="main">=</span> Some <span class="free">h'</span>"</span></span>
    <span class="quoted"><span class="quoted">"effect <span class="free">c</span> <span class="free">h</span> <span class="free">h'</span> <span class="free">r</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">unfolding</span></span> effect_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">σ</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> run.simps<span class="main">)</span>


<span class="keyword1"><span class="command">lemma</span></span> run_effectI<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span>  <span class="quoted"><span class="quoted">"run <span class="free">c</span> <span class="main">(</span>Some <span class="free">h</span><span class="main">)</span> <span class="main">(</span>Some <span class="free">h'</span><span class="main">)</span> <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>  <span class="quoted"><span class="quoted">"effect <span class="free">c</span> <span class="free">h</span> <span class="free">h'</span> <span class="free">r</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> run_effectE<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> effect_run<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"effect <span class="free">c</span> <span class="free">h</span> <span class="free">h'</span> <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"run <span class="free">c</span> <span class="main">(</span>Some <span class="free">h</span><span class="main">)</span> <span class="main">(</span>Some <span class="free">h'</span><span class="main">)</span> <span class="free">r</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">unfolding</span></span> effect_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> run.intros<span class="main">)</span> 

<span class="keyword1"><span class="command">lemma</span></span> success_run<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"success <span class="free">f</span> <span class="free">h</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">h'</span> <span class="free">r</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"run <span class="free">f</span> <span class="main">(</span>Some <span class="free">h</span><span class="main">)</span> <span class="main">(</span>Some <span class="free">h'</span><span class="main">)</span> <span class="free">r</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">r</span></span> <span class="skolem"><span class="skolem">h'</span></span> 
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"Heap_Monad.execute <span class="free">f</span> <span class="free">h</span> <span class="main">=</span> Some <span class="main">(</span><span class="skolem">r</span><span class="main">,</span> <span class="skolem">h'</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> success_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="free">thesis</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> that<span class="main"><span class="main">[</span></span><span class="operator">OF</span> regular<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"Some <span class="free"><span class="free"><span class="free">h</span></span></span>"</span></span></span></span><span class="main"><span class="main"><span class="main">,</span></span></span> <span class="operator">simplified</span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹run always yields a result›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> run_complete<span class="main">:</span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">σ'</span> <span class="free">r</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"run <span class="free">c</span> <span class="free">σ</span> <span class="free">σ'</span> <span class="free">r</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"is_exn <span class="free">σ</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> run.intros<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"execute <span class="free">c</span> <span class="main">(</span>the_state <span class="free">σ</span><span class="main">)</span>"</span></span><span class="main">)</span>  
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> run.intros<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> run_detE<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"run <span class="free">c</span> <span class="free">σ</span> <span class="free">σ'</span> <span class="free">r</span>"</span></span> <span class="quoted"><span class="quoted">"run <span class="free">c</span> <span class="free">σ</span> <span class="free">τ</span> <span class="free">s</span>"</span></span>
          <span class="quoted"><span class="quoted">"<span class="main">¬</span>is_exn <span class="free">σ</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="quoted"><span class="quoted">"is_exn <span class="free">σ'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">σ'</span> <span class="main">=</span> <span class="free">τ</span>"</span></span> <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> is_exn <span class="free">σ'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">σ'</span> <span class="main">=</span> <span class="free">τ</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">=</span> <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> run.simps<span class="main">)</span>
   
<span class="keyword1"><span class="command">lemma</span></span> run_detI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"run <span class="free">c</span> <span class="main">(</span>Some <span class="free">h</span><span class="main">)</span> <span class="main">(</span>Some <span class="free">h'</span><span class="main">)</span> <span class="free">r</span>"</span></span> <span class="quoted"><span class="quoted">"run <span class="free">c</span> <span class="main">(</span>Some <span class="free">h</span><span class="main">)</span> <span class="free">σ</span> <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">σ</span> <span class="main">=</span> Some <span class="free">h'</span> <span class="main">∧</span> <span class="free">r</span> <span class="main">=</span> <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> run.simps<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> run_exn<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"run <span class="free">f</span> <span class="free">σ</span> <span class="free">σ'</span> <span class="free">r</span>"</span></span>
          <span class="quoted"><span class="quoted">"is_exn <span class="free">σ</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="quoted"><span class="quoted">"<span class="free">σ'</span><span class="main">=</span><span class="free">σ</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">σ</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> run.cases <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> that<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Elimination Rules for Basic Combinators›</span></span>

<span class="keyword1"><span class="command">named_theorems</span></span> run_elims <span class="quoted">"elemination rules for run"</span>

<span class="keyword1"><span class="command">lemma</span></span> runE<span class="main">[</span><span class="operator">run_elims</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"run <span class="main">(</span><span class="free">f</span> <span class="main">⤜</span> <span class="free">g</span><span class="main">)</span> <span class="free">σ</span> <span class="free">σ''</span> <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">σ'</span> <span class="free">r'</span> <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="quoted"><span class="quoted">"run <span class="free">f</span> <span class="free">σ</span> <span class="free">σ'</span> <span class="free">r'</span>"</span></span>
    <span class="quoted"><span class="quoted">"run <span class="main">(</span><span class="free">g</span> <span class="free">r'</span><span class="main">)</span> <span class="free">σ'</span> <span class="free">σ''</span> <span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"is_exn <span class="free">σ</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> run.simps<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"execute <span class="free">f</span> <span class="main">(</span>the_state <span class="free">σ</span><span class="main">)</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> run.simps bind_def<span class="main">)</span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_def run.simps<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> runE'<span class="main">[</span><span class="operator">run_elims</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"run <span class="main">(</span><span class="free">f</span> <span class="main">⪢</span> <span class="free">g</span><span class="main">)</span> <span class="free">σ</span> <span class="free">σ''</span> <span class="free">res</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">σt</span> <span class="free">rt</span> <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="quoted"><span class="quoted">"run <span class="free">f</span> <span class="free">σ</span> <span class="free">σt</span> <span class="free">rt</span>"</span></span>
    <span class="quoted"><span class="quoted">"run <span class="free">g</span> <span class="free">σt</span> <span class="free">σ''</span> <span class="free">res</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule_tac</span> runE<span class="main">)</span>


<span class="keyword1"><span class="command">lemma</span></span> run_return<span class="main">[</span><span class="operator">run_elims</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"run <span class="main">(</span>return <span class="free">x</span><span class="main">)</span> <span class="free">σ</span> <span class="free">σ'</span> <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">=</span> <span class="free">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">σ'</span> <span class="main">=</span> <span class="free">σ</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> is_exn <span class="free">σ</span>"</span></span> <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">σ</span> <span class="main">=</span> None"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">σ</span></span><span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> run.simps<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> run.simps <span class="dynamic"><span class="dynamic">execute_simps</span></span><span class="main">)</span>


<span class="keyword1"><span class="command">lemma</span></span> run_raise_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"run <span class="main">(</span>raise <span class="free">s</span><span class="main">)</span> <span class="free">σ</span> <span class="free">σ'</span> <span class="free">r</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">σ'</span><span class="main">=</span>None<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">σ</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> run.simps <span class="dynamic"><span class="dynamic">execute_simps</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> run_raise<span class="main">[</span><span class="operator">run_elims</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"run <span class="main">(</span>raise <span class="free">s</span><span class="main">)</span> <span class="free">σ</span> <span class="free">σ'</span> <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="quoted"><span class="quoted">"<span class="free">σ'</span> <span class="main">=</span> None"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> run_raise_iff<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> run_raiseI<span class="main">:</span>
  <span class="quoted"><span class="quoted">"run <span class="main">(</span>raise <span class="free">s</span><span class="main">)</span> <span class="free">σ</span> None <span class="free">r</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> run_raise_iff<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> run_if<span class="main">[</span><span class="operator">run_elims</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"run <span class="main">(</span><span class="keyword1">if</span> <span class="free">c</span> <span class="keyword1">then</span> <span class="free">t</span> <span class="keyword1">else</span> <span class="free">e</span><span class="main">)</span> <span class="free">h</span> <span class="free">h'</span> <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="quoted"><span class="quoted">"<span class="free">c</span>"</span></span> <span class="quoted"><span class="quoted">"run <span class="free">t</span> <span class="free">h</span> <span class="free">h'</span> <span class="free">r</span>"</span></span>
        <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="free">c</span>"</span></span> <span class="quoted"><span class="quoted">"run <span class="free">e</span> <span class="free">h</span> <span class="free">h'</span> <span class="free">r</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
  
<span class="keyword1"><span class="command">lemma</span></span> run_case_option<span class="main">[</span><span class="operator">run_elims</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"run <span class="main">(</span><span class="keyword1">case</span> <span class="free">x</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="free">n</span> <span class="main">|</span> Some <span class="bound">y</span> <span class="main">⇒</span> <span class="free">s</span> <span class="bound">y</span><span class="main">)</span> <span class="free">σ</span> <span class="free">σ'</span> <span class="free">r</span>"</span></span>
          <span class="quoted"><span class="quoted">"<span class="main">¬</span>is_exn <span class="free">σ</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> None"</span></span> <span class="quoted"><span class="quoted">"run <span class="free">n</span> <span class="free">σ</span> <span class="free">σ'</span> <span class="free">r</span>"</span></span>
        <span class="main">|</span> <span class="free">y</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> Some <span class="free">y</span>"</span></span> <span class="quoted"><span class="quoted">"run <span class="main">(</span><span class="free">s</span> <span class="free">y</span><span class="main">)</span> <span class="free">σ</span> <span class="free">σ'</span> <span class="free">r</span>"</span></span> 
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> run_heap<span class="main">[</span><span class="operator">run_elims</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"run <span class="main">(</span>Heap_Monad.heap <span class="free">f</span><span class="main">)</span> <span class="free">σ</span> <span class="free">σ'</span> <span class="free">res</span>"</span></span>
          <span class="quoted"><span class="quoted">"<span class="main">¬</span>is_exn <span class="free">σ</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="quoted"><span class="quoted">"<span class="free">σ'</span> <span class="main">=</span> Some <span class="main">(</span>snd <span class="main">(</span><span class="free">f</span> <span class="main">(</span>the_state <span class="free">σ</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">res</span> <span class="main">=</span> <span class="main">(</span>fst <span class="main">(</span><span class="free">f</span> <span class="main">(</span>the_state <span class="free">σ</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">σ</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> run.simps<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">execute_simps</span></span><span class="main">)</span>
  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">execute_simps</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">hypsubst_thin</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">premises</span></span> prems <span class="keyword2"><span class="keyword">for</span></span> a h'
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> prems<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">h'</span> <span class="main">=</span> snd <span class="main">(</span><span class="free">f</span> <span class="skolem">a</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">res</span> <span class="main">=</span> fst <span class="main">(</span><span class="free">f</span> <span class="skolem">a</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command">from</span></span> prems<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Array Commands›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> run_length<span class="main">[</span><span class="operator">run_elims</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"run <span class="main">(</span>Array.len <span class="free">a</span><span class="main">)</span> <span class="free">σ</span> <span class="free">σ'</span> <span class="free">r</span>"</span></span>
          <span class="quoted"><span class="quoted">"<span class="main">¬</span>is_exn <span class="free">σ</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>is_exn <span class="free">σ</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">σ'</span> <span class="main">=</span> <span class="free">σ</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">=</span> Array.length <span class="main">(</span>the_state <span class="free">σ</span><span class="main">)</span> <span class="free">a</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">σ</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> run.simps <span class="dynamic"><span class="dynamic">execute_simps</span></span><span class="main">)</span>


<span class="keyword1"><span class="command">lemma</span></span> run_new_array<span class="main">[</span><span class="operator">run_elims</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"run <span class="main">(</span>Array.new <span class="free">n</span> <span class="free">x</span><span class="main">)</span> <span class="free">σ</span> <span class="free">σ'</span> <span class="free">r</span>"</span></span>
          <span class="quoted"><span class="quoted">"<span class="main">¬</span>is_exn <span class="free">σ</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="quoted"><span class="quoted">"<span class="free">σ'</span> <span class="main">=</span> Some <span class="main">(</span>snd <span class="main">(</span>Array.alloc <span class="main">(</span>replicate <span class="free">n</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span>the_state <span class="free">σ</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">=</span> fst <span class="main">(</span>Array.alloc <span class="main">(</span>replicate <span class="free">n</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span>the_state <span class="free">σ</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"Array.get <span class="main">(</span>the_state <span class="free">σ'</span><span class="main">)</span> <span class="free">r</span> <span class="main">=</span> replicate <span class="free">n</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">σ</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> run.simps<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">execute_simps</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Array.get_alloc<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">hypsubst_thin</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">premises</span></span> prems <span class="keyword2"><span class="keyword">for</span></span> a h'
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> prems<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">h'</span> <span class="main">=</span> snd <span class="main">(</span>Array.alloc <span class="main">(</span>replicate <span class="free">n</span> <span class="free">x</span><span class="main">)</span> <span class="skolem">a</span><span class="main">)</span>"</span></span> 
      <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">=</span> fst <span class="main">(</span>Array.alloc <span class="main">(</span>replicate <span class="free">n</span> <span class="free">x</span><span class="main">)</span> <span class="skolem">a</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">execute_simps</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> prems<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> run_make<span class="main">[</span><span class="operator">run_elims</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"run <span class="main">(</span>Array.make <span class="free">n</span> <span class="free">f</span><span class="main">)</span> <span class="free">σ</span> <span class="free">σ'</span> <span class="free">r</span>"</span></span>
          <span class="quoted"><span class="quoted">"<span class="main">¬</span>is_exn <span class="free">σ</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="quoted"><span class="quoted">"<span class="free">σ'</span> <span class="main">=</span> Some <span class="main">(</span>snd <span class="main">(</span>Array.alloc <span class="main">(</span>map <span class="free">f</span> <span class="main">[</span><span class="main">0</span> <span class="main">..&lt;</span> <span class="free">n</span><span class="main">]</span><span class="main">)</span> <span class="main">(</span>the_state <span class="free">σ</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
          <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">=</span> fst <span class="main">(</span>Array.alloc <span class="main">(</span>map <span class="free">f</span> <span class="main">[</span><span class="main">0</span> <span class="main">..&lt;</span> <span class="free">n</span><span class="main">]</span><span class="main">)</span> <span class="main">(</span>the_state <span class="free">σ</span><span class="main">)</span><span class="main">)</span>"</span></span>
          <span class="quoted"><span class="quoted">"Array.get <span class="main">(</span>the_state <span class="free">σ'</span><span class="main">)</span> <span class="free">r</span> <span class="main">=</span> <span class="main">(</span>map <span class="free">f</span> <span class="main">[</span><span class="main">0</span> <span class="main">..&lt;</span> <span class="free">n</span><span class="main">]</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">σ</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> run.simps <span class="dynamic"><span class="dynamic">execute_simps</span></span> Array.get_alloc<span class="main"><span class="keyword3">;</span></span> <span class="operator">fastforce</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>    

<span class="keyword1"><span class="command">lemma</span></span> run_upd<span class="main">[</span><span class="operator">run_elims</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"run <span class="main">(</span>Array.upd <span class="free">i</span> <span class="free">x</span> <span class="free">a</span><span class="main">)</span> <span class="free">σ</span> <span class="free">σ'</span> <span class="free">res</span>"</span></span>
          <span class="quoted"><span class="quoted">"<span class="main">¬</span>is_exn <span class="free">σ</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">i</span> <span class="main">&lt;</span> Array.length <span class="main">(</span>the_state <span class="free">σ</span><span class="main">)</span> <span class="free">a</span>"</span></span> 
          <span class="quoted"><span class="quoted">"<span class="free">σ'</span> <span class="main">=</span> None"</span></span> 
  <span class="main">|</span>
          <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">&lt;</span> Array.length <span class="main">(</span>the_state <span class="free">σ</span><span class="main">)</span> <span class="free">a</span>"</span></span> 
          <span class="quoted"><span class="quoted">"<span class="free">σ'</span> <span class="main">=</span> Some <span class="main">(</span>Array.update <span class="free">a</span> <span class="free">i</span> <span class="free">x</span> <span class="main">(</span>the_state <span class="free">σ</span><span class="main">)</span><span class="main">)</span>"</span></span> 
          <span class="quoted"><span class="quoted">"<span class="free">res</span> <span class="main">=</span> <span class="free">a</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">σ</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">&lt;</span> Array.length <span class="main">(</span>the_state <span class="free">σ</span><span class="main">)</span> <span class="free">a</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> run.simps<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">execute_simps</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span> 3
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span><span class="main"><span class="keyword3">[</span></span>2<span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">hypsubst_thin</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">premises</span></span> prems <span class="keyword2"><span class="keyword">for</span></span> aa h'
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> prems<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">h'</span> <span class="main">=</span> Array.update <span class="free">a</span> <span class="free">i</span> <span class="free">x</span> <span class="skolem">aa</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">res</span> <span class="main">=</span> <span class="free">a</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> prems<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">lemma</span></span> run_nth<span class="main">[</span><span class="operator">run_elims</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"run <span class="main">(</span>Array.nth <span class="free">a</span> <span class="free">i</span><span class="main">)</span> <span class="free">σ</span> <span class="free">σ'</span> <span class="free">r</span>"</span></span>
          <span class="quoted"><span class="quoted">"<span class="main">¬</span>is_exn <span class="free">σ</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>is_exn <span class="free">σ</span>"</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">&lt;</span> Array.length <span class="main">(</span>the_state <span class="free">σ</span><span class="main">)</span> <span class="free">a</span>"</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">=</span> <span class="main">(</span>Array.get <span class="main">(</span>the_state <span class="free">σ</span><span class="main">)</span> <span class="free">a</span><span class="main">)</span> <span class="main">!</span> <span class="free">i</span>"</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">σ'</span> <span class="main">=</span> <span class="free">σ</span>"</span></span> 
  <span class="main">|</span> 
    <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">i</span> <span class="main">&lt;</span> Array.length <span class="main">(</span>the_state <span class="free">σ</span><span class="main">)</span> <span class="free">a</span>"</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">σ'</span> <span class="main">=</span> None"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">σ</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">&lt;</span> Array.length <span class="main">(</span>the_state <span class="free">σ</span><span class="main">)</span> <span class="free">a</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> run.simps<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">execute_simps</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span> 3
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span><span class="main"><span class="keyword3">[</span></span>2<span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">hypsubst_thin</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">premises</span></span> prems <span class="keyword2"><span class="keyword">for</span></span> aa h'
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> prems<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">=</span> Array.get <span class="skolem">aa</span> <span class="free">a</span> <span class="main">!</span> <span class="free">i</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">h'</span> <span class="main">=</span> <span class="skolem">aa</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> prems<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">lemma</span></span> run_of_list<span class="main">[</span><span class="operator">run_elims</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"run <span class="main">(</span>Array.of_list <span class="free">xs</span><span class="main">)</span> <span class="free">σ</span> <span class="free">σ'</span> <span class="free">r</span>"</span></span>
          <span class="quoted"><span class="quoted">"<span class="main">¬</span>is_exn <span class="free">σ</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="quoted"><span class="quoted">"<span class="free">σ'</span> <span class="main">=</span> Some <span class="main">(</span>snd <span class="main">(</span>Array.alloc <span class="free">xs</span> <span class="main">(</span>the_state <span class="free">σ</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
          <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">=</span> fst <span class="main">(</span>Array.alloc <span class="free">xs</span> <span class="main">(</span>the_state <span class="free">σ</span><span class="main">)</span><span class="main">)</span>"</span></span>
          <span class="quoted"><span class="quoted">"Array.get <span class="main">(</span>the_state <span class="free">σ'</span><span class="main">)</span> <span class="free">r</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">σ</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> run.simps<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">execute_simps</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Array.get_alloc<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">hypsubst_thin</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">premises</span></span> prems <span class="keyword2"><span class="keyword">for</span></span> a h'
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> prems<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">h'</span> <span class="main">=</span> snd <span class="main">(</span>Array.alloc <span class="free">xs</span> <span class="skolem">a</span><span class="main">)</span>"</span></span> 
      <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">=</span> fst <span class="main">(</span>Array.alloc <span class="free">xs</span> <span class="skolem">a</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">execute_simps</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> prems<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> run_freeze<span class="main">[</span><span class="operator">run_elims</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"run <span class="main">(</span>Array.freeze <span class="free">a</span><span class="main">)</span> <span class="free">σ</span> <span class="free">σ'</span> <span class="free">r</span>"</span></span>
          <span class="quoted"><span class="quoted">"<span class="main">¬</span>is_exn <span class="free">σ</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="quoted"><span class="quoted">"<span class="free">σ'</span> <span class="main">=</span> <span class="free">σ</span>"</span></span>
          <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">=</span> Array.get <span class="main">(</span>the_state <span class="free">σ</span><span class="main">)</span> <span class="free">a</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">σ</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> run.simps <span class="dynamic"><span class="dynamic">execute_simps</span></span><span class="main">)</span>



<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Reference Commands›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> run_new_ref<span class="main">[</span><span class="operator">run_elims</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"run <span class="main">(</span>ref <span class="free">x</span><span class="main">)</span> <span class="free">σ</span> <span class="free">σ'</span> <span class="free">r</span>"</span></span>
          <span class="quoted"><span class="quoted">"<span class="main">¬</span>is_exn <span class="free">σ</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="quoted"><span class="quoted">"<span class="free">σ'</span> <span class="main">=</span> Some <span class="main">(</span>snd <span class="main">(</span>Ref.alloc <span class="free">x</span> <span class="main">(</span>the_state <span class="free">σ</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
          <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">=</span> fst <span class="main">(</span>Ref.alloc <span class="free">x</span> <span class="main">(</span>the_state <span class="free">σ</span><span class="main">)</span><span class="main">)</span>"</span></span>
          <span class="quoted"><span class="quoted">"Ref.get <span class="main">(</span>the_state <span class="free">σ'</span><span class="main">)</span> <span class="free">r</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">σ</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> run.simps<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">execute_simps</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">hypsubst_thin</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">premises</span></span> prems <span class="keyword2"><span class="keyword">for</span></span> a h'
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> prems<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> 
      <span class="quoted"><span class="quoted">"<span class="skolem">h'</span> <span class="main">=</span> snd <span class="main">(</span>Ref.alloc <span class="free">x</span> <span class="skolem">a</span><span class="main">)</span>"</span></span> 
      <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">=</span> fst <span class="main">(</span>Ref.alloc <span class="free">x</span> <span class="skolem">a</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">execute_simps</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> prems<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"fst <span class="main">(</span>Ref.alloc <span class="free">x</span> <span class="free">h</span><span class="main">)</span> <span class="main">=</span> Ref <span class="main">(</span>lim <span class="free">h</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> alloc_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>

  
<span class="keyword1"><span class="command">lemma</span></span> run_update<span class="main">[</span><span class="operator">run_elims</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"run <span class="main">(</span><span class="free">p</span> <span class="main">:=</span> <span class="free">x</span><span class="main">)</span> <span class="free">σ</span> <span class="free">σ'</span> <span class="free">r</span>"</span></span>
          <span class="quoted"><span class="quoted">"<span class="main">¬</span>is_exn <span class="free">σ</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="quoted"><span class="quoted">"<span class="free">σ'</span> <span class="main">=</span> Some <span class="main">(</span>Ref.set <span class="free">p</span> <span class="free">x</span> <span class="main">(</span>the_state <span class="free">σ</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">=</span> <span class="main">()</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">unfolding</span></span> Ref.update_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> run_heap<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> run_lookup<span class="main">[</span><span class="operator">run_elims</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"run <span class="main">(</span><span class="main">!</span><span class="free">p</span><span class="main">)</span> <span class="free">σ</span> <span class="free">σ'</span> <span class="free">r</span>"</span></span>
          <span class="quoted"><span class="quoted">"<span class="main">¬</span> is_exn <span class="free">σ</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>is_exn <span class="free">σ</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">σ'</span> <span class="main">=</span> <span class="free">σ</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">=</span> Ref.get <span class="main">(</span>the_state <span class="free">σ</span><span class="main">)</span> <span class="free">p</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">σ</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> run.simps <span class="dynamic"><span class="dynamic">execute_simps</span></span><span class="main">)</span>
  
<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Assertions">
<div class="head">
<h1>Theory Assertions</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">"Assertions"</span></span>

<span class="keyword1"><span class="command">theory</span></span> Assertions
<span class="keyword2"><span class="keyword">imports</span></span> 
  <span class="quoted">"<a href="Imperative_HOL_Add.html">Tools/Imperative_HOL_Add</a>"</span> 
  <span class="quoted">"<a href="Syntax_Match.html">Tools/Syntax_Match</a>"</span> 
  <a href="../Automatic_Refinement/Misc.html">Automatic_Refinement.Misc</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Partial Heaps›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  A partial heap is modeled by a heap and a set of valid addresses, with the
  side condition that the valid addresses have to be within the limit of the
  heap. This modeling is somewhat strange for separation logic, however, it 
  allows us to solve some technical problems related to definition of 
  Hoare triples, that will be detailed later.
›</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> pheap <span class="main">=</span> <span class="quoted"><span class="quoted">"heap <span class="main">×</span> addr set"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Predicate that expresses that the address set of a partial heap is 
  within the heap's limit.
›</span></span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">in_range</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>heap <span class="main">×</span> addr set<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">in_range</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">h</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">a</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">.</span> <span class="bound">a</span> <span class="main">&lt;</span> lim <span class="free"><span class="bound"><span class="entity">h</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">declare</span></span> in_range.simps<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> in_range_empty<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"in_range <span class="main">(</span><span class="free">h</span><span class="main">,</span><span class="main">{}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_range.simps<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> in_range_dist_union<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"in_range <span class="main">(</span><span class="free">h</span><span class="main">,</span><span class="free">as</span> <span class="main">∪</span> <span class="free">as'</span><span class="main">)</span> <span class="main">⟷</span> in_range <span class="main">(</span><span class="free">h</span><span class="main">,</span><span class="free">as</span><span class="main">)</span> <span class="main">∧</span> in_range <span class="main">(</span><span class="free">h</span><span class="main">,</span><span class="free">as'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_range.simps<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> in_range_subset<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">as</span> <span class="main">⊆</span> <span class="free">as'</span><span class="main">;</span> in_range <span class="main">(</span><span class="free">h</span><span class="main">,</span><span class="free">as'</span><span class="main">)</span><span class="main">⟧</span> <span class="main">⟹</span> in_range <span class="main">(</span><span class="free">h</span><span class="main">,</span><span class="free">as</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_range.simps<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Relation that holds if two heaps are identical on a given 
  address range›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">relH</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"addr set <span class="main">⇒</span> heap <span class="main">⇒</span> heap <span class="main">⇒</span> bool"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">relH</span> <span class="free"><span class="bound"><span class="entity">as</span></span></span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="free"><span class="bound"><span class="entity">h'</span></span></span> <span class="main">≡</span> 
  in_range <span class="main">(</span><span class="free"><span class="bound"><span class="entity">h</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">)</span> 
  <span class="main">∧</span> in_range <span class="main">(</span><span class="free"><span class="bound"><span class="entity">h'</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">)</span> 
  <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">t</span><span class="main">.</span> <span class="main">∀</span><span class="bound">a</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">.</span> 
        refs <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="bound">t</span> <span class="bound">a</span> <span class="main">=</span> refs <span class="free"><span class="bound"><span class="entity">h'</span></span></span> <span class="bound">t</span> <span class="bound">a</span> 
      <span class="main">∧</span> arrays <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="bound">t</span> <span class="bound">a</span> <span class="main">=</span> arrays <span class="free"><span class="bound"><span class="entity">h'</span></span></span> <span class="bound">t</span> <span class="bound">a</span>
    <span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> relH_in_rangeI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"relH <span class="free">as</span> <span class="free">h</span> <span class="free">h'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"in_range <span class="main">(</span><span class="free">h</span><span class="main">,</span><span class="free">as</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"in_range <span class="main">(</span><span class="free">h'</span><span class="main">,</span><span class="free">as</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> relH_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">"Reflexivity"</span></span>
<span class="keyword1"><span class="command">lemma</span></span> relH_refl<span class="main">:</span> <span class="quoted"><span class="quoted">"in_range <span class="main">(</span><span class="free">h</span><span class="main">,</span><span class="free">as</span><span class="main">)</span> <span class="main">⟹</span> relH <span class="free">as</span> <span class="free">h</span> <span class="free">h</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> relH_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">"Symmetry"</span></span>
<span class="keyword1"><span class="command">lemma</span></span> relH_sym<span class="main">:</span> <span class="quoted"><span class="quoted">"relH <span class="free">as</span> <span class="free">h</span> <span class="free">h'</span> <span class="main">⟹</span> relH <span class="free">as</span> <span class="free">h'</span> <span class="free">h</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> relH_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">"Transitivity"</span></span>
<span class="keyword1"><span class="command">lemma</span></span> relH_trans<span class="main">[</span><span class="operator">trans</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>relH <span class="free">as</span> <span class="free">h1</span> <span class="free">h2</span><span class="main">;</span> relH <span class="free">as</span> <span class="free">h2</span> <span class="free">h3</span><span class="main">⟧</span> <span class="main">⟹</span> relH <span class="free">as</span> <span class="free">h1</span> <span class="free">h3</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> relH_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> relH_dist_union<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"relH <span class="main">(</span><span class="free">as</span><span class="main">∪</span><span class="free">as'</span><span class="main">)</span> <span class="free">h</span> <span class="free">h'</span> <span class="main">⟷</span> relH <span class="free">as</span> <span class="free">h</span> <span class="free">h'</span> <span class="main">∧</span> relH <span class="free">as'</span> <span class="free">h</span> <span class="free">h'</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> relH_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> relH_subset<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"relH <span class="free">bs</span> <span class="free">h</span> <span class="free">h'</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">as</span> <span class="main">⊆</span> <span class="free">bs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"relH <span class="free">as</span> <span class="free">h</span> <span class="free">h'</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> relH_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> in_range_subset<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> relH_ref<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"relH <span class="free">as</span> <span class="free">h</span> <span class="free">h'</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"addr_of_ref <span class="free">r</span> <span class="main">∈</span> <span class="free">as</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Ref.get <span class="free">h</span> <span class="free">r</span> <span class="main">=</span> Ref.get <span class="free">h'</span> <span class="free">r</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> relH_def Ref.get_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> relH_array<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"relH <span class="free">as</span> <span class="free">h</span> <span class="free">h'</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"addr_of_array <span class="free">r</span> <span class="main">∈</span> <span class="free">as</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Array.get <span class="free">h</span> <span class="free">r</span> <span class="main">=</span> Array.get <span class="free">h'</span> <span class="free">r</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> relH_def Array.get_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> relH_set_ref<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> addr_of_ref <span class="free">r</span> <span class="main">∉</span> <span class="free">as</span><span class="main">;</span> in_range <span class="main">(</span><span class="free">h</span><span class="main">,</span><span class="free">as</span><span class="main">)</span><span class="main">⟧</span> 
  <span class="main">⟹</span> relH <span class="free">as</span> <span class="free">h</span> <span class="main">(</span>Ref.set <span class="free">r</span> <span class="free">x</span> <span class="free">h</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> relH_def Ref.set_def 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_range.simps<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> relH_set_array<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>addr_of_array <span class="free">r</span> <span class="main">∉</span> <span class="free">as</span><span class="main">;</span> in_range <span class="main">(</span><span class="free">h</span><span class="main">,</span><span class="free">as</span><span class="main">)</span><span class="main">⟧</span> 
  <span class="main">⟹</span> relH <span class="free">as</span> <span class="free">h</span> <span class="main">(</span>Array.set <span class="free">r</span> <span class="free">x</span> <span class="free">h</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> relH_def Array.set_def 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_range.simps<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Assertions›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Assertions are predicates on partial heaps, that fulfill a well-formedness 
  condition called properness: They only depend on the part of the heap
  by the address set, and must be false for partial heaps that are not in range.
›</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> assn_raw <span class="main">=</span> <span class="quoted"><span class="quoted">"pheap <span class="main">⇒</span> bool"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">proper</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"assn_raw <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">proper</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">≡</span> <span class="main">∀</span><span class="bound">h</span> <span class="bound">h'</span> <span class="bound">as</span><span class="main">.</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">(</span><span class="bound">h</span><span class="main">,</span><span class="bound">as</span><span class="main">)</span> <span class="main">⟶</span> in_range <span class="main">(</span><span class="bound">h</span><span class="main">,</span><span class="bound">as</span><span class="main">)</span><span class="main">)</span> 
    <span class="main">∧</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">(</span><span class="bound">h</span><span class="main">,</span><span class="bound">as</span><span class="main">)</span> <span class="main">∧</span> relH <span class="bound">as</span> <span class="bound">h</span> <span class="bound">h'</span> <span class="main">∧</span> in_range <span class="main">(</span><span class="bound">h'</span><span class="main">,</span><span class="bound">as</span><span class="main">)</span> <span class="main">⟶</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">(</span><span class="bound">h'</span><span class="main">,</span><span class="bound">as</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> properI<span class="main">[</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">?</span></span></span></span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">as</span> <span class="bound">h</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span><span class="bound">h</span><span class="main">,</span><span class="bound">as</span><span class="main">)</span> <span class="main">⟹</span> in_range <span class="main">(</span><span class="bound">h</span><span class="main">,</span><span class="bound">as</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">as</span> <span class="bound">h</span> <span class="bound">h'</span><span class="main">.</span> 
    <span class="main">⟦</span><span class="free">P</span> <span class="main">(</span><span class="bound">h</span><span class="main">,</span><span class="bound">as</span><span class="main">)</span><span class="main">;</span> relH <span class="bound">as</span> <span class="bound">h</span> <span class="bound">h'</span><span class="main">;</span> in_range <span class="main">(</span><span class="bound">h'</span><span class="main">,</span><span class="bound">as</span><span class="main">)</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span><span class="bound">h'</span><span class="main">,</span><span class="bound">as</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"proper <span class="free">P</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> proper_def <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> properD1<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"proper <span class="free">P</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">(</span><span class="free">h</span><span class="main">,</span><span class="free">as</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"in_range <span class="main">(</span><span class="free">h</span><span class="main">,</span><span class="free">as</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> proper_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> properD2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"proper <span class="free">P</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">(</span><span class="free">h</span><span class="main">,</span><span class="free">as</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"relH <span class="free">as</span> <span class="free">h</span> <span class="free">h'</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"in_range <span class="main">(</span><span class="free">h'</span><span class="main">,</span><span class="free">as</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">(</span><span class="free">h'</span><span class="main">,</span><span class="free">as</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> proper_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemmas</span></span> properD <span class="main">=</span> properD1 properD2

<span class="keyword1"><span class="command">lemma</span></span> proper_iff<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"proper <span class="free">P</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"relH <span class="free">as</span> <span class="free">h</span> <span class="free">h'</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"in_range <span class="main">(</span><span class="free">h'</span><span class="main">,</span><span class="free">as</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">(</span><span class="free">h</span><span class="main">,</span><span class="free">as</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">P</span> <span class="main">(</span><span class="free">h'</span><span class="main">,</span><span class="free">as</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> properD2 relH_in_rangeI<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> relH_sym<span class="main">)</span> 

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We encapsulate assertions in their own type›</span></span>  
<span class="keyword1"><span class="command">typedef</span></span> assn <span class="main">=</span> <span class="quoted"><span class="quoted">"Collect proper"</span></span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">unfolding</span></span> proper_def 
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> Rep_assn_inverse Rep_assn_inject 
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span> <span class="main">=</span> Rep_assn<span class="main">[</span><span class="operator">unfolded</span> mem_Collect_eq<span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> Abs_assn_eqI<span class="main">[</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main">?</span></span></span></span></span></span></span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">h</span><span class="main">.</span> <span class="free">P</span> <span class="bound">h</span> <span class="main">=</span> Rep_assn <span class="free">Pr</span> <span class="bound">h</span><span class="main">)</span> <span class="main">⟹</span> Abs_assn <span class="free">P</span> <span class="main">=</span> <span class="free">Pr</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">h</span><span class="main">.</span> <span class="free">P</span> <span class="bound">h</span> <span class="main">=</span> Rep_assn <span class="free">Pr</span> <span class="bound">h</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">Pr</span> <span class="main">=</span> Abs_assn <span class="free">P</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Rep_assn_inverse predicate1I xt1<span class="main"><span class="main">(</span></span>5<span class="main"><span class="main">)</span></span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">models</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"pheap <span class="main">⇒</span> assn <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">⊨</span>"</span> 50<span class="main">)</span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">h</span></span></span><span class="main"><span class="free">⊨</span></span><span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">≡</span> Rep_assn <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">h</span></span></span>"</span></span>


<span class="keyword1"><span class="command">lemma</span></span> models_in_range<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">h</span><span class="main">⊨</span><span class="free">P</span> <span class="main">⟹</span> in_range <span class="free">h</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">h</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> mem_Collect_eq Rep_assn properD1<span class="main">)</span>
    
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Empty Partial Heap›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The empty partial heap satisfies some special properties.
  We set up a simplification that tries to rewrite it to the standard
  empty partial heap <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>h<span class="hidden">⇩</span><sub>⊥</sub>›</span></span></span></span>›</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">h_bot</span> <span class="main">(</span><span class="quoted">"<span class="keyword1">h<span class="hidden">⇩</span><sub>⊥</sub></span>"</span><span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="free">h<span class="hidden">⇩</span><sub>⊥</sub></span></span> <span class="main">≡</span> <span class="main">(</span>undefined<span class="main">,</span><span class="main">{}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">lemma</span></span> mod_h_bot_indep<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">h</span><span class="main">,</span><span class="main">{}</span><span class="main">)</span><span class="main">⊨</span><span class="free">P</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">h'</span><span class="main">,</span><span class="main">{}</span><span class="main">)</span><span class="main">⊨</span><span class="free">P</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> mem_Collect_eq Rep_assn emptyE in_range_empty 
    proper_iff relH_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> mod_h_bot_normalize<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"syntax_fo_nomatch undefined <span class="free">h</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">h</span><span class="main">,</span><span class="main">{}</span><span class="main">)</span><span class="main">⊨</span><span class="free">P</span> <span class="main">⟷</span> <span class="keyword1">h<span class="hidden">⇩</span><sub>⊥</sub></span> <span class="main">⊨</span> <span class="free">P</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> mod_h_bot_indep<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> h'<span class="main"><span class="main">=</span></span><span class="quoted">undefined</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Properness, lifted to the assertion type.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> mod_relH<span class="main">:</span> <span class="quoted"><span class="quoted">"relH <span class="free">as</span> <span class="free">h</span> <span class="free">h'</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">h</span><span class="main">,</span><span class="free">as</span><span class="main">)</span><span class="main">⊨</span><span class="free">P</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">h'</span><span class="main">,</span><span class="free">as</span><span class="main">)</span><span class="main">⊨</span><span class="free">P</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> mem_Collect_eq Rep_assn proper_iff relH_in_rangeI<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
    
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Connectives›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We define several operations on assertions, and instantiate some type classes.
›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Empty Heap and Separation Conjunction›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The assertion that describes the empty heap, and the separation
  conjunction form a commutative monoid:›</span></span>
<span class="keyword1"><span class="command">instantiation</span></span> assn <span class="main">::</span> <span class="quoted">one</span> <span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">fun</span></span> <span class="entity">one_assn_raw</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"pheap <span class="main">⇒</span> bool"</span></span> 
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">one_assn_raw</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">h</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">=</span><span class="main">{}</span>"</span></span>
  
  <span class="keyword1"><span class="command">lemma</span></span> one_assn_proper<span class="main">[</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">,</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"proper one_assn_raw"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> properI<span class="main">)</span>
  
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity"><span class="class_parameter">one_assn</span></span> <span class="main">::</span> <span class="quoted">assn</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">≡</span> Abs_assn one_assn_raw"</span></span>
  <span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">one_assn</span><span class="main">::</span><span class="quoted">assn</span> <span class="main">(</span><span class="quoted">"<span class="keyword1">emp</span>"</span><span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">one_assn</span> <span class="main">≡</span> <span class="main">1</span>"</span></span>
  
<span class="keyword1"><span class="command">instantiation</span></span> assn <span class="main">::</span> <span class="quoted">times</span> <span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">fun</span></span> <span class="entity">times_assn_raw</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"assn_raw <span class="main">⇒</span> assn_raw <span class="main">⇒</span> assn_raw"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">times_assn_raw</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">h</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">)</span> 
    <span class="main">=</span> <span class="main">(</span><span class="main">∃</span><span class="bound">as1</span> <span class="bound">as2</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">=</span><span class="bound">as1</span><span class="main">∪</span><span class="bound">as2</span> <span class="main">∧</span> <span class="bound">as1</span><span class="main">∩</span><span class="bound">as2</span><span class="main">=</span><span class="main">{}</span> 
        <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">h</span></span></span><span class="main">,</span><span class="bound">as1</span><span class="main">)</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">h</span></span></span><span class="main">,</span><span class="bound">as2</span><span class="main">)</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> times_assn_proper<span class="main">[</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">,</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"proper <span class="free">P</span> <span class="main">⟹</span> proper <span class="free">Q</span> <span class="main">⟹</span> proper <span class="main">(</span>times_assn_raw <span class="free">P</span> <span class="free">Q</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> properI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> properD1<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> <span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> properD2<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> <span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> properD2<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity"><span class="class_parameter">times_assn</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">P</span></span></span><span class="main">*</span><span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">≡</span> 
    Abs_assn <span class="main">(</span>times_assn_raw <span class="main">(</span>Rep_assn <span class="free"><span class="bound"><span class="entity">P</span></span></span><span class="main">)</span> <span class="main">(</span>Rep_assn <span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> mod_star_conv<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">h</span><span class="main">⊨</span><span class="free">A</span><span class="main">*</span><span class="free">B</span> 
  <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">hr</span> <span class="bound">as1</span> <span class="bound">as2</span><span class="main">.</span> <span class="free">h</span><span class="main">=</span><span class="main">(</span><span class="bound">hr</span><span class="main">,</span><span class="bound">as1</span><span class="main">∪</span><span class="bound">as2</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">as1</span><span class="main">∩</span><span class="bound">as2</span><span class="main">=</span><span class="main">{}</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">hr</span><span class="main">,</span><span class="bound">as1</span><span class="main">)</span><span class="main">⊨</span><span class="free">A</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">hr</span><span class="main">,</span><span class="bound">as2</span><span class="main">)</span><span class="main">⊨</span><span class="free">B</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> times_assn_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">h</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Abs_assn_inverse<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> mod_starD<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">h</span><span class="main">⊨</span><span class="free">A</span><span class="main">*</span><span class="free">B</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">h1</span> <span class="bound">h2</span><span class="main">.</span> <span class="bound">h1</span><span class="main">⊨</span><span class="free">A</span> <span class="main">∧</span> <span class="bound">h2</span><span class="main">⊨</span><span class="free">B</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mod_star_conv<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> star_assnI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">h</span><span class="main">,</span><span class="free">as</span><span class="main">)</span><span class="main">⊨</span><span class="free">P</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">h</span><span class="main">,</span><span class="free">as'</span><span class="main">)</span><span class="main">⊨</span><span class="free">Q</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">as</span><span class="main">∩</span><span class="free">as'</span><span class="main">=</span><span class="main">{}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">h</span><span class="main">,</span><span class="free">as</span><span class="main">∪</span><span class="free">as'</span><span class="main">)</span><span class="main">⊨</span><span class="free">P</span><span class="main">*</span><span class="free">Q</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> times_assn_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Abs_assn_inverse<span class="main">)</span>
 
<span class="keyword1"><span class="command">instantiation</span></span> assn <span class="main">::</span> <span class="quoted">comm_monoid_mult</span> <span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> assn_one_left<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">1</span><span class="main">*</span><span class="free">P</span> <span class="main">=</span> <span class="main">(</span><span class="free">P</span><span class="main">::</span>assn<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> one_assn_def times_assn_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Abs_assn_inverse<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">lemma</span></span> assn_times_comm<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span><span class="main">*</span><span class="free">Q</span> <span class="main">=</span> <span class="free">Q</span><span class="main">*</span><span class="main">(</span><span class="free">P</span><span class="main">::</span>assn<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> times_assn_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_assn_inverse Un_ac<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">lemma</span></span> assn_times_assoc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">P</span><span class="main">*</span><span class="free">Q</span><span class="main">)</span><span class="main">*</span><span class="free">R</span> <span class="main">=</span> <span class="free">P</span><span class="main">*</span><span class="main">(</span><span class="free">Q</span><span class="main">*</span><span class="main">(</span><span class="free">R</span><span class="main">::</span>assn<span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> times_assn_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Abs_assn_inverse<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="improper">as1</span><span class="main">∪</span><span class="improper">as1a</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="improper">as2a</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Un_ac<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="improper">as1a</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="improper">as2a</span><span class="main">∪</span><span class="improper">as2</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Un_ac<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">instance</span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> assn_times_assoc<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> assn_times_comm<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> assn_one_left<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>
  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Magic Wand›</span></span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">wand_raw</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"assn_raw <span class="main">⇒</span> assn_raw <span class="main">⇒</span> assn_raw"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">wand_raw</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">h</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">)</span> <span class="main">⟷</span> in_range <span class="main">(</span><span class="free"><span class="bound"><span class="entity">h</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">)</span> 
  <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">h'</span> <span class="bound">as'</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">∩</span><span class="bound">as'</span><span class="main">=</span><span class="main">{}</span> <span class="main">∧</span> relH <span class="free"><span class="bound"><span class="entity">as</span></span></span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="bound">h'</span> <span class="main">∧</span> in_range <span class="main">(</span><span class="bound">h'</span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">)</span>
    <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">(</span><span class="bound">h'</span><span class="main">,</span><span class="bound">as'</span><span class="main">)</span>
    <span class="main">⟶</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">(</span><span class="bound">h'</span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">∪</span><span class="bound">as'</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> wand_proper<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"proper <span class="main">(</span>wand_raw <span class="free">P</span> <span class="free">Q</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> properI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> relH_trans<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">definition</span></span> 
  <span class="entity">wand_assn</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"assn <span class="main">⇒</span> assn <span class="main">⇒</span> assn"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">-*</span>"</span> 56<span class="main">)</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">P</span></span></span><span class="main"><span class="free">-*</span></span><span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">≡</span> Abs_assn <span class="main">(</span>wand_raw <span class="main">(</span>Rep_assn <span class="free"><span class="bound"><span class="entity">P</span></span></span><span class="main">)</span> <span class="main">(</span>Rep_assn <span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> wand_assnI<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"in_range <span class="main">(</span><span class="free">h</span><span class="main">,</span><span class="free">as</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">h'</span> <span class="bound">as'</span><span class="main">.</span> <span class="main">⟦</span>
    <span class="free">as</span> <span class="main">∩</span> <span class="bound">as'</span> <span class="main">=</span> <span class="main">{}</span><span class="main">;</span> 
    relH <span class="free">as</span> <span class="free">h</span> <span class="bound">h'</span><span class="main">;</span> 
    in_range <span class="main">(</span><span class="bound">h'</span><span class="main">,</span><span class="free">as</span><span class="main">)</span><span class="main">;</span> 
    <span class="main">(</span><span class="bound">h'</span><span class="main">,</span><span class="bound">as'</span><span class="main">)</span><span class="main">⊨</span><span class="free">Q</span> 
  <span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="bound">h'</span><span class="main">,</span><span class="free">as</span><span class="main">∪</span><span class="bound">as'</span><span class="main">)</span> <span class="main">⊨</span> <span class="free">R</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">h</span><span class="main">,</span><span class="free">as</span><span class="main">)</span> <span class="main">⊨</span> <span class="free">Q</span> <span class="main">-*</span> <span class="free">R</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms 
  <span class="keyword1"><span class="command">unfolding</span></span> wand_assn_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Abs_assn_inverse<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Boolean Algebra on Assertions›</span></span>
<span class="keyword1"><span class="command">instantiation</span></span> assn <span class="main">::</span> <span class="quoted">boolean_algebra</span> <span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity"><span class="class_parameter">top_assn</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"top <span class="main">≡</span> Abs_assn in_range"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity"><span class="class_parameter">bot_assn</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"bot <span class="main">≡</span> Abs_assn <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> False<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity"><span class="class_parameter">sup_assn</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"sup <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">≡</span> Abs_assn <span class="main">(</span><span class="main">λ</span><span class="bound">h</span><span class="main">.</span> <span class="bound">h</span><span class="main">⊨</span><span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">∨</span> <span class="bound">h</span><span class="main">⊨</span><span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity"><span class="class_parameter">inf_assn</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"inf <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">≡</span> Abs_assn <span class="main">(</span><span class="main">λ</span><span class="bound">h</span><span class="main">.</span> <span class="bound">h</span><span class="main">⊨</span><span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">∧</span> <span class="bound">h</span><span class="main">⊨</span><span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity"><span class="class_parameter">uminus_assn</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="quoted"><span class="quoted">"<span class="main">-</span><span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">≡</span> Abs_assn <span class="main">(</span><span class="main">λ</span><span class="bound">h</span><span class="main">.</span> in_range <span class="bound">h</span> <span class="main">∧</span> <span class="main">¬</span><span class="bound">h</span><span class="main">⊨</span><span class="free"><span class="bound"><span class="entity">P</span></span></span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> bool_assn_proper<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"proper in_range"</span></span>
    <span class="quoted"><span class="quoted">"proper <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> False<span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"proper <span class="free">P</span> <span class="main">⟹</span> proper <span class="free">Q</span> <span class="main">⟹</span> proper <span class="main">(</span><span class="main">λ</span><span class="bound">h</span><span class="main">.</span> <span class="free">P</span> <span class="bound">h</span> <span class="main">∨</span> <span class="free">Q</span> <span class="bound">h</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"proper <span class="free">P</span> <span class="main">⟹</span> proper <span class="free">Q</span> <span class="main">⟹</span> proper <span class="main">(</span><span class="main">λ</span><span class="bound">h</span><span class="main">.</span> <span class="free">P</span> <span class="bound">h</span> <span class="main">∧</span> <span class="free">Q</span> <span class="bound">h</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"proper <span class="free">P</span> <span class="main">⟹</span> proper <span class="main">(</span><span class="main">λ</span><span class="bound">h</span><span class="main">.</span> in_range <span class="bound">h</span> <span class="main">∧</span> <span class="main">¬</span><span class="free">P</span> <span class="bound">h</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
      <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> properI 
      <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> relH_in_rangeI 
      <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> properD1 
      <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> proper_iff<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹(And, Or, True, False, Not) are a Boolean algebra. 
    Due to idiosyncrasies of the Isabelle/HOL class setup, we have to
    also define a difference and an ordering:›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity"><span class="class_parameter">less_eq_assn</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">::</span>assn<span class="main">)</span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">=</span> inf <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity"><span class="class_parameter">less_assn</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">::</span>assn<span class="main">)</span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">≠</span><span class="free"><span class="bound"><span class="entity">b</span></span></span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity"><span class="class_parameter">minus_assn</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">::</span>assn<span class="main">)</span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">≡</span> inf <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">(</span><span class="main">-</span><span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">instance</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
    <span class="keyword1"><span class="command">unfolding</span></span> 
      top_assn_def bot_assn_def sup_assn_def inf_assn_def uminus_assn_def
      less_eq_assn_def less_assn_def minus_assn_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
      <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Abs_assn_inverse conj_commute conj_ac 
      <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> Abs_assn_eqI models_in_range<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">)</span></span> Abs_assn_inverse<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> mem_Collect_eq<span class="main"><span class="main">]</span></span>
      Rep_assn<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> mem_Collect_eq<span class="main"><span class="main">]</span></span> bool_assn_proper<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">)</span></span>
      Abs_assn_inverse<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> mem_Collect_eq<span class="main"><span class="main">]</span></span>
      Rep_assn<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> mem_Collect_eq<span class="main"><span class="main">]</span></span> bool_assn_proper<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_assn_inverse<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">)</span></span> 
      Abs_assn_inverse<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> mem_Collect_eq<span class="main"><span class="main">]</span></span> 
      Rep_assn<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> mem_Collect_eq<span class="main"><span class="main">]</span></span> bool_assn_proper<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We give the operations some more standard names›</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">top_assn</span><span class="main">::</span><span class="quoted">assn</span> <span class="main">(</span><span class="quoted">"<span class="keyword1">true</span>"</span><span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">top_assn</span> <span class="main">≡</span> top"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">bot_assn</span><span class="main">::</span><span class="quoted">assn</span> <span class="main">(</span><span class="quoted">"<span class="keyword1">false</span>"</span><span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">bot_assn</span> <span class="main">≡</span> bot"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">sup_assn</span><span class="main">::</span><span class="quoted"><span class="quoted">"assn<span class="main">⇒</span>assn<span class="main">⇒</span>assn"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixr</span></span> <span class="quoted">"<span class="keyword1">∨<span class="hidden">⇩</span><sub>A</sub></span>"</span> 61<span class="main">)</span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">sup_assn</span> <span class="main">≡</span> sup"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">inf_assn</span><span class="main">::</span><span class="quoted"><span class="quoted">"assn<span class="main">⇒</span>assn<span class="main">⇒</span>assn"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixr</span></span> <span class="quoted">"<span class="keyword1">∧<span class="hidden">⇩</span><sub>A</sub></span>"</span> 62<span class="main">)</span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">inf_assn</span> <span class="main">≡</span> inf"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">uminus_assn</span><span class="main">::</span><span class="quoted"><span class="quoted">"assn <span class="main">⇒</span> assn"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">¬<span class="hidden">⇩</span><sub>A</sub></span> _"</span> <span class="main">[</span>81<span class="main">]</span> 80<span class="main">)</span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">uminus_assn</span> <span class="main">≡</span> uminus"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Now we prove some relations between the Boolean algebra operations
  and the (empty heap,separation conjunction) monoid›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> star_false_left<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">false</span> <span class="main">*</span> <span class="free">P</span> <span class="main">=</span> <span class="keyword1">false</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> times_assn_def bot_assn_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_assn_inverse<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> star_false_right<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">*</span> <span class="keyword1">false</span> <span class="main">=</span> <span class="keyword1">false</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> star_false_left <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assn_times_comm<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> star_false <span class="main">=</span> star_false_left star_false_right 
  
<span class="keyword1"><span class="command">lemma</span></span> assn_basic_inequalities<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="keyword1">true</span> <span class="main">≠</span> <span class="keyword1">emp</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">emp</span> <span class="main">≠</span> <span class="keyword1">true</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="keyword1">false</span> <span class="main">≠</span> <span class="keyword1">emp</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">emp</span> <span class="main">≠</span> <span class="keyword1">false</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="keyword1">true</span> <span class="main">≠</span> <span class="keyword1">false</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">false</span> <span class="main">≠</span> <span class="keyword1">true</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> one_assn_def top_assn_def
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">subst</span> Abs_assn_inject<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">?</span></span><span class="main">)</span> 
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"in_range <span class="main">(</span><span class="main">⦇</span>arrays <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">[]</span><span class="main">)</span><span class="main">,</span> refs <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">0</span><span class="main">)</span><span class="main">,</span> lim <span class="main">=</span> <span class="main">1</span><span class="main">⦈</span><span class="main">,</span><span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"in_range <span class="var">?h</span>"</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_range.simps<span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>one_assn_raw <span class="var">?h</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"in_range <span class="main">≠</span> one_assn_raw"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>      
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">‹<span class="keyword1">true</span> <span class="main">≠</span> <span class="keyword1">emp</span>›</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
  <span class="keyword1"><span class="command">using</span></span> star_false_left <span class="quoted"><span class="quoted">‹<span class="keyword1">true</span> <span class="main">≠</span> <span class="keyword1">emp</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">‹<span class="keyword1">false</span> <span class="main">≠</span> <span class="keyword1">emp</span>›</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> inf_bot_right inf_top.right_neutral <span class="quoted"><span class="quoted">‹<span class="keyword1">true</span> <span class="main">≠</span> <span class="keyword1">emp</span>›</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="keyword1">true</span> <span class="main">≠</span> <span class="keyword1">false</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  
  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Existential Quantification›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ex_assn</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> assn<span class="main">)</span> <span class="main">⇒</span> assn"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">binder</span></span> <span class="quoted">"<span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span>"</span> 11<span class="main">)</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1"><span class="free">∃<span class="hidden">⇩</span><sub>A</sub></span></span><span class="bound">x</span><span class="main"><span class="free">.</span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="bound">x</span><span class="main">)</span> <span class="main">≡</span> Abs_assn <span class="main">(</span><span class="main">λ</span><span class="bound">h</span><span class="main">.</span> <span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="bound">h</span><span class="main">⊨</span><span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="bound">x</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ex_assn_proper<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> proper <span class="main">(</span><span class="free">P</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> proper <span class="main">(</span><span class="main">λ</span><span class="bound">h</span><span class="main">.</span> <span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span> <span class="bound">h</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> properI <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> properD1 <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> proper_iff<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ex_assn_const<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">x</span><span class="main">.</span> <span class="free">c</span><span class="main">)</span> <span class="main">=</span> <span class="free">c</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> ex_assn_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> ex_one_point_gen<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">⋀</span><span class="bound">h</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">h</span><span class="main">⊨</span><span class="free">P</span> <span class="bound">x</span> <span class="main">⟹</span> <span class="bound">x</span><span class="main">=</span><span class="free">v</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">P</span> <span class="free">v</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ex_assn_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> ex_distrib_star<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span> <span class="main">*</span> <span class="free">Q</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span> <span class="main">*</span> <span class="free">Q</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ex_assn_def times_assn_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_assn_inverse<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> ex_distrib_and<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span> <span class="keyword1">∧<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">Q</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span> <span class="keyword1">∧<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">Q</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ex_assn_def inf_assn_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_assn_inverse<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> ex_distrib_or<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span> <span class="keyword1">∨<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">Q</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span> <span class="keyword1">∨<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">Q</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ex_assn_def sup_assn_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_assn_inverse<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> ex_join_or<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span> <span class="keyword1">∨<span class="hidden">⇩</span><sub>A</sub></span> <span class="main">(</span><span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">x</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span> <span class="keyword1">∨<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">Q</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ex_assn_def sup_assn_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_assn_inverse<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Pure Assertions›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Pure assertions do not depend on any heap content.›</span></span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">pure_assn_raw</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">pure_assn_raw</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">h</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">=</span><span class="main">{}</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">pure_assn</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"bool <span class="main">⇒</span> assn"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">↑</span>"</span><span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main"><span class="free">↑</span></span><span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">≡</span> Abs_assn <span class="main">(</span>pure_assn_raw <span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> pure_assn_proper<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"proper <span class="main">(</span>pure_assn_raw <span class="free">b</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> properI <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> relH_in_rangeI<span class="main">)</span>


    
<span class="keyword1"><span class="command">lemma</span></span> pure_true<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">↑</span>True <span class="main">=</span> <span class="keyword1">emp</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> pure_assn_def one_assn_def 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_assn_inverse<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> pure_false<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">↑</span>False <span class="main">=</span> <span class="keyword1">false</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> pure_assn_def bot_assn_def 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Abs_assn_inverse<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> pure_assn_eq_false_iff<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">↑</span><span class="free">P</span> <span class="main">=</span> <span class="keyword1">false</span> <span class="main">⟷</span> <span class="main">¬</span><span class="free">P</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
<span class="keyword1"><span class="command">lemma</span></span> pure_assn_eq_emp_iff<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">↑</span><span class="free">P</span> <span class="main">=</span> <span class="keyword1">emp</span> <span class="main">⟷</span> <span class="free">P</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">P</span></span><span class="main">)</span> <span class="operator">auto</span>
    
<span class="keyword1"><span class="command">lemma</span></span> merge_pure_star<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">↑</span><span class="free">a</span> <span class="main">*</span> <span class="main">↑</span><span class="free">b</span> <span class="main">=</span> <span class="main">↑</span><span class="main">(</span><span class="free">a</span><span class="main">∧</span><span class="free">b</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> times_assn_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command">unfolding</span></span> pure_assn_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_assn_inverse<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> merge_true_star<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">true</span><span class="main">*</span><span class="keyword1">true</span> <span class="main">=</span> <span class="keyword1">true</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> times_assn_def top_assn_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_assn_inverse<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_range.simps<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> merge_pure_and<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">↑</span><span class="free">a</span> <span class="keyword1">∧<span class="hidden">⇩</span><sub>A</sub></span> <span class="main">↑</span><span class="free">b</span> <span class="main">=</span> <span class="main">↑</span><span class="main">(</span><span class="free">a</span><span class="main">∧</span><span class="free">b</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> inf_assn_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command">unfolding</span></span> pure_assn_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_assn_inverse<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> merge_pure_or<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">↑</span><span class="free">a</span> <span class="keyword1">∨<span class="hidden">⇩</span><sub>A</sub></span> <span class="main">↑</span><span class="free">b</span> <span class="main">=</span> <span class="main">↑</span><span class="main">(</span><span class="free">a</span><span class="main">∨</span><span class="free">b</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> sup_assn_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command">unfolding</span></span> pure_assn_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_assn_inverse<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

    
<span class="keyword1"><span class="command">lemma</span></span> pure_assn_eq_conv<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">↑</span><span class="free">P</span> <span class="main">=</span> <span class="main">↑</span><span class="free">Q</span> <span class="main">⟷</span> <span class="free">P</span><span class="main">=</span><span class="free">Q</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">is_pure_assn</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">≡</span> <span class="main">∃</span><span class="bound">P</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">=</span><span class="main">↑</span><span class="bound">P</span>"</span></span>
<span class="keyword1"><span class="command">lemma</span></span> is_pure_assnE<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"is_pure_assn <span class="free">a</span>"</span></span> <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">P</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span><span class="main">=</span><span class="main">↑</span><span class="free">P</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> is_pure_assn_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> is_pure_assn_pure<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"is_pure_assn <span class="main">(</span><span class="main">↑</span><span class="free">P</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> is_pure_assn_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> is_pure_assn_basic_simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"is_pure_assn <span class="keyword1">false</span>"</span></span>
  <span class="quoted"><span class="quoted">"is_pure_assn <span class="keyword1">emp</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"is_pure_assn <span class="main">(</span><span class="main">↑</span>False<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">rule</span> <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"is_pure_assn <span class="keyword1">false</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"is_pure_assn <span class="main">(</span><span class="main">↑</span>True<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">rule</span> <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"is_pure_assn <span class="keyword1">emp</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>  

<span class="keyword1"><span class="command">lemma</span></span> is_pure_assn_starI<span class="main">[</span><span class="operator">simp</span><span class="main">,</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>is_pure_assn <span class="free">a</span><span class="main">;</span> is_pure_assn <span class="free">b</span><span class="main">⟧</span> <span class="main">⟹</span> is_pure_assn <span class="main">(</span><span class="free">a</span><span class="main">*</span><span class="free">b</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> is_pure_assnE<span class="main">)</span>
    
    
    
    
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Pointers›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In Imperative HOL, we have to distinguish between pointers to single
  values and pointers to arrays. For both, we define assertions that 
  describe the part of the heap that a pointer points to.›</span></span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">sngr_assn_raw</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>heap ref <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> assn_raw"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">sngr_assn_raw</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">h</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">)</span> <span class="main">⟷</span> Ref.get <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">as</span></span></span> <span class="main">=</span> <span class="main">{</span>addr_of_ref <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">}</span> <span class="main">∧</span> 
  addr_of_ref <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">&lt;</span> lim <span class="free"><span class="bound"><span class="entity">h</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> sngr_assn_proper<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"proper <span class="main">(</span>sngr_assn_raw <span class="free">r</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> properI <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> relH_ref<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> in_range.simps<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> in_range.simps <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> relH_in_rangeI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">sngr_assn</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>heap ref <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> assn"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">↦<span class="hidden">⇩</span><sub>r</sub></span>"</span> 82<span class="main">)</span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="keyword1"><span class="free">↦<span class="hidden">⇩</span><sub>r</sub></span></span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≡</span> Abs_assn <span class="main">(</span>sngr_assn_raw <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">snga_assn_raw</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>heap array <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> assn_raw"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">snga_assn_raw</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">h</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">)</span> 
  <span class="main">⟷</span> Array.get <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">as</span></span></span> <span class="main">=</span> <span class="main">{</span>addr_of_array <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">}</span> 
      <span class="main">∧</span> addr_of_array <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">&lt;</span> lim <span class="free"><span class="bound"><span class="entity">h</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> snga_assn_proper<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"proper <span class="main">(</span>snga_assn_raw <span class="free">r</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> properI <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> relH_array<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> in_range.simps<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> in_range.simps <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> relH_in_rangeI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">definition</span></span> 
  <span class="entity">snga_assn</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>heap array <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> assn"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">↦<span class="hidden">⇩</span><sub>a</sub></span>"</span> 82<span class="main">)</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="keyword1"><span class="free">↦<span class="hidden">⇩</span><sub>a</sub></span></span><span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">≡</span> Abs_assn <span class="main">(</span>snga_assn_raw <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Two disjoint parts of the heap cannot be pointed to by the 
  same pointer›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> sngr_same_false<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="keyword1">↦<span class="hidden">⇩</span><sub>r</sub></span> <span class="free">x</span> <span class="main">*</span> <span class="free">p</span> <span class="keyword1">↦<span class="hidden">⇩</span><sub>r</sub></span> <span class="free">y</span> <span class="main">=</span> <span class="keyword1">false</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> times_assn_def bot_assn_def sngr_assn_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Abs_assn_inverse<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> snga_same_false<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="keyword1">↦<span class="hidden">⇩</span><sub>a</sub></span> <span class="free">x</span> <span class="main">*</span> <span class="free">p</span> <span class="keyword1">↦<span class="hidden">⇩</span><sub>a</sub></span> <span class="free">y</span> <span class="main">=</span> <span class="keyword1">false</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> times_assn_def bot_assn_def snga_assn_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Abs_assn_inverse<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Properties of the Models-Predicate›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> mod_true<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">h</span><span class="main">⊨</span><span class="keyword1">true</span> <span class="main">⟷</span> in_range <span class="free">h</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> top_assn_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_assn_inverse<span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> mod_false<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">h</span><span class="main">⊨</span><span class="keyword1">false</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> bot_assn_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_assn_inverse<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> mod_emp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">h</span><span class="main">⊨</span><span class="keyword1">emp</span> <span class="main">⟷</span> snd <span class="free">h</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> one_assn_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">h</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_assn_inverse<span class="main">)</span>
  
<span class="keyword1"><span class="command">lemma</span></span> mod_emp_simp<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">h</span><span class="main">,</span><span class="main">{}</span><span class="main">)</span><span class="main">⊨</span><span class="keyword1">emp</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mod_emp<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> mod_pure<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">h</span><span class="main">⊨</span><span class="main">↑</span><span class="free">b</span> <span class="main">⟷</span> snd <span class="free">h</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">∧</span> <span class="free">b</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> pure_assn_def 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">h</span></span><span class="main">)</span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_assn_inverse<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> mod_ex_dist<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">h</span><span class="main">⊨</span><span class="main">(</span><span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="free">h</span><span class="main">⊨</span><span class="free">P</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ex_assn_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Abs_assn_inverse<span class="main">)</span>
  
<span class="keyword1"><span class="command">lemma</span></span> mod_exI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="free">h</span><span class="main">⊨</span><span class="free">P</span> <span class="bound">x</span> <span class="main">⟹</span> <span class="free">h</span><span class="main">⊨</span><span class="main">(</span><span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mod_ex_dist<span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> mod_exE<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span><span class="main">⊨</span><span class="main">(</span><span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">x</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span><span class="main">⊨</span><span class="free">P</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mod_ex_dist<span class="main">)</span>

<span class="comment1">(* Not declared as simp, to not interfere with precision.
  TODO: Perhaps define own connector for precision claims?
*)</span>
<span class="keyword1"><span class="command">lemma</span></span> mod_and_dist<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">h</span><span class="main">⊨</span><span class="free">P</span><span class="keyword1">∧<span class="hidden">⇩</span><sub>A</sub></span><span class="free">Q</span> <span class="main">⟷</span> <span class="free">h</span><span class="main">⊨</span><span class="free">P</span> <span class="main">∧</span> <span class="free">h</span><span class="main">⊨</span><span class="free">Q</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> inf_assn_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_assn_inverse<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> mod_or_dist<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">h</span><span class="main">⊨</span><span class="free">P</span><span class="keyword1">∨<span class="hidden">⇩</span><sub>A</sub></span><span class="free">Q</span> <span class="main">⟷</span> <span class="free">h</span><span class="main">⊨</span><span class="free">P</span> <span class="main">∨</span> <span class="free">h</span><span class="main">⊨</span><span class="free">Q</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> sup_assn_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_assn_inverse<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> mod_not_dist<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">h</span><span class="main">⊨</span><span class="main">(</span><span class="keyword1">¬<span class="hidden">⇩</span><sub>A</sub></span><span class="free">P</span><span class="main">)</span> <span class="main">⟷</span> in_range <span class="free">h</span> <span class="main">∧</span> <span class="main">¬</span> <span class="free">h</span><span class="main">⊨</span><span class="free">P</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> uminus_assn_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_assn_inverse<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> mod_pure_star_dist<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">h</span><span class="main">⊨</span><span class="free">P</span><span class="main">*</span><span class="main">↑</span><span class="free">b</span> <span class="main">⟷</span> <span class="free">h</span><span class="main">⊨</span><span class="free">P</span> <span class="main">∧</span> <span class="free">b</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>full_types<span class="main"><span class="main">)</span></span> mod_false mult_1_right pure_false 
    pure_true star_false_right<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> mod_dist <span class="main">=</span> mod_pure mod_pure_star_dist mod_ex_dist mod_and_dist
  mod_or_dist mod_not_dist

<span class="keyword1"><span class="command">lemma</span></span> mod_star_trueI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">h</span><span class="main">⊨</span><span class="free">P</span> <span class="main">⟹</span> <span class="free">h</span><span class="main">⊨</span><span class="free">P</span><span class="main">*</span><span class="keyword1">true</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> times_assn_def top_assn_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_assn_inverse<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">h</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> mod_star_trueE'<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span><span class="main">⊨</span><span class="free">P</span><span class="main">*</span><span class="keyword1">true</span>"</span></span> <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">h'</span> <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"fst <span class="free">h'</span> <span class="main">=</span> fst <span class="free">h</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"snd <span class="free">h'</span> <span class="main">⊆</span> snd <span class="free">h</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">h'</span><span class="main">⊨</span><span class="free">P</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">unfolding</span></span> times_assn_def top_assn_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">h</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_assn_inverse<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> mod_star_trueE<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span><span class="main">⊨</span><span class="free">P</span><span class="main">*</span><span class="keyword1">true</span>"</span></span> <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">h'</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">h'</span><span class="main">⊨</span><span class="free">P</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> mod_star_trueE'<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> mod_h_bot_iff<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">h</span><span class="main">,</span><span class="main">{}</span><span class="main">)</span> <span class="main">⊨</span> <span class="main">↑</span><span class="free">b</span> <span class="main">⟷</span> <span class="free">b</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">h</span><span class="main">,</span><span class="main">{}</span><span class="main">)</span> <span class="main">⊨</span> <span class="keyword1">true</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">h</span><span class="main">,</span><span class="main">{}</span><span class="main">)</span> <span class="main">⊨</span> <span class="free">p</span><span class="keyword1">↦<span class="hidden">⇩</span><sub>r</sub></span><span class="free">x</span> <span class="main">⟷</span> False"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">h</span><span class="main">,</span><span class="main">{}</span><span class="main">)</span> <span class="main">⊨</span> <span class="free">q</span><span class="keyword1">↦<span class="hidden">⇩</span><sub>a</sub></span><span class="free">y</span> <span class="main">⟷</span> False"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">h</span><span class="main">,</span><span class="main">{}</span><span class="main">)</span> <span class="main">⊨</span> <span class="free">P</span><span class="main">*</span><span class="free">Q</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">(</span><span class="free">h</span><span class="main">,</span><span class="main">{}</span><span class="main">)</span> <span class="main">⊨</span> <span class="free">P</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">(</span><span class="free">h</span><span class="main">,</span><span class="main">{}</span><span class="main">)</span> <span class="main">⊨</span> <span class="free">Q</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">h</span><span class="main">,</span><span class="main">{}</span><span class="main">)</span> <span class="main">⊨</span> <span class="free">P</span><span class="keyword1">∧<span class="hidden">⇩</span><sub>A</sub></span><span class="free">Q</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">(</span><span class="free">h</span><span class="main">,</span><span class="main">{}</span><span class="main">)</span> <span class="main">⊨</span> <span class="free">P</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">(</span><span class="free">h</span><span class="main">,</span><span class="main">{}</span><span class="main">)</span> <span class="main">⊨</span> <span class="free">Q</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">h</span><span class="main">,</span><span class="main">{}</span><span class="main">)</span> <span class="main">⊨</span> <span class="free">P</span><span class="keyword1">∨<span class="hidden">⇩</span><sub>A</sub></span><span class="free">Q</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">(</span><span class="free">h</span><span class="main">,</span><span class="main">{}</span><span class="main">)</span> <span class="main">⊨</span> <span class="free">P</span><span class="main">)</span> <span class="main">∨</span> <span class="main">(</span><span class="main">(</span><span class="free">h</span><span class="main">,</span><span class="main">{}</span><span class="main">)</span> <span class="main">⊨</span> <span class="free">Q</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">h</span><span class="main">,</span><span class="main">{}</span><span class="main">)</span> <span class="main">⊨</span> <span class="main">(</span><span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">x</span><span class="main">.</span> <span class="free">R</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="free">h</span><span class="main">,</span><span class="main">{}</span><span class="main">)</span> <span class="main">⊨</span> <span class="free">R</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pure_assn_def Abs_assn_inverse<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sngr_assn_def Abs_assn_inverse<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> snga_assn_def Abs_assn_inverse<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> times_assn_def Abs_assn_inverse<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inf_assn_def Abs_assn_inverse<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sup_assn_def Abs_assn_inverse<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ex_assn_def Abs_assn_inverse<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Entailment›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">entails</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"assn <span class="main">⇒</span> assn <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span>"</span> 10<span class="main">)</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="keyword1"><span class="free">⟹<span class="hidden">⇩</span><sub>A</sub></span></span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">≡</span> <span class="main">∀</span><span class="bound">h</span><span class="main">.</span> <span class="bound">h</span><span class="main">⊨</span><span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">⟶</span> <span class="bound">h</span><span class="main">⊨</span><span class="free"><span class="bound"><span class="entity">Q</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> entailsI<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">h</span><span class="main">.</span> <span class="bound">h</span><span class="main">⊨</span><span class="free">P</span> <span class="main">⟹</span> <span class="bound">h</span><span class="main">⊨</span><span class="free">Q</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">Q</span>"</span></span> 
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> entails_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> entailsD<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">Q</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span><span class="main">⊨</span><span class="free">P</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span><span class="main">⊨</span><span class="free">Q</span>"</span></span> 
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> entails_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Properties›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> ent_fwd<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span><span class="main">⊨</span><span class="free">P</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">Q</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span><span class="main">⊨</span><span class="free">Q</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">,</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> entailsD<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ent_refl<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">P</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> entailsI<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ent_trans<span class="main">[</span><span class="operator">trans</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">P</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">Q</span><span class="main">;</span> <span class="free">Q</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span><span class="free">R</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">R</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> entailsI <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> entailsD<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ent_iffI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span><span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span><span class="free">B</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">B</span><span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span><span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span><span class="main">=</span><span class="free">B</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> Rep_assn_inject<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> entails_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> ent_false<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">false</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">P</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> entailsI<span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> ent_true<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="keyword1">true</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> entailsI <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> models_in_range<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ent_false_iff<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">P</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="keyword1">false</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">h</span><span class="main">.</span> <span class="main">¬</span><span class="bound">h</span><span class="main">⊨</span><span class="free">P</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> entails_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> ent_pure_pre_iff<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">P</span><span class="main">*</span><span class="main">↑</span><span class="free">b</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">Q</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">b</span> <span class="main">⟶</span> <span class="main">(</span><span class="free">P</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">Q</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> entails_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mod_dist<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ent_pure_pre_iff_sng<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">↑</span><span class="free">b</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">Q</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">b</span> <span class="main">⟶</span> <span class="main">(</span><span class="keyword1">emp</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">Q</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> ent_pure_pre_iff<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> P<span class="main"><span class="main">=</span></span><span class="quoted"><span class="keyword1">emp</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> ent_pure_post_iff<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">P</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">Q</span><span class="main">*</span><span class="main">↑</span><span class="free">b</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">(</span><span class="main">∀</span><span class="bound">h</span><span class="main">.</span> <span class="bound">h</span><span class="main">⊨</span><span class="free">P</span> <span class="main">⟶</span> <span class="free">b</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="free">P</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">Q</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> entails_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mod_dist<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ent_pure_post_iff_sng<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">P</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="main">↑</span><span class="free">b</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">(</span><span class="main">∀</span><span class="bound">h</span><span class="main">.</span> <span class="bound">h</span><span class="main">⊨</span><span class="free">P</span> <span class="main">⟶</span> <span class="free">b</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="free">P</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="keyword1">emp</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> ent_pure_post_iff<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> Q<span class="main"><span class="main">=</span></span><span class="quoted"><span class="keyword1">emp</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> ent_ex_preI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">Q</span><span class="main">)</span> <span class="main">⟹</span> <span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">Q</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> entails_def ex_assn_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Abs_assn_inverse<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ent_ex_postI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">P</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">Q</span> <span class="free">x</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">P</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">x</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">x</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> entails_def ex_assn_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Abs_assn_inverse<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ent_mp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">P</span> <span class="main">*</span> <span class="main">(</span><span class="free">P</span> <span class="main">-*</span> <span class="free">Q</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">Q</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> entailsI<span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> times_assn_def wand_assn_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_assn_inverse<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="improper">a</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="improper">as1</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Un_ac relH_refl<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> ent_star_mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">P</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">P'</span><span class="main">;</span> <span class="free">Q</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">Q'</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span><span class="main">*</span><span class="free">Q</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">P'</span><span class="main">*</span><span class="free">Q'</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> entails_def times_assn_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_assn_inverse<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">metis</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> ent_wandI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> IMP<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Q</span><span class="main">*</span><span class="free">P</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">R</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="main">(</span><span class="free">Q</span> <span class="main">-*</span> <span class="free">R</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> entails_def 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> wand_assnI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> models_in_range<span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">h</span> <span class="skolem">as</span> <span class="skolem">h'</span> <span class="skolem">as'</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">h</span><span class="main">,</span><span class="skolem">as</span><span class="main">)</span><span class="main">⊨</span><span class="free">P</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">as</span><span class="main">∩</span><span class="skolem">as'</span><span class="main">=</span><span class="main">{}</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"relH <span class="skolem">as</span> <span class="skolem">h</span> <span class="skolem">h'</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"in_range <span class="main">(</span><span class="skolem">h'</span><span class="main">,</span><span class="skolem">as</span><span class="main">)</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">h'</span><span class="main">,</span><span class="skolem">as'</span><span class="main">)</span> <span class="main">⊨</span> <span class="free">Q</span>"</span></span>

  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">h</span><span class="main">,</span><span class="skolem">as</span><span class="main">)</span><span class="main">⊨</span><span class="free">P</span>›</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">‹relH <span class="skolem">as</span> <span class="skolem">h</span> <span class="skolem">h'</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">h'</span><span class="main">,</span><span class="skolem">as</span><span class="main">)</span><span class="main">⊨</span><span class="free">P</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mod_relH<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">h'</span><span class="main">,</span><span class="skolem">as'</span><span class="main">)</span> <span class="main">⊨</span> <span class="free">Q</span>›</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">as</span><span class="main">∩</span><span class="skolem">as'</span><span class="main">=</span><span class="main">{}</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">h'</span><span class="main">,</span><span class="skolem">as</span><span class="main">∪</span><span class="skolem">as'</span><span class="main">)</span><span class="main">⊨</span><span class="free">Q</span><span class="main">*</span><span class="free">P</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> star_assnI Int_commute Un_commute<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> IMP <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">h'</span><span class="main">,</span><span class="skolem">as</span><span class="main">∪</span><span class="skolem">as'</span><span class="main">)</span> <span class="main">⊨</span> <span class="free">R</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> ent_fwd<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ent_disjI1<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="keyword1">∨<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">Q</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">R</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">R</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> entails_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> ent_disjI2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="keyword1">∨<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">Q</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">R</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">R</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> entails_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> ent_disjI1_direct<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">A</span> <span class="keyword1">∨<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">B</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> entails_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ent_disjI2_direct<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">A</span> <span class="keyword1">∨<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">B</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> entails_def<span class="main">)</span>
    
<span class="keyword1"><span class="command">lemma</span></span> ent_disjE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">A</span><span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span><span class="free">C</span><span class="main">;</span> <span class="free">B</span><span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span><span class="free">C</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">A</span><span class="keyword1">∨<span class="hidden">⇩</span><sub>A</sub></span><span class="free">B</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span><span class="free">C</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> entails_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> ent_conjI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">A</span><span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span><span class="free">B</span><span class="main">;</span> <span class="free">A</span><span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span><span class="free">C</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">A</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">B</span> <span class="keyword1">∧<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">C</span>"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> entails_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mod_and_dist<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ent_conjE1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">A</span><span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span><span class="free">C</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">A</span><span class="keyword1">∧<span class="hidden">⇩</span><sub>A</sub></span><span class="free">B</span><span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span><span class="free">C</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> entails_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mod_and_dist<span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> ent_conjE2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">B</span><span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span><span class="free">C</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">A</span><span class="keyword1">∧<span class="hidden">⇩</span><sub>A</sub></span><span class="free">B</span><span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span><span class="free">C</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> entails_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mod_and_dist<span class="main">)</span>



<span class="keyword1"><span class="command">lemma</span></span> star_or_dist1<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">A</span> <span class="keyword1">∨<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">B</span><span class="main">)</span><span class="main">*</span><span class="free">C</span> <span class="main">=</span> <span class="main">(</span><span class="free">A</span><span class="main">*</span><span class="free">C</span> <span class="keyword1">∨<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">B</span><span class="main">*</span><span class="free">C</span><span class="main">)</span>"</span></span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ent_iffI<span class="main">)</span> 
  <span class="keyword1"><span class="command">unfolding</span></span> entails_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mod_star_conv<span class="main">)</span> 
  
<span class="keyword1"><span class="command">lemma</span></span> star_or_dist2<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="free">C</span><span class="main">*</span><span class="main">(</span><span class="free">A</span> <span class="keyword1">∨<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">B</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">C</span><span class="main">*</span><span class="free">A</span> <span class="keyword1">∨<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">C</span><span class="main">*</span><span class="free">B</span><span class="main">)</span>"</span></span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ent_iffI<span class="main">)</span> 
  <span class="keyword1"><span class="command">unfolding</span></span> entails_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mod_star_conv<span class="main">)</span> 

<span class="keyword1"><span class="command">lemmas</span></span> star_or_dist <span class="main">=</span> star_or_dist1 star_or_dist2  
    
<span class="keyword1"><span class="command">lemma</span></span> ent_disjI1'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span><span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span><span class="free">B</span> <span class="main">⟹</span> <span class="free">A</span><span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span><span class="free">B</span><span class="keyword1">∨<span class="hidden">⇩</span><sub>A</sub></span><span class="free">C</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> entails_def star_or_dist<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ent_disjI2'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span><span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span><span class="free">C</span> <span class="main">⟹</span> <span class="free">A</span><span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span><span class="free">B</span><span class="keyword1">∨<span class="hidden">⇩</span><sub>A</sub></span><span class="free">C</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> entails_def star_or_dist<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> triv_exI<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="free">x</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">x</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> ent_ex_postI ent_refl<span class="main">)</span>
    
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Weak Entails›</span></span>    
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Weakening of entails to allow arbitrary unspecified memory in conclusion›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">entailst</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"assn <span class="main">⇒</span> assn <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">⟹<span class="hidden">⇩</span><sub>t</sub></span>"</span> 10<span class="main">)</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">entailst</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">*</span> <span class="keyword1">true</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> enttI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span><span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span><span class="free">B</span><span class="main">*</span><span class="keyword1">true</span> <span class="main">⟹</span> <span class="free">A</span><span class="keyword1">⟹<span class="hidden">⇩</span><sub>t</sub></span><span class="free">B</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> entailst_def <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lemma</span></span> enttD<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span><span class="keyword1">⟹<span class="hidden">⇩</span><sub>t</sub></span><span class="free">B</span> <span class="main">⟹</span> <span class="free">A</span><span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span><span class="free">B</span><span class="main">*</span><span class="keyword1">true</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> entailst_def <span class="keyword1"><span class="command">.</span></span>
    
<span class="keyword1"><span class="command">lemma</span></span> entt_trans<span class="main">:</span>
  <span class="quoted"><span class="quoted">"entailst <span class="free">A</span> <span class="free">B</span> <span class="main">⟹</span> entailst <span class="free">B</span> <span class="free">C</span> <span class="main">⟹</span> entailst <span class="free">A</span> <span class="free">C</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> entailst_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> ent_trans<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> assn_times_assoc ent_star_mono ent_true merge_true_star<span class="main">)</span>  

<span class="keyword1"><span class="command">lemma</span></span> entt_refl<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"entailst <span class="free">A</span> <span class="free">A</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> entailst_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> entailsI mod_star_trueI<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> entt_true<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"entailst <span class="free">A</span> <span class="keyword1">true</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> entailst_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> entt_emp<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"entailst <span class="free">A</span> <span class="keyword1">emp</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> entailst_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> entt_star_true_simp<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"entailst <span class="free">A</span> <span class="main">(</span><span class="free">B</span><span class="main">*</span><span class="keyword1">true</span><span class="main">)</span> <span class="main">⟷</span> entailst <span class="free">A</span> <span class="free">B</span>"</span></span>
  <span class="quoted"><span class="quoted">"entailst <span class="main">(</span><span class="free">A</span><span class="main">*</span><span class="keyword1">true</span><span class="main">)</span> <span class="free">B</span> <span class="main">⟷</span> entailst <span class="free">A</span> <span class="free">B</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> entailst_def 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> assn_times_assoc<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> iffI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> entails_def mod_star_trueI <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> assn_times_assoc ent_refl ent_star_mono merge_true_star<span class="main">)</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> entt_star_mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>entailst <span class="free">A</span> <span class="free">B</span><span class="main">;</span> entailst <span class="free">C</span> <span class="free">D</span><span class="main">⟧</span> <span class="main">⟹</span> entailst <span class="main">(</span><span class="free">A</span><span class="main">*</span><span class="free">C</span><span class="main">)</span> <span class="main">(</span><span class="free">B</span><span class="main">*</span><span class="free">D</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> entailst_def
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">assume</span></span> a1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">B</span> <span class="main">*</span> <span class="keyword1">true</span>"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">C</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">D</span> <span class="main">*</span> <span class="keyword1">true</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">*</span> <span class="free">C</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="keyword1">true</span> <span class="main">*</span> <span class="free">B</span> <span class="main">*</span> <span class="main">(</span><span class="keyword1">true</span> <span class="main">*</span> <span class="free">D</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> a1 assn_times_comm ent_star_mono <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">*</span> <span class="free">C</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">B</span> <span class="main">*</span> <span class="free">D</span> <span class="main">*</span> <span class="keyword1">true</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ab_semigroup_mult_class.mult.left_commute assn_times_comm<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>  
    
<span class="keyword1"><span class="command">lemma</span></span> entt_frame_fwd<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"entailst <span class="free">P</span> <span class="free">Q</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"entailst <span class="free">A</span> <span class="main">(</span><span class="free">P</span><span class="main">*</span><span class="free">F</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"entailst <span class="main">(</span><span class="free">Q</span><span class="main">*</span><span class="free">F</span><span class="main">)</span> <span class="free">B</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"entailst <span class="free">A</span> <span class="free">B</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> entt_refl entt_star_mono entt_trans<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> enttI_true<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span><span class="main">*</span><span class="keyword1">true</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">Q</span><span class="main">*</span><span class="keyword1">true</span> <span class="main">⟹</span> <span class="free">P</span><span class="keyword1">⟹<span class="hidden">⇩</span><sub>t</sub></span><span class="free">Q</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">drule</span> enttI<span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> entt_def_true<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">P</span><span class="keyword1">⟹<span class="hidden">⇩</span><sub>t</sub></span><span class="free">Q</span><span class="main">)</span> <span class="main">≡</span> <span class="main">(</span><span class="free">P</span><span class="main">*</span><span class="keyword1">true</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">Q</span><span class="main">*</span><span class="keyword1">true</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> entailst_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> eq_reflection<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> entailst_def entt_star_true_simp<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  

<span class="keyword1"><span class="command">lemma</span></span> ent_imp_entt<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span><span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span><span class="free">Q</span> <span class="main">⟹</span> <span class="free">P</span><span class="keyword1">⟹<span class="hidden">⇩</span><sub>t</sub></span><span class="free">Q</span>"</span></span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> enttI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> ent_trans<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> entailsI mod_star_trueI<span class="main">)</span>  

<span class="keyword1"><span class="command">lemma</span></span> entt_disjI1_direct<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>t</sub></span> <span class="free">A</span> <span class="keyword1">∨<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">B</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> ent_imp_entt<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ent_disjI1_direct<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> entt_disjI2_direct<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>t</sub></span> <span class="free">A</span> <span class="keyword1">∨<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">B</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> ent_imp_entt<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ent_disjI2_direct<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> entt_disjI1'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span><span class="keyword1">⟹<span class="hidden">⇩</span><sub>t</sub></span><span class="free">B</span> <span class="main">⟹</span> <span class="free">A</span><span class="keyword1">⟹<span class="hidden">⇩</span><sub>t</sub></span><span class="free">B</span><span class="keyword1">∨<span class="hidden">⇩</span><sub>A</sub></span><span class="free">C</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> entailst_def entails_def star_or_dist<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> entt_disjI2'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span><span class="keyword1">⟹<span class="hidden">⇩</span><sub>t</sub></span><span class="free">C</span> <span class="main">⟹</span> <span class="free">A</span><span class="keyword1">⟹<span class="hidden">⇩</span><sub>t</sub></span><span class="free">B</span><span class="keyword1">∨<span class="hidden">⇩</span><sub>A</sub></span><span class="free">C</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> entailst_def entails_def star_or_dist<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> entt_disjE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">A</span><span class="keyword1">⟹<span class="hidden">⇩</span><sub>t</sub></span><span class="free">M</span><span class="main">;</span> <span class="free">B</span><span class="keyword1">⟹<span class="hidden">⇩</span><sub>t</sub></span><span class="free">M</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">A</span><span class="keyword1">∨<span class="hidden">⇩</span><sub>A</sub></span><span class="free">B</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>t</sub></span> <span class="free">M</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> ent_disjE enttD enttI <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>  
    
<span class="keyword1"><span class="command">lemma</span></span> entt_disjD1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span><span class="keyword1">∨<span class="hidden">⇩</span><sub>A</sub></span><span class="free">B</span><span class="keyword1">⟹<span class="hidden">⇩</span><sub>t</sub></span><span class="free">C</span> <span class="main">⟹</span> <span class="free">A</span><span class="keyword1">⟹<span class="hidden">⇩</span><sub>t</sub></span><span class="free">C</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> entt_disjI1_direct entt_trans <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> entt_disjD2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span><span class="keyword1">∨<span class="hidden">⇩</span><sub>A</sub></span><span class="free">B</span><span class="keyword1">⟹<span class="hidden">⇩</span><sub>t</sub></span><span class="free">C</span> <span class="main">⟹</span> <span class="free">B</span><span class="keyword1">⟹<span class="hidden">⇩</span><sub>t</sub></span><span class="free">C</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> entt_disjI2_direct entt_trans <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    
    
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Precision›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Precision rules describe that parts of an assertion may depend only on the
  underlying heap. For example, the data where a pointer points to is the same
  for the same heap.
›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Precision rules should have the form: 
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">text</span></span> [display] <span class="raw_text"><span class="raw_text">"∀x y. (h⊨(P x * F1) ∧<span class="hidden">⇩</span><sub>A</sub> (P y * F2)) ⟶ x=y"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">precise</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">≡</span> <span class="main">∀</span><span class="bound">a</span> <span class="bound">a'</span> <span class="bound">h</span> <span class="bound">p</span> <span class="bound">F</span> <span class="bound">F'</span><span class="main">.</span> 
  <span class="bound">h</span> <span class="main">⊨</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="bound">a</span> <span class="bound">p</span> <span class="main">*</span> <span class="bound">F</span> <span class="keyword1">∧<span class="hidden">⇩</span><sub>A</sub></span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="bound">a'</span> <span class="bound">p</span> <span class="main">*</span> <span class="bound">F'</span> <span class="main">⟶</span> <span class="bound">a</span> <span class="main">=</span> <span class="bound">a'</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> preciseI<span class="main">[</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">?</span></span></span></span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">a</span> <span class="bound">a'</span> <span class="bound">h</span> <span class="bound">p</span> <span class="bound">F</span> <span class="bound">F'</span><span class="main">.</span> <span class="bound">h</span> <span class="main">⊨</span> <span class="free">R</span> <span class="bound">a</span> <span class="bound">p</span> <span class="main">*</span> <span class="bound">F</span> <span class="keyword1">∧<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">R</span> <span class="bound">a'</span> <span class="bound">p</span> <span class="main">*</span> <span class="bound">F'</span> <span class="main">⟹</span> <span class="bound">a</span> <span class="main">=</span> <span class="bound">a'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"precise <span class="free">R</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> precise_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> preciseD<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"precise <span class="free">R</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">⊨</span> <span class="free">R</span> <span class="free">a</span> <span class="free">p</span> <span class="main">*</span> <span class="free">F</span> <span class="keyword1">∧<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">R</span> <span class="free">a'</span> <span class="free">p</span> <span class="main">*</span> <span class="free">F'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span><span class="main">=</span><span class="free">a'</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> precise_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> preciseD'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"precise <span class="free">R</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">⊨</span> <span class="free">R</span> <span class="free">a</span> <span class="free">p</span> <span class="main">*</span> <span class="free">F</span>"</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">⊨</span> <span class="free">R</span> <span class="free">a'</span> <span class="free">p</span> <span class="main">*</span> <span class="free">F'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span><span class="main">=</span><span class="free">a'</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> preciseD<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> assms<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> mod_and_dist<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> assms<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> precise_extr_pure<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"precise <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="main">↑</span><span class="free">P</span> <span class="main">*</span> <span class="free">R</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">P</span> <span class="main">⟶</span> precise <span class="free">R</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"precise <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">R</span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">*</span> <span class="main">↑</span><span class="free">P</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">P</span> <span class="main">⟶</span> precise <span class="free">R</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">P</span></span><span class="main"><span class="keyword3">,</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> preciseI<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>2<span class="main"><span class="keyword3">]</span></span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> sngr_prec<span class="main">:</span> <span class="quoted"><span class="quoted">"precise <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">p</span><span class="main">.</span> <span class="bound">p</span><span class="keyword1">↦<span class="hidden">⇩</span><sub>r</sub></span><span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mod_and_dist<span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> sngr_assn_def times_assn_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_assn_inverse<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> snga_prec<span class="main">:</span> <span class="quoted"><span class="quoted">"precise <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">p</span><span class="main">.</span> <span class="bound">p</span><span class="keyword1">↦<span class="hidden">⇩</span><sub>a</sub></span><span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mod_and_dist<span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> snga_assn_def times_assn_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_assn_inverse<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Hoare_Triple">
<div class="head">
<h1>Theory Hoare_Triple</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Hoare-Triples›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Hoare_Triple
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Run.html">Run</a> <a href="Assertions.html">Assertions</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In this theory, we define Hoare-Triples, which are our basic tool
  for specifying properties of Imperative HOL programs.›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Definition›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Analyze the heap before and after executing a command, to add
  the allocated addresses to the covered address range.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">new_addrs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"heap <span class="main">⇒</span> addr set <span class="main">⇒</span> heap <span class="main">⇒</span> addr set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">new_addrs</span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="free"><span class="bound"><span class="entity">as</span></span></span> <span class="free"><span class="bound"><span class="entity">h'</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">as</span></span></span> <span class="main">∪</span> <span class="main">{</span><span class="bound">a</span><span class="main">.</span> lim <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="main">≤</span> <span class="bound">a</span> <span class="main">∧</span> <span class="bound">a</span> <span class="main">&lt;</span> lim <span class="free"><span class="bound"><span class="entity">h'</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> new_addr_refl<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"new_addrs <span class="free">h</span> <span class="free">as</span> <span class="free">h</span> <span class="main">=</span> <span class="free">as</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> new_addrs_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Apart from correctness of the program wrt. the pre- and post condition,
  a Hoare-triple also encodes some well-formedness conditions of the command:
  The command must not change addresses outside the address range of the 
  precondition, and it must not decrease the heap limit. 

  Note that we do not require that the command only reads from heap locations
  inside the precondition's address range, as this condition would be quite
  complicated to express with the heap model of Imperative/HOL, and is not 
  necessary in our formalization of partial heaps, that always contain the 
  information for all addresses.
›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">hoare_triple</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"assn <span class="main">⇒</span> <span class="tfree">'a</span> Heap <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> assn<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">&lt;</span>_<span class="keyword1">&gt;</span><span class="keyword3">/ </span>_<span class="keyword3">/ </span><span class="keyword1">&lt;</span>_<span class="keyword1">&gt;</span>"</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main"><span class="free">&lt;</span></span><span class="free"><span class="bound"><span class="entity">P</span></span></span><span class="main"><span class="free">&gt;</span></span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main"><span class="free">&lt;</span></span><span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main"><span class="free">&gt;</span></span> <span class="main">≡</span> <span class="main">∀</span><span class="bound">h</span> <span class="bound">as</span> <span class="bound">σ</span> <span class="bound">r</span><span class="main">.</span> <span class="main">(</span><span class="bound">h</span><span class="main">,</span><span class="bound">as</span><span class="main">)</span><span class="main">⊨</span><span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">∧</span> run <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">(</span>Some <span class="bound">h</span><span class="main">)</span> <span class="bound">σ</span> <span class="bound">r</span> 
  <span class="main">⟶</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">h'</span><span class="main">=</span>the_state <span class="bound">σ</span><span class="main">;</span> <span class="bound">as'</span><span class="main">=</span>new_addrs <span class="bound">h</span> <span class="bound">as</span> <span class="bound">h'</span> <span class="keyword1">in</span>  
    <span class="main">¬</span>is_exn <span class="bound">σ</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">h'</span><span class="main">,</span><span class="bound">as'</span><span class="main">)</span><span class="main">⊨</span><span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="bound">r</span> <span class="main">∧</span> relH <span class="main">(</span><span class="main">{</span><span class="bound">a</span> <span class="main">.</span> <span class="bound">a</span><span class="main">&lt;</span>lim <span class="bound">h</span> <span class="main">∧</span> <span class="bound">a</span><span class="main">∉</span><span class="bound">as</span><span class="main">}</span><span class="main">)</span> <span class="bound">h</span> <span class="bound">h'</span> 
    <span class="main">∧</span> lim <span class="bound">h</span> <span class="main">≤</span> lim <span class="bound">h'</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Sanity checking theorems for Hoare-Triples›</span></span>  
<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">P</span><span class="main">&gt;</span> <span class="free">c</span> <span class="main">&lt;</span><span class="free">Q</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">h</span><span class="main">,</span><span class="free">as</span><span class="main">)</span><span class="main">⊨</span><span class="free">P</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> hoare_triple_success<span class="main">:</span> <span class="quoted"><span class="quoted">"success <span class="free">c</span> <span class="free">h</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> hoare_triple_effect<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">h'</span> <span class="bound">r</span><span class="main">.</span> effect <span class="free">c</span> <span class="free">h</span> <span class="bound">h'</span> <span class="bound">r</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">h'</span><span class="main">,</span>new_addrs <span class="free">h</span> <span class="free">as</span> <span class="bound">h'</span><span class="main">)</span><span class="main">⊨</span><span class="free">Q</span> <span class="bound">r</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms 
  <span class="keyword1"><span class="command">unfolding</span></span> hoare_triple_def success_def effect_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def run.simps<span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> is_exn.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> not_Some_eq2 the_state.simps<span class="main">)</span>

    
<span class="keyword1"><span class="command">lemma</span></span> hoare_tripleD<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">h</span> <span class="free">h'</span> <span class="free">as</span> <span class="free">as'</span> <span class="free">σ</span> <span class="free">r</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">P</span><span class="main">&gt;</span> <span class="free">c</span> <span class="main">&lt;</span><span class="free">Q</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">h</span><span class="main">,</span><span class="free">as</span><span class="main">)</span><span class="main">⊨</span><span class="free">P</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"run <span class="free">c</span> <span class="main">(</span>Some <span class="free">h</span><span class="main">)</span> <span class="free">σ</span> <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">h'</span><span class="main">≡</span>the_state <span class="free">σ</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">as'</span><span class="main">≡</span>new_addrs <span class="free">h</span> <span class="free">as</span> <span class="free">h'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>is_exn <span class="free">σ</span>"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">h'</span><span class="main">,</span><span class="free">as'</span><span class="main">)</span><span class="main">⊨</span><span class="free">Q</span> <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"relH <span class="main">(</span><span class="main">{</span><span class="bound">a</span> <span class="main">.</span> <span class="bound">a</span><span class="main">&lt;</span>lim <span class="free">h</span> <span class="main">∧</span> <span class="bound">a</span><span class="main">∉</span><span class="free">as</span><span class="main">}</span><span class="main">)</span> <span class="free">h</span> <span class="free">h'</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"lim <span class="free">h</span> <span class="main">≤</span> lim <span class="free">h'</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms 
  <span class="keyword1"><span class="command">unfolding</span></span> hoare_triple_def h'_def as'_def 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹For garbage-collected languages, specifications usually allow for some
  arbitrary heap parts in the postcondition. The following abbreviation defines
  a handy shortcut notation for such specifications.›</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">hoare_triple'</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"assn <span class="main">⇒</span> <span class="tfree">'r</span> Heap <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'r</span> <span class="main">⇒</span> assn<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">&lt;</span>_<span class="keyword1">&gt;</span> _ <span class="keyword1">&lt;</span>_<span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span><span class="main">)</span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="free">&lt;</span></span><span class="free"><span class="bound"><span class="entity">P</span></span></span><span class="main"><span class="free">&gt;</span></span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main"><span class="free">&lt;</span></span><span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="keyword1"><span class="free">&gt;<span class="hidden">⇩</span><sub>t</sub></span></span> <span class="main">≡</span> <span class="main">&lt;</span><span class="free"><span class="bound"><span class="entity">P</span></span></span><span class="main">&gt;</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="bound">r</span> <span class="main">*</span> <span class="keyword1">true</span><span class="main">&gt;</span>"</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Rules›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  In this section, we provide a set of rules to prove Hoare-Triples correct.
›</span></span>
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Basic Rules›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> hoare_triple_preI<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">h</span><span class="main">.</span> <span class="bound">h</span><span class="main">⊨</span><span class="free">P</span> <span class="main">⟹</span> <span class="main">&lt;</span><span class="free">P</span><span class="main">&gt;</span> <span class="free">c</span> <span class="main">&lt;</span><span class="free">Q</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">P</span><span class="main">&gt;</span> <span class="free">c</span> <span class="main">&lt;</span><span class="free">Q</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">unfolding</span></span> hoare_triple_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>


<span class="keyword1"><span class="command">lemma</span></span> frame_rule<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">P</span><span class="main">&gt;</span> <span class="free">c</span> <span class="main">&lt;</span><span class="free">Q</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">P</span><span class="main">*</span><span class="free">R</span><span class="main">&gt;</span> <span class="free">c</span> <span class="main">&lt;</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">x</span> <span class="main">*</span> <span class="free">R</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> hoare_triple_def Let_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> allI impI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> conjE<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> conjI<span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">h</span> <span class="skolem">as</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">h</span><span class="main">,</span><span class="skolem">as</span><span class="main">)</span> <span class="main">⊨</span> <span class="free">P</span> <span class="main">*</span> <span class="free">R</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">as1</span></span> <span class="skolem"><span class="skolem">as2</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">as</span><span class="main">=</span><span class="skolem">as1</span><span class="main">∪</span><span class="skolem">as2</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> DJ<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">as1</span><span class="main">∩</span><span class="skolem">as2</span><span class="main">=</span><span class="main">{}</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> M1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">h</span><span class="main">,</span><span class="skolem">as1</span><span class="main">)</span><span class="main">⊨</span><span class="free">P</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> M2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">h</span><span class="main">,</span><span class="skolem">as2</span><span class="main">)</span><span class="main">⊨</span><span class="free">R</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> times_assn_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Abs_assn_inverse<span class="main">)</span>

  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">σ</span> <span class="skolem">r</span>
  <span class="keyword3"><span class="command">assume</span></span> RUN<span class="main">:</span> <span class="quoted"><span class="quoted">"run <span class="free">c</span> <span class="main">(</span>Some <span class="skolem">h</span><span class="main">)</span> <span class="skolem">σ</span> <span class="skolem">r</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> hoare_tripleD<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> A M1 RUN<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> is_exn <span class="skolem">σ</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">from</span></span> hoare_tripleD<span class="main">(</span>4<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> A M1 RUN<span class="main">]</span> 
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"lim <span class="skolem">h</span> <span class="main">≤</span> lim <span class="main">(</span>the_state <span class="skolem">σ</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1"><span class="command">from</span></span> hoare_tripleD<span class="main">(</span>3<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> A M1 RUN<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> 
    RH1<span class="main">:</span> <span class="quoted"><span class="quoted">"relH <span class="main">{</span><span class="bound">a</span><span class="main">.</span> <span class="bound">a</span> <span class="main">&lt;</span> lim <span class="skolem">h</span> <span class="main">∧</span> <span class="bound">a</span> <span class="main">∉</span> <span class="skolem">as1</span><span class="main">}</span> <span class="skolem">h</span> <span class="main">(</span>the_state <span class="skolem">σ</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">a</span><span class="main">.</span> <span class="bound">a</span> <span class="main">&lt;</span> lim <span class="skolem">h</span> <span class="main">∧</span> <span class="bound">a</span> <span class="main">∉</span> <span class="skolem">as</span><span class="main">}</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">a</span><span class="main">.</span> <span class="bound">a</span> <span class="main">&lt;</span> lim <span class="skolem">h</span> <span class="main">∧</span> <span class="bound">a</span> <span class="main">∉</span> <span class="skolem">as1</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"relH <span class="main">{</span><span class="bound">a</span><span class="main">.</span> <span class="bound">a</span> <span class="main">&lt;</span> lim <span class="skolem">h</span> <span class="main">∧</span> <span class="bound">a</span> <span class="main">∉</span> <span class="skolem">as</span><span class="main">}</span> <span class="skolem">h</span> <span class="main">(</span>the_state <span class="skolem">σ</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> relH_subset<span class="main">)</span>
    
  <span class="keyword1"><span class="command">from</span></span> hoare_tripleD<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> A M1 RUN<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span>the_state <span class="skolem">σ</span><span class="main">,</span> new_addrs <span class="skolem">h</span> <span class="skolem">as1</span> <span class="main">(</span>the_state <span class="skolem">σ</span><span class="main">)</span><span class="main">)</span> <span class="main">⊨</span> <span class="free">Q</span> <span class="skolem">r</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> DJN<span class="main">:</span> <span class="quoted"><span class="quoted">"new_addrs <span class="skolem">h</span> <span class="skolem">as1</span> <span class="main">(</span>the_state <span class="skolem">σ</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">as2</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> DJ models_in_range<span class="main">[</span><span class="operator">OF</span> M2<span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_range.simps new_addrs_def<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">as2</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">a</span><span class="main">.</span> <span class="bound">a</span> <span class="main">&lt;</span> lim <span class="skolem">h</span> <span class="main">∧</span> <span class="bound">a</span> <span class="main">∉</span> <span class="skolem">as1</span><span class="main">}</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> DJ models_in_range<span class="main">[</span><span class="operator">OF</span> M2<span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_range.simps<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"relH <span class="skolem">as2</span> <span class="skolem">h</span> <span class="main">(</span>the_state <span class="skolem">σ</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> RH1
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> relH_subset<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> M2 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>the_state <span class="skolem">σ</span><span class="main">,</span> <span class="skolem">as2</span><span class="main">)</span><span class="main">⊨</span><span class="free">R</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> mem_Collect_eq Rep_assn  
      proper_iff relH_in_rangeI<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"new_addrs <span class="skolem">h</span> <span class="skolem">as</span> <span class="main">(</span>the_state <span class="skolem">σ</span><span class="main">)</span> 
    <span class="main">=</span> new_addrs <span class="skolem">h</span> <span class="skolem">as1</span> <span class="main">(</span>the_state <span class="skolem">σ</span><span class="main">)</span> <span class="main">∪</span> <span class="skolem">as2</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> new_addrs_def<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span>the_state <span class="skolem">σ</span><span class="main">,</span> new_addrs <span class="skolem">h</span> <span class="skolem">as</span> <span class="main">(</span>the_state <span class="skolem">σ</span><span class="main">)</span><span class="main">)</span> <span class="main">⊨</span> <span class="free">Q</span> <span class="skolem">r</span> <span class="main">*</span> <span class="free">R</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> times_assn_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_assn_inverse<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">lemma</span></span> false_rule<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="keyword1">false</span><span class="main">&gt;</span> <span class="free">c</span> <span class="main">&lt;</span><span class="free">Q</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> hoare_triple_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

  
<span class="keyword1"><span class="command">lemma</span></span> cons_rule<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> CPRE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">P'</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> CPOST<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">x</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">Q'</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> R<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">P'</span><span class="main">&gt;</span> <span class="free">c</span> <span class="main">&lt;</span><span class="free">Q</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">P</span><span class="main">&gt;</span> <span class="free">c</span> <span class="main">&lt;</span><span class="free">Q'</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> hoare_triple_def Let_def
  <span class="keyword1"><span class="command">using</span></span> hoare_tripleD<span class="main">[</span><span class="operator">OF</span> R entailsD<span class="main"><span class="main"><span class="main"><span class="main"><span class="main">[</span></span></span></span></span><span class="operator"><span class="operator"><span class="operator"><span class="operator">OF</span></span></span></span> CPRE<span class="main"><span class="main"><span class="main"><span class="main"><span class="main">]</span></span></span></span></span><span class="main">]</span> entailsD<span class="main">[</span><span class="operator">OF</span> CPOST<span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemmas</span></span> cons_pre_rule <span class="main">=</span> cons_rule<span class="main">[</span><span class="operator">OF</span> _ ent_refl<span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> cons_post_rule <span class="main">=</span> cons_rule<span class="main">[</span><span class="operator">OF</span> ent_refl<span class="main">,</span> <span class="operator">rotated</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> cons_rulet<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">P</span><span class="keyword1">⟹<span class="hidden">⇩</span><sub>t</sub></span><span class="free">P'</span><span class="main">;</span> <span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">x</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>t</sub></span> <span class="free">Q'</span> <span class="bound">x</span><span class="main">;</span> <span class="main">&lt;</span><span class="free">P'</span><span class="main">&gt;</span> <span class="free">c</span> <span class="main">&lt;</span><span class="free">Q</span><span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="main">&lt;</span><span class="free">P</span><span class="main">&gt;</span> <span class="free">c</span> <span class="main">&lt;</span><span class="free">Q'</span><span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> entailst_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cons_pre_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cons_post_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> frame_rule<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> enttD enttI<span class="main">)</span>  

<span class="keyword1"><span class="command">lemmas</span></span> cons_pre_rulet <span class="main">=</span> cons_rulet<span class="main">[</span><span class="operator">OF</span> _ entt_refl<span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> cons_post_rulet <span class="main">=</span> cons_rulet<span class="main">[</span><span class="operator">OF</span> entt_refl<span class="main">,</span> <span class="operator">rotated</span><span class="main">]</span>

  
  
<span class="keyword1"><span class="command">lemma</span></span> norm_pre_ex_rule<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="main">&lt;</span><span class="free">P</span> <span class="bound">x</span><span class="main">&gt;</span> <span class="free">f</span> <span class="main">&lt;</span><span class="free">Q</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">&gt;</span> <span class="free">f</span> <span class="main">&lt;</span><span class="free">Q</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> hoare_triple_def Let_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> allI impI<span class="main"><span class="keyword3">,</span></span> <span class="operator">elim</span> conjE mod_exE<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> hoare_tripleD<span class="main">[</span><span class="operator">OF</span> A<span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> norm_pre_pure_iff<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">P</span><span class="main">*</span><span class="main">↑</span><span class="free">b</span><span class="main">&gt;</span> <span class="free">f</span> <span class="main">&lt;</span><span class="free">Q</span><span class="main">&gt;</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">b</span> <span class="main">⟶</span> <span class="main">&lt;</span><span class="free">P</span><span class="main">&gt;</span> <span class="free">f</span> <span class="main">&lt;</span><span class="free">Q</span><span class="main">&gt;</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> hoare_triple_def Let_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> norm_pre_pure_iff_sng<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="main">↑</span><span class="free">b</span><span class="main">&gt;</span> <span class="free">f</span> <span class="main">&lt;</span><span class="free">Q</span><span class="main">&gt;</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">b</span> <span class="main">⟶</span> <span class="main">&lt;</span><span class="keyword1">emp</span><span class="main">&gt;</span> <span class="free">f</span> <span class="main">&lt;</span><span class="free">Q</span><span class="main">&gt;</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> norm_pre_pure_iff<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> P<span class="main"><span class="main">=</span></span><span class="quoted"><span class="keyword1">emp</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> norm_pre_pure_rule1<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">b</span> <span class="main">⟹</span> <span class="main">&lt;</span><span class="free">P</span><span class="main">&gt;</span> <span class="free">f</span> <span class="main">&lt;</span><span class="free">Q</span><span class="main">&gt;</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="main">&lt;</span><span class="free">P</span><span class="main">*</span><span class="main">↑</span><span class="free">b</span><span class="main">&gt;</span> <span class="free">f</span> <span class="main">&lt;</span><span class="free">Q</span><span class="main">&gt;</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> norm_pre_pure_rule2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">b</span> <span class="main">⟹</span> <span class="main">&lt;</span><span class="keyword1">emp</span><span class="main">&gt;</span> <span class="free">f</span> <span class="main">&lt;</span><span class="free">Q</span><span class="main">&gt;</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="main">&lt;</span><span class="main">↑</span><span class="free">b</span><span class="main">&gt;</span> <span class="free">f</span> <span class="main">&lt;</span><span class="free">Q</span><span class="main">&gt;</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemmas</span></span> norm_pre_pure_rule <span class="main">=</span> norm_pre_pure_rule1 norm_pre_pure_rule2

<span class="keyword1"><span class="command">lemma</span></span> post_exI_rule<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">P</span><span class="main">&gt;</span> <span class="free">c</span> <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">r</span> <span class="free">x</span><span class="main">&gt;</span> <span class="main">⟹</span> <span class="main">&lt;</span><span class="free">P</span><span class="main">&gt;</span> <span class="free">c</span> <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">x</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">r</span> <span class="bound">x</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> cons_post_rule ent_ex_postI ent_refl<span class="main">)</span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Rules for Atomic Commands›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> ref_rule<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="keyword1">emp</span><span class="main">&gt;</span> ref <span class="free">x</span> <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="bound">r</span> <span class="keyword1">↦<span class="hidden">⇩</span><sub>r</sub></span> <span class="free">x</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> one_assn_def sngr_assn_def hoare_triple_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def Abs_assn_inverse<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> allI impI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> conjE <span class="dynamic"><span class="dynamic">run_elims</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
    <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> new_addrs_def Ref.alloc_def Let_def
    Ref.set_def Ref.get_def relH_def in_range.simps<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> lookup_rule<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">p</span> <span class="keyword1">↦<span class="hidden">⇩</span><sub>r</sub></span> <span class="free">x</span><span class="main">&gt;</span> <span class="main">!</span><span class="free">p</span> <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="free">p</span> <span class="keyword1">↦<span class="hidden">⇩</span><sub>r</sub></span> <span class="free">x</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="bound">r</span> <span class="main">=</span> <span class="free">x</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> hoare_triple_def sngr_assn_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def Abs_assn_inverse<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">run_elims</span></span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> relH_refl in_range.simps new_addrs_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> update_rule<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">p</span> <span class="keyword1">↦<span class="hidden">⇩</span><sub>r</sub></span> <span class="free">y</span><span class="main">&gt;</span> <span class="free">p</span> <span class="main">:=</span> <span class="free">x</span> <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="free">p</span> <span class="keyword1">↦<span class="hidden">⇩</span><sub>r</sub></span> <span class="free">x</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> hoare_triple_def sngr_assn_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> run_update 
    <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def Abs_assn_inverse new_addrs_def in_range.simps 
    <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> relH_set_ref<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> update_wp_rule<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">r</span> <span class="keyword1">↦<span class="hidden">⇩</span><sub>r</sub></span> <span class="free">y</span> <span class="main">*</span> <span class="main">(</span><span class="main">(</span><span class="free">r</span> <span class="keyword1">↦<span class="hidden">⇩</span><sub>r</sub></span> <span class="free">x</span><span class="main">)</span> <span class="main">-*</span> <span class="main">(</span><span class="free">Q</span> <span class="main">()</span><span class="main">)</span><span class="main">)</span><span class="main">&gt;</span> <span class="free">r</span> <span class="main">:=</span> <span class="free">x</span> <span class="main">&lt;</span><span class="free">Q</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cons_post_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> frame_rule<span class="main"><span class="main">[</span></span><span class="operator">OF</span> update_rule<span class="main"><span class="main"><span class="main">[</span></span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> p<span class="main"><span class="main"><span class="main"><span class="main">=</span></span></span></span><span class="quoted"><span class="free">r</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span></span> x<span class="main"><span class="main"><span class="main"><span class="main">=</span></span></span></span><span class="quoted"><span class="free">x</span></span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">,</span></span> 
    <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">r</span> <span class="keyword1">↦<span class="hidden">⇩</span><sub>r</sub></span> <span class="free">x</span><span class="main">)</span> <span class="main">-*</span> <span class="main">(</span><span class="free">Q</span> <span class="main">()</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ent_trans<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ent_mp<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> new_rule<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="keyword1">emp</span><span class="main">&gt;</span> Array.new <span class="free">n</span> <span class="free">x</span> <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="bound">r</span> <span class="keyword1">↦<span class="hidden">⇩</span><sub>a</sub></span> replicate <span class="free">n</span> <span class="free">x</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> hoare_triple_def snga_assn_def one_assn_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def Abs_assn_inverse<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
    <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">run_elims</span></span>
    <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def new_addrs_def Array.get_def Array.set_def Array.alloc_def
      relH_def in_range.simps
  <span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> make_rule<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="keyword1">emp</span><span class="main">&gt;</span> Array.make <span class="free">n</span> <span class="free">f</span> <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="bound">r</span> <span class="keyword1">↦<span class="hidden">⇩</span><sub>a</sub></span> <span class="main">(</span>map <span class="free">f</span> <span class="main">[</span><span class="main">0</span> <span class="main">..&lt;</span> <span class="free">n</span><span class="main">]</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> hoare_triple_def snga_assn_def one_assn_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def Abs_assn_inverse<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
    <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">run_elims</span></span>
    <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def new_addrs_def Array.get_def Array.set_def Array.alloc_def
      relH_def in_range.simps
  <span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    
<span class="keyword1"><span class="command">lemma</span></span> of_list_rule<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="keyword1">emp</span><span class="main">&gt;</span> Array.of_list <span class="free">xs</span> <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="bound">r</span> <span class="keyword1">↦<span class="hidden">⇩</span><sub>a</sub></span> <span class="free">xs</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> hoare_triple_def snga_assn_def one_assn_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def Abs_assn_inverse<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
    <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">run_elims</span></span>
    <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def new_addrs_def Array.get_def Array.set_def Array.alloc_def
      relH_def in_range.simps
  <span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> length_rule<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">a</span> <span class="keyword1">↦<span class="hidden">⇩</span><sub>a</sub></span> <span class="free">xs</span><span class="main">&gt;</span> Array.len <span class="free">a</span> <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="free">a</span> <span class="keyword1">↦<span class="hidden">⇩</span><sub>a</sub></span> <span class="free">xs</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="bound">r</span> <span class="main">=</span> length <span class="free">xs</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> hoare_triple_def snga_assn_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def Abs_assn_inverse<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
    <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">run_elims</span></span>
    <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def new_addrs_def Array.get_def Array.set_def Array.alloc_def
      relH_def in_range.simps Array.length_def
  <span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Note that the Boolean expression is placed at meta level and not 
  inside the precondition. This makes frame inference simpler.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> nth_rule<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">i</span> <span class="main">&lt;</span> length <span class="free">xs</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="main">&lt;</span><span class="free">a</span> <span class="keyword1">↦<span class="hidden">⇩</span><sub>a</sub></span> <span class="free">xs</span><span class="main">&gt;</span> Array.nth <span class="free">a</span> <span class="free">i</span> <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="free">a</span> <span class="keyword1">↦<span class="hidden">⇩</span><sub>a</sub></span> <span class="free">xs</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="bound">r</span> <span class="main">=</span> <span class="free">xs</span> <span class="main">!</span> <span class="free">i</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> hoare_triple_def snga_assn_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def Abs_assn_inverse<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
    <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">run_elims</span></span>
    <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def new_addrs_def Array.get_def Array.set_def Array.alloc_def
      relH_def in_range.simps Array.length_def
  <span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> upd_rule<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">i</span> <span class="main">&lt;</span> length <span class="free">xs</span><span class="main">⟧</span> <span class="main">⟹</span> 
  <span class="main">&lt;</span><span class="free">a</span> <span class="keyword1">↦<span class="hidden">⇩</span><sub>a</sub></span> <span class="free">xs</span><span class="main">&gt;</span> 
  Array.upd <span class="free">i</span> <span class="free">x</span> <span class="free">a</span> 
  <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="main">(</span><span class="free">a</span> <span class="keyword1">↦<span class="hidden">⇩</span><sub>a</sub></span> <span class="main">(</span>list_update <span class="free">xs</span> <span class="free">i</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="bound">r</span> <span class="main">=</span> <span class="free">a</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> hoare_triple_def snga_assn_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def Abs_assn_inverse<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
    <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">run_elims</span></span>
    <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def new_addrs_def Array.get_def Array.set_def Array.alloc_def
      relH_def in_range.simps Array.length_def Array.update_def comp_def
  <span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> freeze_rule<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">a</span> <span class="keyword1">↦<span class="hidden">⇩</span><sub>a</sub></span> <span class="free">xs</span><span class="main">&gt;</span> Array.freeze <span class="free">a</span> <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="free">a</span> <span class="keyword1">↦<span class="hidden">⇩</span><sub>a</sub></span> <span class="free">xs</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="bound">r</span> <span class="main">=</span> <span class="free">xs</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> hoare_triple_def snga_assn_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def Abs_assn_inverse<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
    <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">run_elims</span></span>
    <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def new_addrs_def Array.get_def Array.set_def Array.alloc_def
      relH_def in_range.simps Array.length_def Array.update_def
  <span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  
<span class="keyword1"><span class="command">lemma</span></span> return_wp_rule<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">Q</span> <span class="free">x</span><span class="main">&gt;</span> return <span class="free">x</span> <span class="main">&lt;</span><span class="free">Q</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> hoare_triple_def Let_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">run_elims</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> relH_refl<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> in_range.simps<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> return_sp_rule<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">P</span><span class="main">&gt;</span> return <span class="free">x</span> <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="free">P</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="bound">r</span> <span class="main">=</span> <span class="free">x</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> hoare_triple_def Let_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_assn_inverse<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">run_elims</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> relH_refl <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> models_in_range<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> in_range.simps<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> raise_iff<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">P</span><span class="main">&gt;</span> raise <span class="free">s</span> <span class="main">&lt;</span><span class="free">Q</span><span class="main">&gt;</span> <span class="main">⟷</span> <span class="free">P</span> <span class="main">=</span> <span class="keyword1">false</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> hoare_triple_def Let_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> iffI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> bot_assn_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> run_raise_iff<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> run_raise_iff<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> raise_rule<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="keyword1">false</span><span class="main">&gt;</span> raise <span class="free">s</span> <span class="main">&lt;</span><span class="free">Q</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> raise_iff<span class="main">)</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Rules for Composed Commands›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> bind_rule<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> T1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">P</span><span class="main">&gt;</span> <span class="free">f</span> <span class="main">&lt;</span><span class="free">R</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> T2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="main">&lt;</span><span class="free">R</span> <span class="bound">x</span><span class="main">&gt;</span> <span class="free">g</span> <span class="bound">x</span> <span class="main">&lt;</span><span class="free">Q</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">P</span><span class="main">&gt;</span> bind <span class="free">f</span> <span class="free">g</span> <span class="main">&lt;</span><span class="free">Q</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> hoare_triple_def Let_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> allI impI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> conjE <span class="dynamic"><span class="dynamic">run_elims</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> conjI<span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">h</span> <span class="skolem">as</span> <span class="skolem">σ''</span> <span class="skolem">r''</span> <span class="skolem">σ'</span> <span class="skolem">r'</span>
  <span class="keyword3"><span class="command">assume</span></span> M<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">h</span><span class="main">,</span><span class="skolem">as</span><span class="main">)</span> <span class="main">⊨</span> <span class="free">P</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> R1<span class="main">:</span> <span class="quoted"><span class="quoted">"run <span class="free">f</span> <span class="main">(</span>Some <span class="skolem">h</span><span class="main">)</span> <span class="skolem">σ'</span> <span class="skolem">r'</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> R2<span class="main">:</span> <span class="quoted"><span class="quoted">"run <span class="main">(</span><span class="free">g</span> <span class="skolem">r'</span><span class="main">)</span> <span class="skolem">σ'</span> <span class="skolem">σ''</span> <span class="skolem">r''</span>"</span></span>

  <span class="keyword1"><span class="command">from</span></span> hoare_tripleD<span class="main">[</span><span class="operator">OF</span> T1 M R1<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> NO_E<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> is_exn <span class="skolem">σ'</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> M'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>the_state <span class="skolem">σ'</span><span class="main">,</span> new_addrs <span class="skolem">h</span> <span class="skolem">as</span> <span class="main">(</span>the_state <span class="skolem">σ'</span><span class="main">)</span><span class="main">)</span> <span class="main">⊨</span> <span class="free">R</span> <span class="skolem">r'</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> RH'<span class="main">:</span> <span class="quoted"><span class="quoted">"relH <span class="main">{</span><span class="bound">a</span><span class="main">.</span> <span class="bound">a</span> <span class="main">&lt;</span> lim <span class="skolem">h</span> <span class="main">∧</span> <span class="bound">a</span> <span class="main">∉</span> <span class="skolem">as</span><span class="main">}</span> <span class="skolem">h</span> <span class="main">(</span>the_state <span class="skolem">σ'</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> LIM<span class="main">:</span> <span class="quoted"><span class="quoted">"lim <span class="skolem">h</span> <span class="main">≤</span> lim <span class="main">(</span>the_state <span class="skolem">σ'</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">from</span></span> NO_E <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Some <span class="main">(</span>the_state <span class="skolem">σ'</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">σ'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">σ'</span></span><span class="main">)</span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">from</span></span> hoare_tripleD<span class="main">[</span><span class="operator">OF</span> T2 M'<span class="main">,</span> <span class="operator">simplified</span><span class="main">,</span> <span class="operator">OF</span> R2<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> 
    NO_E''<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> is_exn <span class="skolem">σ''</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> M''<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>the_state <span class="skolem">σ''</span><span class="main">,</span>
      new_addrs <span class="main">(</span>the_state <span class="skolem">σ'</span><span class="main">)</span> 
        <span class="main">(</span>new_addrs <span class="skolem">h</span> <span class="skolem">as</span> <span class="main">(</span>the_state <span class="skolem">σ'</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>the_state <span class="skolem">σ''</span><span class="main">)</span><span class="main">)</span> 
      <span class="main">⊨</span> <span class="free">Q</span> <span class="skolem">r''</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> RH''<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"relH 
      <span class="main">{</span><span class="bound">a</span><span class="main">.</span> <span class="bound">a</span> <span class="main">&lt;</span> lim <span class="main">(</span>the_state <span class="skolem">σ'</span><span class="main">)</span> 
        <span class="main">∧</span> <span class="bound">a</span> <span class="main">∉</span> new_addrs <span class="skolem">h</span> <span class="skolem">as</span> <span class="main">(</span>the_state <span class="skolem">σ'</span><span class="main">)</span>
      <span class="main">}</span>
      <span class="main">(</span>the_state <span class="skolem">σ'</span><span class="main">)</span> <span class="main">(</span>the_state <span class="skolem">σ''</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> LIM'<span class="main">:</span> <span class="quoted"><span class="quoted">"lim <span class="main">(</span>the_state <span class="skolem">σ'</span><span class="main">)</span> <span class="main">≤</span> lim <span class="main">(</span>the_state <span class="skolem">σ''</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> is_exn <span class="skolem">σ''</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>

  <span class="keyword1"><span class="command">have</span></span>  
    <span class="quoted"><span class="quoted">"new_addrs 
      <span class="main">(</span>the_state <span class="skolem">σ'</span><span class="main">)</span> 
      <span class="main">(</span>new_addrs <span class="skolem">h</span> <span class="skolem">as</span> <span class="main">(</span>the_state <span class="skolem">σ'</span><span class="main">)</span><span class="main">)</span> 
      <span class="main">(</span>the_state <span class="skolem">σ''</span><span class="main">)</span> 
    <span class="main">=</span> new_addrs <span class="skolem">h</span> <span class="skolem">as</span> <span class="main">(</span>the_state <span class="skolem">σ''</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> LIM LIM' 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> new_addrs_def<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> M'' <span class="keyword3"><span class="command">show</span></span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span>the_state <span class="skolem">σ''</span><span class="main">,</span> new_addrs <span class="skolem">h</span> <span class="skolem">as</span> <span class="main">(</span>the_state <span class="skolem">σ''</span><span class="main">)</span><span class="main">)</span> <span class="main">⊨</span> <span class="free">Q</span> <span class="skolem">r''</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

  <span class="keyword1"><span class="command">note</span></span> RH'
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"relH <span class="main">{</span><span class="bound">a</span><span class="main">.</span> <span class="bound">a</span> <span class="main">&lt;</span> lim <span class="skolem">h</span> <span class="main">∧</span> <span class="bound">a</span> <span class="main">∉</span> <span class="skolem">as</span><span class="main">}</span> <span class="main">(</span>the_state <span class="skolem">σ'</span><span class="main">)</span> <span class="main">(</span>the_state <span class="skolem">σ''</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> relH_subset<span class="main"><span class="main">[</span></span><span class="operator">OF</span> RH''<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> LIM LIM'
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> new_addrs_def<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"relH <span class="main">{</span><span class="bound">a</span><span class="main">.</span> <span class="bound">a</span> <span class="main">&lt;</span> lim <span class="skolem">h</span> <span class="main">∧</span> <span class="bound">a</span> <span class="main">∉</span> <span class="skolem">as</span><span class="main">}</span> <span class="skolem">h</span> <span class="main">(</span>the_state <span class="skolem">σ''</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1"><span class="command">note</span></span> LIM
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> LIM'
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"lim <span class="skolem">h</span> <span class="main">≤</span> lim <span class="main">(</span>the_state <span class="skolem">σ''</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> if_rule<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span>  <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">⟹</span> <span class="main">&lt;</span><span class="free">P</span><span class="main">&gt;</span> <span class="free">f</span> <span class="main">&lt;</span><span class="free">Q</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span>  <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="free">b</span> <span class="main">⟹</span> <span class="main">&lt;</span><span class="free">P</span><span class="main">&gt;</span> <span class="free">g</span> <span class="main">&lt;</span><span class="free">Q</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">P</span><span class="main">&gt;</span> <span class="keyword1">if</span> <span class="free">b</span> <span class="keyword1">then</span> <span class="free">f</span> <span class="keyword1">else</span> <span class="free">g</span> <span class="main">&lt;</span><span class="free">Q</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> if_rule_split<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span>  B<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">⟹</span> <span class="main">&lt;</span><span class="free">P</span><span class="main">&gt;</span> <span class="free">f</span> <span class="main">&lt;</span><span class="free">Q1</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span>  NB<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="free">b</span> <span class="main">⟹</span> <span class="main">&lt;</span><span class="free">P</span><span class="main">&gt;</span> <span class="free">g</span> <span class="main">&lt;</span><span class="free">Q2</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> M<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="free">Q1</span> <span class="bound">x</span> <span class="main">*</span> <span class="main">↑</span><span class="free">b</span><span class="main">)</span> <span class="keyword1">∨<span class="hidden">⇩</span><sub>A</sub></span> <span class="main">(</span><span class="free">Q2</span> <span class="bound">x</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="main">¬</span><span class="free">b</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">Q</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">P</span><span class="main">&gt;</span> <span class="keyword1">if</span> <span class="free">b</span> <span class="keyword1">then</span> <span class="free">f</span> <span class="keyword1">else</span> <span class="free">g</span> <span class="main">&lt;</span><span class="free">Q</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">b</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cons_post_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> B<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ent_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ ent_disjI1<span class="main"><span class="main">[</span></span><span class="operator">OF</span> M<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>

  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cons_post_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> NB<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ent_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ ent_disjI2<span class="main"><span class="main">[</span></span><span class="operator">OF</span> M<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> split_rule<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> P<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">P</span><span class="main">&gt;</span> <span class="free">c</span> <span class="main">&lt;</span><span class="free">R</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> Q<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">Q</span><span class="main">&gt;</span> <span class="free">c</span> <span class="main">&lt;</span><span class="free">R</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">P</span> <span class="keyword1">∨<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">Q</span><span class="main">&gt;</span> <span class="free">c</span> <span class="main">&lt;</span><span class="free">R</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> hoare_triple_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> allI impI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> conjE<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> disjE<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> hoare_tripleD<span class="main">[</span><span class="operator">OF</span> P<span class="main">]</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">using</span></span> hoare_tripleD<span class="main">[</span><span class="operator">OF</span> Q<span class="main">]</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemmas</span></span> decon_if_split <span class="main">=</span> if_rule_split split_rule
  <span class="comment1">― ‹Use with care: Complete splitting of if statements›</span>

<span class="keyword1"><span class="command">lemma</span></span> case_prod_rule<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">a</span> <span class="bound">b</span><span class="main">.</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">&lt;</span><span class="free">P</span><span class="main">&gt;</span> <span class="free">f</span> <span class="bound">a</span> <span class="bound">b</span> <span class="main">&lt;</span><span class="free">Q</span><span class="main">&gt;</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">&lt;</span><span class="free">P</span><span class="main">&gt;</span> <span class="keyword1">case</span> <span class="free">x</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span> <span class="main">⇒</span> <span class="free">f</span> <span class="bound">a</span> <span class="bound">b</span> <span class="main">&lt;</span><span class="free">Q</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> case_list_rule<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">l</span><span class="main">=</span><span class="main">[]</span> <span class="main">⟹</span> <span class="main">&lt;</span><span class="free">P</span><span class="main">&gt;</span> <span class="free">fn</span> <span class="main">&lt;</span><span class="free">Q</span><span class="main">&gt;</span><span class="main">;</span> <span class="main">⋀</span><span class="bound">x</span> <span class="bound">xs</span><span class="main">.</span> <span class="free">l</span><span class="main">=</span><span class="bound">x</span><span class="main">#</span><span class="bound">xs</span> <span class="main">⟹</span> <span class="main">&lt;</span><span class="free">P</span><span class="main">&gt;</span> <span class="free">fc</span> <span class="bound">x</span> <span class="bound">xs</span> <span class="main">&lt;</span><span class="free">Q</span><span class="main">&gt;</span> <span class="main">⟧</span> <span class="main">⟹</span> 
  <span class="main">&lt;</span><span class="free">P</span><span class="main">&gt;</span> case_list <span class="free">fn</span> <span class="free">fc</span> <span class="free">l</span> <span class="main">&lt;</span><span class="free">Q</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> list.split<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> case_option_rule<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">v</span><span class="main">=</span>None <span class="main">⟹</span> <span class="main">&lt;</span><span class="free">P</span><span class="main">&gt;</span> <span class="free">fn</span> <span class="main">&lt;</span><span class="free">Q</span><span class="main">&gt;</span><span class="main">;</span> <span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="free">v</span><span class="main">=</span>Some <span class="bound">x</span> <span class="main">⟹</span> <span class="main">&lt;</span><span class="free">P</span><span class="main">&gt;</span> <span class="free">fs</span> <span class="bound">x</span> <span class="main">&lt;</span><span class="free">Q</span><span class="main">&gt;</span> <span class="main">⟧</span> 
  <span class="main">⟹</span> <span class="main">&lt;</span><span class="free">P</span><span class="main">&gt;</span> case_option <span class="free">fn</span> <span class="free">fs</span> <span class="free">v</span> <span class="main">&lt;</span><span class="free">Q</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> case_sum_rule<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="free">v</span><span class="main">=</span>Inl <span class="bound">x</span> <span class="main">⟹</span> <span class="main">&lt;</span><span class="free">P</span><span class="main">&gt;</span> <span class="free">fl</span> <span class="bound">x</span> <span class="main">&lt;</span><span class="free">Q</span><span class="main">&gt;</span><span class="main">;</span> 
     <span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="free">v</span><span class="main">=</span>Inr <span class="bound">x</span> <span class="main">⟹</span> <span class="main">&lt;</span><span class="free">P</span><span class="main">&gt;</span> <span class="free">fr</span> <span class="bound">x</span> <span class="main">&lt;</span><span class="free">Q</span><span class="main">&gt;</span> <span class="main">⟧</span> 
  <span class="main">⟹</span> <span class="main">&lt;</span><span class="free">P</span><span class="main">&gt;</span> case_sum <span class="free">fl</span> <span class="free">fr</span> <span class="free">v</span> <span class="main">&lt;</span><span class="free">Q</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> sum.split<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> let_rule<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">t</span> <span class="main">⟹</span> <span class="main">&lt;</span><span class="free">P</span><span class="main">&gt;</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">&lt;</span><span class="free">Q</span><span class="main">&gt;</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">&lt;</span><span class="free">P</span><span class="main">&gt;</span> Let <span class="free">t</span> <span class="free">f</span> <span class="main">&lt;</span><span class="free">Q</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Automation">
<div class="head">
<h1>Theory Automation</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Automation›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Automation
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Hoare_Triple.html">Hoare_Triple</a> <span class="comment1">(*"../Lib/Refine_Util"*)</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  In this theory, we provide a set of tactics and a simplifier setup for easy
  reasoning with our separation logic.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Normalization of Assertions›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  In this section, we provide a set of lemmas and a simplifier
  setup to bring assertions to a normal form. We provide a simproc that
  detects pure parts of assertions and duplicate pointers. Moreover,
  we provide ac-rules for assertions. See Section~\ref{sec:auto:overview}
  for a short overview of the available proof methods.
›</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> assn_aci <span class="main">=</span>   
  inf_aci<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'a</span><span class="main"><span class="main"><span class="main"><span class="main"><span class="main">=</span></span></span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">assn</span></span></span></span><span class="main">]</span> 
  sup_aci<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'a</span><span class="main"><span class="main"><span class="main"><span class="main"><span class="main">=</span></span></span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">assn</span></span></span></span><span class="main">]</span> 
  mult.left_ac<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'a</span><span class="main"><span class="main"><span class="main"><span class="main">=</span></span></span></span><span class="quoted"><span class="quoted"><span class="quoted">assn</span></span></span><span class="main">]</span> 

<span class="keyword1"><span class="command">lemmas</span></span> star_assoc <span class="main">=</span> mult.assoc<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'a</span><span class="main"><span class="main">=</span></span><span class="quoted">assn</span><span class="main">]</span> 
<span class="keyword1"><span class="command">lemmas</span></span> assn_assoc <span class="main">=</span> 
  mult.left_assoc inf_assoc<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'a</span><span class="main"><span class="main">=</span></span><span class="quoted">assn</span><span class="main">]</span> sup_assoc<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'a</span><span class="main"><span class="main">=</span></span><span class="quoted">assn</span><span class="main">]</span> 

<span class="keyword1"><span class="command">lemma</span></span> merge_true_star_ctx<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">true</span> <span class="main">*</span> <span class="main">(</span><span class="keyword1">true</span> <span class="main">*</span> <span class="free">P</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">true</span> <span class="main">*</span> <span class="free">P</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mult.left_ac<span class="main">)</span>
  
<span class="keyword1"><span class="command">lemmas</span></span> star_aci <span class="main">=</span> 
  mult.assoc<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'a</span><span class="main"><span class="main">=</span></span><span class="quoted">assn</span><span class="main">]</span> mult.commute<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'a</span><span class="main"><span class="main">=</span></span><span class="quoted">assn</span><span class="main">]</span> mult.left_commute<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'a</span><span class="main"><span class="main">=</span></span><span class="quoted">assn</span><span class="main">]</span>
  assn_one_left mult_1_right<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'a</span><span class="main"><span class="main">=</span></span><span class="quoted">assn</span><span class="main">]</span>
  merge_true_star merge_true_star_ctx

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Move existential quantifiers to the front of assertions›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> ex_assn_move_out<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">Q</span> <span class="bound">R</span><span class="main">.</span> <span class="main">(</span><span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">x</span><span class="main">.</span> <span class="bound">Q</span> <span class="bound">x</span><span class="main">)</span> <span class="main">*</span> <span class="bound">R</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="bound">Q</span> <span class="bound">x</span> <span class="main">*</span> <span class="bound">R</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">Q</span> <span class="bound">R</span><span class="main">.</span> <span class="bound">R</span> <span class="main">*</span> <span class="main">(</span><span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">x</span><span class="main">.</span> <span class="bound">Q</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="bound">R</span> <span class="main">*</span> <span class="bound">Q</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>

  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">P</span> <span class="bound">Q</span><span class="main">.</span> <span class="main">(</span><span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">x</span><span class="main">.</span> <span class="bound">Q</span> <span class="bound">x</span><span class="main">)</span> <span class="keyword1">∧<span class="hidden">⇩</span><sub>A</sub></span> <span class="bound">P</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="bound">Q</span> <span class="bound">x</span> <span class="keyword1">∧<span class="hidden">⇩</span><sub>A</sub></span> <span class="bound">P</span><span class="main">)</span><span class="main">)</span> "</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">P</span> <span class="bound">Q</span><span class="main">.</span> <span class="bound">Q</span> <span class="keyword1">∧<span class="hidden">⇩</span><sub>A</sub></span> <span class="main">(</span><span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">x</span><span class="main">.</span> <span class="bound">P</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="bound">Q</span> <span class="keyword1">∧<span class="hidden">⇩</span><sub>A</sub></span> <span class="bound">P</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>

  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">P</span> <span class="bound">Q</span><span class="main">.</span> <span class="main">(</span><span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">x</span><span class="main">.</span> <span class="bound">Q</span> <span class="bound">x</span><span class="main">)</span> <span class="keyword1">∨<span class="hidden">⇩</span><sub>A</sub></span> <span class="bound">P</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="bound">Q</span> <span class="bound">x</span> <span class="keyword1">∨<span class="hidden">⇩</span><sub>A</sub></span> <span class="bound">P</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">P</span> <span class="bound">Q</span><span class="main">.</span> <span class="bound">Q</span> <span class="keyword1">∨<span class="hidden">⇩</span><sub>A</sub></span> <span class="main">(</span><span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">x</span><span class="main">.</span> <span class="bound">P</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="bound">Q</span> <span class="keyword1">∨<span class="hidden">⇩</span><sub>A</sub></span> <span class="bound">P</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ex_distrib_star<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> mult.commute<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> mult.commute<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ex_distrib_star<span class="main">)</span>

  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ex_distrib_and<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> inf_commute<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> inf_commute<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ex_distrib_and<span class="main">)</span>

  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ex_distrib_or<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> sup_commute<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> sup_commute<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ex_distrib_or<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Extract pure assertions from and-clauses›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> and_extract_pure_left_iff<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">↑</span><span class="free">b</span> <span class="keyword1">∧<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">Q</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">emp</span><span class="keyword1">∧<span class="hidden">⇩</span><sub>A</sub></span><span class="free">Q</span><span class="main">)</span><span class="main">*</span><span class="main">↑</span><span class="free">b</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">b</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> and_extract_pure_left_ctx_iff<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span><span class="main">*</span><span class="main">↑</span><span class="free">b</span> <span class="keyword1">∧<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">Q</span> <span class="main">=</span> <span class="main">(</span><span class="free">P</span><span class="keyword1">∧<span class="hidden">⇩</span><sub>A</sub></span><span class="free">Q</span><span class="main">)</span><span class="main">*</span><span class="main">↑</span><span class="free">b</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">b</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> and_extract_pure_right_iff<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="keyword1">∧<span class="hidden">⇩</span><sub>A</sub></span> <span class="main">↑</span><span class="free">b</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">emp</span><span class="keyword1">∧<span class="hidden">⇩</span><sub>A</sub></span><span class="free">P</span><span class="main">)</span><span class="main">*</span><span class="main">↑</span><span class="free">b</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">b</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> assn_aci<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> and_extract_pure_right_ctx_iff<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="keyword1">∧<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">Q</span><span class="main">*</span><span class="main">↑</span><span class="free">b</span> <span class="main">=</span> <span class="main">(</span><span class="free">P</span><span class="keyword1">∧<span class="hidden">⇩</span><sub>A</sub></span><span class="free">Q</span><span class="main">)</span><span class="main">*</span><span class="main">↑</span><span class="free">b</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">b</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemmas</span></span> and_extract_pure_iff <span class="main">=</span> 
  and_extract_pure_left_iff and_extract_pure_left_ctx_iff
  and_extract_pure_right_iff and_extract_pure_right_ctx_iff

<span class="keyword1"><span class="command">lemmas</span></span> norm_assertion_simps <span class="main">=</span>
  <span class="comment1">(* Neutral elements *)</span>
  mult_1<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'a</span><span class="main"><span class="main">=</span></span><span class="quoted">assn</span><span class="main">]</span> mult_1_right<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'a</span><span class="main"><span class="main">=</span></span><span class="quoted">assn</span><span class="main">]</span>
  inf_top_left<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'a</span><span class="main"><span class="main">=</span></span><span class="quoted">assn</span><span class="main">]</span> inf_top_right<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'a</span><span class="main"><span class="main">=</span></span><span class="quoted">assn</span><span class="main">]</span>
  sup_bot_left<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'a</span><span class="main"><span class="main">=</span></span><span class="quoted">assn</span><span class="main">]</span> sup_bot_right<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'a</span><span class="main"><span class="main">=</span></span><span class="quoted">assn</span><span class="main">]</span>

  <span class="comment1">(* Zero elements *)</span>
  star_false_left star_false_right
  inf_bot_left<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'a</span><span class="main"><span class="main">=</span></span><span class="quoted">assn</span><span class="main">]</span> inf_bot_right<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'a</span><span class="main"><span class="main">=</span></span><span class="quoted">assn</span><span class="main">]</span>
  sup_top_left<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'a</span><span class="main"><span class="main">=</span></span><span class="quoted">assn</span><span class="main">]</span> sup_top_right<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'a</span><span class="main"><span class="main">=</span></span><span class="quoted">assn</span><span class="main">]</span>

  <span class="comment1">(* Associativity *)</span>
  mult.left_assoc<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'a</span><span class="main"><span class="main">=</span></span><span class="quoted">assn</span><span class="main">]</span>
  inf_assoc<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'a</span><span class="main"><span class="main">=</span></span><span class="quoted">assn</span><span class="main">]</span>
  sup_assoc<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'a</span><span class="main"><span class="main">=</span></span><span class="quoted">assn</span><span class="main">]</span>

  <span class="comment1">(* Existential Quantifiers *)</span>
  ex_assn_move_out ex_assn_const

  <span class="comment1">(* Extract pure assertions from conjunctions *)</span>
  and_extract_pure_iff

  <span class="comment1">(* Merging *)</span>
  merge_pure_star merge_pure_and merge_pure_or
  merge_true_star 
  inf_idem<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'a</span><span class="main"><span class="main">=</span></span><span class="quoted">assn</span><span class="main">]</span> sup_idem<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'a</span><span class="main"><span class="main">=</span></span><span class="quoted">assn</span><span class="main">]</span>

  <span class="comment1">(* Duplicated References *)</span>
  sngr_same_false snga_same_false


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Simplifier Setup Fine-Tuning›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Imperative HOL likes to simplify pointer inequations to this strange
  operator. We do some additional simplifier setup here›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> not_same_noteqr<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">a</span><span class="main">=!=</span><span class="free">a</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Ref.unequal<span class="main">)</span>
<span class="keyword1"><span class="command">declare</span></span> Ref.noteq_irrefl<span class="main">[</span><span class="operator">dest</span><span class="main"><span class="main">!</span></span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> not_same_noteqa<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">a</span><span class="main">=!!=</span><span class="free">a</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Array.unequal<span class="main">)</span>
<span class="keyword1"><span class="command">declare</span></span> Array.noteq_irrefl<span class="main">[</span><span class="operator">dest</span><span class="main"><span class="main">!</span></span><span class="main">]</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹However, it is safest to disable this rewriting, as there is
  a working standard simplifier setup for <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>(≠)›</span></span></span></span>
›</span></span>
<span class="keyword1"><span class="command">declare</span></span> Ref.unequal<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> Array.unequal<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Normalization of Entailments›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Used by existential quantifier extraction tactic›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> enorm_exI'<span class="main">:</span> <span class="comment1">(* Incomplete, as chosen x may depend on heap! *)</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="free">Z</span> <span class="bound">x</span> <span class="main">⟶</span> <span class="main">(</span><span class="free">P</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">Q</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="free">Z</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⟶</span> <span class="main">(</span><span class="free">P</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="main">(</span><span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">x</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> ent_ex_postI<span class="main">)</span>
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Example of how to build an extraction lemma.›</span></span>
<span class="keyword1"><span class="command">thm</span></span> enorm_exI'<span class="main">[</span><span class="operator">OF</span> enorm_exI'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> imp_refl<span class="main"><span class="main">]</span></span><span class="main">]</span>

<span class="keyword1"><span class="command">lemmas</span></span> ent_triv <span class="main">=</span> ent_true ent_false

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Dummy rule to detect Hoare triple goal›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> is_hoare_triple<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">P</span><span class="main">&gt;</span> <span class="free">c</span> <span class="main">&lt;</span><span class="free">Q</span><span class="main">&gt;</span> <span class="main">⟹</span> <span class="main">&lt;</span><span class="free">P</span><span class="main">&gt;</span> <span class="free">c</span> <span class="main">&lt;</span><span class="free">Q</span><span class="main">&gt;</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Dummy rule to detect entailment goal›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> is_entails<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span><span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span><span class="free">Q</span> <span class="main">⟹</span> <span class="free">P</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span><span class="free">Q</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Frame Matcher›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Given star-lists P,Q and a frame F, this method tries to match 
  all elements of Q with corresponding elements of P. The result is a 
  partial match, that contains matching pairs and the unmatched content.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The frame-matcher internally uses syntactic lists separated by
  star, and delimited by the special symbol <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>SLN›</span></span></span></span>, which is defined
  to be <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>emp›</span></span></span></span>.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">SLN</span> <span class="main">≡</span> <span class="keyword1">emp</span>"</span></span>
<span class="keyword1"><span class="command">lemma</span></span> SLN_left<span class="main">:</span> <span class="quoted"><span class="quoted">"SLN <span class="main">*</span> <span class="free">P</span> <span class="main">=</span> <span class="free">P</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">lemma</span></span> SLN_right<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">*</span> SLN <span class="main">=</span> <span class="free">P</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemmas</span></span> SLN_normalize <span class="main">=</span> SLN_right mult.left_assoc<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'a</span><span class="main"><span class="main">=</span></span><span class="quoted">assn</span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> SLN_strip <span class="main">=</span> SLN_right SLN_left mult.left_assoc<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'a</span><span class="main"><span class="main">=</span></span><span class="quoted">assn</span><span class="main">]</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A query to the frame matcher. Contains the assertions
  P and Q that shall be matched, as well as a frame F, that is not 
  touched.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">FI_QUERY</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free"><span class="bound"><span class="entity">F</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">*</span><span class="free"><span class="bound"><span class="entity">F</span></span></span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">fi_m_fst</span> <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="main">≡</span> foldr <span class="main">(*)</span> <span class="main">(</span>map fst <span class="free"><span class="bound"><span class="entity">M</span></span></span><span class="main">)</span> <span class="keyword1">emp</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">fi_m_snd</span> <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="main">≡</span> foldr <span class="main">(*)</span> <span class="main">(</span>map snd <span class="free"><span class="bound"><span class="entity">M</span></span></span><span class="main">)</span> <span class="keyword1">emp</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">fi_m_match</span> <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="main">∀</span><span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">q</span><span class="main">)</span><span class="main">∈</span>set <span class="free"><span class="bound"><span class="entity">M</span></span></span><span class="main">.</span> <span class="bound">p</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="bound">q</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A result of the frame matcher. Contains a list of matching pairs,
  as well as the unmatched parts of P and Q, and the frame F.
›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">FI_RESULT</span> <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="free"><span class="bound"><span class="entity">UP</span></span></span> <span class="free"><span class="bound"><span class="entity">UQ</span></span></span> <span class="free"><span class="bound"><span class="entity">F</span></span></span> <span class="main">≡</span> 
  fi_m_match <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="main">⟶</span> <span class="main">(</span>fi_m_fst <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="main">*</span> <span class="free"><span class="bound"><span class="entity">UP</span></span></span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> fi_m_snd <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="main">*</span> <span class="free"><span class="bound"><span class="entity">UQ</span></span></span> <span class="main">*</span> <span class="free"><span class="bound"><span class="entity">F</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Internal structure used by the frame matcher: 
  m contains the matched pairs; p,q the assertions that still needs to be 
  matched; up,uq the assertions that could not be matched; and f the frame.
  p and q are SLN-delimited syntactic lists. 
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">FI</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="free"><span class="bound"><span class="entity">up</span></span></span> <span class="free"><span class="bound"><span class="entity">uq</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> 
  fi_m_match <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">⟶</span> <span class="main">(</span>fi_m_fst <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">*</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">*</span> <span class="free"><span class="bound"><span class="entity">up</span></span></span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> fi_m_snd <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">*</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">*</span> <span class="free"><span class="bound"><span class="entity">uq</span></span></span> <span class="main">*</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Initialize processing of query›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> FI_init<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"FI <span class="main">[]</span> <span class="main">(</span>SLN<span class="main">*</span><span class="free">P</span><span class="main">)</span> <span class="main">(</span>SLN<span class="main">*</span><span class="free">Q</span><span class="main">)</span> SLN SLN <span class="free">F</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"FI_QUERY <span class="free">P</span> <span class="free">Q</span> <span class="free">F</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Construct result from internal representation›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> FI_finalize<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"FI_RESULT <span class="free">m</span> <span class="main">(</span><span class="free">p</span><span class="main">*</span><span class="free">up</span><span class="main">)</span> <span class="main">(</span><span class="free">q</span><span class="main">*</span><span class="free">uq</span><span class="main">)</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"FI <span class="free">m</span> <span class="free">p</span> <span class="free">q</span> <span class="free">up</span> <span class="free">uq</span> <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assn_aci<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Auxiliary lemma to show that all matching pairs together form
  an entailment. This is required for most applications.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> fi_match_entails<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"fi_m_match <span class="free">m</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fi_m_fst <span class="free">m</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> fi_m_snd <span class="free">m</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">m</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split_asm <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ent_star_mono<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Internally, the frame matcher tries to match the first assertion
  of q with the first assertion of p. If no match is found, the first
  assertion of p is discarded. If no match for any assertion in p can be
  found, the first assertion of q is discarded.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Match›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> FI_match<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">q</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"FI <span class="main">(</span><span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">q</span><span class="main">)</span><span class="main">#</span><span class="free">m</span><span class="main">)</span> <span class="main">(</span><span class="free">ps</span><span class="main">*</span><span class="free">up</span><span class="main">)</span> <span class="main">(</span><span class="free">qs</span><span class="main">*</span><span class="free">uq</span><span class="main">)</span> SLN SLN <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"FI <span class="free">m</span> <span class="main">(</span><span class="free">ps</span><span class="main">*</span><span class="free">p</span><span class="main">)</span> <span class="main">(</span><span class="free">qs</span><span class="main">*</span><span class="free">q</span><span class="main">)</span> <span class="free">up</span> <span class="free">uq</span> <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> FI_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assn_aci<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹No match›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> FI_p_nomatch<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"FI <span class="free">m</span> <span class="free">ps</span> <span class="main">(</span><span class="free">qs</span><span class="main">*</span><span class="free">q</span><span class="main">)</span> <span class="main">(</span><span class="free">p</span><span class="main">*</span><span class="free">up</span><span class="main">)</span> <span class="free">uq</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"FI <span class="free">m</span> <span class="main">(</span><span class="free">ps</span><span class="main">*</span><span class="free">p</span><span class="main">)</span> <span class="main">(</span><span class="free">qs</span><span class="main">*</span><span class="free">q</span><span class="main">)</span> <span class="free">up</span> <span class="free">uq</span> <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> FI_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assn_aci<span class="main">)</span>
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Head of q could not be matched›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> FI_q_nomatch<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"FI <span class="free">m</span> <span class="main">(</span>SLN<span class="main">*</span><span class="free">up</span><span class="main">)</span> <span class="free">qs</span> SLN <span class="main">(</span><span class="free">q</span><span class="main">*</span><span class="free">uq</span><span class="main">)</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"FI <span class="free">m</span> SLN <span class="main">(</span><span class="free">qs</span><span class="main">*</span><span class="free">q</span><span class="main">)</span> <span class="free">up</span> <span class="free">uq</span> <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> FI_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assn_aci<span class="main">)</span> 

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Frame Inference›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> frame_inference_init<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"FI_QUERY <span class="free">P</span> <span class="free">Q</span> <span class="free">F</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">Q</span> <span class="main">*</span> <span class="free">F</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> frame_inference_finalize<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"FI_RESULT <span class="free">M</span> <span class="free">F</span> <span class="keyword1">emp</span> <span class="free">F</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> fi_match_entails<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ent_star_mono<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ ent_refl<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Entailment Solver›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> entails_solve_init<span class="main">:</span>
  <span class="quoted"><span class="quoted">"FI_QUERY <span class="free">P</span> <span class="free">Q</span> <span class="keyword1">true</span> <span class="main">⟹</span> <span class="free">P</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">Q</span> <span class="main">*</span> <span class="keyword1">true</span>"</span></span>
  <span class="quoted"><span class="quoted">"FI_QUERY <span class="free">P</span> <span class="free">Q</span> <span class="keyword1">emp</span> <span class="main">⟹</span> <span class="free">P</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">Q</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assn_aci<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> entails_solve_finalize<span class="main">:</span>
  <span class="quoted"><span class="quoted">"FI_RESULT <span class="free">M</span> <span class="free">P</span> <span class="keyword1">emp</span> <span class="keyword1">true</span>"</span></span>
  <span class="quoted"><span class="quoted">"FI_RESULT <span class="free">M</span> <span class="keyword1">emp</span> <span class="keyword1">emp</span> <span class="keyword1">emp</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fi_match_entails <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> ent_star_mono<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> solve_ent_preprocess_simps <span class="main">=</span> 
  ent_pure_post_iff ent_pure_post_iff_sng ent_pure_pre_iff ent_pure_pre_iff_sng
  
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Verification Condition Generator›</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> normalize_rules <span class="main">=</span> norm_pre_ex_rule norm_pre_pure_rule

<span class="comment1">(* Originally we introduced backwards-reasoning here, via
  cons_pre_rule[OF _ return_wp_rule] (old name: complete_return_cons). 
  This only works, if the postcondition is not schematic! However, for 
  forward reasoning, one usually assumes a schematic postcondition!
  *)</span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹May be useful in simple, manual proofs, where the postcondition
  is no schematic variable.›</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> return_cons_rule <span class="main">=</span> cons_pre_rule<span class="main">[</span><span class="operator">OF</span> _ return_wp_rule<span class="main">]</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Useful frame-rule variant for manual proof:›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> frame_rule_left<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">P</span><span class="main">&gt;</span> <span class="free">c</span> <span class="main">&lt;</span><span class="free">Q</span><span class="main">&gt;</span> <span class="main">⟹</span> <span class="main">&lt;</span><span class="free">R</span> <span class="main">*</span> <span class="free">P</span><span class="main">&gt;</span> <span class="free">c</span> <span class="main">&lt;</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">R</span> <span class="main">*</span> <span class="free">Q</span> <span class="bound">x</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> frame_rule <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assn_aci<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> deconstruct_rules <span class="main">=</span> 
  bind_rule if_rule false_rule return_sp_rule let_rule 
  case_prod_rule case_list_rule case_option_rule case_sum_rule

<span class="keyword1"><span class="command">lemmas</span></span> heap_rules <span class="main">=</span> 
  ref_rule
  lookup_rule
  update_rule
  new_rule
  make_rule
  of_list_rule
  length_rule
  nth_rule
  upd_rule
  freeze_rule

<span class="keyword1"><span class="command">lemma</span></span> fi_rule<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> CMD<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">P</span><span class="main">&gt;</span> <span class="free">c</span> <span class="main">&lt;</span><span class="free">Q</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> FRAME<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Ps</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">P</span> <span class="main">*</span> <span class="free">F</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">Ps</span><span class="main">&gt;</span> <span class="free">c</span> <span class="main">&lt;</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">x</span> <span class="main">*</span> <span class="free">F</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cons_pre_rule<span class="main"><span class="main">[</span></span><span class="operator">rotated</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> frame_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> CMD<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> FRAME<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹ML-setup›</span></span>

<span class="keyword1"><span class="command">named_theorems</span></span> sep_dflt_simps <span class="quoted">"Seplogic: Default simplification rules for automated solvers"</span>
<span class="keyword1"><span class="command">named_theorems</span></span> sep_eintros <span class="quoted">"Seplogic: Intro rules for entailment solver"</span>
<span class="keyword1"><span class="command">named_theorems</span></span> sep_heap_rules <span class="quoted">"Seplogic: VCG heap rules"</span>
<span class="keyword1"><span class="command">named_theorems</span></span> sep_decon_rules <span class="quoted">"Seplogic: VCG deconstruct rules"</span>

<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹
<span class="keyword1"><span class="keyword">infix</span></span> <span class="inner_numeral">1</span> THEN_IGNORE_NEWGOALS

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Seplogic_Auto</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

  <span class="comment1">(***********************************)</span>
  <span class="comment1">(*             Tools               *)</span>
  <span class="comment1">(***********************************)</span>

  <span class="comment1">(* Repeat tac on subgoal. Determinize each step. 
     Stop if tac fails or subgoal is solved. *)</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">REPEAT_DETERM'</span> <span class="entity">tac</span> <span class="entity">i</span> <span class="entity">st</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">n</span> <span class="main">=</span> Thm.nprems_of <span class="entity">st</span> 
  <span class="keyword2"><span class="keyword">in</span></span>
    REPEAT_DETERM <span class="main">(</span>COND <span class="main">(</span>has_fewer_prems <span class="entity">n</span><span class="main">)</span> no_tac <span class="main">(</span><span class="entity">tac</span> <span class="entity">i</span><span class="main">)</span><span class="main">)</span> <span class="entity">st</span>
  <span class="keyword2"><span class="keyword">end</span></span>


  <span class="comment1">(***********************************)</span>
  <span class="comment1">(*             Debugging           *)</span>
  <span class="comment1">(***********************************)</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tr_term</span> <span class="entity">t</span> <span class="main">=</span> Pretty.string_of <span class="main">(</span>Syntax.pretty_term <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="entity">t</span><span class="main">)</span><span class="main">;</span>


  <span class="comment1">(***********************************)</span>
  <span class="comment1">(*        Custom Tacticals         *)</span>
  <span class="comment1">(***********************************)</span>

  <span class="comment1">(* Apply tac1, and then tac2 with an offset such that anything left 
     over by tac1 is skipped.

     The typical usage of this tactic is, if a theorem is instantiated
     with another theorem that produces additional goals that should 
     be ignored first. Here, it is used in the vcg to ensure that 
     frame inference is done before additional premises (that may 
     depend on the frame) are discharged.
  *)</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="main">(</span><span class="entity">tac1</span> <span class="entity">THEN_IGNORE_NEWGOALS</span> <span class="entity">tac2</span><span class="main">)</span> <span class="entity">i</span> <span class="entity">st</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">np</span> <span class="main">=</span> Thm.nprems_of <span class="entity">st</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="entity">tac1</span> <span class="entity">i</span> THEN <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">st'</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">np'</span> <span class="main">=</span> Thm.nprems_of <span class="entity">st'</span> <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">np'</span>&lt;<span class="entity">np</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">tac2</span> <span class="entity">i</span> <span class="entity">st'</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">tac2</span> <span class="main">(</span><span class="entity">i</span>+<span class="main">(</span><span class="entity">np'</span>-<span class="entity">np</span><span class="main">)</span>+<span class="inner_numeral">1</span><span class="main">)</span> <span class="entity">st'</span>
    <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span><span class="main">)</span> <span class="entity">st</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>


  <span class="comment1">(***********************************)</span>
  <span class="comment1">(*     Assertion Normalization     *)</span>
  <span class="comment1">(***********************************)</span>
  <span class="comment1">(* Find two terms in a list whose key is equal *)</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">find_similar</span> <span class="main">(</span><span class="entity">key_of</span><span class="main">:</span>term <span class="main">-&gt;</span> term<span class="main">)</span> <span class="main">(</span><span class="entity">ts</span><span class="main">:</span>term list<span class="main">)</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">frec</span> <span class="main">_</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> NONE
    <span class="main">|</span> <span class="entity">frec</span> <span class="entity">tab</span> <span class="main">(</span><span class="entity">t</span>::<span class="entity">ts</span><span class="main">)</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">k</span><span class="main">=</span><span class="entity">key_of</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> Termtab.defined <span class="entity">tab</span> <span class="entity">k</span> <span class="keyword2"><span class="keyword">then</span></span>
        SOME <span class="main">(</span>the <span class="main">(</span>Termtab.lookup <span class="entity">tab</span> <span class="entity">k</span><span class="main">)</span><span class="main">,</span><span class="entity">t</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">frec</span> <span class="main">(</span>Termtab.update <span class="main">(</span><span class="entity">k</span><span class="main">,</span><span class="entity">t</span><span class="main">)</span> <span class="entity">tab</span><span class="main">)</span> <span class="entity">ts</span>
    <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">frec</span> Termtab.empty <span class="entity">ts</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

  <span class="comment1">(* Perform DFS over term with binary operator opN, threading through
    a state. Atomic terms are transformed by tr. Supports omission of
    terms from the result structure by transforming them to NONE. *)</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dfs_opr</span> <span class="entity">opN</span> <span class="main">(</span><span class="entity">tr</span><span class="main">:</span>'state <span class="main">-&gt;</span> term <span class="main">-&gt;</span> <span class="main">(</span>'state*term option<span class="main">)</span><span class="main">)</span> 
    <span class="entity">d</span> <span class="main">(</span><span class="entity">t</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">op_t</span> <span class="keyword1"><span class="keyword">as</span></span> Const <span class="main">(</span><span class="entity">fN</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">)</span>$<span class="entity">t1</span>$<span class="entity">t2</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">fN</span> <span class="main">=</span> <span class="entity">opN</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">d1</span><span class="main">,</span><span class="entity">t1'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dfs_opr</span> <span class="entity">opN</span> <span class="entity">tr</span> <span class="entity">d</span> <span class="entity">t1</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">d2</span><span class="main">,</span><span class="entity">t2'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dfs_opr</span> <span class="entity">opN</span> <span class="entity">tr</span> <span class="entity">d1</span> <span class="entity">t2</span><span class="main">;</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="keyword2"><span class="keyword">case</span></span> <span class="main">(</span><span class="entity">t1'</span><span class="main">,</span><span class="entity">t2'</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
          <span class="main">(</span>NONE<span class="main">,</span>NONE<span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">d2</span><span class="main">,</span>NONE<span class="main">)</span>
        <span class="main">|</span> <span class="main">(</span>SOME <span class="entity">t1'</span><span class="main">,</span>NONE<span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">d2</span><span class="main">,</span>SOME <span class="entity">t1'</span><span class="main">)</span>
        <span class="main">|</span> <span class="main">(</span>NONE<span class="main">,</span>SOME <span class="entity">t2'</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">d2</span><span class="main">,</span>SOME <span class="entity">t2'</span><span class="main">)</span>
        <span class="main">|</span> <span class="main">(</span>SOME <span class="entity">t1'</span><span class="main">,</span>SOME <span class="entity">t2'</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">d2</span><span class="main">,</span>SOME <span class="main">(</span><span class="entity">op_t</span>$<span class="entity">t1'</span>$<span class="entity">t2'</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">tr</span> <span class="entity">d</span> <span class="entity">t</span>
  <span class="main">|</span> <span class="entity">dfs_opr</span> <span class="main">_</span> <span class="entity">tr</span> <span class="entity">d</span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">tr</span> <span class="entity">d</span> <span class="entity">t</span><span class="main">;</span>
    
  <span class="comment1">(* Replace single occurrence of (atomic) ot in t by nt. 
    Returns new term or NONE if nothing was removed. *)</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dfs_replace_atomic</span> <span class="entity">opN</span> <span class="entity">ot</span> <span class="entity">nt</span> <span class="entity">t</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tr</span> <span class="entity">d</span> <span class="entity">t</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> not <span class="entity">d</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">t</span><span class="main">=</span><span class="entity">ot</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span>true<span class="main">,</span>SOME <span class="entity">nt</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="entity">d</span><span class="main">,</span>SOME <span class="entity">t</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">success</span><span class="main">,</span>SOME <span class="entity">t'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dfs_opr</span> <span class="entity">opN</span> <span class="entity">tr</span> false <span class="entity">t</span><span class="main">;</span> 
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">success</span> <span class="keyword2"><span class="keyword">then</span></span> SOME <span class="entity">t'</span> <span class="keyword2"><span class="keyword">else</span></span> NONE
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">assn_simproc_fun</span> <span class="entity">ctxt</span> <span class="entity">credex</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">[</span><span class="entity">redex</span><span class="main">]</span><span class="main">,</span><span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span> Variable.import_terms true <span class="main">[</span>Thm.term_of <span class="entity">credex</span><span class="main">]</span> <span class="entity">ctxt</span><span class="main">;</span>
    <span class="comment1">(*val _ = tracing (tr_term redex);*)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">export</span> <span class="main">=</span> singleton <span class="main">(</span>Variable.export <span class="entity">ctxt'</span> <span class="entity">ctxt</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_star</span> <span class="entity">t1</span> <span class="entity">t2</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="main">(*)</span><span class="main">::</span>assn <span class="main">⇒</span> <span class="main">_</span> <span class="main">⇒</span> <span class="main">_</span>"</span><span class="antiquote">}</span></span>$<span class="entity">t2</span>$<span class="entity">t1</span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_star'</span> NONE NONE <span class="main">=</span> NONE
    <span class="main">|</span> <span class="entity">mk_star'</span> <span class="main">(</span>SOME <span class="entity">t1</span><span class="main">)</span> NONE  <span class="main">=</span> SOME <span class="entity">t1</span>
    <span class="main">|</span> <span class="entity">mk_star'</span> NONE <span class="main">(</span>SOME <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span> SOME <span class="entity">t2</span>
    <span class="main">|</span> <span class="entity">mk_star'</span> <span class="main">(</span>SOME <span class="entity">t1</span><span class="main">)</span> <span class="main">(</span>SOME <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span> SOME <span class="main">(</span><span class="entity">mk_star</span> <span class="entity">t1</span> <span class="entity">t2</span><span class="main">)</span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ptrs_key</span> <span class="main">(</span><span class="main">_</span>$<span class="entity">k</span>$<span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">k</span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">remove_term</span> <span class="entity">pt</span> <span class="entity">t</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span>
      <span class="entity">dfs_replace_atomic</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "Groups.times_class.times"<span class="antiquote">}</span></span> <span class="entity">pt</span> 
        <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted"><span class="keyword1">emp</span></span><span class="antiquote">}</span></span> <span class="entity">t</span> 
    <span class="keyword2"><span class="keyword">of</span></span>
      SOME <span class="entity">t'</span> <span class="main">=&gt;</span> <span class="entity">t'</span><span class="main">;</span>  

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">normalize</span> <span class="entity">t</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ep_tr</span> <span class="main">(</span><span class="entity">has_true</span><span class="main">,</span><span class="entity">ps</span><span class="main">,</span><span class="entity">ptrs</span><span class="main">)</span> <span class="entity">t</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span> 
        Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "Assertions.pure_assn"<span class="antiquote">}</span></span><span class="main">,</span><span class="main">_</span><span class="main">)</span>$<span class="main">_</span> 
        <span class="main">=&gt;</span> <span class="main">(</span><span class="main">(</span><span class="entity">has_true</span><span class="main">,</span><span class="entity">t</span>::<span class="entity">ps</span><span class="main">,</span><span class="entity">ptrs</span><span class="main">)</span><span class="main">,</span>NONE<span class="main">)</span>
      <span class="main">|</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "Assertions.sngr_assn"<span class="antiquote">}</span></span><span class="main">,</span><span class="main">_</span><span class="main">)</span>$<span class="main">_</span>$<span class="main">_</span> 
        <span class="main">=&gt;</span> <span class="main">(</span><span class="main">(</span><span class="entity">has_true</span><span class="main">,</span><span class="entity">ps</span><span class="main">,</span><span class="entity">t</span>::<span class="entity">ptrs</span><span class="main">)</span><span class="main">,</span>SOME <span class="entity">t</span><span class="main">)</span>
      <span class="main">|</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "Assertions.snga_assn"<span class="antiquote">}</span></span><span class="main">,</span><span class="main">_</span><span class="main">)</span>$<span class="main">_</span>$<span class="main">_</span>
        <span class="main">=&gt;</span> <span class="main">(</span><span class="main">(</span><span class="entity">has_true</span><span class="main">,</span><span class="entity">ps</span><span class="main">,</span><span class="entity">t</span>::<span class="entity">ptrs</span><span class="main">)</span><span class="main">,</span>SOME <span class="entity">t</span><span class="main">)</span>
      <span class="main">|</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "Orderings.top_class.top"<span class="antiquote">}</span></span><span class="main">,</span><span class="main">_</span><span class="main">)</span>
        <span class="main">=&gt;</span> <span class="main">(</span><span class="main">(</span>true<span class="main">,</span><span class="entity">ps</span><span class="main">,</span><span class="entity">ptrs</span><span class="main">)</span><span class="main">,</span>NONE<span class="main">)</span>
      <span class="main">|</span> <span class="main">(</span><span class="entity">inf_op</span> <span class="keyword1"><span class="keyword">as</span></span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "Lattices.inf_class.inf"<span class="antiquote">}</span></span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">)</span>$<span class="entity">t1</span>$<span class="entity">t2</span>
        <span class="main">=&gt;</span> <span class="main">(</span><span class="main">(</span><span class="entity">has_true</span><span class="main">,</span><span class="entity">ps</span><span class="main">,</span><span class="entity">ptrs</span><span class="main">)</span><span class="main">,</span>SOME <span class="main">(</span><span class="entity">inf_op</span>$<span class="entity">normalize</span> <span class="entity">t1</span>$<span class="entity">normalize</span> <span class="entity">t2</span><span class="main">)</span><span class="main">)</span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">(</span><span class="entity">has_true</span><span class="main">,</span><span class="entity">ps</span><span class="main">,</span><span class="entity">ptrs</span><span class="main">)</span><span class="main">,</span>SOME <span class="entity">t</span><span class="main">)</span><span class="main">;</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">normalizer</span> <span class="entity">t</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">dfs_opr</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "Groups.times_class.times"<span class="antiquote">}</span></span>
        <span class="entity">ep_tr</span> <span class="main">(</span>false<span class="main">,</span><span class="main">[</span><span class="main">]</span><span class="main">,</span><span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="entity">t</span> 
      <span class="keyword2"><span class="keyword">of</span></span> 
        <span class="main">(</span><span class="main">(</span><span class="entity">has_true</span><span class="main">,</span><span class="entity">ps</span><span class="main">,</span><span class="entity">ptrs</span><span class="main">)</span><span class="main">,</span><span class="entity">rt</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">(</span><span class="entity">has_true</span><span class="main">,</span>rev <span class="entity">ps</span><span class="main">,</span><span class="entity">ptrs</span><span class="main">)</span><span class="main">,</span><span class="entity">rt</span><span class="main">)</span><span class="main">;</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">normalize_core</span> <span class="entity">t</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span> 
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">has_true</span><span class="main">,</span><span class="entity">pures</span><span class="main">,</span><span class="entity">ptrs</span><span class="main">)</span><span class="main">,</span><span class="entity">rt</span><span class="main">)</span> <span class="main">=</span> <span class="entity">normalizer</span> <span class="entity">t</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">similar</span> <span class="main">=</span> <span class="entity">find_similar</span> <span class="entity">ptrs_key</span> <span class="entity">ptrs</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">true_t</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">has_true</span> <span class="keyword2"><span class="keyword">then</span></span> SOME <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"Assertions.top_assn"</span><span class="antiquote">}</span></span> 
          <span class="keyword2"><span class="keyword">else</span></span> NONE<span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pures'</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">pures</span> <span class="keyword2"><span class="keyword">of</span></span> 
            <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> NONE
          <span class="main">|</span> <span class="entity">p</span>::<span class="entity">ps</span> <span class="main">=&gt;</span> SOME <span class="main">(</span>fold <span class="entity">mk_star</span> <span class="entity">ps</span> <span class="entity">p</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">similar</span> <span class="keyword2"><span class="keyword">of</span></span> NONE <span class="main">=&gt;</span> the <span class="main">(</span><span class="entity">mk_star'</span> <span class="entity">pures'</span> <span class="main">(</span><span class="entity">mk_star'</span> <span class="entity">true_t</span> <span class="entity">rt</span><span class="main">)</span><span class="main">)</span>
        <span class="main">|</span> SOME <span class="main">(</span><span class="entity">t1</span><span class="main">,</span><span class="entity">t2</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t_stripped</span> <span class="main">=</span> <span class="entity">remove_term</span> <span class="entity">t1</span> <span class="main">(</span><span class="entity">remove_term</span> <span class="entity">t2</span> <span class="entity">t</span><span class="main">)</span><span class="main">;</span>
          <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">mk_star</span> <span class="entity">t_stripped</span> <span class="main">(</span><span class="entity">mk_star</span> <span class="entity">t1</span> <span class="entity">t2</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">skip_ex</span> <span class="main">(</span><span class="main">(</span><span class="entity">exq</span> <span class="keyword1"><span class="keyword">as</span></span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "ex_assn"<span class="antiquote">}</span></span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">)</span>$<span class="main">(</span>Abs <span class="main">(</span><span class="entity">n</span><span class="main">,</span><span class="entity">ty</span><span class="main">,</span><span class="entity">t</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
        <span class="entity">exq</span>$Abs <span class="main">(</span><span class="entity">n</span><span class="main">,</span><span class="entity">ty</span><span class="main">,</span><span class="entity">skip_ex</span> <span class="entity">t</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">skip_ex</span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">normalize_core</span> <span class="entity">t</span><span class="main">;</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">bs</span><span class="main">,</span><span class="entity">t'</span><span class="main">)</span> <span class="main">=</span> strip_abs <span class="entity">t</span><span class="main">;</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty</span> <span class="main">=</span> fastype_of1 <span class="main">(</span>map <span class="main">#</span><span class="inner_numeral">2</span> <span class="entity">bs</span><span class="main">,</span><span class="entity">t'</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">ty</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">assn</span><span class="antiquote">}</span></span> <span class="keyword2"><span class="keyword">then</span></span>
        Logic.rlist_abs <span class="main">(</span><span class="entity">bs</span><span class="main">,</span><span class="entity">skip_ex</span> <span class="entity">t'</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">t</span>
    <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

    <span class="comment1">(*val _ = tracing (tr_term redex);*)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">f</span><span class="main">,</span><span class="entity">terms</span><span class="main">)</span> <span class="main">=</span> strip_comb <span class="entity">redex</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">nterms</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">let</span></span>
        <span class="comment1">(*val _ = tracing (tr_term t); *)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t'</span><span class="main">=</span><span class="entity">normalize</span> <span class="entity">t</span><span class="main">;</span> 
        <span class="comment1">(*val _ = tracing (tr_term t');*)</span>
      <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">t'</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span> <span class="entity">terms</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">new_form</span> <span class="main">=</span> list_comb <span class="main">(</span><span class="entity">f</span><span class="main">,</span><span class="entity">nterms</span><span class="main">)</span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">res_ss</span> <span class="main">=</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt</span> addsimps <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> star_aci<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">result</span> <span class="main">=</span> Option.map <span class="main">(</span><span class="entity">export</span> o <span class="entity">mk_meta_eq</span><span class="main">)</span> <span class="main">(</span><span class="entity">Arith_Data.prove_conv_nohyps</span>
      <span class="main">[</span><span class="entity">simp_tac</span> <span class="entity">res_ss</span> <span class="inner_numeral">1</span><span class="main">]</span> <span class="entity">ctxt'</span> <span class="main">(</span><span class="entity">redex</span><span class="main">,</span><span class="entity">new_form</span><span class="main">)</span>
    <span class="main">)</span><span class="main">;</span>

  <span class="keyword2"><span class="keyword">in</span></span> 
    <span class="entity">result</span>
  <span class="keyword2"><span class="keyword">end</span></span> <span class="keyword3"><span class="keyword">handle</span></span> <span class="entity">exc</span> <span class="main">=&gt;</span>
    <span class="keyword2"><span class="keyword">if</span></span> Exn.is_interrupt <span class="entity">exc</span> <span class="keyword2"><span class="keyword">then</span></span> Exn.reraise <span class="entity">exc</span>
    <span class="keyword2"><span class="keyword">else</span></span>
      <span class="main">(</span>tracing <span class="main">(</span><span class="inner_quoted">"assn_simproc failed with exception\n:"</span> ^ Runtime.exn_message <span class="entity">exc</span><span class="main">)</span><span class="main">;</span>
        NONE<span class="main">)</span> <span class="comment1">(* Fail silently *)</span><span class="main">;</span>
  
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">assn_simproc</span> <span class="main">=</span>
    <span class="entity">Simplifier.make_simproc</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="inner_quoted">"assn_simproc"</span>
     <span class="main">{</span>lhss <span class="main">=</span>
      <span class="main">[</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="free">h</span> <span class="main">⊨</span> <span class="free">P</span>"</span><span class="antiquote">}</span></span><span class="main">,</span>
       <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="free">P</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">Q</span>"</span><span class="antiquote">}</span></span><span class="main">,</span>
       <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="free">P</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>t</sub></span> <span class="free">Q</span>"</span><span class="antiquote">}</span></span><span class="main">,</span>
       <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"Hoare_Triple.hoare_triple <span class="free">P</span> <span class="free">c</span> <span class="free">Q</span>"</span><span class="antiquote">}</span></span><span class="main">,</span>
       <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="main">(</span><span class="free">P</span><span class="main">::</span>assn<span class="main">)</span> <span class="main">=</span> <span class="free">Q</span>"</span><span class="antiquote">}</span></span><span class="main">]</span><span class="main">,</span>
      proc <span class="main">=</span> K <span class="entity">assn_simproc_fun</span><span class="main">}</span><span class="main">;</span>



  <span class="comment1">(***********************************)</span>
  <span class="comment1">(*     Default Simplifications     *)</span>
  <span class="comment1">(***********************************)</span>

  <span class="comment1">(* Default simplification. MUST contain assertion normalization!
    Tactic must not fail! *)</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dflt_tac</span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="entity">asm_full_simp_tac</span>
    <span class="main">(</span>put_simpset <span class="entity">HOL_ss</span> <span class="entity">ctxt</span>
      addsimprocs <span class="main">[</span><span class="entity">assn_simproc</span><span class="main">]</span> 
      addsimps <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> norm_assertion_simps<span class="antiquote">}</span></span></span>
      addsimps <span class="main">(</span><span class="entity">Named_Theorems.get</span> <span class="entity">ctxt</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">named_theorems</span> sep_dflt_simps<span class="antiquote">}</span></span><span class="main">)</span>
      |&gt; fold <span class="entity">Splitter.del_split</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> if_split<span class="antiquote">}</span></span></span>
    <span class="main">)</span><span class="main">;</span>

  <span class="comment1">(***********************************)</span>
  <span class="comment1">(*         Frame Matcher           *)</span>
  <span class="comment1">(***********************************)</span>

  <span class="comment1">(* Do frame matching
    imp_solve_tac - tactic used to discharge first assumption of match-rule
      cf. lemma FI_match.
  *)</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">match_frame_tac</span> <span class="entity">imp_solve_tac</span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span>
    <span class="comment1">(* Normalize star-lists *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">norm_tac</span> <span class="main">=</span> <span class="entity">simp_tac</span> <span class="main">(</span>
      put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt</span> addsimps <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> SLN_normalize<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">;</span>

    <span class="comment1">(* Strip star-lists *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">strip_tac</span> <span class="main">=</span> 
      <span class="entity">simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt</span> addsimps <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> SLN_strip<span class="antiquote">}</span></span></span><span class="main">)</span> THEN'
      <span class="entity">simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt</span> addsimps <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> SLN_def<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">;</span>

    <span class="comment1">(* Do a match step *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">match_tac</span> <span class="main">=</span> resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> FI_match<span class="antiquote">}</span></span></span> <span class="comment1">(* Separate p,q*)</span>
      THEN' SOLVED' <span class="entity">imp_solve_tac</span> <span class="comment1">(* Solve implication *)</span>
      THEN' <span class="entity">norm_tac</span><span class="main">;</span>

    <span class="comment1">(* Do a no-match step *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">nomatch_tac</span> <span class="main">=</span> resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> FI_p_nomatch<span class="antiquote">}</span></span></span> ORELSE' 
      <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> FI_q_nomatch<span class="antiquote">}</span></span></span> THEN' <span class="entity">norm_tac</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> FI_init<span class="antiquote">}</span></span></span> THEN' <span class="entity">norm_tac</span> 
    THEN' <span class="entity">REPEAT_DETERM'</span> <span class="main">(</span>FIRST' <span class="main">[</span>
      CHANGED o <span class="entity">dflt_tac</span> <span class="entity">ctxt</span><span class="main">,</span>
      <span class="main">(</span><span class="entity">match_tac</span> ORELSE' <span class="entity">nomatch_tac</span><span class="main">)</span><span class="main">]</span><span class="main">)</span>
    THEN' resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> FI_finalize<span class="antiquote">}</span></span></span> THEN' <span class="entity">strip_tac</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>


  <span class="comment1">(***********************************)</span>
  <span class="comment1">(*         Frame Inference         *)</span>
  <span class="comment1">(***********************************)</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">frame_inference_tac</span> <span class="entity">ctxt</span> <span class="main">=</span>
    resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> frame_inference_init<span class="antiquote">}</span></span></span> 
    THEN' <span class="entity">match_frame_tac</span> <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> ent_refl<span class="antiquote">}</span></span></span><span class="main">)</span> <span class="entity">ctxt</span>
    THEN' resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> frame_inference_finalize<span class="antiquote">}</span></span></span><span class="main">;</span>


  <span class="comment1">(***********************************)</span>
  <span class="comment1">(*       Entailment Solver         *)</span>
  <span class="comment1">(***********************************)</span>

  <span class="comment1">(* Extract existential quantifiers from entailment goal *)</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">extract_ex_tac</span> <span class="entity">ctxt</span> <span class="entity">i</span> <span class="entity">st</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">count_ex</span> <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Assertions.entails<span class="antiquote">}</span></span><span class="main">,</span><span class="main">_</span><span class="main">)</span>$<span class="main">_</span>$<span class="entity">c</span><span class="main">)</span> <span class="main">=</span> 
      <span class="entity">count_ex</span> <span class="entity">c</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> HOL.mp<span class="antiquote">}</span></span></span>
    <span class="main">|</span> <span class="entity">count_ex</span> <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Assertions.ex_assn<span class="antiquote">}</span></span><span class="main">,</span><span class="main">_</span><span class="main">)</span>$Abs <span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="main">_</span><span class="main">,</span><span class="entity">t</span><span class="main">)</span><span class="main">)</span>
      <span class="main">=</span> <span class="entity">count_ex</span> <span class="entity">t</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> enorm_exI'<span class="antiquote">}</span></span></span>
    <span class="main">|</span> <span class="entity">count_ex</span> <span class="main">_</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> imp_refl<span class="antiquote">}</span></span></span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">concl</span> <span class="main">=</span> Logic.concl_of_goal <span class="main">(</span>Thm.prop_of <span class="entity">st</span><span class="main">)</span> <span class="entity">i</span> |&gt; <span class="entity">HOLogic.dest_Trueprop</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm</span> <span class="main">=</span> <span class="entity">count_ex</span> <span class="entity">concl</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span>TRY o REPEAT_ALL_NEW <span class="main">(</span>match_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> ent_ex_preI<span class="antiquote">}</span></span></span><span class="main">)</span> THEN'
     resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">thm</span><span class="main">]</span><span class="main">)</span> <span class="entity">i</span> <span class="entity">st</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>


  <span class="comment1">(* Solve Entailment *)</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">solve_entails_tac</span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">preprocess_entails_tac</span> <span class="main">=</span> 
      <span class="entity">dflt_tac</span> <span class="entity">ctxt</span> 
      THEN' <span class="entity">extract_ex_tac</span> <span class="entity">ctxt</span>
      THEN' <span class="entity">simp_tac</span> 
        <span class="main">(</span>put_simpset <span class="entity">HOL_ss</span> <span class="entity">ctxt</span> addsimps <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> solve_ent_preprocess_simps<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">match_entails_tac</span> <span class="main">=</span>
      resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> entails_solve_init<span class="antiquote">}</span></span></span> 
      THEN' <span class="entity">match_frame_tac</span> <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> ent_refl<span class="antiquote">}</span></span></span><span class="main">)</span> <span class="entity">ctxt</span>
      THEN' resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> entails_solve_finalize<span class="antiquote">}</span></span></span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">preprocess_entails_tac</span>
    THEN' <span class="main">(</span>TRY o
      REPEAT_ALL_NEW <span class="main">(</span>match_tac <span class="entity">ctxt</span> <span class="main">(</span>rev <span class="main">(</span><span class="entity">Named_Theorems.get</span> <span class="entity">ctxt</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">named_theorems</span> sep_eintros<span class="antiquote">}</span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    THEN_ALL_NEW <span class="main">(</span><span class="entity">dflt_tac</span> <span class="entity">ctxt</span> THEN' 
      TRY o <span class="main">(</span>match_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> ent_triv<span class="antiquote">}</span></span></span> 
        ORELSE' resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> ent_refl<span class="antiquote">}</span></span></span>
        ORELSE' <span class="entity">match_entails_tac</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>


  <span class="comment1">(***********************************)</span>
  <span class="comment1">(* Verification Condition Generator*)</span>
  <span class="comment1">(***********************************)</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">heap_rule_tac</span> <span class="entity">ctxt</span> <span class="entity">h_thms</span> <span class="main">=</span> 
    resolve_tac <span class="entity">ctxt</span> <span class="entity">h_thms</span> ORELSE' <span class="main">(</span>
    resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> fi_rule<span class="antiquote">}</span></span></span> THEN' <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="entity">h_thms</span> <span class="entity">THEN_IGNORE_NEWGOALS</span>
    <span class="entity">frame_inference_tac</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">vcg_step_tac</span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">h_thms</span> <span class="main">=</span> rev <span class="main">(</span><span class="entity">Named_Theorems.get</span> <span class="entity">ctxt</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">named_theorems</span> sep_heap_rules<span class="antiquote">}</span></span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">d_thms</span> <span class="main">=</span> rev <span class="main">(</span><span class="entity">Named_Theorems.get</span> <span class="entity">ctxt</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">named_theorems</span> sep_decon_rules<span class="antiquote">}</span></span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">heap_rule_tac</span> <span class="main">=</span> <span class="entity">heap_rule_tac</span> <span class="entity">ctxt</span> <span class="entity">h_thms</span>

    <span class="comment1">(* Apply consequence rule if postcondition is not a schematic var *)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">app_post_cons_tac</span> <span class="entity">i</span> <span class="entity">st</span> <span class="main">=</span> 
      <span class="keyword2"><span class="keyword">case</span></span> Logic.concl_of_goal <span class="main">(</span>Thm.prop_of <span class="entity">st</span><span class="main">)</span> <span class="entity">i</span> |&gt; <span class="entity">HOLogic.dest_Trueprop</span> <span class="keyword2"><span class="keyword">of</span></span>
        Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Hoare_Triple.hoare_triple<span class="antiquote">}</span></span><span class="main">,</span><span class="main">_</span><span class="main">)</span>$<span class="main">_</span>$<span class="main">_</span>$<span class="entity">qt</span> <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">if</span></span> is_Var <span class="main">(</span>head_of <span class="entity">qt</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> no_tac <span class="entity">st</span>
          <span class="keyword2"><span class="keyword">else</span></span> resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> cons_post_rule<span class="antiquote">}</span></span></span> <span class="entity">i</span> <span class="entity">st</span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> no_tac <span class="entity">st</span><span class="main">;</span>

  <span class="keyword2"><span class="keyword">in</span></span>
    CSUBGOAL <span class="main">(</span>snd #&gt; <span class="main">(</span>FIRST' <span class="main">[</span>
      CHANGED o <span class="entity">dflt_tac</span> <span class="entity">ctxt</span><span class="main">,</span>
      REPEAT_ALL_NEW <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> normalize_rules<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">,</span>
      CHANGED o <span class="main">(</span>FIRST' <span class="main">[</span>resolve_tac <span class="entity">ctxt</span> <span class="entity">d_thms</span><span class="main">,</span> <span class="entity">heap_rule_tac</span><span class="main">]</span>
        ORELSE' <span class="main">(</span><span class="entity">app_post_cons_tac</span> THEN' 
          FIRST' <span class="main">[</span>resolve_tac <span class="entity">ctxt</span> <span class="entity">d_thms</span><span class="main">,</span> <span class="entity">heap_rule_tac</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> 
    <span class="main">]</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">vcg_tac</span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="entity">REPEAT_DETERM'</span> <span class="main">(</span><span class="entity">vcg_step_tac</span> <span class="entity">ctxt</span><span class="main">)</span>

  <span class="comment1">(***********************************)</span>
  <span class="comment1">(*        Automatic Solver         *)</span>
  <span class="comment1">(***********************************)</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">sep_autosolve_tac</span> <span class="entity">do_pre</span> <span class="entity">do_post</span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pre_tacs</span> <span class="main">=</span> <span class="main">[</span>
      CHANGED o <span class="entity">clarsimp_tac</span> <span class="entity">ctxt</span><span class="main">,</span>
      CHANGED o REPEAT_ALL_NEW <span class="main">(</span>match_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> ballI allI impI conjI<span class="antiquote">}</span></span></span><span class="main">)</span>
    <span class="main">]</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">main_tacs</span> <span class="main">=</span> <span class="main">[</span>
      match_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> is_hoare_triple<span class="antiquote">}</span></span></span> THEN' CHANGED o <span class="entity">vcg_tac</span> <span class="entity">ctxt</span><span class="main">,</span>
      match_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> is_entails<span class="antiquote">}</span></span></span> THEN' CHANGED o <span class="entity">solve_entails_tac</span> <span class="entity">ctxt</span>
    <span class="main">]</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">post_tacs</span> <span class="main">=</span> <span class="main">[</span>SELECT_GOAL <span class="main">(</span><span class="entity">auto_tac</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">]</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tacs</span> <span class="main">=</span> <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">do_pre</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">pre_tacs</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
      @ <span class="entity">main_tacs</span> 
      @ <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">do_post</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">post_tacs</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">REPEAT_DETERM'</span> <span class="main">(</span>CHANGED o FIRST' <span class="entity">tacs</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>


  <span class="comment1">(***********************************)</span>
  <span class="comment1">(*          Method Setup           *)</span>
  <span class="comment1">(***********************************)</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dflt_simps_modifiers</span> <span class="main">=</span> <span class="main">[</span>
    Args.$$$ <span class="inner_quoted">"dflt_simps"</span> -- Scan.option Args.add -- Args.colon 
      &gt;&gt; K <span class="main">(</span><span class="entity">Method.modifier</span> <span class="main">(</span><span class="entity">Named_Theorems.add</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">named_theorems</span> sep_dflt_simps<span class="antiquote">}</span></span><span class="main">)</span> <span class="antiquoted"><span class="operator"><span class="entity">⌂</span></span></span><span class="main">)</span><span class="main">,</span>
    Args.$$$ <span class="inner_quoted">"dflt_simps"</span> -- Scan.option Args.del -- Args.colon 
      &gt;&gt; K <span class="main">(</span><span class="entity">Method.modifier</span> <span class="main">(</span><span class="entity">Named_Theorems.del</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">named_theorems</span> sep_dflt_simps<span class="antiquote">}</span></span><span class="main">)</span> <span class="antiquoted"><span class="operator"><span class="entity">⌂</span></span></span><span class="main">)</span>
  <span class="main">]</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">heap_modifiers</span> <span class="main">=</span> <span class="main">[</span>
    Args.$$$ <span class="inner_quoted">"heap"</span> -- Scan.option Args.add -- Args.colon 
      &gt;&gt; K <span class="main">(</span><span class="entity">Method.modifier</span> <span class="main">(</span><span class="entity">Named_Theorems.add</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">named_theorems</span> sep_heap_rules<span class="antiquote">}</span></span><span class="main">)</span> <span class="antiquoted"><span class="operator"><span class="entity">⌂</span></span></span><span class="main">)</span><span class="main">,</span>
    Args.$$$ <span class="inner_quoted">"heap"</span> -- Scan.option Args.del -- Args.colon 
      &gt;&gt; K <span class="main">(</span><span class="entity">Method.modifier</span> <span class="main">(</span><span class="entity">Named_Theorems.del</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">named_theorems</span> sep_heap_rules<span class="antiquote">}</span></span><span class="main">)</span> <span class="antiquoted"><span class="operator"><span class="entity">⌂</span></span></span><span class="main">)</span>
  <span class="main">]</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">decon_modifiers</span> <span class="main">=</span> <span class="main">[</span>
    Args.$$$ <span class="inner_quoted">"decon"</span> -- Scan.option Args.add -- Args.colon 
      &gt;&gt; K <span class="main">(</span><span class="entity">Method.modifier</span> <span class="main">(</span><span class="entity">Named_Theorems.add</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">named_theorems</span> sep_decon_rules<span class="antiquote">}</span></span><span class="main">)</span> <span class="antiquoted"><span class="operator"><span class="entity">⌂</span></span></span><span class="main">)</span><span class="main">,</span>
    Args.$$$ <span class="inner_quoted">"decon"</span> -- Scan.option Args.del -- Args.colon 
      &gt;&gt; K <span class="main">(</span><span class="entity">Method.modifier</span> <span class="main">(</span><span class="entity">Named_Theorems.del</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">named_theorems</span> sep_decon_rules<span class="antiquote">}</span></span><span class="main">)</span> <span class="antiquoted"><span class="operator"><span class="entity">⌂</span></span></span><span class="main">)</span>
  <span class="main">]</span><span class="main">;</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eintros_modifiers</span> <span class="main">=</span> <span class="main">[</span>
    Args.$$$ <span class="inner_quoted">"eintros"</span> -- Scan.option Args.add -- Args.colon 
      &gt;&gt; K <span class="main">(</span><span class="entity">Method.modifier</span> <span class="main">(</span><span class="entity">Named_Theorems.add</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">named_theorems</span> sep_eintros<span class="antiquote">}</span></span><span class="main">)</span> <span class="antiquoted"><span class="operator"><span class="entity">⌂</span></span></span><span class="main">)</span><span class="main">,</span>
    Args.$$$ <span class="inner_quoted">"eintros"</span> -- Scan.option Args.del -- Args.colon 
      &gt;&gt; K <span class="main">(</span><span class="entity">Method.modifier</span> <span class="main">(</span><span class="entity">Named_Theorems.del</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">named_theorems</span> sep_eintros<span class="antiquote">}</span></span><span class="main">)</span> <span class="antiquoted"><span class="operator"><span class="entity">⌂</span></span></span><span class="main">)</span>
  <span class="main">]</span><span class="main">;</span>


  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">solve_entails_modifiers</span> <span class="main">=</span> <span class="entity">dflt_simps_modifiers</span> @ <span class="entity">eintros_modifiers</span><span class="main">;</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">vcg_modifiers</span> <span class="main">=</span> 
    <span class="entity">heap_modifiers</span> @ <span class="entity">decon_modifiers</span> @ <span class="entity">dflt_simps_modifiers</span><span class="main">;</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sep_auto_modifiers</span> <span class="main">=</span> 
    <span class="entity">clasimp_modifiers</span> @ <span class="entity">vcg_modifiers</span> @ <span class="entity">eintros_modifiers</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
›</span>

<span class="keyword1"><span class="command">simproc_setup</span></span> assn_simproc 
  <span class="main">(</span><span class="quoted"><span class="quoted">"<span class="free">h</span><span class="main">⊨</span><span class="free">P</span>"</span></span> <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">P</span><span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span><span class="free">Q</span>"</span></span> <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">P</span><span class="keyword1">⟹<span class="hidden">⇩</span><sub>t</sub></span><span class="free">Q</span>"</span></span> <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">P</span><span class="main">&gt;</span> <span class="free">c</span> <span class="main">&lt;</span><span class="free">R</span><span class="main">&gt;</span>"</span></span> <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">P</span><span class="main">::</span>assn<span class="main">)</span> <span class="main">=</span> <span class="free">Q</span>"</span></span><span class="main">)</span> 
  <span class="main">=</span> <span class="quoted">‹K <span class="entity">Seplogic_Auto.assn_simproc_fun</span>›</span>

<span class="keyword1"><span class="command">method_setup</span></span> assn_simp <span class="main">=</span><span class="quoted">‹Scan.succeed <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">SIMPLE_METHOD'</span> <span class="main">(</span>
  CHANGED o <span class="entity">Seplogic_Auto.dflt_tac</span> <span class="entity">ctxt</span>
<span class="main">)</span><span class="main">)</span><span class="main">)</span>›</span> <span class="quoted">"Seplogic: Simplification of assertions"</span>

<span class="keyword1"><span class="command">method_setup</span></span> frame_inference <span class="main">=</span> <span class="quoted">‹Scan.succeed <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">SIMPLE_METHOD'</span> <span class="main">(</span>
  CHANGED o <span class="entity">Seplogic_Auto.frame_inference_tac</span> <span class="entity">ctxt</span>
<span class="main">)</span><span class="main">)</span><span class="main">)</span>›</span> <span class="quoted">"Seplogic: Frame inference"</span>

<span class="keyword1"><span class="command">method_setup</span></span> solve_entails <span class="main">=</span> <span class="quoted">‹
  <span class="entity">Method.sections</span> <span class="entity">Seplogic_Auto.solve_entails_modifiers</span> &gt;&gt;
  <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> <span class="entity">SIMPLE_METHOD'</span> <span class="main">(</span>
  CHANGED o <span class="entity">Seplogic_Auto.solve_entails_tac</span> <span class="entity">ctxt</span>
<span class="main">)</span><span class="main">)</span>›</span> <span class="quoted">"Seplogic: Entailment Solver"</span>

<span class="keyword1"><span class="command">method_setup</span></span> heap_rule <span class="main">=</span> <span class="quoted">‹
  <span class="entity">Attrib.thms</span> &gt;&gt;
  <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">thms</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> <span class="entity">SIMPLE_METHOD'</span> <span class="main">(</span> 
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thms</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">thms</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> rev <span class="main">(</span><span class="entity">Named_Theorems.get</span> <span class="entity">ctxt</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">named_theorems</span> sep_heap_rules<span class="antiquote">}</span></span><span class="main">)</span>
        <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">thms</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      CHANGED o <span class="entity">Seplogic_Auto.heap_rule_tac</span> <span class="entity">ctxt</span> <span class="entity">thms</span>
    <span class="keyword2"><span class="keyword">end</span></span>
<span class="main">)</span><span class="main">)</span>›</span> <span class="quoted">"Seplogic: Apply rule with frame inference"</span>


<span class="keyword1"><span class="command">method_setup</span></span> vcg <span class="main">=</span> <span class="quoted">‹
  Scan.lift <span class="main">(</span>Args.mode <span class="inner_quoted">"ss"</span><span class="main">)</span> --
  <span class="entity">Method.sections</span> <span class="entity">Seplogic_Auto.vcg_modifiers</span> &gt;&gt;
  <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">ss</span><span class="main">,</span><span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> <span class="entity">SIMPLE_METHOD'</span> <span class="main">(</span>
  CHANGED o <span class="main">(</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">ss</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">Seplogic_Auto.vcg_step_tac</span> <span class="entity">ctxt</span> 
    <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">Seplogic_Auto.vcg_tac</span> <span class="entity">ctxt</span>
  <span class="main">)</span>
<span class="main">)</span><span class="main">)</span>›</span> <span class="quoted">"Seplogic: Verification Condition Generator"</span>

<span class="keyword1"><span class="command">method_setup</span></span> sep_auto <span class="main">=</span> 
  <span class="quoted">‹Scan.lift <span class="main">(</span>Args.mode <span class="inner_quoted">"nopre"</span> -- Args.mode <span class="inner_quoted">"nopost"</span> -- Args.mode <span class="inner_quoted">"plain"</span><span class="main">)</span> 
      --| <span class="entity">Method.sections</span> <span class="entity">Seplogic_Auto.sep_auto_modifiers</span> &gt;&gt;
  <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">nopre</span><span class="main">,</span><span class="entity">nopost</span><span class="main">)</span><span class="main">,</span><span class="entity">plain</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> <span class="entity">SIMPLE_METHOD'</span> <span class="main">(</span>
    CHANGED o <span class="entity">Seplogic_Auto.sep_autosolve_tac</span> 
      <span class="main">(</span><span class="main">(</span>not <span class="entity">nopre</span><span class="main">)</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="main">(</span>not <span class="entity">plain</span><span class="main">)</span><span class="main">)</span> 
      <span class="main">(</span><span class="main">(</span>not <span class="entity">nopost</span><span class="main">)</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="main">(</span>not <span class="entity">plain</span><span class="main">)</span><span class="main">)</span> <span class="entity">ctxt</span>
  <span class="main">)</span><span class="main">)</span>›</span> <span class="quoted">"Seplogic: Automatic solver"</span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">sep_dflt_simps</span><span class="main">]</span> <span class="main">=</span> split

<span class="keyword1"><span class="command">declare</span></span> deconstruct_rules<span class="main">[</span><span class="operator">sep_decon_rules</span><span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> heap_rules<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">sep_eintros</span><span class="main">]</span> <span class="main">=</span> impI conjI exI

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Semi-Automatic Reasoning›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In this section, we provide some lemmas for semi-automatic reasoning›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Forward reasoning with frame. Use <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>frame_inference›</span></span></span></span>-method 
  to discharge second assumption.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> ent_frame_fwd<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> R<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">R</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> F<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Ps</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">P</span><span class="main">*</span><span class="free">F</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> I<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">R</span><span class="main">*</span><span class="free">F</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">Q</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">Ps</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">Q</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> ent_refl ent_star_mono ent_trans<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> mod_frame_fwd<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> M<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">h</span><span class="main">⊨</span><span class="free">Ps</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> R<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span><span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span><span class="free">R</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> F<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Ps</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">P</span><span class="main">*</span><span class="free">F</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span><span class="main">⊨</span><span class="free">R</span><span class="main">*</span><span class="free">F</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> ent_star_mono entails_def<span class="main">)</span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Apply precision rule with frame inference.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> prec_frame<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> PREC<span class="main">:</span> <span class="quoted"><span class="quoted">"precise <span class="free">P</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> M1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">h</span><span class="main">⊨</span><span class="main">(</span><span class="free">R1</span> <span class="keyword1">∧<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">R2</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> F1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">R1</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">P</span> <span class="free">x</span> <span class="free">p</span> <span class="main">*</span> <span class="free">F1</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> F2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">R2</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">P</span> <span class="free">y</span> <span class="free">p</span> <span class="main">*</span> <span class="free">F2</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span><span class="main">=</span><span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> preciseD<span class="main">[</span><span class="operator">OF</span> PREC<span class="main">]</span> M1 F1 F2
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> entailsD mod_and_dist<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> prec_frame_expl<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> PREC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="main">(</span><span class="free">h</span><span class="main">⊨</span><span class="main">(</span><span class="free">P</span> <span class="bound">x</span> <span class="main">*</span> <span class="free">F1</span><span class="main">)</span> <span class="keyword1">∧<span class="hidden">⇩</span><sub>A</sub></span> <span class="main">(</span><span class="free">P</span> <span class="bound">y</span> <span class="main">*</span> <span class="free">F2</span><span class="main">)</span><span class="main">)</span> <span class="main">⟶</span> <span class="bound">x</span><span class="main">=</span><span class="bound">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> M1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">h</span><span class="main">⊨</span><span class="main">(</span><span class="free">R1</span> <span class="keyword1">∧<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">R2</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> F1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">R1</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">P</span> <span class="free">x</span> <span class="main">*</span> <span class="free">F1</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> F2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">R2</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">P</span> <span class="free">y</span> <span class="main">*</span> <span class="free">F2</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span><span class="main">=</span><span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> entailsD mod_and_dist<span class="main">)</span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Variant that is useful within induction proofs, where induction
  goes over <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>x›</span></span></span></span> or <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>y›</span></span></span></span>›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> prec_frame'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> PREC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">h</span><span class="main">⊨</span><span class="main">(</span><span class="free">P</span> <span class="free">x</span> <span class="main">*</span> <span class="free">F1</span><span class="main">)</span> <span class="keyword1">∧<span class="hidden">⇩</span><sub>A</sub></span> <span class="main">(</span><span class="free">P</span> <span class="free">y</span> <span class="main">*</span> <span class="free">F2</span><span class="main">)</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">x</span><span class="main">=</span><span class="free">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> M1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">h</span><span class="main">⊨</span><span class="main">(</span><span class="free">R1</span> <span class="keyword1">∧<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">R2</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> F1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">R1</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">P</span> <span class="free">x</span> <span class="main">*</span> <span class="free">F1</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> F2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">R2</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">P</span> <span class="free">y</span> <span class="main">*</span> <span class="free">F2</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span><span class="main">=</span><span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> entailsD mod_and_dist<span class="main">)</span>


<span class="keyword1"><span class="command">lemma</span></span> ent_wand_frameI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Q</span> <span class="main">-*</span> <span class="free">R</span><span class="main">)</span> <span class="main">*</span> <span class="free">F</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">F</span> <span class="main">*</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q</span><span class="main">*</span><span class="free">X</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">R</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">S</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> ent_frame_fwd ent_wandI mult.commute<span class="main">)</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Manual Frame Inference›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ent_true_drop<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="free">P</span><span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span><span class="free">Q</span><span class="main">*</span><span class="keyword1">true</span> <span class="main">⟹</span> <span class="free">P</span><span class="main">*</span><span class="free">R</span><span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span><span class="free">Q</span><span class="main">*</span><span class="keyword1">true</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">P</span><span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span><span class="free">Q</span> <span class="main">⟹</span> <span class="free">P</span><span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span><span class="free">Q</span><span class="main">*</span><span class="keyword1">true</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> assn_times_comm ent_star_mono ent_true merge_true_star_ctx<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> assn_one_left ent_star_mono ent_true star_aci<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> fr_refl<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span><span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span><span class="free">B</span> <span class="main">⟹</span> <span class="free">A</span><span class="main">*</span><span class="free">C</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span><span class="free">B</span><span class="main">*</span><span class="free">C</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> ent_star_mono ent_refl<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> fr_rot<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">A</span><span class="main">*</span><span class="free">B</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">C</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">B</span><span class="main">*</span><span class="free">A</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">C</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assn_aci<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> fr_rot_rhs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">A</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">B</span><span class="main">*</span><span class="free">C</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">A</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">C</span><span class="main">*</span><span class="free">B</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assn_aci<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ent_star_mono_true<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">A'</span> <span class="main">*</span> <span class="keyword1">true</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">B'</span> <span class="main">*</span> <span class="keyword1">true</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span><span class="main">*</span><span class="free">B</span><span class="main">*</span><span class="keyword1">true</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">A'</span><span class="main">*</span><span class="free">B'</span><span class="main">*</span><span class="keyword1">true</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> ent_star_mono<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">using</span></span> ent_true_drop<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> ent_refl_true<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">A</span> <span class="main">*</span> <span class="keyword1">true</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ent_true_drop<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span> 
    
<span class="keyword1"><span class="command">lemma</span></span> entt_fr_refl<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">F</span><span class="keyword1">⟹<span class="hidden">⇩</span><sub>t</sub></span><span class="free">F'</span> <span class="main">⟹</span> <span class="free">F</span><span class="main">*</span><span class="free">A</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>t</sub></span> <span class="free">F'</span><span class="main">*</span><span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> entt_star_mono<span class="main">)</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">lemma</span></span> entt_fr_drop<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">F</span><span class="keyword1">⟹<span class="hidden">⇩</span><sub>t</sub></span><span class="free">F'</span> <span class="main">⟹</span> <span class="free">F</span><span class="main">*</span><span class="free">A</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>t</sub></span> <span class="free">F'</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> ent_true_drop<span class="main">(</span>1<span class="main">)</span> enttD enttI <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span> 
    
    
<span class="keyword1"><span class="command">method_setup</span></span> fr_rot <span class="main">=</span> <span class="quoted">‹
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rot_tac</span> <span class="entity">ctxt</span> <span class="main">=</span> 
      resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> fr_rot<span class="antiquote">}</span></span></span> THEN'
      <span class="entity">simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt</span> 
        addsimps <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> star_assoc<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span><span class="antiquote">}</span></span></span><span class="main">)</span>

  <span class="keyword2"><span class="keyword">in</span></span>
    Scan.lift Parse.nat &gt;&gt; 
      <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">n</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> <span class="entity">SIMPLE_METHOD'</span> <span class="main">(</span>
        <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">i</span> <span class="main">=&gt;</span> REPEAT_DETERM_N <span class="entity">n</span> <span class="main">(</span><span class="entity">rot_tac</span> <span class="entity">ctxt</span> <span class="entity">i</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

  <span class="keyword2"><span class="keyword">end</span></span>
›</span>

<span class="keyword1"><span class="command">method_setup</span></span> fr_rot_rhs <span class="main">=</span> <span class="quoted">‹
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rot_tac</span> <span class="entity">ctxt</span> <span class="main">=</span> 
      resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> fr_rot_rhs<span class="antiquote">}</span></span></span> THEN'
      <span class="entity">simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt</span> 
        addsimps <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> star_assoc<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span><span class="antiquote">}</span></span></span><span class="main">)</span>

  <span class="keyword2"><span class="keyword">in</span></span>
    Scan.lift Parse.nat &gt;&gt; 
      <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">n</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> <span class="entity">SIMPLE_METHOD'</span> <span class="main">(</span>
        <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">i</span> <span class="main">=&gt;</span> REPEAT_DETERM_N <span class="entity">n</span> <span class="main">(</span><span class="entity">rot_tac</span> <span class="entity">ctxt</span> <span class="entity">i</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

  <span class="keyword2"><span class="keyword">end</span></span>
›</span>



<span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Test Cases›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="free">A</span> <span class="bound">x</span> <span class="main">*</span> <span class="keyword1">true</span> <span class="main">*</span> <span class="free">Q</span> <span class="bound">x</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="keyword1">true</span> <span class="main">*</span> <span class="free">A</span> <span class="bound">x</span> <span class="main">*</span> <span class="free">Q</span> <span class="bound">x</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">*</span> <span class="main">(</span><span class="keyword1">true</span> <span class="main">*</span> <span class="free">B</span><span class="main">)</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="keyword1">true</span> <span class="main">*</span> <span class="free">A</span> <span class="main">*</span> <span class="free">B</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span><span class="main">⊨</span><span class="keyword1">true</span><span class="main">*</span><span class="free">P</span><span class="main">*</span><span class="keyword1">true</span> <span class="main">⟷</span> <span class="free">h</span><span class="main">⊨</span><span class="free">P</span><span class="main">*</span><span class="keyword1">true</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">*</span> <span class="keyword1">true</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="free">b</span> <span class="main">∧</span> <span class="free">c</span><span class="main">)</span> <span class="main">*</span> <span class="keyword1">true</span> <span class="main">*</span> <span class="free">B</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="main">↑</span><span class="free">b</span> <span class="main">*</span> <span class="main">↑</span><span class="free">c</span> <span class="main">*</span> <span class="keyword1">true</span> <span class="main">*</span><span class="free">A</span> <span class="main">*</span> <span class="free">B</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">y</span> <span class="bound">c</span><span class="main">.</span> <span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span> <span class="main">*</span> <span class="main">(</span><span class="free">R</span> <span class="bound">x</span> <span class="main">*</span> <span class="free">Q</span> <span class="bound">y</span><span class="main">)</span> <span class="main">*</span> <span class="main">↑</span> <span class="main">(</span><span class="free">b</span> <span class="main">∧</span> <span class="bound">c</span><span class="main">)</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="main">(</span><span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">x</span><span class="main">.</span> <span class="main">↑</span><span class="free">b</span> <span class="main">*</span> <span class="main">(</span><span class="free">P</span> <span class="bound">x</span> <span class="main">*</span> <span class="main">(</span><span class="free">R</span> <span class="bound">x</span> <span class="main">*</span> <span class="free">Q</span> <span class="bound">y</span><span class="main">)</span> <span class="main">*</span> <span class="main">↑</span><span class="bound">c</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">*</span> <span class="free">B</span> <span class="main">*</span> <span class="main">(</span><span class="main">↑</span><span class="free">c</span> <span class="main">*</span> <span class="free">B</span> <span class="main">*</span> <span class="free">C</span> <span class="main">*</span> <span class="free">D</span> <span class="main">*</span> <span class="main">↑</span><span class="free">a</span> <span class="main">*</span> <span class="keyword1">true</span> <span class="main">*</span> <span class="main">↑</span><span class="free">d</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span><span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">x</span><span class="main">.</span> <span class="free">E</span> <span class="bound">x</span> <span class="main">*</span> <span class="free">F</span> <span class="main">*</span> <span class="main">↑</span><span class="free">b</span><span class="main">)</span> <span class="main">*</span> <span class="keyword1">true</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="main">(</span><span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">x</span><span class="main">.</span> <span class="main">↑</span> <span class="main">(</span><span class="free">c</span> <span class="main">∧</span> <span class="free">a</span> <span class="main">∧</span> <span class="free">d</span> <span class="main">∧</span> <span class="free">b</span><span class="main">)</span> <span class="main">*</span>
          <span class="keyword1">true</span> <span class="main">*</span> <span class="free">A</span> <span class="main">*</span> <span class="free">B</span> <span class="main">*</span> <span class="main">(</span><span class="keyword1">true</span> <span class="main">*</span> <span class="free">B</span> <span class="main">*</span> <span class="free">C</span> <span class="main">*</span> <span class="free">D</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span><span class="free">E</span> <span class="bound">x</span> <span class="main">*</span> <span class="free">F</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">P</span><span class="main">&gt;</span> <span class="free">c</span> <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">r</span> <span class="main">*</span> <span class="keyword1">true</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="free">b</span> <span class="bound">r</span><span class="main">)</span> <span class="main">*</span> <span class="keyword1">true</span> <span class="main">*</span> <span class="main">↑</span><span class="free">a</span><span class="main">&gt;</span> 
  <span class="main">⟷</span> <span class="main">&lt;</span><span class="free">P</span><span class="main">&gt;</span> <span class="free">c</span> <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">r</span> <span class="main">*</span> <span class="keyword1">true</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="free">b</span> <span class="bound">r</span> <span class="main">∧</span> <span class="free">a</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">h</span><span class="main">⊨</span><span class="main">(</span><span class="main">(</span><span class="free">A</span><span class="main">*</span><span class="free">B</span><span class="main">*</span><span class="main">↑</span><span class="free">b</span><span class="main">*</span><span class="keyword1">true</span><span class="main">*</span><span class="main">↑</span><span class="free">c</span><span class="main">*</span><span class="keyword1">true</span><span class="main">)</span> <span class="keyword1">∧<span class="hidden">⇩</span><sub>A</sub></span> <span class="main">(</span><span class="main">↑</span><span class="main">(</span><span class="free">p</span><span class="main">=</span><span class="free">q</span><span class="main">)</span><span class="main">*</span><span class="free">P</span><span class="main">*</span><span class="free">Q</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
  <span class="main">⟷</span> <span class="free">h</span> <span class="main">⊨</span> <span class="free">A</span> <span class="main">*</span> <span class="free">B</span> <span class="main">*</span> <span class="keyword1">true</span> <span class="keyword1">∧<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">P</span> <span class="main">*</span> <span class="free">Q</span> <span class="main">∧</span> <span class="free">b</span> <span class="main">∧</span> <span class="free">c</span> <span class="main">∧</span> <span class="free">p</span> <span class="main">=</span> <span class="free">q</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"FI_RESULT <span class="main">[</span><span class="main">(</span><span class="free">B</span><span class="main">,</span> <span class="free">B</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="free">A</span><span class="main">,</span> <span class="free">A</span><span class="main">)</span><span class="main">]</span> <span class="free">C</span> <span class="free">D</span> <span class="free">F</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"FI_QUERY <span class="main">(</span><span class="free">A</span><span class="main">*</span><span class="free">B</span><span class="main">*</span><span class="free">C</span><span class="main">)</span> <span class="main">(</span><span class="free">D</span><span class="main">*</span><span class="free">B</span><span class="main">*</span><span class="free">A</span><span class="main">)</span> <span class="free">F</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">tactic</span> <span class="quoted">‹<span class="entity">Seplogic_Auto.match_frame_tac</span> 
    <span class="main">(</span>resolve_tac <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> ent_refl<span class="antiquote">}</span></span></span><span class="main">)</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="inner_numeral">1</span>›</span><span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> assms<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"FI_RESULT <span class="main">[</span><span class="main">(</span><span class="free">B</span><span class="main">,</span><span class="free">B</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="free">A</span><span class="main">,</span><span class="free">A</span><span class="main">)</span><span class="main">]</span> <span class="free">C</span> <span class="keyword1">emp</span> <span class="free">F</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"FI_QUERY <span class="main">(</span><span class="free">A</span><span class="main">*</span><span class="free">B</span><span class="main">*</span><span class="free">C</span><span class="main">)</span> <span class="main">(</span><span class="free">B</span><span class="main">*</span><span class="free">A</span><span class="main">)</span> <span class="free">F</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">tactic</span> <span class="quoted">‹<span class="entity">Seplogic_Auto.match_frame_tac</span> 
    <span class="main">(</span>resolve_tac <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> ent_refl<span class="antiquote">}</span></span></span><span class="main">)</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="inner_numeral">1</span>›</span><span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> assms<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"FI_RESULT <span class="main">[</span><span class="main">(</span><span class="free">B</span><span class="main">,</span> <span class="free">B</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="free">A</span><span class="main">,</span> <span class="free">A</span><span class="main">)</span><span class="main">]</span> <span class="keyword1">emp</span> <span class="keyword1">emp</span> <span class="free">F</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"FI_QUERY <span class="main">(</span><span class="free">A</span><span class="main">*</span><span class="free">B</span><span class="main">)</span> <span class="main">(</span><span class="free">B</span><span class="main">*</span><span class="free">A</span><span class="main">)</span> <span class="free">F</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">tactic</span> <span class="quoted">‹<span class="entity">Seplogic_Auto.match_frame_tac</span> 
    <span class="main">(</span>resolve_tac <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> ent_refl<span class="antiquote">}</span></span></span><span class="main">)</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="inner_numeral">1</span>›</span><span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> assms<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"FI_RESULT <span class="main">[</span><span class="main">(</span><span class="free">A</span><span class="main">,</span> <span class="free">A</span><span class="main">)</span><span class="main">]</span> <span class="keyword1">emp</span> <span class="keyword1">emp</span> <span class="free">F</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"FI_QUERY <span class="main">(</span><span class="free">A</span><span class="main">)</span> <span class="main">(</span><span class="free">A</span><span class="main">)</span> <span class="free">F</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">tactic</span> <span class="quoted">‹<span class="entity">Seplogic_Auto.match_frame_tac</span> 
    <span class="main">(</span>resolve_tac <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> ent_refl<span class="antiquote">}</span></span></span><span class="main">)</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="inner_numeral">1</span>›</span><span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> assms<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"FI_RESULT <span class="main">[</span><span class="main">(</span><span class="free">A</span><span class="main">,</span> <span class="free">A</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span><span class="free">B</span> <span class="main">*</span> <span class="free">C</span> <span class="main">*</span> <span class="free">D</span><span class="main">)</span> <span class="keyword1">emp</span> <span class="free">F</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"FI_QUERY <span class="main">(</span><span class="free">B</span><span class="main">*</span><span class="free">C</span><span class="main">*</span><span class="free">D</span><span class="main">*</span><span class="free">A</span><span class="main">)</span> <span class="main">(</span><span class="free">A</span><span class="main">)</span> <span class="free">F</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">tactic</span> <span class="quoted">‹<span class="entity">Seplogic_Auto.match_frame_tac</span> 
    <span class="main">(</span>resolve_tac <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> ent_refl<span class="antiquote">}</span></span></span><span class="main">)</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="inner_numeral">1</span>›</span><span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> assms<span class="main">)</span>


<span class="keyword1"><span class="command">schematic_goal</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">P1</span> <span class="main">*</span> <span class="free">P2</span> <span class="main">*</span> <span class="free">P3</span> <span class="main">*</span> <span class="free">P4</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">P3</span> <span class="main">*</span> <span class="var">?R1</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">P1</span> <span class="main">*</span> <span class="main">(</span><span class="free">P2</span> <span class="main">*</span> <span class="main">(</span><span class="free">P3</span> <span class="main">*</span> <span class="free">P4</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">P1</span> <span class="main">*</span> <span class="var">?R2</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">P4</span> <span class="main">*</span> <span class="main">(</span><span class="free">P2</span> <span class="main">*</span> <span class="main">(</span><span class="free">P1</span> <span class="main">*</span> <span class="free">P3</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">P1</span> <span class="main">*</span> <span class="var">?R2'</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">P1</span> <span class="main">*</span> <span class="free">P2</span> <span class="main">*</span> <span class="free">P3</span> <span class="main">*</span> <span class="free">P4</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">P4</span> <span class="main">*</span> <span class="var">?R3</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">P1</span> <span class="main">*</span> <span class="free">P2</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">P1</span> <span class="main">*</span> <span class="var">?R4</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">P1</span> <span class="main">*</span> <span class="free">P2</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">P2</span> <span class="main">*</span> <span class="var">?R5</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">P1</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">P1</span> <span class="main">*</span> <span class="var">?R6</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">P1</span> <span class="main">*</span> <span class="free">P2</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="keyword1">emp</span> <span class="main">*</span> <span class="var">?R7</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">frame_inference</span><span class="main"><span class="keyword3">+</span></span>


<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">A</span><span class="main">;</span> <span class="free">B</span><span class="main">;</span> <span class="free">C</span><span class="main">;</span> <span class="free">b</span> <span class="numeral">17</span><span class="main">⟧</span> <span class="main">⟹</span> 
  <span class="free">Q</span> <span class="main">1</span> <span class="numeral">5</span> <span class="numeral">3</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="main">(</span><span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">x</span> <span class="bound">y</span> <span class="bound">z</span><span class="main">.</span> <span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">a</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">x</span> <span class="bound">y</span> <span class="bound">z</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="free">b</span> <span class="bound">a</span><span class="main">)</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="bound">y</span><span class="main">=</span><span class="numeral">5</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">solve_entails</span>

<span class="keyword1"><span class="command">thm</span></span> nth_rule
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">P</span> <span class="main">*</span> <span class="free">x</span><span class="keyword1">↦<span class="hidden">⇩</span><sub>a</sub></span><span class="main">[</span><span class="main">1</span><span class="main">,</span><span class="numeral">2</span><span class="main">,</span><span class="numeral">3</span><span class="main">]</span><span class="main">&gt;</span> 
  <span class="keyword1">do</span> <span class="main">{</span> <span class="bound">v</span><span class="main">←</span>Array.nth <span class="free">x</span> <span class="main">1</span><span class="main">;</span> return <span class="bound">v</span> <span class="main">}</span> 
  <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="free">P</span> <span class="main">*</span> <span class="free">x</span><span class="keyword1">↦<span class="hidden">⇩</span><sub>a</sub></span><span class="main">[</span><span class="main">1</span><span class="main">,</span><span class="numeral">2</span><span class="main">,</span><span class="numeral">3</span><span class="main">]</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="bound">r</span><span class="main">=</span><span class="numeral">2</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sep_auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Quick Overview of Proof Methods›</span></span> 
  <span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:auto:overview}›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  In this section, we give a quick overview of the available proof methods 
  and options. The most versatile proof method that we provide is
  <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sep_auto›</span></span></span></span>. It tries to solve the first subgoal, invoking appropriate
  proof methods as required. If it cannot solve the subgoal completely, it
  stops at the intermediate state that it could not handle any more. 

  <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sep_auto›</span></span></span></span> can be configured by 
  section-arguments for the simplifier, the classical reasoner, and all
  section-arguments for the verification condition generator and 
  entailment solver. Moreover, it takes an optional mode argument (mode), where
  valid modes are:
  \begin{description}
    \item[(nopre)] No preprocessing of goal. The preprocessor tries to clarify
      and simplify the goal before the main method is invoked.
    \item[(nopost)] No postprocessing of goal. The postprocessor tries to 
      solve or simplify goals left over by verification condition generation or
      entailment solving.
    \item[(plain)] Neither pre- nor postprocessing. Just applies vcg and 
      entailment solver.  
  \end{description}

  \paragraph{Entailment Solver.} The entailment solver processes goals of the
  form <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>P ⟹<span class="hidden">⇩</span><sub>A</sub> Q›</span></span></span></span>. It is invoked by the method <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>solve_entails›</span></span></span></span>.
  It first tries to pull out pure parts of
  <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>P›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Q›</span></span></span></span>. This may introduce quantifiers, conjunction,
  and implication into the goal, that are eliminated by resolving with rules
  declared as <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sep_eintros›</span></span></span></span> (method argument: eintros[add/del]:).
  Moreover, it simplifies with rules declared as <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sep_dflt_simps›</span></span></span></span> 
  (section argument: <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>dflt_simps[add/del]:›</span></span></span></span>).

  Now, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>P›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Q›</span></span></span></span> should have the form <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>X<span class="hidden">⇩</span><sub>1</sub>*…*X<span class="hidden">⇩</span><sub>n</sub>›</span></span></span></span>.
  Then, the frame-matcher is used to match all items of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>P›</span></span></span></span> with items
  of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Q›</span></span></span></span>, and thus solve the implication. Matching is currently done 
  syntactically, but can instantiate schematic variables.

  Note that, by default, existential introduction is declared as 
  <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sep_eintros›</span></span></span></span>-rule. This introduces schematic variables, that can
  later be matched against. However, in some cases, the matching may instantiate
  the schematic variables in an undesired way. In this case, the argument 
  <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>eintros del: exI›</span></span></span></span> should be passed to the entailment solver, and
  the existential quantifier should be instantiated manually.

  \paragraph{Frame Inference}
  The method <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>frame_inference›</span></span></span></span> tries to solve a goal of the 
  form <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>P⟹Q*?F›</span></span></span></span>, by matching <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Q›</span></span></span></span> against the parts of 
  <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>P›</span></span></span></span>, and instantiating <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>?F›</span></span></span></span> accordingly. 
  Matching is done syntactically, possibly 
  instantiating schematic variables. <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>P›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Q›</span></span></span></span> should be 
  assertions separated by <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>*›</span></span></span></span>. Note that frame inference does no 
  simplification or other kinds of normalization.

  The method <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>heap_rule›</span></span></span></span> applies the specified heap rules, using
  frame inference if necessary. If no rules are specified, the default 
  heap rules are used.

  \paragraph{Verification Condition Generator}
  The verification condition generator processes goals of the form 
  <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>&lt;P&gt;c&lt;Q&gt;›</span></span></span></span>. It is invoked by the method <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>vcg›</span></span></span></span>.
  First, it tries to pull out pure parts and simplifies with
  the default simplification rules. Then, it tries to resolve the goal with
  deconstruct rules (attribute: <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sep_decon_rules›</span></span></span></span>, 
  section argument: <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>decon[add/del]:›</span></span></span></span>), and if this does not succeed, 
  it tries
  to resolve the goal with heap rules (attribute: <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sep_heap_rules›</span></span></span></span>, 
  section argument: <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>heap[add/del]:›</span></span></span></span>), using the frame rule and 
  frame inference.
  If resolving is not possible, it also tries to apply the consequence rule to
  make the postcondition a schematic variable.
›</span></span>


<span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Hiding of internal stuff›</span></span>
<span class="keyword1"><span class="command">hide_const</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> FI SLN
<span class="comment1">(*&gt;*)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Sep_Main">
<div class="head">
<h1>Theory Sep_Main</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Separation Logic Framework Entrypoint›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Sep_Main
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Automation.html">Automation</a>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Import this theory to make available Imperative/HOL with 
    separation logic.›</span></span>
<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Imp_List_Spec">
<div class="head">
<h1>Theory Imp_List_Spec</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Interface for Lists›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Imp_List_Spec
<span class="keyword2"><span class="keyword">imports</span></span> <span class="quoted">"<a href="Sep_Main.html">../Sep_Main</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  This file specifies an abstract interface for list data structures. It can
  be implemented by concrete list data structures, as demonstrated in the open
  and circular singly linked list examples.
›</span></span>

<span class="keyword1"><span class="command">locale</span></span> imp_list <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">is_list</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'l</span> <span class="main">⇒</span> assn"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> precise<span class="main">:</span> <span class="quoted"><span class="quoted">"precise <span class="free">is_list</span>"</span></span>
    <span class="comment1">(*"∀l l'. h⊨(is_list l p * F1) ∧<span class="hidden">⇩</span><sub>A</sub> (is_list l' p * F2) ⟶ l=l'"*)</span>

<span class="keyword1"><span class="command">locale</span></span> imp_list_empty <span class="main">=</span> imp_list <span class="main">+</span>
  <span class="keyword2"><span class="keyword">constrains</span></span> is_list <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'l</span> <span class="main">⇒</span> assn"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">empty</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'l</span> Heap"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> empty_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="keyword1">emp</span><span class="main">&gt;</span> <span class="free">empty</span> <span class="main">&lt;</span><span class="free">is_list</span> <span class="main">[]</span><span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> imp_list_is_empty <span class="main">=</span> imp_list <span class="main">+</span>
  <span class="keyword2"><span class="keyword">constrains</span></span> is_list <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'l</span> <span class="main">⇒</span> assn"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">is_empty</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'l</span> <span class="main">⇒</span> bool Heap"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> is_empty_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">is_list</span> <span class="free">l</span> <span class="free">p</span><span class="main">&gt;</span> <span class="free">is_empty</span> <span class="free">p</span> <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="free">is_list</span> <span class="free">l</span> <span class="free">p</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="bound">r</span> <span class="main">⟷</span> <span class="free">l</span><span class="main">=</span><span class="main">[]</span><span class="main">)</span><span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> imp_list_append <span class="main">=</span> imp_list <span class="main">+</span>
  <span class="keyword2"><span class="keyword">constrains</span></span> is_list <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'l</span> <span class="main">⇒</span> assn"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">append</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'l</span> <span class="main">⇒</span> <span class="tfree">'l</span> Heap"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> append_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">is_list</span> <span class="free">l</span> <span class="free">p</span><span class="main">&gt;</span> <span class="free">append</span> <span class="free">a</span> <span class="free">p</span> <span class="main">&lt;</span><span class="free">is_list</span> <span class="main">(</span><span class="free">l</span><span class="main">@</span><span class="main">[</span><span class="free">a</span><span class="main">]</span><span class="main">)</span><span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> imp_list_prepend <span class="main">=</span> imp_list <span class="main">+</span>
  <span class="keyword2"><span class="keyword">constrains</span></span> is_list <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'l</span> <span class="main">⇒</span> assn"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">prepend</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'l</span> <span class="main">⇒</span> <span class="tfree">'l</span> Heap"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> prepend_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">is_list</span> <span class="free">l</span> <span class="free">p</span><span class="main">&gt;</span> <span class="free">prepend</span> <span class="free">a</span> <span class="free">p</span> <span class="main">&lt;</span><span class="free">is_list</span> <span class="main">(</span><span class="free">a</span><span class="main">#</span><span class="free">l</span><span class="main">)</span><span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>
    
<span class="keyword1"><span class="command">locale</span></span> imp_list_head <span class="main">=</span> imp_list <span class="main">+</span>
  <span class="keyword2"><span class="keyword">constrains</span></span> is_list <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'l</span> <span class="main">⇒</span> assn"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">head</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'l</span> <span class="main">⇒</span> <span class="tfree">'a</span> Heap"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> head_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="free">l</span><span class="main">≠</span><span class="main">[]</span> <span class="main">⟹</span> <span class="main">&lt;</span><span class="free">is_list</span> <span class="free">l</span> <span class="free">p</span><span class="main">&gt;</span> <span class="free">head</span> <span class="free">p</span> <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="free">is_list</span> <span class="free">l</span> <span class="free">p</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="bound">r</span><span class="main">=</span>hd <span class="free">l</span><span class="main">)</span><span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> imp_list_pop <span class="main">=</span> imp_list <span class="main">+</span>
  <span class="keyword2"><span class="keyword">constrains</span></span> is_list <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'l</span> <span class="main">⇒</span> assn"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">pop</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'l</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">×</span><span class="tfree">'l</span><span class="main">)</span> Heap"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> pop_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="free">l</span><span class="main">≠</span><span class="main">[]</span> <span class="main">⟹</span> 
      <span class="main">&lt;</span><span class="free">is_list</span> <span class="free">l</span> <span class="free">p</span><span class="main">&gt;</span> 
      <span class="free">pop</span> <span class="free">p</span> 
      <span class="main">&lt;</span><span class="main">λ</span><span class="main">(</span><span class="bound">r</span><span class="main">,</span><span class="bound">p'</span><span class="main">)</span><span class="main">.</span> <span class="free">is_list</span> <span class="main">(</span>tl <span class="free">l</span><span class="main">)</span> <span class="bound">p'</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="bound">r</span><span class="main">=</span>hd <span class="free">l</span><span class="main">)</span><span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> imp_list_rotate <span class="main">=</span> imp_list <span class="main">+</span>
  <span class="keyword2"><span class="keyword">constrains</span></span> is_list <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'l</span> <span class="main">⇒</span> assn"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">rotate</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'l</span> <span class="main">⇒</span> <span class="tfree">'l</span> Heap"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> rotate_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">is_list</span> <span class="free">l</span> <span class="free">p</span><span class="main">&gt;</span> <span class="free">rotate</span> <span class="free">p</span> <span class="main">&lt;</span><span class="free">is_list</span> <span class="main">(</span>rotate1 <span class="free">l</span><span class="main">)</span><span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> imp_list_reverse <span class="main">=</span> imp_list <span class="main">+</span>
  <span class="keyword2"><span class="keyword">constrains</span></span> is_list <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'l</span> <span class="main">⇒</span> assn"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">reverse</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'l</span> <span class="main">⇒</span> <span class="tfree">'l</span> Heap"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> reverse_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">is_list</span> <span class="free">l</span> <span class="free">p</span><span class="main">&gt;</span> <span class="free">reverse</span> <span class="free">p</span> <span class="main">&lt;</span><span class="free">is_list</span> <span class="main">(</span>rev <span class="free">l</span><span class="main">)</span><span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> imp_list_iterate <span class="main">=</span> imp_list <span class="main">+</span>
  <span class="keyword2"><span class="keyword">constrains</span></span> is_list <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'l</span> <span class="main">⇒</span> assn"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">is_it</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'l</span> <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'it</span> <span class="main">⇒</span> assn"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">it_init</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'l</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'it</span><span class="main">)</span> Heap"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">it_has_next</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'it</span> <span class="main">⇒</span> bool Heap"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">it_next</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'it</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">×</span><span class="tfree">'it</span><span class="main">)</span> Heap"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> it_init_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">is_list</span> <span class="free">l</span> <span class="free">p</span><span class="main">&gt;</span> <span class="free">it_init</span> <span class="free">p</span> <span class="main">&lt;</span><span class="free">is_it</span> <span class="free">l</span> <span class="free">p</span> <span class="free">l</span><span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> it_next_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">l'</span><span class="main">≠</span><span class="main">[]</span> <span class="main">⟹</span> 
    <span class="main">&lt;</span><span class="free">is_it</span> <span class="free">l</span> <span class="free">p</span> <span class="free">l'</span> <span class="free">it</span><span class="main">&gt;</span> 
      <span class="free">it_next</span> <span class="free">it</span> 
    <span class="main">&lt;</span><span class="main">λ</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">it'</span><span class="main">)</span><span class="main">.</span> <span class="free">is_it</span> <span class="free">l</span> <span class="free">p</span> <span class="main">(</span>tl <span class="free">l'</span><span class="main">)</span> <span class="bound">it'</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="bound">a</span><span class="main">=</span>hd <span class="free">l'</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> it_has_next_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">is_it</span> <span class="free">l</span> <span class="free">p</span> <span class="free">l'</span> <span class="free">it</span><span class="main">&gt;</span> 
       <span class="free">it_has_next</span> <span class="free">it</span> 
     <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="free">is_it</span> <span class="free">l</span> <span class="free">p</span> <span class="free">l'</span> <span class="free">it</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="bound">r</span><span class="main">⟷</span><span class="free">l'</span><span class="main">≠</span><span class="main">[]</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> quit_iteration<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free">is_it</span> <span class="free">l</span> <span class="free">p</span> <span class="free">l'</span> <span class="free">it</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">is_list</span> <span class="free">l</span> <span class="free">p</span> <span class="main">*</span> <span class="keyword1">true</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="List_Seg">
<div class="head">
<h1>Theory List_Seg</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Singly Linked List Segments›</span></span>
<span class="keyword1"><span class="command">theory</span></span> List_Seg
<span class="keyword2"><span class="keyword">imports</span></span> <span class="quoted">"<a href="Sep_Main.html">../Sep_Main</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Nodes›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We define a node of a list to contain a data value and a next pointer.
  As Imperative HOL does not support null-pointers, we make the next-pointer
  an optional value, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>None›</span></span></span></span> representing a null pointer.

  Unfortunately, Imperative HOL requires some boilerplate code to define 
  a datatype.
›</span></span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹Sign.add_const_constraint 
  <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Ref<span class="antiquote">}</span></span><span class="main">,</span> SOME <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"nat <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">::</span>type ref"</span><span class="antiquote">}</span></span><span class="main">)</span>›</span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="tfree">'a</span> node <span class="main">=</span> Node <span class="quoted"><span class="quoted">"<span class="tfree">'a</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> node ref option"</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹Sign.add_const_constraint 
  <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Ref<span class="antiquote">}</span></span><span class="main">,</span> SOME <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"nat <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">::</span>heap ref"</span><span class="antiquote">}</span></span><span class="main">)</span>›</span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹Sign.add_const_constraint <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Node<span class="antiquote">}</span></span><span class="main">,</span> 
  SOME <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>heap <span class="main">⇒</span> <span class="tfree">'a</span> node ref option <span class="main">⇒</span> <span class="tfree">'a</span> node"</span><span class="antiquote">}</span></span><span class="main">)</span>›</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Selector Functions›</span></span>
<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">val</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>heap node <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="main">[</span><span class="operator">sep_dflt_simps</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">val</span> <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="quoted">"<span class="entity">next</span>"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>heap node <span class="main">⇒</span> <span class="tfree">'a</span> node ref option"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="main">[</span><span class="operator">sep_dflt_simps</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">next</span> <span class="main">(</span>Node <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Encoding to natural numbers, as required by Imperative/HOL›</span></span>
<span class="keyword1"><span class="command">fun</span></span>
  <span class="entity">node_encode</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>heap node <span class="main">⇒</span> nat"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">node_encode</span> <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">=</span> to_nat <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">instance</span></span> node <span class="main">::</span> <span class="main">(</span><span class="quoted">heap</span><span class="main">)</span> <span class="quoted">heap</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> heap_class.intro<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> countable_classI <span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted">"node_encode"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">case_tac</span> <span class="quoted"><span class="improper">y</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
  <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹List Segment Assertion›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Intuitively, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>lseg l p s›</span></span></span></span> describes a list starting at <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>p›</span></span></span></span> and
  ending with a pointer <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>s›</span></span></span></span>. The content of the list are <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>l›</span></span></span></span>.
  Note that the pointer <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>s›</span></span></span></span> may also occur earlier in the list, in which
  case it is handled as a usual next-pointer.
›</span></span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">lseg</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>heap list <span class="main">⇒</span> <span class="tfree">'a</span> node ref option <span class="main">⇒</span> <span class="tfree">'a</span> node ref option <span class="main">⇒</span> assn"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lseg</span> <span class="main">[]</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="main">↑</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">lseg</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">q</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="keyword1">↦<span class="hidden">⇩</span><sub>r</sub></span> Node <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="bound">q</span> <span class="main">*</span> <span class="free">lseg</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="bound">q</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">lseg</span> <span class="main">(</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">#</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> None <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> <span class="keyword1">false</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lseg_if_splitf1<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">sep_dflt_simps</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"lseg <span class="free">l</span> None None <span class="main">=</span> <span class="main">↑</span><span class="main">(</span><span class="free">l</span><span class="main">=</span><span class="main">[]</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">l</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> lseg_if_splitf2<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">sep_dflt_simps</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"lseg <span class="main">(</span><span class="free">x</span><span class="main">#</span><span class="free">xs</span><span class="main">)</span> <span class="free">p</span> <span class="free">q</span> 
    <span class="main">=</span> <span class="main">(</span><span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">pp</span> <span class="bound">n</span><span class="main">.</span> <span class="bound">pp</span> <span class="keyword1">↦<span class="hidden">⇩</span><sub>r</sub></span> <span class="main">(</span>Node <span class="free">x</span> <span class="bound">n</span><span class="main">)</span> <span class="main">*</span> lseg <span class="free">xs</span> <span class="bound">n</span> <span class="free">q</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="free">p</span><span class="main">=</span>Some <span class="bound">pp</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
  <span class="comment1">(* TODO: One-point simproc for assertions! *)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ent_iffI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">solve_entails</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">solve_entails</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Lemmas›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Concatenation›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> lseg_prepend<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="keyword1">↦<span class="hidden">⇩</span><sub>r</sub></span>Node <span class="free">x</span> <span class="free">q</span> <span class="main">*</span> lseg <span class="free">l</span> <span class="free">q</span> <span class="free">s</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> lseg <span class="main">(</span><span class="free">x</span><span class="main">#</span><span class="free">l</span><span class="main">)</span> <span class="main">(</span>Some <span class="free">p</span><span class="main">)</span> <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">sep_auto</span>

<span class="keyword1"><span class="command">lemma</span></span> lseg_append<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"lseg <span class="free">l</span> <span class="free">p</span> <span class="main">(</span>Some <span class="free">s</span><span class="main">)</span> <span class="main">*</span> <span class="free">s</span><span class="keyword1">↦<span class="hidden">⇩</span><sub>r</sub></span>Node <span class="free">x</span> <span class="free">q</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> lseg <span class="main">(</span><span class="free">l</span><span class="main">@</span><span class="main">[</span><span class="free">x</span><span class="main">]</span><span class="main">)</span> <span class="free">p</span> <span class="free">q</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">l</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">sep_auto</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">y</span> <span class="skolem">l</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">p</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ent_frame_fwd<span class="main"><span class="main">[</span></span><span class="operator">OF</span> Cons.IH<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">frame_inference</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">solve_entails</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lseg_conc<span class="main">:</span> <span class="quoted"><span class="quoted">"lseg <span class="free">l1</span> <span class="free">p</span> <span class="free">q</span> <span class="main">*</span> lseg <span class="free">l2</span> <span class="free">q</span> <span class="free">r</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> lseg <span class="main">(</span><span class="free">l1</span><span class="main">@</span><span class="free">l2</span><span class="main">)</span> <span class="free">p</span> <span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">l1</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">x</span> <span class="skolem">l1</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sep_auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ent_frame_fwd<span class="main"><span class="main">[</span></span><span class="operator">OF</span> Cons.hyps<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">frame_inference</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">solve_entails</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Splitting›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> lseg_split<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"lseg <span class="main">(</span><span class="free">l1</span><span class="main">@</span><span class="free">l2</span><span class="main">)</span> <span class="free">p</span> <span class="free">r</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">q</span><span class="main">.</span> lseg <span class="free">l1</span> <span class="free">p</span> <span class="bound">q</span> <span class="main">*</span> lseg <span class="free">l2</span> <span class="bound">q</span> <span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">l1</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">sep_auto</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">x</span> <span class="skolem">l1</span><span class="main">)</span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lseg <span class="main">(</span><span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">l1</span><span class="main">)</span> <span class="main">@</span> <span class="free">l2</span><span class="main">)</span> <span class="skolem">p</span> <span class="free">r</span> 
    <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">pp</span> <span class="bound">n</span><span class="main">.</span> <span class="bound">pp</span> <span class="keyword1">↦<span class="hidden">⇩</span><sub>r</sub></span> Node <span class="skolem">x</span> <span class="bound">n</span> <span class="main">*</span> lseg <span class="main">(</span><span class="skolem">l1</span> <span class="main">@</span> <span class="free">l2</span><span class="main">)</span> <span class="bound">n</span> <span class="free">r</span> <span class="main">*</span> <span class="main">↑</span> <span class="main">(</span><span class="skolem">p</span> <span class="main">=</span> Some <span class="bound">pp</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> 
    <span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">pp</span> <span class="bound">n</span> <span class="bound">q</span><span class="main">.</span> <span class="bound">pp</span> <span class="keyword1">↦<span class="hidden">⇩</span><sub>r</sub></span> Node <span class="skolem">x</span> <span class="bound">n</span> 
      <span class="main">*</span> lseg <span class="skolem">l1</span> <span class="bound">n</span> <span class="bound">q</span> 
      <span class="main">*</span> lseg <span class="free">l2</span> <span class="bound">q</span> <span class="free">r</span> 
      <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="skolem">p</span> <span class="main">=</span> Some <span class="bound">pp</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> ent_ex_preI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ent_frame_fwd<span class="main"><span class="main">[</span></span><span class="operator">OF</span> Cons.hyps<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">frame_inference</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sep_auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">q</span><span class="main">.</span> lseg <span class="main">(</span><span class="skolem">x</span><span class="main">#</span><span class="skolem">l1</span><span class="main">)</span> <span class="skolem">p</span> <span class="bound">q</span> <span class="main">*</span> lseg <span class="free">l2</span> <span class="bound">q</span> <span class="free">r</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">sep_auto</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Precision›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> lseg_prec1<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">l</span> <span class="bound">l'</span><span class="main">.</span> <span class="main">(</span><span class="free">h</span><span class="main">⊨</span>
      <span class="main">(</span>lseg <span class="bound">l</span> <span class="free">p</span> <span class="main">(</span>Some <span class="free">q</span><span class="main">)</span> <span class="main">*</span> <span class="free">q</span> <span class="keyword1">↦<span class="hidden">⇩</span><sub>r</sub></span> <span class="free">x</span> <span class="main">*</span> <span class="free">F1</span><span class="main">)</span> 
       <span class="keyword1">∧<span class="hidden">⇩</span><sub>A</sub></span> <span class="main">(</span>lseg <span class="bound">l'</span> <span class="free">p</span> <span class="main">(</span>Some <span class="free">q</span><span class="main">)</span> <span class="main">*</span> <span class="free">q</span> <span class="keyword1">↦<span class="hidden">⇩</span><sub>r</sub></span> <span class="free">x</span> <span class="main">*</span> <span class="free">F2</span><span class="main">)</span><span class="main">)</span> 
    <span class="main">⟶</span> <span class="bound">l</span><span class="main">=</span><span class="bound">l'</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> allI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> l l'
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">l</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="skolem">l'</span></span> <span class="quoted"><span class="free">F1</span></span> <span class="quoted"><span class="free">F2</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">l'</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">y</span> <span class="skolem">l</span><span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> Cons.prems <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">l'</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">p</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span><span class="main">)</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span><span class="main">=</span><span class="improper">a</span> <span class="main">∧</span> <span class="improper">na</span><span class="main">=</span><span class="improper">n</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

      <span class="keyword1"><span class="command">using</span></span> Cons.hyps <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> prec_frame'<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">frame_inference</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">frame_inference</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> p<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">aa</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> prec_frame<span class="main"><span class="main">[</span></span><span class="operator">OF</span> sngr_prec<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">frame_inference</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">frame_inference</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> lseg_prec2<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">l</span> <span class="bound">l'</span><span class="main">.</span> <span class="main">(</span><span class="free">h</span><span class="main">⊨</span>
      <span class="main">(</span>lseg <span class="bound">l</span> <span class="free">p</span> None <span class="main">*</span> <span class="free">F1</span><span class="main">)</span> <span class="keyword1">∧<span class="hidden">⇩</span><sub>A</sub></span> <span class="main">(</span>lseg <span class="bound">l'</span> <span class="free">p</span> None <span class="main">*</span> <span class="free">F2</span><span class="main">)</span><span class="main">)</span> 
    <span class="main">⟶</span> <span class="bound">l</span><span class="main">=</span><span class="bound">l'</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> allI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> l l'
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">l</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="skolem">l'</span></span> <span class="quoted"><span class="free">F1</span></span> <span class="quoted"><span class="free">F2</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">l'</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">p</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">y</span> <span class="skolem">l</span><span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> Cons.prems <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">p</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">l'</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span><span class="main">)</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span><span class="main">=</span><span class="improper">aa</span> <span class="main">∧</span> <span class="improper">na</span><span class="main">=</span><span class="improper">n</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

      <span class="keyword1"><span class="command">using</span></span> Cons.hyps <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> prec_frame'<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">frame_inference</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">frame_inference</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> p<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">a</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> prec_frame<span class="main"><span class="main">[</span></span><span class="operator">OF</span> sngr_prec<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">frame_inference</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">frame_inference</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> lseg_prec3<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">q</span> <span class="bound">q'</span><span class="main">.</span> <span class="free">h</span> <span class="main">⊨</span> <span class="main">(</span>lseg <span class="free">l</span> <span class="free">p</span> <span class="bound">q</span> <span class="main">*</span> <span class="free">F1</span><span class="main">)</span> <span class="keyword1">∧<span class="hidden">⇩</span><sub>A</sub></span> <span class="main">(</span>lseg <span class="free">l</span> <span class="free">p</span> <span class="bound">q'</span> <span class="main">*</span> <span class="free">F2</span><span class="main">)</span> <span class="main">⟶</span> <span class="bound">q</span><span class="main">=</span><span class="bound">q'</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> allI<span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">l</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="free">F1</span></span> <span class="quoted"><span class="free">F2</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">x</span> <span class="skolem">l</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="improper">na</span><span class="main">=</span><span class="improper">n</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> Cons.hyps <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> prec_frame'<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">frame_inference</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">frame_inference</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> prec_frame<span class="main"><span class="main">[</span></span><span class="operator">OF</span> sngr_prec<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">frame_inference</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">frame_inference</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Open_List">
<div class="head">
<h1>Theory Open_List</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Open Singly Linked Lists›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Open_List
<span class="keyword2"><span class="keyword">imports</span></span> <a href="List_Seg.html">List_Seg</a> <a href="Imp_List_Spec.html">Imp_List_Spec</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Definitions›</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'a</span> os_list <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> node ref option"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">os_list</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>heap<span class="main">)</span> os_list <span class="main">⇒</span> assn"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">os_list</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> lseg <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> None"</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Precision›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> os_prec<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"precise os_list"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">rule</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lseg_prec2<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> os_imp_list_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"imp_list os_list"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> os_prec<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">interpretation</span></span> os<span class="main">:</span> imp_list <span class="quoted">os_list</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> os_imp_list_impl<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Operations›</span></span>
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Allocate Empty List›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">os_empty</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>heap os_list Heap"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">os_empty</span> <span class="main">≡</span> return None"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> os_empty_rule<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="keyword1">emp</span><span class="main">&gt;</span> os_empty <span class="main">&lt;</span>os_list <span class="main">[]</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> os_empty_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sep_auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> os_empty_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"imp_list_empty os_list os_empty"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> os_empty_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">interpretation</span></span> os<span class="main">:</span> imp_list_empty <span class="quoted">os_list</span> <span class="quoted">os_empty</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> os_empty_impl<span class="main">)</span>
  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Emptiness check›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A linked list is empty, iff it is the null pointer.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">os_is_empty</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>heap os_list <span class="main">⇒</span> bool Heap"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">os_is_empty</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">≡</span> return <span class="main">(</span><span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">=</span> None<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> os_is_empty_rule<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span>os_list <span class="free">xs</span> <span class="free">b</span><span class="main">&gt;</span> os_is_empty <span class="free">b</span> <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> os_list <span class="free">xs</span> <span class="free">b</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="bound">r</span> <span class="main">⟷</span> <span class="free">xs</span> <span class="main">=</span> <span class="main">[]</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> os_is_empty_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sep_auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> os_is_empty_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"imp_list_is_empty os_list os_is_empty"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> os_is_empty_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">interpretation</span></span> os<span class="main">:</span> imp_list_is_empty <span class="quoted">os_list</span> <span class="quoted">os_is_empty</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> os_is_empty_impl<span class="main">)</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Prepend›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹To push an element to the front of a list we allocate a new node which
  stores the element and the old list as successor. The new list is the new 
  allocated reference.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">os_prepend</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">::</span>heap os_list <span class="main">⇒</span> <span class="tfree">'a</span> os_list Heap"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">os_prepend</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span> <span class="bound">p</span> <span class="main">←</span> ref <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span><span class="main">;</span> return <span class="main">(</span>Some <span class="bound">p</span><span class="main">)</span> <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> os_prepend_rule<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span>os_list <span class="free">xs</span> <span class="free">n</span><span class="main">&gt;</span> os_prepend <span class="free">x</span> <span class="free">n</span> <span class="main">&lt;</span>os_list <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> os_prepend_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sep_auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> os_prepend_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"imp_list_prepend os_list os_prepend"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> os_prepend_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">interpretation</span></span> os<span class="main">:</span> imp_list_prepend <span class="quoted">os_list</span> <span class="quoted">os_prepend</span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> os_prepend_impl<span class="main">)</span>

<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹Pop›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹To pop the first element out of the list we look up the value and the
  reference of the node and return the pair of those.›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">os_pop</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>heap os_list <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'a</span> os_list<span class="main">)</span> Heap"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">os_pop</span> None   <span class="main">=</span> raise <span class="keyword1">STR</span> <span class="inner_quoted">''Empty Os_list''</span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">os_pop</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span><span class="bound">m</span> <span class="main">←</span> <span class="main">!</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">;</span> return <span class="main">(</span>val <span class="bound">m</span><span class="main">,</span> next <span class="bound">m</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">declare</span></span> os_pop.simps<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword">del</span></span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> os_pop_rule<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> <span class="main">[]</span> <span class="main">⟹</span> <span class="main">&lt;</span>os_list <span class="free">xs</span> <span class="free">r</span><span class="main">&gt;</span> 
  os_pop <span class="free">r</span> 
  <span class="main">&lt;</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">r'</span><span class="main">)</span><span class="main">.</span> os_list <span class="main">(</span>tl <span class="free">xs</span><span class="main">)</span> <span class="bound">r'</span> <span class="main">*</span> <span class="main">(</span>the <span class="free">r</span><span class="main">)</span> <span class="keyword1">↦<span class="hidden">⇩</span><sub>r</sub></span> <span class="main">(</span>Node <span class="bound">x</span> <span class="bound">r'</span><span class="main">)</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="bound">x</span> <span class="main">=</span> hd <span class="free">xs</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>

  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">r</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>

  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> os_pop.simps<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> os_pop_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"imp_list_pop os_list os_pop"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> os_pop_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">interpretation</span></span> os<span class="main">:</span> imp_list_pop <span class="quoted">os_list</span> <span class="quoted">os_pop</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> os_pop_impl<span class="main">)</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Reverse›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The following reversal function is equivalent to the one from 
  Imperative HOL. And gives a more difficult example.›</span></span>

<span class="keyword1"><span class="command">partial_function</span></span> <span class="main">(</span>heap<span class="main">)</span> <span class="entity">os_reverse_aux</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>heap os_list <span class="main">⇒</span> <span class="tfree">'a</span> os_list <span class="main">⇒</span> <span class="tfree">'a</span> os_list Heap"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">os_reverse_aux</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="keyword1">of</span> 
    None <span class="main">⇒</span> return <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">|</span>
    Some <span class="bound">r</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">v</span> <span class="main">←</span> <span class="main">!</span><span class="bound">r</span><span class="main">;</span>
      <span class="bound">r</span> <span class="main">:=</span> Node <span class="main">(</span>val <span class="bound">v</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span><span class="main">;</span>
      <span class="free">os_reverse_aux</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">(</span>next <span class="bound">v</span><span class="main">)</span> <span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">sep_dflt_simps</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"os_reverse_aux <span class="free">q</span> None <span class="main">=</span> return <span class="free">q</span>"</span></span>
  <span class="quoted"><span class="quoted">"os_reverse_aux <span class="free">q</span> <span class="main">(</span>Some <span class="free">r</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">v</span> <span class="main">←</span> <span class="main">!</span><span class="free">r</span><span class="main">;</span>
      <span class="free">r</span> <span class="main">:=</span> Node <span class="main">(</span>val <span class="bound">v</span><span class="main">)</span> <span class="free">q</span><span class="main">;</span>
      os_reverse_aux <span class="main">(</span>Some <span class="free">r</span><span class="main">)</span> <span class="main">(</span>next <span class="bound">v</span><span class="main">)</span> <span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> os_reverse_aux.simps<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> os_reverse_aux.simps<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">os_reverse</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> os_reverse_aux None <span class="free"><span class="bound"><span class="entity">p</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> os_reverse_aux_rule<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span>os_list <span class="free">xs</span> <span class="free">p</span> <span class="main">*</span> os_list <span class="free">ys</span> <span class="free">q</span><span class="main">&gt;</span> 
    os_reverse_aux <span class="free">q</span> <span class="free">p</span> 
  <span class="main">&lt;</span>os_list <span class="main">(</span><span class="main">(</span>rev <span class="free">xs</span><span class="main">)</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span> <span class="main">&gt;</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="free">q</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sep_auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">x</span> <span class="skolem">xs</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">p</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cons_pre_rule<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ Cons.hyps<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> os_reverse_rule<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span>os_list <span class="free">xs</span> <span class="free">p</span><span class="main">&gt;</span> os_reverse <span class="free">p</span> <span class="main">&lt;</span>os_list <span class="main">(</span>rev <span class="free">xs</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> os_reverse_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> os_reverse_aux_rule<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> ys<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">[]</span>"</span></span><span class="main"><span class="main">,</span></span> <span class="operator">simplified</span><span class="main"><span class="main">,</span></span> <span class="operator">rule_format</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> os_reverse_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"imp_list_reverse os_list os_reverse"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> os_reverse_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">interpretation</span></span> os<span class="main">:</span> imp_list_reverse <span class="quoted">os_list</span> <span class="quoted">os_reverse</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> os_reverse_impl<span class="main">)</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Remove›</span></span>
 
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Remove all appearances of an element from a linked list.›</span></span>

<span class="keyword1"><span class="command">partial_function</span></span> <span class="main">(</span>heap<span class="main">)</span> <span class="entity">os_rem</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>heap <span class="main">⇒</span> <span class="tfree">'a</span> node ref option <span class="main">⇒</span> <span class="tfree">'a</span> node ref option Heap"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">os_rem</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="keyword1">of</span> 
     None <span class="main">⇒</span> return None <span class="main">|</span>
     Some <span class="bound">p</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span> 
       <span class="bound">n</span> <span class="main">←</span> <span class="main">!</span><span class="bound">p</span><span class="main">;</span>
       <span class="bound">q</span> <span class="main">←</span> <span class="free">os_rem</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span>next <span class="bound">n</span><span class="main">)</span><span class="main">;</span>
       <span class="main">(</span><span class="keyword1">if</span> <span class="main">(</span>val <span class="bound">n</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> 
         <span class="keyword1">then</span> return <span class="bound">q</span>
         <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span> 
           <span class="bound">p</span> <span class="main">:=</span> Node <span class="main">(</span>val <span class="bound">n</span><span class="main">)</span> <span class="bound">q</span><span class="main">;</span> 
           return <span class="main">(</span>Some <span class="bound">p</span><span class="main">)</span> <span class="main">}</span><span class="main">)</span> <span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">sep_dflt_simps</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"os_rem <span class="free">x</span> None <span class="main">=</span> return None"</span></span>
  <span class="quoted"><span class="quoted">"os_rem <span class="free">x</span> <span class="main">(</span>Some <span class="free">p</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span> 
       <span class="bound">n</span> <span class="main">←</span> <span class="main">!</span><span class="free">p</span><span class="main">;</span>
       <span class="bound">q</span> <span class="main">←</span> os_rem <span class="free">x</span> <span class="main">(</span>next <span class="bound">n</span><span class="main">)</span><span class="main">;</span>
       <span class="main">(</span><span class="keyword1">if</span> <span class="main">(</span>val <span class="bound">n</span> <span class="main">=</span> <span class="free">x</span><span class="main">)</span> 
         <span class="keyword1">then</span> return <span class="bound">q</span>
         <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span> 
           <span class="free">p</span> <span class="main">:=</span> Node <span class="main">(</span>val <span class="bound">n</span><span class="main">)</span> <span class="bound">q</span><span class="main">;</span> 
           return <span class="main">(</span>Some <span class="free">p</span><span class="main">)</span> <span class="main">}</span><span class="main">)</span> <span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> os_rem.simps<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> os_rem_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span>os_list <span class="free">xs</span> <span class="free">b</span><span class="main">&gt;</span> os_rem <span class="free">x</span> <span class="free">b</span> <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> os_list <span class="main">(</span>removeAll <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="bound">r</span> <span class="main">*</span> <span class="keyword1">true</span><span class="main">&gt;</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">b</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="comment1">(* Have to generalize over x, as 
    sep_auto preprocessor introduces a new variable. Alternative: 
    No preprocessing. (See alternative proof below) *)</span>
  <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sep_auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">y</span> <span class="skolem">xs</span><span class="main">)</span> 
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Cons.hyps<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> os_rem_rule_alt_proof<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span>os_list <span class="free">xs</span> <span class="free">b</span><span class="main">&gt;</span> os_rem <span class="free">x</span> <span class="free">b</span> <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> os_list <span class="main">(</span>removeAll <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="bound">r</span> <span class="main">*</span> <span class="keyword1">true</span><span class="main">&gt;</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">b</span></span><span class="main">)</span> 
  <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sep_auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">y</span> <span class="skolem">xs</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">nopre</span><span class="main"><span class="main">)</span></span> <span class="quasi_keyword">heap</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Cons.hyps<span class="main">)</span> <span class="comment1">(* Switching off preprocessor *)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Iterator›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'a</span> os_list_it <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> os_list"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">os_is_it</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">l2</span></span></span> <span class="free"><span class="bound"><span class="entity">it</span></span></span> 
  <span class="main">≡</span> <span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">l1</span><span class="main">.</span> <span class="main">↑</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">=</span><span class="bound">l1</span><span class="main">@</span><span class="free"><span class="bound"><span class="entity">l2</span></span></span><span class="main">)</span> <span class="main">*</span> lseg <span class="bound">l1</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">it</span></span></span> <span class="main">*</span> os_list <span class="free"><span class="bound"><span class="entity">l2</span></span></span> <span class="free"><span class="bound"><span class="entity">it</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">os_it_init</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> os_list <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> os_list_it<span class="main">)</span> Heap"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">os_it_init</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> return <span class="free"><span class="bound"><span class="entity">l</span></span></span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">os_it_next</span> <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">os_it_next</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">n</span> <span class="main">←</span> <span class="main">!</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">;</span>
    return <span class="main">(</span>val <span class="bound">n</span><span class="main">,</span>next <span class="bound">n</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">os_it_has_next</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> os_list_it <span class="main">⇒</span> bool Heap"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">os_it_has_next</span> <span class="free"><span class="bound"><span class="entity">it</span></span></span> <span class="main">≡</span> return <span class="main">(</span><span class="free"><span class="bound"><span class="entity">it</span></span></span><span class="main">≠</span>None<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> os_iterate_impl<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"imp_list_iterate os_list os_is_it os_it_init os_it_has_next os_it_next"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command">unfolding</span></span> os_it_init_def os_is_it_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sep_auto</span>

  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">it</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">l'</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sep_auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ent_frame_fwd<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lseg_append<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">frame_inference</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>

  <span class="keyword1"><span class="command">unfolding</span></span> os_it_has_next_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> neq_NilE<span class="main">)</span>

  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">solve_entails</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ent_frame_fwd<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lseg_conc<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">frame_inference</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">solve_entails</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">interpretation</span></span> os<span class="main">:</span> 
  imp_list_iterate <span class="quoted">os_list</span> <span class="quoted">os_is_it</span> <span class="quoted">os_it_init</span> <span class="quoted">os_it_has_next</span> <span class="quoted">os_it_next</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> os_iterate_impl<span class="main">)</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹List-Sum›</span></span>

<span class="keyword1"><span class="command">partial_function</span></span> <span class="main">(</span>heap<span class="main">)</span> <span class="entity">os_sum'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"int os_list_it <span class="main">⇒</span> int <span class="main">⇒</span> int Heap"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">os_sum'</span> <span class="free"><span class="bound"><span class="entity">it</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">b</span> <span class="main">←</span> os_it_has_next <span class="free"><span class="bound"><span class="entity">it</span></span></span><span class="main">;</span>
    <span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">it'</span><span class="main">)</span> <span class="main">←</span> os_it_next <span class="free"><span class="bound"><span class="entity">it</span></span></span><span class="main">;</span>
      <span class="free">os_sum'</span> <span class="bound">it'</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">+</span><span class="bound">x</span><span class="main">)</span>
    <span class="main">}</span> <span class="keyword1">else</span> return <span class="free"><span class="bound"><span class="entity">s</span></span></span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> os_sum'_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span>os_is_it <span class="free">l</span> <span class="free">p</span> <span class="free">l'</span> <span class="free">it</span><span class="main">&gt;</span> 
    os_sum' <span class="free">it</span> <span class="free">s</span> 
  <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> os_list <span class="free">l</span> <span class="free">p</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="bound">r</span> <span class="main">=</span> <span class="free">s</span> <span class="main">+</span> sum_list <span class="free">l'</span><span class="main">)</span><span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">l'</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">it</span></span> <span class="quoted"><span class="free">s</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> os_sum'.simps<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> os.quit_iteration<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">x</span> <span class="skolem">l'</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> os_sum'.simps<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> Cons.hyps<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">os_sum</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span> 
  <span class="bound">it</span> <span class="main">←</span> os_it_init <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">;</span>
  os_sum' <span class="bound">it</span> <span class="main">0</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> os_sum_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span>os_list <span class="free">l</span> <span class="free">p</span><span class="main">&gt;</span> os_sum <span class="free">p</span> <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> os_list <span class="free">l</span> <span class="free">p</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="bound">r</span><span class="main">=</span>sum_list <span class="free">l</span><span class="main">)</span><span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> os_sum_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">sep_auto</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Circ_List">
<div class="head">
<h1>Theory Circ_List</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Circular Singly Linked Lists›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Circ_List
<span class="keyword2"><span class="keyword">imports</span></span> <a href="List_Seg.html">List_Seg</a> <a href="Imp_List_Spec.html">Imp_List_Spec</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Example of circular lists, with efficient append, prepend, pop, and rotate
  operations.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Datatype Definition›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'a</span> cs_list <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> node ref option"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A circular list is described by a list segment, with special
  cases for the empty list:›</span></span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">cs_list</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>heap list <span class="main">⇒</span> <span class="tfree">'a</span> node ref option <span class="main">⇒</span> assn"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">cs_list</span> <span class="main">[]</span> None <span class="main">=</span> <span class="keyword1">emp</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">cs_list</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="main">=</span> lseg <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">cs_list</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> <span class="keyword1">false</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"cs_list <span class="free">l</span> None <span class="main">=</span> <span class="main">↑</span><span class="main">(</span><span class="free">l</span><span class="main">=</span><span class="main">[]</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">l</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"cs_list <span class="free">l</span> <span class="main">(</span>Some <span class="free">p</span><span class="main">)</span> 
  <span class="main">=</span> <span class="main">(</span><span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">x</span> <span class="bound">ls</span><span class="main">.</span> <span class="main">↑</span><span class="main">(</span><span class="free">l</span><span class="main">=</span><span class="bound">x</span><span class="main">#</span><span class="bound">ls</span><span class="main">)</span> <span class="main">*</span> lseg <span class="main">(</span><span class="bound">x</span><span class="main">#</span><span class="bound">ls</span><span class="main">)</span> <span class="main">(</span>Some <span class="free">p</span><span class="main">)</span> <span class="main">(</span>Some <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ent_iffI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">l</span></span><span class="main">)</span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sep_auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">l</span></span><span class="main">)</span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sep_auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Precision›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> cs_prec<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"precise cs_list"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">p</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>

  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="improper">x</span><span class="main">=</span><span class="improper">xa</span> <span class="main">∧</span> <span class="improper">n</span><span class="main">=</span><span class="improper">na</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> prec_frame_expl<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lseg_prec1<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">frame_inference</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">frame_inference</span>

  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> prec_frame<span class="main"><span class="main">[</span></span><span class="operator">OF</span> sngr_prec<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">frame_inference</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">frame_inference</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> cs_imp_list_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"imp_list cs_list"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cs_prec<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">interpretation</span></span> cs<span class="main">:</span> imp_list <span class="quoted">cs_list</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> cs_imp_list_impl<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Operations›</span></span>
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Allocate Empty List›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">cs_empty</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>heap cs_list Heap"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">cs_empty</span> <span class="main">≡</span> return None"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> cs_empty_rule<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="keyword1">emp</span><span class="main">&gt;</span> cs_empty <span class="main">&lt;</span>cs_list <span class="main">[]</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> cs_empty_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">sep_auto</span>

<span class="keyword1"><span class="command">lemma</span></span> cs_empty_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"imp_list_empty cs_list cs_empty"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> cs_empty_rule<span class="main">)</span>
<span class="keyword1"><span class="command">interpretation</span></span> cs<span class="main">:</span> imp_list_empty <span class="quoted">cs_list</span> <span class="quoted">cs_empty</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> cs_empty_impl<span class="main">)</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Prepend Element›</span></span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">cs_prepend</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">::</span>heap cs_list <span class="main">⇒</span> <span class="tfree">'a</span> cs_list Heap"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">cs_prepend</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> None <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">p</span> <span class="main">←</span> ref <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">x</span></span></span> None<span class="main">)</span><span class="main">;</span> 
    <span class="bound">p</span><span class="main">:=</span>Node <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span>Some <span class="bound">p</span><span class="main">)</span><span class="main">;</span> 
    return <span class="main">(</span>Some <span class="bound">p</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">cs_prepend</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">n</span> <span class="main">←</span> <span class="main">!</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">;</span>
    <span class="bound">q</span> <span class="main">←</span> ref <span class="main">(</span>Node <span class="main">(</span>val <span class="bound">n</span><span class="main">)</span> <span class="main">(</span>next <span class="bound">n</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">:=</span> Node <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span>Some <span class="bound">q</span><span class="main">)</span><span class="main">;</span>
    return <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">declare</span></span> cs_prepend.simps <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword">del</span></span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> cs_prepend_rule<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span>cs_list <span class="free">l</span> <span class="free">p</span><span class="main">&gt;</span> cs_prepend <span class="free">x</span> <span class="free">p</span> <span class="main">&lt;</span>cs_list <span class="main">(</span><span class="free">x</span><span class="main">#</span><span class="free">l</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cs_prepend.simps<span class="main">)</span>

  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cs_prepend.simps<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> cs_prepend_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"imp_list_prepend cs_list cs_prepend"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> cs_prepend_rule<span class="main">)</span>
<span class="keyword1"><span class="command">interpretation</span></span> cs<span class="main">:</span> imp_list_prepend <span class="quoted">cs_list</span> <span class="quoted">cs_prepend</span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> cs_prepend_impl<span class="main">)</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Append Element›</span></span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">cs_append</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">::</span>heap cs_list <span class="main">⇒</span> <span class="tfree">'a</span> cs_list Heap"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">cs_append</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> None <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span> 
    <span class="bound">p</span> <span class="main">←</span> ref <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">x</span></span></span> None<span class="main">)</span><span class="main">;</span> 
    <span class="bound">p</span><span class="main">:=</span>Node <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span>Some <span class="bound">p</span><span class="main">)</span><span class="main">;</span> 
    return <span class="main">(</span>Some <span class="bound">p</span><span class="main">)</span> <span class="main">}</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">cs_append</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">n</span> <span class="main">←</span> <span class="main">!</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">;</span>
    <span class="bound">q</span> <span class="main">←</span> ref <span class="main">(</span>Node <span class="main">(</span>val <span class="bound">n</span><span class="main">)</span> <span class="main">(</span>next <span class="bound">n</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">:=</span> Node <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span>Some <span class="bound">q</span><span class="main">)</span><span class="main">;</span>
    return <span class="main">(</span>Some <span class="bound">q</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">declare</span></span> cs_append.simps <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword">del</span></span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> cs_append_rule<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span>cs_list <span class="free">l</span> <span class="free">p</span><span class="main">&gt;</span> cs_append <span class="free">x</span> <span class="free">p</span> <span class="main">&lt;</span>cs_list <span class="main">(</span><span class="free">l</span><span class="main">@</span><span class="main">[</span><span class="free">x</span><span class="main">]</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cs_append.simps<span class="main">)</span>

  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cs_append.simps<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ent_frame_fwd<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> s<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">a</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> lseg_append<span class="main">)</span> <span class="comment1">(* frame_inference does no backtracking
    on instantiating schematics, hence we have to give it some help here. *)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">frame_inference</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> cs_append_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"imp_list_append cs_list cs_append"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> cs_append_rule<span class="main">)</span>
<span class="keyword1"><span class="command">interpretation</span></span> cs<span class="main">:</span> imp_list_append <span class="quoted">cs_list</span> <span class="quoted">cs_append</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> cs_append_impl<span class="main">)</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Pop First Element›</span></span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">cs_pop</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>heap cs_list <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">×</span><span class="tfree">'a</span> cs_list<span class="main">)</span> Heap"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">cs_pop</span> None <span class="main">=</span> raise <span class="keyword1">STR</span> <span class="inner_quoted">''Pop from empty list''</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">cs_pop</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">n1</span> <span class="main">←</span> <span class="main">!</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">;</span>
    <span class="keyword1">if</span> next <span class="bound">n1</span> <span class="main">=</span> Some <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="keyword1">then</span>
      return <span class="main">(</span>val <span class="bound">n1</span><span class="main">,</span>None<span class="main">)</span> <span class="comment1">― ‹Singleton list becomes empty list›</span>
    <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="keyword1">let</span> <span class="bound">p2</span> <span class="main">=</span> the <span class="main">(</span>next <span class="bound">n1</span><span class="main">)</span><span class="main">;</span>
      <span class="bound">n2</span> <span class="main">←</span> <span class="main">!</span><span class="bound">p2</span><span class="main">;</span>
      <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">:=</span> Node <span class="main">(</span>val <span class="bound">n2</span><span class="main">)</span> <span class="main">(</span>next <span class="bound">n2</span><span class="main">)</span><span class="main">;</span>
      return <span class="main">(</span>val <span class="bound">n1</span><span class="main">,</span>Some <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>
    <span class="main">}</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">declare</span></span> cs_pop.simps<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword">del</span></span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> cs_pop_rule<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span>cs_list <span class="main">(</span><span class="free">x</span><span class="main">#</span><span class="free">l</span><span class="main">)</span> <span class="free">p</span><span class="main">&gt;</span> cs_pop <span class="free">p</span> <span class="main">&lt;</span><span class="main">λ</span><span class="main">(</span><span class="bound">y</span><span class="main">,</span><span class="bound">p'</span><span class="main">)</span><span class="main">.</span> cs_list <span class="free">l</span> <span class="bound">p'</span> <span class="main">*</span> <span class="keyword1">true</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="bound">y</span><span class="main">=</span><span class="free">x</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cs_pop.simps<span class="main">)</span>

  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">l</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cs_pop.simps <span class="quasi_keyword">dflt_simps</span><span class="main"><span class="main">:</span></span> option.sel<span class="main">)</span>

  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> 
    <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cs_pop.simps 
    <span class="quasi_keyword">dflt_simps</span><span class="main"><span class="main">:</span></span> option.sel 
    <span class="quasi_keyword">eintros</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> exI<span class="main">)</span>
  <span class="comment1">(* Some unfortunate quantifier fiddling :( *)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">aa</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">list</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">a</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> exI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sep_auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> cs_pop_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"imp_list_pop cs_list cs_pop"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> cs_pop_rule <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> neq_NilE<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">interpretation</span></span> cs<span class="main">:</span> imp_list_pop <span class="quoted">cs_list</span> <span class="quoted">cs_pop</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> cs_pop_impl<span class="main">)</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Rotate›</span></span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">cs_rotate</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>heap cs_list <span class="main">⇒</span> <span class="tfree">'a</span> cs_list Heap"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">cs_rotate</span> None <span class="main">=</span> return None"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">cs_rotate</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">n</span> <span class="main">←</span> <span class="main">!</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">;</span>
    return <span class="main">(</span>next <span class="bound">n</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">declare</span></span> cs_rotate.simps <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword">del</span></span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> cs_rotate_rule<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span>cs_list <span class="free">l</span> <span class="free">p</span><span class="main">&gt;</span> cs_rotate <span class="free">p</span> <span class="main">&lt;</span>cs_list <span class="main">(</span>rotate1 <span class="free">l</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cs_rotate.simps<span class="main">)</span>

  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">l</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>

  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">list</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cs_rotate.simps<span class="main">)</span>

  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cs_rotate.simps<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ent_frame_fwd<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> s<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="improper">a</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> lseg_append<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">frame_inference</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sep_auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> cs_rotate_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"imp_list_rotate cs_list cs_rotate"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> cs_rotate_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">interpretation</span></span> cs<span class="main">:</span> imp_list_rotate <span class="quoted">cs_list</span> <span class="quoted">cs_rotate</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> cs_rotate_impl<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Test›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">test</span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="bound">l</span> <span class="main">←</span> cs_empty<span class="main">;</span>
  <span class="bound">l</span> <span class="main">←</span> cs_append <span class="inner_quoted">''a''</span> <span class="bound">l</span><span class="main">;</span>
  <span class="bound">l</span> <span class="main">←</span> cs_append <span class="inner_quoted">''b''</span> <span class="bound">l</span><span class="main">;</span>
  <span class="bound">l</span> <span class="main">←</span> cs_append <span class="inner_quoted">''c''</span> <span class="bound">l</span><span class="main">;</span>
  <span class="bound">l</span> <span class="main">←</span> cs_prepend <span class="inner_quoted">''0''</span> <span class="bound">l</span><span class="main">;</span>
  <span class="bound">l</span> <span class="main">←</span> cs_rotate <span class="bound">l</span><span class="main">;</span>
  <span class="main">(</span><span class="bound">v1</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span><span class="main">←</span>cs_pop <span class="bound">l</span><span class="main">;</span>
  <span class="main">(</span><span class="bound">v2</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span><span class="main">←</span>cs_pop <span class="bound">l</span><span class="main">;</span>
  <span class="main">(</span><span class="bound">v3</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span><span class="main">←</span>cs_pop <span class="bound">l</span><span class="main">;</span>
  <span class="main">(</span><span class="bound">v4</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span><span class="main">←</span>cs_pop <span class="bound">l</span><span class="main">;</span>
  return <span class="main">[</span><span class="bound">v1</span><span class="main">,</span><span class="bound">v2</span><span class="main">,</span><span class="bound">v3</span><span class="main">,</span><span class="bound">v4</span><span class="main">]</span>
<span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">test_result</span> <span class="main">≡</span> <span class="main">[</span><span class="inner_quoted">''a''</span><span class="main">,</span> <span class="inner_quoted">''b''</span><span class="main">,</span> <span class="inner_quoted">''c''</span><span class="main">,</span> <span class="inner_quoted">''0''</span><span class="main">]</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="keyword1">emp</span><span class="main">&gt;</span> test <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="main">↑</span><span class="main">(</span><span class="bound">r</span><span class="main">=</span>test_result<span class="main">)</span> <span class="main">*</span> <span class="keyword1">true</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> test_def test_result_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  
<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">test</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML_imp

<span class="keyword1"><span class="command">ML_val</span></span> <span class="quoted">‹
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">res</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">test</span><span class="antiquote">}</span></span></span> <span class="main">(</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">res</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">test_result</span><span class="antiquote">}</span></span></span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword3"><span class="keyword">raise</span></span> Match<span class="main">;</span>
›</span>

<span class="keyword1"><span class="command">hide_const</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> test test_result

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Imp_Map_Spec">
<div class="head">
<h1>Theory Imp_Map_Spec</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Interface for Maps›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Imp_Map_Spec
<span class="keyword2"><span class="keyword">imports</span></span> <span class="quoted">"<a href="Sep_Main.html">../Sep_Main</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  This file specifies an abstract interface for map data structures. It can
  be implemented by concrete map data structures, as demonstrated in the 
  hash map example.
›</span></span>

<span class="keyword1"><span class="command">locale</span></span> imp_map <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">is_map</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span> <span class="main">⇀</span> <span class="tfree">'v</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'m</span> <span class="main">⇒</span> assn"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> precise<span class="main">:</span> <span class="quoted"><span class="quoted">"precise <span class="free">is_map</span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> imp_map_empty <span class="main">=</span> imp_map <span class="main">+</span>
  <span class="keyword2"><span class="keyword">constrains</span></span> is_map <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span> <span class="main">⇀</span> <span class="tfree">'v</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'m</span> <span class="main">⇒</span> assn"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">empty</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> Heap"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> empty_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="keyword1">emp</span><span class="main">&gt;</span> <span class="free">empty</span> <span class="main">&lt;</span><span class="free">is_map</span> Map.empty<span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> imp_map_is_empty <span class="main">=</span> imp_map <span class="main">+</span>
  <span class="keyword2"><span class="keyword">constrains</span></span> is_map <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span> <span class="main">⇀</span> <span class="tfree">'v</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'m</span> <span class="main">⇒</span> assn"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">is_empty</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> <span class="main">⇒</span> bool Heap"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> is_empty_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">is_map</span> <span class="free">m</span> <span class="free">p</span><span class="main">&gt;</span> <span class="free">is_empty</span> <span class="free">p</span> <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="free">is_map</span> <span class="free">m</span> <span class="free">p</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="bound">r</span> <span class="main">⟷</span> <span class="free">m</span><span class="main">=</span>Map.empty<span class="main">)</span><span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> imp_map_lookup <span class="main">=</span> imp_map <span class="main">+</span>
  <span class="keyword2"><span class="keyword">constrains</span></span> is_map <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span> <span class="main">⇀</span> <span class="tfree">'v</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'m</span> <span class="main">⇒</span> assn"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">lookup</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k</span> <span class="main">⇒</span> <span class="tfree">'m</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span> option<span class="main">)</span> Heap"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> lookup_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">is_map</span> <span class="free">m</span> <span class="free">p</span><span class="main">&gt;</span> <span class="free">lookup</span> <span class="free">k</span> <span class="free">p</span> <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="free">is_map</span> <span class="free">m</span> <span class="free">p</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="bound">r</span> <span class="main">=</span> <span class="free">m</span> <span class="free">k</span><span class="main">)</span><span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> imp_map_update <span class="main">=</span> imp_map <span class="main">+</span>
  <span class="keyword2"><span class="keyword">constrains</span></span> is_map <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span> <span class="main">⇀</span> <span class="tfree">'v</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'m</span> <span class="main">⇒</span> assn"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">update</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k</span> <span class="main">⇒</span> <span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'m</span> Heap"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> update_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">is_map</span> <span class="free">m</span> <span class="free">p</span><span class="main">&gt;</span> <span class="free">update</span> <span class="free">k</span> <span class="free">v</span> <span class="free">p</span> <span class="main">&lt;</span><span class="free">is_map</span> <span class="main">(</span><span class="free">m</span><span class="main">(</span><span class="free">k</span> <span class="main">↦</span> <span class="free">v</span><span class="main">)</span><span class="main">)</span><span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>
    
<span class="keyword1"><span class="command">locale</span></span> imp_map_delete <span class="main">=</span> imp_map <span class="main">+</span>
  <span class="keyword2"><span class="keyword">constrains</span></span> is_map <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span> <span class="main">⇀</span> <span class="tfree">'v</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'m</span> <span class="main">⇒</span> assn"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">delete</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k</span> <span class="main">⇒</span> <span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'m</span> Heap"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> delete_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">is_map</span> <span class="free">m</span> <span class="free">p</span><span class="main">&gt;</span> <span class="free">delete</span> <span class="free">k</span> <span class="free">p</span> <span class="main">&lt;</span><span class="free">is_map</span> <span class="main">(</span><span class="free">m</span> <span class="main">|`</span> <span class="main">(</span><span class="main">-</span><span class="main">{</span><span class="free">k</span><span class="main">}</span><span class="main">)</span><span class="main">)</span><span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> imp_map_add <span class="main">=</span> imp_map <span class="main">+</span>
  <span class="keyword2"><span class="keyword">constrains</span></span> is_map <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span> <span class="main">⇀</span> <span class="tfree">'v</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'m</span> <span class="main">⇒</span> assn"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">add</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'m</span> Heap"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> add_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">is_map</span> <span class="free">m</span> <span class="free">p</span> <span class="main">*</span> <span class="free">is_map</span> <span class="free">m'</span> <span class="free">p'</span><span class="main">&gt;</span> <span class="free">add</span> <span class="free">p</span> <span class="free">p'</span> 
     <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="free">is_map</span> <span class="free">m</span> <span class="free">p</span> <span class="main">*</span> <span class="free">is_map</span> <span class="free">m'</span> <span class="free">p'</span> <span class="main">*</span> <span class="free">is_map</span> <span class="main">(</span><span class="free">m</span> <span class="main">++</span> <span class="free">m'</span><span class="main">)</span> <span class="bound">r</span><span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>


<span class="keyword1"><span class="command">locale</span></span> imp_map_size <span class="main">=</span> imp_map <span class="main">+</span>
  <span class="keyword2"><span class="keyword">constrains</span></span> is_map <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span> <span class="main">⇀</span> <span class="tfree">'v</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'m</span> <span class="main">⇒</span> assn"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">size</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> <span class="main">⇒</span> nat Heap"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> size_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">is_map</span> <span class="free">m</span> <span class="free">p</span><span class="main">&gt;</span> <span class="free">size</span> <span class="free">p</span> <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="free">is_map</span> <span class="free">m</span> <span class="free">p</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="bound">r</span> <span class="main">=</span> card <span class="main">(</span>dom <span class="free">m</span><span class="main">)</span><span class="main">)</span><span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> imp_map_iterate <span class="main">=</span> imp_map <span class="main">+</span>
  <span class="keyword2"><span class="keyword">constrains</span></span> is_map <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span> <span class="main">⇀</span> <span class="tfree">'v</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'m</span> <span class="main">⇒</span> assn"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">is_it</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span> <span class="main">⇀</span> <span class="tfree">'v</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'m</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span> <span class="main">⇀</span> <span class="tfree">'v</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'it</span> <span class="main">⇒</span> assn"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">it_init</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'it</span><span class="main">)</span> Heap"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">it_has_next</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'it</span> <span class="main">⇒</span> bool Heap"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">it_next</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'it</span> <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'k</span><span class="main">×</span><span class="tfree">'v</span><span class="main">)</span><span class="main">×</span><span class="tfree">'it</span><span class="main">)</span> Heap"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> it_init_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">is_map</span> <span class="free">s</span> <span class="free">p</span><span class="main">&gt;</span> <span class="free">it_init</span> <span class="free">p</span> <span class="main">&lt;</span><span class="free">is_it</span> <span class="free">s</span> <span class="free">p</span> <span class="free">s</span><span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> it_next_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">m'</span><span class="main">≠</span>Map.empty <span class="main">⟹</span> 
    <span class="main">&lt;</span><span class="free">is_it</span> <span class="free">m</span> <span class="free">p</span> <span class="free">m'</span> <span class="free">it</span><span class="main">&gt;</span> 
      <span class="free">it_next</span> <span class="free">it</span> 
    <span class="main">&lt;</span><span class="main">λ</span><span class="main">(</span><span class="main">(</span><span class="bound">k</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">,</span><span class="bound">it'</span><span class="main">)</span><span class="main">.</span> <span class="free">is_it</span> <span class="free">m</span> <span class="free">p</span> <span class="main">(</span><span class="free">m'</span> <span class="main">|`</span> <span class="main">(</span><span class="main">-</span><span class="main">{</span><span class="bound">k</span><span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="bound">it'</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="free">m'</span> <span class="bound">k</span> <span class="main">=</span> Some <span class="bound">v</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> it_has_next_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">is_it</span> <span class="free">m</span> <span class="free">p</span> <span class="free">m'</span> <span class="free">it</span><span class="main">&gt;</span> <span class="free">it_has_next</span> <span class="free">it</span> <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="free">is_it</span> <span class="free">m</span> <span class="free">p</span> <span class="free">m'</span> <span class="free">it</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="bound">r</span><span class="main">⟷</span><span class="free">m'</span><span class="main">≠</span>Map.empty<span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> quit_iteration<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free">is_it</span> <span class="free">m</span> <span class="free">p</span> <span class="free">m'</span> <span class="free">it</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">is_map</span> <span class="free">m</span> <span class="free">p</span> <span class="main">*</span> <span class="keyword1">true</span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> imp_map_iterate' <span class="main">=</span> imp_map <span class="main">+</span>
  <span class="keyword2"><span class="keyword">constrains</span></span> is_map <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span> <span class="main">⇀</span> <span class="tfree">'v</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'m</span> <span class="main">⇒</span> assn"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">is_it</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span> <span class="main">⇀</span> <span class="tfree">'v</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'m</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span><span class="main">×</span><span class="tfree">'v</span><span class="main">)</span> list <span class="main">⇒</span> <span class="tfree">'it</span> <span class="main">⇒</span> assn"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">it_init</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'it</span><span class="main">)</span> Heap"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">it_has_next</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'it</span> <span class="main">⇒</span> bool Heap"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">it_next</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'it</span> <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'k</span><span class="main">×</span><span class="tfree">'v</span><span class="main">)</span><span class="main">×</span><span class="tfree">'it</span><span class="main">)</span> Heap"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> it_init_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">is_map</span> <span class="free">s</span> <span class="free">p</span><span class="main">&gt;</span> <span class="free">it_init</span> <span class="free">p</span> <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">l</span><span class="main">.</span> <span class="main">↑</span><span class="main">(</span>map_of <span class="bound">l</span> <span class="main">=</span> <span class="free">s</span><span class="main">)</span> <span class="main">*</span> <span class="free">is_it</span> <span class="free">s</span> <span class="free">p</span> <span class="bound">l</span> <span class="bound">r</span><span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> it_next_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">" 
    <span class="main">&lt;</span><span class="free">is_it</span> <span class="free">m</span> <span class="free">p</span> <span class="main">(</span><span class="free">kv</span><span class="main">#</span><span class="free">l</span><span class="main">)</span> <span class="free">it</span><span class="main">&gt;</span> 
      <span class="free">it_next</span> <span class="free">it</span> 
    <span class="main">&lt;</span><span class="main">λ</span><span class="main">(</span><span class="bound">kv'</span><span class="main">,</span><span class="bound">it'</span><span class="main">)</span><span class="main">.</span> <span class="free">is_it</span> <span class="free">m</span> <span class="free">p</span> <span class="free">l</span> <span class="bound">it'</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="bound">kv'</span><span class="main">=</span><span class="free">kv</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> it_has_next_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">is_it</span> <span class="free">m</span> <span class="free">p</span> <span class="free">l</span> <span class="free">it</span><span class="main">&gt;</span> <span class="free">it_has_next</span> <span class="free">it</span> <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="free">is_it</span> <span class="free">m</span> <span class="free">p</span> <span class="free">l</span> <span class="free">it</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="bound">r</span><span class="main">⟷</span><span class="free">l</span><span class="main">≠</span><span class="main">[]</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> quit_iteration<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free">is_it</span> <span class="free">m</span> <span class="free">p</span> <span class="free">l</span> <span class="free">it</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">is_map</span> <span class="free">m</span> <span class="free">p</span> <span class="main">*</span> <span class="keyword1">true</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Hash_Table">
<div class="head">
<h1>Theory Hash_Table</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">"Hash-Tables"</span></span>
<span class="keyword1"><span class="command">theory</span></span> Hash_Table
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="../Collections/HashCode.html">Collections.HashCode</a>
  <a href="../Collections/Code_Target_ICF.html">Collections.Code_Target_ICF</a>
  <span class="quoted">"<a href="Sep_Main.html">../Sep_Main</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Datatype›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Definition›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="main">(</span><span class="tfree">'k</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">)</span> hashtable <span class="main">=</span> HashTable <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span> <span class="main">×</span> <span class="tfree">'v</span><span class="main">)</span> list array"</span></span> <span class="quoted">nat</span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">the_array</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">)</span> hashtable <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span> <span class="main">×</span> <span class="tfree">'v</span><span class="main">)</span> list array"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">the_array</span> <span class="main">(</span>HashTable <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span>"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">the_size</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">)</span> hashtable <span class="main">⇒</span> nat"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">the_size</span> <span class="main">(</span>HashTable <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span>"</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Storable on Heap›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">hs_encode</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span><span class="main">::</span>countable<span class="main">,</span> <span class="tfree">'v</span><span class="main">::</span>countable<span class="main">)</span> hashtable <span class="main">⇒</span> nat"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">hs_encode</span> <span class="main">(</span>HashTable <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> to_nat <span class="main">(</span><span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">instance</span></span> hashtable <span class="main">::</span> <span class="main">(</span><span class="quoted">countable</span><span class="main">,</span> <span class="quoted">countable</span><span class="main">)</span> <span class="quoted">countable</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> countable_classI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted">"hs_encode"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> hashtable"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"hs_encode <span class="skolem">x</span> <span class="main">=</span> hs_encode <span class="skolem">y</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">y</span></span><span class="main">)</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">instance</span></span> hashtable <span class="main">::</span> <span class="main">(</span><span class="quoted">heap</span><span class="main">,</span> <span class="quoted">heap</span><span class="main">)</span> <span class="quoted">heap</span> <span class="keyword1"><span class="command">..</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Assertions›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Assertion for Hashtable›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ht_table</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span><span class="main">::</span>heap <span class="main">×</span> <span class="tfree">'v</span><span class="main">::</span>heap<span class="main">)</span> list list <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">)</span> hashtable <span class="main">⇒</span> assn"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ht_table</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">ht</span></span></span> <span class="main">=</span> <span class="main">(</span>the_array <span class="free"><span class="bound"><span class="entity">ht</span></span></span><span class="main">)</span> <span class="keyword1">↦<span class="hidden">⇩</span><sub>a</sub></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ht_size</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list list <span class="main">⇒</span> nat <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ht_size</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> sum_list <span class="main">(</span>map length <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ht_hash</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span><span class="main">::</span>hashable <span class="main">×</span> <span class="tfree">'v</span><span class="main">)</span> list list <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ht_hash</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">≡</span> <span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span>length <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">.</span> <span class="main">∀</span><span class="bound">x</span><span class="main">∈</span>set <span class="main">(</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">!</span><span class="bound">i</span><span class="main">)</span><span class="main">.</span>
    bounded_hashcode_nat <span class="main">(</span>length <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="main">(</span>fst <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="bound">i</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ht_distinct</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span> <span class="main">×</span> <span class="tfree">'v</span><span class="main">)</span> list list <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ht_distinct</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">≡</span> <span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span>length <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">.</span> distinct <span class="main">(</span>map fst <span class="main">(</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">!</span><span class="bound">i</span><span class="main">)</span><span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">is_hashtable</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span><span class="main">::</span><span class="main">{</span>heap<span class="main">,</span>hashable<span class="main">}</span> <span class="main">×</span> <span class="tfree">'v</span><span class="main">::</span>heap<span class="main">)</span> list list
    <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">)</span> hashtable <span class="main">⇒</span> assn"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">is_hashtable</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">ht</span></span></span> <span class="main">=</span>
  <span class="main">(</span>the_array <span class="free"><span class="bound"><span class="entity">ht</span></span></span> <span class="keyword1">↦<span class="hidden">⇩</span><sub>a</sub></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="main">*</span>
  <span class="main">↑</span><span class="main">(</span>ht_size <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">(</span>the_size <span class="free"><span class="bound"><span class="entity">ht</span></span></span><span class="main">)</span>
    <span class="main">∧</span> ht_hash <span class="free"><span class="bound"><span class="entity">l</span></span></span>
    <span class="main">∧</span> ht_distinct <span class="free"><span class="bound"><span class="entity">l</span></span></span>
    <span class="main">∧</span> <span class="main">1</span> <span class="main">&lt;</span> length <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> is_hashtable_prec<span class="main">:</span> <span class="quoted"><span class="quoted">"precise is_hashtable"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> preciseI<span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> is_hashtable_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> preciseD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> snga_prec<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹These rules are quite useful for automated methods, to avoid unfolding
  of definitions, that might be used folded in other lemmas,
  like induction hypothesis. However, they show in some sense a possibility for
  modularization improvement, as it should be enough to show an implication
  and know that the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>nth›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>len›</span></span></span></span> operations do not change
  the heap.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> ht_array_nth_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free">i</span><span class="main">&lt;</span>length <span class="free">l</span> <span class="main">⟹</span> <span class="main">&lt;</span>is_hashtable <span class="free">l</span> <span class="free">ht</span><span class="main">&gt;</span>
      Array.nth <span class="main">(</span>the_array <span class="free">ht</span><span class="main">)</span> <span class="free">i</span>
      <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> is_hashtable <span class="free">l</span> <span class="free">ht</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="bound">r</span> <span class="main">=</span> <span class="free">l</span><span class="main">!</span><span class="free">i</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> is_hashtable_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">sep_auto</span>

<span class="keyword1"><span class="command">lemma</span></span> ht_array_length_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">&lt;</span>is_hashtable <span class="free">l</span> <span class="free">ht</span><span class="main">&gt;</span>
      Array.len <span class="main">(</span>the_array <span class="free">ht</span><span class="main">)</span>
      <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> is_hashtable <span class="free">l</span> <span class="free">ht</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="bound">r</span> <span class="main">=</span> length <span class="free">l</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> is_hashtable_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">sep_auto</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹New›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Definition›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ht_new_sz</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span><span class="main">::</span><span class="main">{</span>heap<span class="main">,</span>hashable<span class="main">}</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">::</span>heap<span class="main">)</span> hashtable Heap"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ht_new_sz</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span> <span class="keyword1">let</span> <span class="bound">l</span> <span class="main">=</span> replicate <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">[]</span><span class="main">;</span>
  <span class="bound">a</span> <span class="main">←</span> Array.of_list <span class="bound">l</span><span class="main">;</span>
  return <span class="main">(</span>HashTable <span class="bound">a</span> <span class="main">0</span><span class="main">)</span> <span class="main">}</span>"</span></span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ht_new</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span><span class="main">::</span><span class="main">{</span>heap<span class="main">,</span>hashable<span class="main">}</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">::</span>heap<span class="main">)</span> hashtable Heap"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ht_new</span> <span class="main">≡</span> ht_new_sz <span class="main">(</span>def_hashmap_size <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'k</span><span class="main">)</span><span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Complete Correctness›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ht_hash_replicate<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ht_hash <span class="main">(</span>replicate <span class="free">n</span> <span class="main">[]</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ht_hash_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">i</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> ht_distinct_replicate<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ht_distinct <span class="main">(</span>replicate <span class="free">n</span> <span class="main">[]</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ht_distinct_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">i</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> ht_size_replicate<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ht_size <span class="main">(</span>replicate <span class="free">n</span> <span class="main">[]</span><span class="main">)</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ht_size_def<span class="main">)</span>

 <span class="comment1">― ‹We can't create hash tables with a size of zero›</span>
<span class="keyword1"><span class="command">lemma</span></span> complete_ht_new_sz<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;</span> <span class="free">n</span> <span class="main">⟹</span> <span class="main">&lt;</span><span class="keyword1">emp</span><span class="main">&gt;</span> ht_new_sz <span class="free">n</span> <span class="main">&lt;</span>is_hashtable <span class="main">(</span>replicate <span class="free">n</span> <span class="main">[]</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> ht_new_sz_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> replicate.simps<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> bind_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> of_list_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> return_cons_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> is_hashtable_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> complete_ht_new<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="keyword1">emp</span><span class="main">&gt;</span>
     ht_new<span class="main">::</span><span class="main">(</span><span class="tfree">'k</span><span class="main">::</span><span class="main">{</span>heap<span class="main">,</span>hashable<span class="main">}</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">::</span>heap<span class="main">)</span> hashtable Heap
   <span class="main">&lt;</span>is_hashtable <span class="main">(</span>replicate <span class="main">(</span>def_hashmap_size <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'k</span><span class="main">)</span><span class="main">)</span> <span class="main">[]</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ht_new_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> complete_ht_new_sz<span class="main"><span class="main">[</span></span><span class="operator">OF</span> def_hashmap_size<span class="main"><span class="main">]</span></span><span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Lookup›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Definition›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">ls_lookup</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span> <span class="main">×</span> <span class="tfree">'v</span><span class="main">)</span> list <span class="main">⇒</span> <span class="tfree">'v</span> option"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ls_lookup</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">[]</span> <span class="main">=</span> None"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">ls_lookup</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="keyword1">then</span> Some <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">else</span> <span class="free">ls_lookup</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ht_lookup</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span><span class="main">::</span><span class="main">{</span>heap<span class="main">,</span>hashable<span class="main">}</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">::</span>heap<span class="main">)</span> hashtable <span class="main">⇒</span> <span class="tfree">'v</span> option Heap"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ht_lookup</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">ht</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">m</span> <span class="main">←</span> Array.len <span class="main">(</span>the_array <span class="free"><span class="bound"><span class="entity">ht</span></span></span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">i</span> <span class="main">=</span> bounded_hashcode_nat <span class="bound">m</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">;</span>
    <span class="bound">l</span> <span class="main">←</span> Array.nth <span class="main">(</span>the_array <span class="free"><span class="bound"><span class="entity">ht</span></span></span><span class="main">)</span> <span class="bound">i</span><span class="main">;</span>
    return <span class="main">(</span>ls_lookup <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="bound">l</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Complete Correctness›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> complete_ht_lookup<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span>is_hashtable <span class="free">l</span> <span class="free">ht</span><span class="main">&gt;</span> ht_lookup <span class="free">x</span> <span class="free">ht</span>
     <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> is_hashtable <span class="free">l</span> <span class="free">ht</span> <span class="main">*</span>
        <span class="main">↑</span><span class="main">(</span><span class="bound">r</span> <span class="main">=</span> ls_lookup <span class="free">x</span> <span class="main">(</span><span class="free">l</span><span class="main">!</span><span class="main">(</span>bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">ht</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> is_hashtable_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ht_lookup_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> bind_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> length_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> norm_pre_pure_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> bind_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> nth_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bounded_hashcode_nat_bounds<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> norm_pre_pure_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> return_cons_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Alternative, more automatic proof›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> complete_ht_lookup_alt_proof<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span>is_hashtable <span class="free">l</span> <span class="free">ht</span><span class="main">&gt;</span> ht_lookup <span class="free">x</span> <span class="free">ht</span>
    <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> is_hashtable <span class="free">l</span> <span class="free">ht</span> <span class="main">*</span>
      <span class="main">↑</span><span class="main">(</span><span class="bound">r</span> <span class="main">=</span> ls_lookup <span class="free">x</span> <span class="main">(</span><span class="free">l</span><span class="main">!</span><span class="main">(</span>bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> is_hashtable_def ht_lookup_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">ht</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> bounded_hashcode_nat_bounds<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Update›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Definition›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">ls_update</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k</span> <span class="main">⇒</span> <span class="tfree">'v</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span> <span class="main">×</span> <span class="tfree">'v</span><span class="main">)</span> list <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'k</span> <span class="main">×</span> <span class="tfree">'v</span><span class="main">)</span> list <span class="main">×</span> bool<span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ls_update</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">[]</span> <span class="main">=</span> <span class="main">(</span><span class="main">[</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span><span class="main">]</span><span class="main">,</span> False<span class="main">)</span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">ls_update</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span><span class="main">)</span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ls</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>
    <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="keyword1">then</span>
      <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ls</span></span></span><span class="main">,</span> True<span class="main">)</span>
    <span class="keyword1">else</span>
      <span class="main">(</span><span class="keyword1">let</span> <span class="bound">r</span> <span class="main">=</span> <span class="free">ls_update</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">ls</span></span></span> <span class="keyword1">in</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span><span class="main">)</span> <span class="main">#</span> fst <span class="bound">r</span><span class="main">,</span> snd <span class="bound">r</span><span class="main">)</span><span class="main">)</span>
  <span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">abs_update</span>
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k</span><span class="main">::</span>hashable <span class="main">⇒</span> <span class="tfree">'v</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span> <span class="main">×</span> <span class="tfree">'v</span><span class="main">)</span> list list <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span> <span class="main">×</span> <span class="tfree">'v</span><span class="main">)</span> list list"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">abs_update</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span>
    <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">[</span>bounded_hashcode_nat <span class="main">(</span>length <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span>
      <span class="main">:=</span> fst <span class="main">(</span>ls_update <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">!</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">]</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ls_update_snd_set<span class="main">:</span> <span class="quoted"><span class="quoted">"snd <span class="main">(</span>ls_update <span class="free">k</span> <span class="free">v</span> <span class="free">l</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">k</span> <span class="main">∈</span> set <span class="main">(</span>map fst <span class="free">l</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">l</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> ls_update.induct<span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> ls_update_fst_set<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>fst <span class="main">(</span>ls_update <span class="free">k</span> <span class="free">v</span> <span class="free">l</span><span class="main">)</span><span class="main">)</span> <span class="main">⊆</span> insert <span class="main">(</span><span class="free">k</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="main">(</span>set <span class="free">l</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">l</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> ls_update.induct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> ls_update_fst_map_set<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>map fst <span class="main">(</span>fst <span class="main">(</span>ls_update <span class="free">k</span> <span class="free">v</span> <span class="free">l</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> insert <span class="free">k</span> <span class="main">(</span>set <span class="main">(</span>map fst <span class="free">l</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">l</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> ls_update.induct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> ls_update_distinct<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst <span class="free">l</span><span class="main">)</span> <span class="main">⟹</span> distinct <span class="main">(</span>map fst <span class="main">(</span>fst <span class="main">(</span>ls_update <span class="free">k</span> <span class="free">v</span> <span class="free">l</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">l</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> ls_update.induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 1 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>2 <span class="skolem">k</span> <span class="skolem">v</span> <span class="skolem">l</span> <span class="skolem">w</span> <span class="skolem">ls</span><span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span> <span class="main">=</span> <span class="skolem">l</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">with</span></span> 2 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">with</span></span> 2 <span class="keyword1"><span class="command">have</span></span> d<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst <span class="main">(</span>fst <span class="main">(</span>ls_update <span class="skolem">k</span> <span class="skolem">v</span> <span class="skolem">ls</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> 2<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">l</span> <span class="main">∉</span> set <span class="main">(</span>map fst <span class="skolem">ls</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">with</span></span> False <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">l</span> <span class="main">∉</span> set <span class="main">(</span>map fst <span class="main">(</span>fst <span class="main">(</span>ls_update <span class="skolem">k</span> <span class="skolem">v</span> <span class="skolem">ls</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> ls_update_fst_map_set<span class="main">)</span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">with</span></span> d False <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ls_update_length<span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>fst <span class="main">(</span>ls_update <span class="free">k</span> <span class="free">v</span> <span class="free">l</span><span class="main">)</span><span class="main">)</span>
  <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="main">(</span><span class="free">k</span> <span class="main">∈</span> set <span class="main">(</span>map fst <span class="free">l</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">then</span> length <span class="free">l</span> <span class="keyword1">else</span> Suc <span class="main">(</span>length <span class="free">l</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">l</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> ls_update.induct<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ls_update_length_snd_True<span class="main">:</span>
  <span class="quoted"><span class="quoted">"snd <span class="main">(</span>ls_update <span class="free">k</span> <span class="free">v</span> <span class="free">l</span><span class="main">)</span> <span class="main">⟹</span> length <span class="main">(</span>fst <span class="main">(</span>ls_update <span class="free">k</span> <span class="free">v</span> <span class="free">l</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> length <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ls_update_length ls_update_snd_set<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ls_update_length_snd_False<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">¬</span> snd <span class="main">(</span>ls_update <span class="free">k</span> <span class="free">v</span> <span class="free">l</span><span class="main">)</span> <span class="main">⟹</span> length <span class="main">(</span>fst <span class="main">(</span>ls_update <span class="free">k</span> <span class="free">v</span> <span class="free">l</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Suc <span class="main">(</span>length <span class="free">l</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ls_update_length ls_update_snd_set<span class="main">)</span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ht_upd</span>
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k</span> <span class="main">⇒</span> <span class="tfree">'v</span>
    <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span><span class="main">::</span><span class="main">{</span>heap<span class="main">,</span>hashable<span class="main">}</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">::</span>heap<span class="main">)</span> hashtable
    <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">)</span> hashtable Heap"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ht_upd</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">ht</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">m</span> <span class="main">←</span> Array.len <span class="main">(</span>the_array <span class="free"><span class="bound"><span class="entity">ht</span></span></span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">i</span> <span class="main">=</span> bounded_hashcode_nat <span class="bound">m</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">;</span>
      <span class="bound">l</span> <span class="main">←</span> Array.nth <span class="main">(</span>the_array <span class="free"><span class="bound"><span class="entity">ht</span></span></span><span class="main">)</span> <span class="bound">i</span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">l</span> <span class="main">=</span> ls_update <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="bound">l</span><span class="main">;</span>
      Array.upd <span class="bound">i</span> <span class="main">(</span>fst <span class="bound">l</span><span class="main">)</span> <span class="main">(</span>the_array <span class="free"><span class="bound"><span class="entity">ht</span></span></span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">n</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="main">(</span>snd <span class="bound">l</span><span class="main">)</span> <span class="keyword1">then</span> the_size <span class="free"><span class="bound"><span class="entity">ht</span></span></span> <span class="keyword1">else</span> Suc <span class="main">(</span>the_size <span class="free"><span class="bound"><span class="entity">ht</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
      return <span class="main">(</span>HashTable <span class="main">(</span>the_array <span class="free"><span class="bound"><span class="entity">ht</span></span></span><span class="main">)</span> <span class="bound">n</span><span class="main">)</span>
    <span class="main">}</span>"</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Complete Correctness›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ht_hash_update<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_hash <span class="free">ls</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ht_hash <span class="main">(</span>abs_update <span class="free">k</span> <span class="free">v</span> <span class="free">ls</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ht_hash_def abs_update_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> allI ballI impI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">premises</span></span> prems <span class="keyword2"><span class="keyword">for</span></span> i x
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">=</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">ls</span><span class="main">)</span> <span class="free">k</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">note</span></span> i <span class="main">=</span> True
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"fst <span class="skolem">x</span> <span class="main">=</span> <span class="free">k</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True
      <span class="keyword1"><span class="command">with</span></span> i <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False
      <span class="keyword1"><span class="command">with</span></span> prems i
      <span class="keyword1"><span class="command">have</span></span>
        <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> set <span class="main">(</span>fst <span class="main">(</span>ls_update <span class="free">k</span> <span class="free">v</span>
                         <span class="main">(</span><span class="free">ls</span> <span class="main">!</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">ls</span><span class="main">)</span> <span class="free">k</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span>
        ls_update_fst_set<span class="main">[</span>
          <span class="operator">of</span> <span class="quoted"><span class="free">k</span></span> <span class="quoted"><span class="free">v</span></span> <span class="quoted"><span class="quoted">"<span class="free">ls</span> <span class="main">!</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">ls</span><span class="main">)</span> <span class="free">k</span>"</span></span><span class="main">]</span>
        False
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> insert <span class="main">(</span><span class="free">k</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span>
                  <span class="main">(</span>set <span class="main">(</span><span class="free">ls</span> <span class="main">!</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">ls</span><span class="main">)</span> <span class="free">k</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> False <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> set <span class="main">(</span><span class="free">ls</span> <span class="main">!</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">ls</span><span class="main">)</span> <span class="free">k</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> i prems assms<span class="main">[</span><span class="operator">unfolded</span> ht_hash_def<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">with</span></span> prems <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> set <span class="main">(</span><span class="free">ls</span> <span class="main">!</span> <span class="skolem">i</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">with</span></span> prems assms<span class="main">[</span><span class="operator">unfolded</span> ht_hash_def<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">lemma</span></span> ht_distinct_update<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_distinct <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ht_distinct <span class="main">(</span>abs_update <span class="free">k</span> <span class="free">v</span> <span class="free">l</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ht_distinct_def abs_update_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> allI impI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">premises</span></span> prems <span class="keyword2"><span class="keyword">for</span></span> i
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">=</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">with</span></span> prems assms<span class="main">[</span><span class="operator">unfolded</span> ht_distinct_def<span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst <span class="main">(</span><span class="free">l</span> <span class="main">!</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> ls_update_distinct<span class="main">[</span><span class="operator">OF</span> this<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">k</span></span> <span class="quoted"><span class="free">v</span></span><span class="main">]</span> True prems
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">with</span></span> prems assms<span class="main">[</span><span class="operator">unfolded</span> ht_distinct_def<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">lemma</span></span> length_update<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;</span> length <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;</span> length <span class="main">(</span>abs_update <span class="free">k</span> <span class="free">v</span> <span class="free">l</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> abs_update_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ht_size_update1<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> size<span class="main">:</span> <span class="quoted"><span class="quoted">"ht_size <span class="free">l</span> <span class="free">n</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> i<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">&lt;</span> length <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> snd<span class="main">:</span> <span class="quoted"><span class="quoted">"snd <span class="main">(</span>ls_update <span class="free">k</span> <span class="free">v</span> <span class="main">(</span><span class="free">l</span> <span class="main">!</span> <span class="free">i</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ht_size <span class="main">(</span><span class="free">l</span><span class="main">[</span><span class="free">i</span> <span class="main">:=</span> fst <span class="main">(</span>ls_update <span class="free">k</span> <span class="free">v</span> <span class="main">(</span><span class="free">l</span><span class="main">!</span><span class="free">i</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>map length <span class="main">(</span><span class="free">l</span><span class="main">[</span><span class="free">i</span> <span class="main">:=</span> fst <span class="main">(</span>ls_update <span class="free">k</span> <span class="free">v</span> <span class="main">(</span><span class="free">l</span> <span class="main">!</span> <span class="free">i</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
    <span class="main">=</span> <span class="main">(</span>map length <span class="free">l</span><span class="main">)</span><span class="main">[</span><span class="free">i</span> <span class="main">:=</span> length <span class="main">(</span>fst <span class="main">(</span>ls_update <span class="free">k</span> <span class="free">v</span> <span class="main">(</span><span class="free">l</span> <span class="main">!</span> <span class="free">i</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">]</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_update<span class="main">)</span> <span class="keyword1"><span class="command">also</span></span>
  <span class="keyword1"><span class="command">from</span></span> sum_list_update<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">i</span></span> <span class="quoted"><span class="quoted">"map length <span class="free">l</span>"</span></span><span class="main">,</span> <span class="operator">simplified</span><span class="main">,</span> <span class="operator">OF</span> i<span class="main">,</span>
    <span class="operator">of</span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>fst <span class="main">(</span>ls_update <span class="free">k</span> <span class="free">v</span> <span class="main">(</span><span class="free">l</span> <span class="main">!</span> <span class="free">i</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="main">]</span>
    ls_update_length_snd_True<span class="main">[</span><span class="operator">OF</span> snd<span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span>
    <span class="quoted"><span class="quoted">"sum_list <span class="main">(</span><span class="main">(</span>map length <span class="free">l</span><span class="main">)</span><span class="main">[</span><span class="free">i</span> <span class="main">:=</span> length <span class="main">(</span>fst <span class="main">(</span>ls_update <span class="free">k</span> <span class="free">v</span> <span class="main">(</span><span class="free">l</span> <span class="main">!</span> <span class="free">i</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">)</span>
    <span class="main">=</span> sum_list <span class="main">(</span>map length <span class="free">l</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ht_size_def assms<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ht_size_update2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> size<span class="main">:</span> <span class="quoted"><span class="quoted">"ht_size <span class="free">l</span> <span class="free">n</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> i<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">&lt;</span> length <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> snd<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> snd <span class="main">(</span>ls_update <span class="free">k</span> <span class="free">v</span> <span class="main">(</span><span class="free">l</span> <span class="main">!</span> <span class="free">i</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ht_size <span class="main">(</span><span class="free">l</span><span class="main">[</span><span class="free">i</span> <span class="main">:=</span> fst <span class="main">(</span>ls_update <span class="free">k</span> <span class="free">v</span> <span class="main">(</span><span class="free">l</span><span class="main">!</span><span class="free">i</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>map length <span class="main">(</span><span class="free">l</span><span class="main">[</span><span class="free">i</span> <span class="main">:=</span> fst <span class="main">(</span>ls_update <span class="free">k</span> <span class="free">v</span> <span class="main">(</span><span class="free">l</span> <span class="main">!</span> <span class="free">i</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
    <span class="main">=</span> <span class="main">(</span>map length <span class="free">l</span><span class="main">)</span><span class="main">[</span><span class="free">i</span> <span class="main">:=</span> length <span class="main">(</span>fst <span class="main">(</span>ls_update <span class="free">k</span> <span class="free">v</span> <span class="main">(</span><span class="free">l</span> <span class="main">!</span> <span class="free">i</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">]</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_update<span class="main">)</span> <span class="keyword1"><span class="command">also</span></span>
  <span class="keyword1"><span class="command">from</span></span> sum_list_update<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">i</span></span> <span class="quoted"><span class="quoted">"map length <span class="free">l</span>"</span></span><span class="main">,</span> <span class="operator">simplified</span><span class="main">,</span> <span class="operator">OF</span> i<span class="main">,</span>
    <span class="operator">of</span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>fst <span class="main">(</span>ls_update <span class="free">k</span> <span class="free">v</span> <span class="main">(</span><span class="free">l</span> <span class="main">!</span> <span class="free">i</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="main">]</span>
    ls_update_length_snd_False<span class="main">[</span><span class="operator">OF</span> snd<span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span>
    <span class="quoted"><span class="quoted">"sum_list <span class="main">(</span><span class="main">(</span>map length <span class="free">l</span><span class="main">)</span><span class="main">[</span><span class="free">i</span> <span class="main">:=</span> length <span class="main">(</span>fst <span class="main">(</span>ls_update <span class="free">k</span> <span class="free">v</span> <span class="main">(</span><span class="free">l</span> <span class="main">!</span> <span class="free">i</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">)</span>
    <span class="main">=</span> Suc <span class="main">(</span>sum_list <span class="main">(</span>map length <span class="free">l</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ht_size_def assms<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">lemma</span></span> complete_ht_upd<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span>is_hashtable <span class="free">l</span> <span class="free">ht</span><span class="main">&gt;</span> ht_upd <span class="free">k</span> <span class="free">v</span> <span class="free">ht</span>
  <span class="main">&lt;</span>is_hashtable <span class="main">(</span>abs_update <span class="free">k</span> <span class="free">v</span> <span class="free">l</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ht_upd_def is_hashtable_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> norm_pre_pure_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> bind_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> length_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> norm_pre_pure_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> bind_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> nth_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bounded_hashcode_nat_bounds<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> norm_pre_pure_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> bind_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> upd_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bounded_hashcode_nat_bounds<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> return_cons_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span>
    <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ht_size_update1 ht_size_update2 bounded_hashcode_nat_bounds
              is_hashtable_def ht_hash_update<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> abs_update_def<span class="main"><span class="main">]</span></span>
              ht_distinct_update<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> abs_update_def<span class="main"><span class="main">]</span></span> abs_update_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Alternative, more automatic proof›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> complete_ht_upd_alt_proof<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span>is_hashtable <span class="free">l</span> <span class="free">ht</span><span class="main">&gt;</span> ht_upd <span class="free">k</span> <span class="free">v</span> <span class="free">ht</span> <span class="main">&lt;</span>is_hashtable <span class="main">(</span>abs_update <span class="free">k</span> <span class="free">v</span> <span class="free">l</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ht_upd_def is_hashtable_def Let_def
  <span class="comment1">(* TODO: Is this huge simp-step really necessary? *)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span>
    <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ht_size_update1 ht_size_update2 bounded_hashcode_nat_bounds
              is_hashtable_def ht_hash_update<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> abs_update_def<span class="main"><span class="main">]</span></span>
              ht_distinct_update<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> abs_update_def<span class="main"><span class="main">]</span></span> abs_update_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Delete›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Definition›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">ls_delete</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span> <span class="main">×</span> <span class="tfree">'v</span><span class="main">)</span> list <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'k</span> <span class="main">×</span> <span class="tfree">'v</span><span class="main">)</span> list <span class="main">×</span> bool<span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ls_delete</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">[]</span> <span class="main">=</span> <span class="main">(</span><span class="main">[]</span><span class="main">,</span> False<span class="main">)</span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">ls_delete</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span><span class="main">)</span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ls</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>
    <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="keyword1">then</span>
      <span class="main">(</span><span class="free"><span class="bound"><span class="entity">ls</span></span></span><span class="main">,</span> True<span class="main">)</span>
    <span class="keyword1">else</span>
      <span class="main">(</span><span class="keyword1">let</span> <span class="bound">r</span> <span class="main">=</span> <span class="free">ls_delete</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">ls</span></span></span> <span class="keyword1">in</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span><span class="main">)</span> <span class="main">#</span> fst <span class="bound">r</span><span class="main">,</span> snd <span class="bound">r</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ls_delete_snd_set<span class="main">:</span> <span class="quoted"><span class="quoted">"snd <span class="main">(</span>ls_delete <span class="free">k</span> <span class="free">l</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">k</span> <span class="main">∈</span> set <span class="main">(</span>map fst <span class="free">l</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">l</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> ls_delete.induct<span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> ls_delete_fst_set<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>fst <span class="main">(</span>ls_delete <span class="free">k</span> <span class="free">l</span><span class="main">)</span><span class="main">)</span> <span class="main">⊆</span> set <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">l</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> ls_delete.induct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> ls_delete_fst_map_set<span class="main">:</span>
  <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst <span class="free">l</span><span class="main">)</span> <span class="main">⟹</span>
  set <span class="main">(</span>map fst <span class="main">(</span>fst <span class="main">(</span>ls_delete <span class="free">k</span> <span class="free">l</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>set <span class="main">(</span>map fst <span class="free">l</span><span class="main">)</span><span class="main">)</span> <span class="main">-</span> <span class="main">{</span><span class="free">k</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">l</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> ls_delete.induct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> ls_delete_distinct<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst <span class="free">l</span><span class="main">)</span> <span class="main">⟹</span> distinct <span class="main">(</span>map fst <span class="main">(</span>fst <span class="main">(</span>ls_delete <span class="free">k</span> <span class="free">l</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">l</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> ls_delete.induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 1 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>2 <span class="skolem">k</span> <span class="skolem">l</span> <span class="skolem">w</span> <span class="skolem">ls</span><span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span> <span class="main">=</span> <span class="skolem">l</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">with</span></span> 2 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">with</span></span> 2 <span class="keyword1"><span class="command">have</span></span> d<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst <span class="main">(</span>fst <span class="main">(</span>ls_delete <span class="skolem">k</span> <span class="skolem">ls</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> 2 <span class="keyword1"><span class="command">have</span></span> d2<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst <span class="skolem">ls</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> 2<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">l</span> <span class="main">∉</span> set <span class="main">(</span>map fst <span class="skolem">ls</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">with</span></span> False 2 ls_delete_fst_map_set<span class="main">[</span><span class="operator">OF</span> d2<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="skolem">k</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">l</span> <span class="main">∉</span> set <span class="main">(</span>map fst <span class="main">(</span>fst <span class="main">(</span>ls_delete <span class="skolem">k</span> <span class="skolem">ls</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">with</span></span> d False <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ls_delete_length<span class="main">:</span>
  <span class="quoted"><span class="quoted">"length <span class="main">(</span>fst <span class="main">(</span>ls_delete <span class="free">k</span> <span class="free">l</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>
    <span class="keyword1">if</span> <span class="main">(</span><span class="free">k</span> <span class="main">∈</span> set <span class="main">(</span>map fst <span class="free">l</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">then</span>
      <span class="main">(</span>length <span class="free">l</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span>
    <span class="keyword1">else</span>
      length <span class="free">l</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">l</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> ls_delete.induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 1
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>2 <span class="skolem">k</span> <span class="skolem">l</span> <span class="skolem">w</span> <span class="skolem">ls</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ls</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ls_delete_length_snd_True<span class="main">:</span>
  <span class="quoted"><span class="quoted">"snd <span class="main">(</span>ls_delete <span class="free">k</span> <span class="free">l</span><span class="main">)</span> <span class="main">⟹</span> length <span class="main">(</span>fst <span class="main">(</span>ls_delete <span class="free">k</span> <span class="free">l</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> length <span class="free">l</span> <span class="main">-</span> <span class="main">1</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ls_delete_length ls_delete_snd_set<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ls_delete_length_snd_False<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">¬</span> snd <span class="main">(</span>ls_delete <span class="free">k</span> <span class="free">l</span><span class="main">)</span> <span class="main">⟹</span> length <span class="main">(</span>fst <span class="main">(</span>ls_delete <span class="free">k</span> <span class="free">l</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> length <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ls_delete_length ls_delete_snd_set<span class="main">)</span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ht_delete</span>
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k</span>
    <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span><span class="main">::</span><span class="main">{</span>heap<span class="main">,</span>hashable<span class="main">}</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">::</span>heap<span class="main">)</span> hashtable
    <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">)</span> hashtable Heap"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ht_delete</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">ht</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">m</span> <span class="main">←</span> Array.len <span class="main">(</span>the_array <span class="free"><span class="bound"><span class="entity">ht</span></span></span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">i</span> <span class="main">=</span> bounded_hashcode_nat <span class="bound">m</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">;</span>
      <span class="bound">l</span> <span class="main">←</span> Array.nth <span class="main">(</span>the_array <span class="free"><span class="bound"><span class="entity">ht</span></span></span><span class="main">)</span> <span class="bound">i</span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">l</span> <span class="main">=</span> ls_delete <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="bound">l</span><span class="main">;</span>
      Array.upd <span class="bound">i</span> <span class="main">(</span>fst <span class="bound">l</span><span class="main">)</span> <span class="main">(</span>the_array <span class="free"><span class="bound"><span class="entity">ht</span></span></span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">n</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="main">(</span>snd <span class="bound">l</span><span class="main">)</span> <span class="keyword1">then</span> <span class="main">(</span>the_size <span class="free"><span class="bound"><span class="entity">ht</span></span></span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="keyword1">else</span> the_size <span class="free"><span class="bound"><span class="entity">ht</span></span></span><span class="main">)</span><span class="main">;</span>
      return <span class="main">(</span>HashTable <span class="main">(</span>the_array <span class="free"><span class="bound"><span class="entity">ht</span></span></span><span class="main">)</span> <span class="bound">n</span><span class="main">)</span>
    <span class="main">}</span>"</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Complete Correctness›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ht_hash_delete<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_hash <span class="free">ls</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ht_hash <span class="main">(</span>
    <span class="free">ls</span><span class="main">[</span>bounded_hashcode_nat <span class="main">(</span>length <span class="free">ls</span><span class="main">)</span> <span class="free">k</span>
      <span class="main">:=</span> fst <span class="main">(</span>ls_delete <span class="free">k</span>
               <span class="main">(</span><span class="free">ls</span> <span class="main">!</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">ls</span><span class="main">)</span> <span class="free">k</span><span class="main">)</span>
             <span class="main">)</span>
      <span class="main">]</span>
  <span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ht_hash_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> allI ballI impI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">premises</span></span> prems <span class="keyword2"><span class="keyword">for</span></span> i x
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">=</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">ls</span><span class="main">)</span> <span class="free">k</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> i<span class="main">:</span> True
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"fst <span class="skolem">x</span> <span class="main">=</span> <span class="free">k</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True
      <span class="keyword1"><span class="command">with</span></span> i <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False
      <span class="keyword1"><span class="command">with</span></span> prems i
      <span class="keyword1"><span class="command">have</span></span>
        <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> set <span class="main">(</span>fst <span class="main">(</span>ls_delete <span class="free">k</span>
                        <span class="main">(</span><span class="free">ls</span> <span class="main">!</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">ls</span><span class="main">)</span> <span class="free">k</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span>
        ls_delete_fst_set<span class="main">[</span>
          <span class="operator">of</span> <span class="quoted"><span class="free">k</span></span> <span class="quoted"><span class="quoted">"<span class="free">ls</span> <span class="main">!</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">ls</span><span class="main">)</span> <span class="free">k</span>"</span></span><span class="main">]</span>
        False
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="main">(</span>set <span class="main">(</span><span class="free">ls</span> <span class="main">!</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">ls</span><span class="main">)</span> <span class="free">k</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> i prems assms<span class="main">[</span><span class="operator">unfolded</span> ht_hash_def<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">with</span></span> prems <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> set <span class="main">(</span><span class="free">ls</span> <span class="main">!</span> <span class="skolem">i</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">with</span></span> prems assms<span class="main">[</span><span class="operator">unfolded</span> ht_hash_def<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> ht_distinct_delete<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_distinct <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ht_distinct <span class="main">(</span>
    <span class="free">l</span><span class="main">[</span>bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span>
      <span class="main">:=</span> fst <span class="main">(</span>ls_delete <span class="free">k</span> <span class="main">(</span><span class="free">l</span> <span class="main">!</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ht_distinct_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> allI impI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">premises</span></span> prems <span class="keyword2"><span class="keyword">for</span></span> i
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">=</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">with</span></span> prems assms<span class="main">[</span><span class="operator">unfolded</span> ht_distinct_def<span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst <span class="main">(</span><span class="free">l</span> <span class="main">!</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> ls_delete_distinct<span class="main">[</span><span class="operator">OF</span> this<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">k</span></span><span class="main">]</span> True prems
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">with</span></span> prems assms<span class="main">[</span><span class="operator">unfolded</span> ht_distinct_def<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> ht_size_delete1<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> size<span class="main">:</span> <span class="quoted"><span class="quoted">"ht_size <span class="free">l</span> <span class="free">n</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> i<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">&lt;</span> length <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> snd<span class="main">:</span> <span class="quoted"><span class="quoted">"snd <span class="main">(</span>ls_delete <span class="free">k</span> <span class="main">(</span><span class="free">l</span> <span class="main">!</span> <span class="free">i</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ht_size <span class="main">(</span><span class="free">l</span><span class="main">[</span><span class="free">i</span> <span class="main">:=</span> fst <span class="main">(</span>ls_delete <span class="free">k</span> <span class="main">(</span><span class="free">l</span><span class="main">!</span><span class="free">i</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="main">(</span><span class="free">n</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>map length <span class="main">(</span><span class="free">l</span><span class="main">[</span><span class="free">i</span> <span class="main">:=</span> fst <span class="main">(</span>ls_delete <span class="free">k</span> <span class="main">(</span><span class="free">l</span> <span class="main">!</span> <span class="free">i</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
    <span class="main">=</span> <span class="main">(</span>map length <span class="free">l</span><span class="main">)</span><span class="main">[</span><span class="free">i</span> <span class="main">:=</span> length <span class="main">(</span>fst <span class="main">(</span>ls_delete <span class="free">k</span> <span class="main">(</span><span class="free">l</span> <span class="main">!</span> <span class="free">i</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">]</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_update<span class="main">)</span> <span class="keyword1"><span class="command">also</span></span>
  <span class="keyword1"><span class="command">from</span></span> sum_list_update<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">i</span></span> <span class="quoted"><span class="quoted">"map length <span class="free">l</span>"</span></span><span class="main">,</span> <span class="operator">simplified</span><span class="main">,</span> <span class="operator">OF</span> i<span class="main">,</span>
    <span class="operator">of</span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>fst <span class="main">(</span>ls_delete <span class="free">k</span> <span class="main">(</span><span class="free">l</span> <span class="main">!</span> <span class="free">i</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="main">]</span>
    ls_delete_length_snd_True<span class="main">[</span><span class="operator">OF</span> snd<span class="main">]</span> snd
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"sum_list <span class="main">(</span><span class="main">(</span>map length <span class="free">l</span><span class="main">)</span><span class="main">[</span><span class="free">i</span> <span class="main">:=</span> length <span class="main">(</span>fst <span class="main">(</span>ls_delete <span class="free">k</span> <span class="main">(</span><span class="free">l</span> <span class="main">!</span> <span class="free">i</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">)</span>
    <span class="main">=</span> sum_list <span class="main">(</span>map length <span class="free">l</span><span class="main">)</span> <span class="main">-</span> <span class="main">1</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"length <span class="main">(</span><span class="free">l</span> <span class="main">!</span> <span class="free">i</span><span class="main">)</span>"</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ls_delete_snd_set<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ht_size_def assms<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ht_size_delete2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> size<span class="main">:</span> <span class="quoted"><span class="quoted">"ht_size <span class="free">l</span> <span class="free">n</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> i<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">&lt;</span> length <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> snd<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> snd <span class="main">(</span>ls_delete <span class="free">k</span> <span class="main">(</span><span class="free">l</span> <span class="main">!</span> <span class="free">i</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ht_size <span class="main">(</span><span class="free">l</span><span class="main">[</span><span class="free">i</span> <span class="main">:=</span> fst <span class="main">(</span>ls_delete <span class="free">k</span> <span class="main">(</span><span class="free">l</span><span class="main">!</span><span class="free">i</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>map length <span class="main">(</span><span class="free">l</span><span class="main">[</span><span class="free">i</span> <span class="main">:=</span> fst <span class="main">(</span>ls_delete <span class="free">k</span> <span class="main">(</span><span class="free">l</span> <span class="main">!</span> <span class="free">i</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
    <span class="main">=</span> <span class="main">(</span>map length <span class="free">l</span><span class="main">)</span><span class="main">[</span><span class="free">i</span> <span class="main">:=</span> length <span class="main">(</span>fst <span class="main">(</span>ls_delete <span class="free">k</span> <span class="main">(</span><span class="free">l</span> <span class="main">!</span> <span class="free">i</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">]</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_update<span class="main">)</span> <span class="keyword1"><span class="command">also</span></span>
  <span class="keyword1"><span class="command">from</span></span> sum_list_update<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">i</span></span> <span class="quoted"><span class="quoted">"map length <span class="free">l</span>"</span></span><span class="main">,</span> <span class="operator">simplified</span><span class="main">,</span> <span class="operator">OF</span> i<span class="main">,</span>
    <span class="operator">of</span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>fst <span class="main">(</span>ls_delete <span class="free">k</span> <span class="main">(</span><span class="free">l</span> <span class="main">!</span> <span class="free">i</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="main">]</span>
    ls_delete_length_snd_False<span class="main">[</span><span class="operator">OF</span> snd<span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"sum_list <span class="main">(</span><span class="main">(</span>map length <span class="free">l</span><span class="main">)</span><span class="main">[</span><span class="free">i</span> <span class="main">:=</span> length <span class="main">(</span>fst <span class="main">(</span>ls_delete <span class="free">k</span> <span class="main">(</span><span class="free">l</span> <span class="main">!</span> <span class="free">i</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">)</span>
    <span class="main">=</span> sum_list <span class="main">(</span>map length <span class="free">l</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ht_size_def assms<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">lemma</span></span> complete_ht_delete<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span>is_hashtable <span class="free">l</span> <span class="free">ht</span><span class="main">&gt;</span> ht_delete <span class="free">k</span> <span class="free">ht</span>
  <span class="main">&lt;</span>is_hashtable <span class="main">(</span><span class="free">l</span><span class="main">[</span>bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span>
    <span class="main">:=</span> fst <span class="main">(</span>ls_delete <span class="free">k</span> <span class="main">(</span><span class="free">l</span> <span class="main">!</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ht_delete_def is_hashtable_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> norm_pre_pure_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> bind_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> length_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> norm_pre_pure_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> bind_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> nth_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bounded_hashcode_nat_bounds<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> norm_pre_pure_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> bind_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> upd_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bounded_hashcode_nat_bounds<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> return_cons_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span>
    <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ht_size_delete1 ht_size_delete2 bounded_hashcode_nat_bounds
              is_hashtable_def ht_hash_delete ht_distinct_delete<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> ht_size_delete1<span class="main">[</span><span class="operator">OF</span> _ bounded_hashcode_nat_bounds<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted">"length <span class="free">l</span>"</span></span> <span class="quoted"><span class="free">k</span></span><span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="quoted">"the_size <span class="free">ht</span>"</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Alternative, more automatic proof›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span>is_hashtable <span class="free">l</span> <span class="free">ht</span><span class="main">&gt;</span> ht_delete <span class="free">k</span> <span class="free">ht</span>
  <span class="main">&lt;</span>is_hashtable <span class="main">(</span><span class="free">l</span><span class="main">[</span>bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span>
    <span class="free">k</span> <span class="main">:=</span> fst <span class="main">(</span>ls_delete <span class="free">k</span> <span class="main">(</span><span class="free">l</span> <span class="main">!</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ht_delete_def is_hashtable_def Let_def
  <span class="keyword1"><span class="command">using</span></span> ht_size_delete1<span class="main">[</span><span class="operator">OF</span> _ bounded_hashcode_nat_bounds<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted">"length <span class="free">l</span>"</span></span> <span class="quoted"><span class="free">k</span></span><span class="main"><span class="main">]</span></span><span class="main">,</span>
    <span class="operator">of</span> <span class="quoted"><span class="quoted">"the_size <span class="free">ht</span>"</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>
    ht_size_delete1 ht_size_delete2 bounded_hashcode_nat_bounds
    is_hashtable_def ht_hash_delete ht_distinct_delete<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Re-Hashing›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Auxiliary Functions›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\paragraph{Insert List}›</span></span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">ht_insls</span>
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span> <span class="main">×</span> <span class="tfree">'v</span><span class="main">)</span> list
    <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span><span class="main">::</span><span class="main">{</span>heap<span class="main">,</span>hashable<span class="main">}</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">::</span>heap<span class="main">)</span> hashtable
    <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">::</span>heap<span class="main">)</span> hashtable Heap"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ht_insls</span> <span class="main">[]</span> <span class="free"><span class="bound"><span class="entity">ht</span></span></span> <span class="main">=</span> return <span class="free"><span class="bound"><span class="entity">ht</span></span></span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">ht_insls</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">ht</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span> <span class="bound">h</span> <span class="main">←</span> ht_upd <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">ht</span></span></span><span class="main">;</span> <span class="free">ht_insls</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="bound">h</span> <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">"Abstract version"</span></span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">ls_insls</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span><span class="main">::</span>hashable <span class="main">×</span> <span class="tfree">'v</span><span class="main">)</span> list
  <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span> <span class="main">×</span> <span class="tfree">'v</span><span class="main">)</span> list list <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span> <span class="main">×</span> <span class="tfree">'v</span><span class="main">)</span> list list"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ls_insls</span> <span class="main">[]</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">ls_insls</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ls</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span>
    <span class="free">ls_insls</span> <span class="free"><span class="bound"><span class="entity">ls</span></span></span> <span class="main">(</span>abs_update <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ht_hash_ls_insls<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_hash <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ht_hash <span class="main">(</span>ls_insls <span class="free">ls</span> <span class="free">l</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">l</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> ls_insls.induct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ht_hash_update<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> ht_distinct_ls_insls<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_distinct <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ht_distinct <span class="main">(</span>ls_insls <span class="free">ls</span> <span class="free">l</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">l</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> ls_insls.induct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ht_distinct_update<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> length_ls_insls<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;</span> length <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;</span> length <span class="main">(</span>ls_insls <span class="free">ls</span> <span class="free">l</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">l</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> ls_insls.induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 1
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>2 <span class="skolem">k</span> <span class="skolem">v</span> <span class="skolem">ls</span> <span class="skolem">l</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> 2<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> length_update<span class="main"><span class="main">[</span></span><span class="operator">OF</span> 2<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="main">,</span></span> <span class="operator">of</span> <span class="quoted"><span class="skolem">k</span></span> <span class="quoted"><span class="skolem">v</span></span><span class="main"><span class="main">]</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> complete_ht_insls<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span>is_hashtable <span class="free">ls</span> <span class="free">ht</span><span class="main">&gt;</span> ht_insls <span class="free">xs</span> <span class="free">ht</span> <span class="main">&lt;</span>is_hashtable <span class="main">(</span>ls_insls <span class="free">xs</span> <span class="free">ls</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">ls</span></span> <span class="quoted"><span class="free">ht</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Nil
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> return_cons_rule<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">x</span> <span class="skolem">xs</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Pair <span class="skolem">k</span> <span class="skolem">v</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> bind_rule<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> complete_ht_upd<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Cons<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\paragraph{Copy}›</span></span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">ht_copy</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span><span class="main">::</span><span class="main">{</span>heap<span class="main">,</span>hashable<span class="main">}</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">::</span>heap<span class="main">)</span> hashtable
  <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">)</span> hashtable <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">)</span> hashtable Heap"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ht_copy</span> <span class="main">0</span> <span class="free"><span class="bound"><span class="entity">src</span></span></span> <span class="free"><span class="bound"><span class="entity">dst</span></span></span> <span class="main">=</span> return <span class="free"><span class="bound"><span class="entity">dst</span></span></span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">ht_copy</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">src</span></span></span> <span class="free"><span class="bound"><span class="entity">dst</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">l</span> <span class="main">←</span> Array.nth <span class="main">(</span>the_array <span class="free"><span class="bound"><span class="entity">src</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">;</span>
    <span class="bound">ht</span> <span class="main">←</span> ht_insls <span class="bound">l</span> <span class="free"><span class="bound"><span class="entity">dst</span></span></span><span class="main">;</span>
    <span class="free">ht_copy</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">src</span></span></span> <span class="bound">ht</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">"Abstract version"</span></span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">ls_copy</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span><span class="main">::</span>hashable <span class="main">×</span> <span class="tfree">'v</span><span class="main">)</span> list list
  <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span> <span class="main">×</span> <span class="tfree">'v</span><span class="main">)</span> list list <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span> <span class="main">×</span> <span class="tfree">'v</span><span class="main">)</span> list list"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ls_copy</span> <span class="main">0</span> <span class="free"><span class="bound"><span class="entity">ss</span></span></span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">ls_copy</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">ss</span></span></span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="main">=</span> <span class="free">ls_copy</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">ss</span></span></span> <span class="main">(</span>ls_insls <span class="main">(</span><span class="free"><span class="bound"><span class="entity">ss</span></span></span> <span class="main">!</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ht_hash_ls_copy<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_hash <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ht_hash <span class="main">(</span>ls_copy <span class="free">n</span> <span class="free">ss</span> <span class="free">l</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">l</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ht_hash_ls_insls<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> ht_distinct_ls_copy<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_distinct <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ht_distinct <span class="main">(</span>ls_copy <span class="free">n</span> <span class="free">ss</span> <span class="free">l</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">l</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ht_distinct_ls_insls<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> length_ls_copy<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;</span> length <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;</span> length <span class="main">(</span>ls_copy <span class="free">n</span> <span class="free">ss</span> <span class="free">l</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">l</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 0
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> Suc<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> length_ls_insls<span class="main"><span class="main">[</span></span><span class="operator">OF</span> Suc<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> complete_ht_copy<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">≤</span> List.length <span class="free">ss</span> <span class="main">⟹</span>
  <span class="main">&lt;</span>is_hashtable <span class="free">ss</span> <span class="free">src</span> <span class="main">*</span> is_hashtable <span class="free">ds</span> <span class="free">dst</span><span class="main">&gt;</span>
  ht_copy <span class="free">n</span> <span class="free">src</span> <span class="free">dst</span>
  <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> is_hashtable <span class="free">ss</span> <span class="free">src</span> <span class="main">*</span> is_hashtable <span class="main">(</span>ls_copy <span class="free">n</span> <span class="free">ss</span> <span class="free">ds</span><span class="main">)</span> <span class="bound">r</span><span class="main">&gt;</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">ds</span></span> <span class="quoted"><span class="free">dst</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 0
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> return_cons_rule<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> n<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">&lt;</span> length <span class="free">ss</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">≤</span> length <span class="free">ss</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">note</span></span> IH <span class="main">=</span> Suc<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> bind_rule<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> frame_rule<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span>is_hashtable <span class="free">ss</span> <span class="free">src</span><span class="main">&gt;</span>
      Array.nth <span class="main">(</span>the_array <span class="free">src</span><span class="main">)</span> <span class="skolem">n</span>
      <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> is_hashtable <span class="free">ss</span> <span class="free">src</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="bound">r</span> <span class="main">=</span> <span class="free">ss</span> <span class="main">!</span> <span class="skolem">n</span><span class="main">)</span><span class="main">&gt;</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> is_hashtable_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> nth_rule <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> n<span class="main">)</span><span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> bind_rule<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> frame_rule_left<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> complete_ht_insls<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> IH<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Alternative, more automatic proof›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> complete_ht_copy_alt_proof<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">≤</span> List.length <span class="free">ss</span> <span class="main">⟹</span>
  <span class="main">&lt;</span>is_hashtable <span class="free">ss</span> <span class="free">src</span> <span class="main">*</span> is_hashtable <span class="free">ds</span> <span class="free">dst</span><span class="main">&gt;</span>
  ht_copy <span class="free">n</span> <span class="free">src</span> <span class="free">dst</span>
  <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> is_hashtable <span class="free">ss</span> <span class="free">src</span> <span class="main">*</span> is_hashtable <span class="main">(</span>ls_copy <span class="free">n</span> <span class="free">ss</span> <span class="free">ds</span><span class="main">)</span> <span class="bound">r</span><span class="main">&gt;</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">ds</span></span> <span class="quoted"><span class="free">dst</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 0
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> N_LESS<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">&lt;</span> length <span class="free">ss</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> N_LE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">≤</span> length <span class="free">ss</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">note</span></span> IH <span class="main">=</span> Suc<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> N_LESS N_LE <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> complete_ht_insls IH<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ht_rehash</span>
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span><span class="main">::</span><span class="main">{</span>heap<span class="main">,</span>hashable<span class="main">}</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">::</span>heap<span class="main">)</span> hashtable <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">)</span> hashtable Heap"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ht_rehash</span> <span class="free"><span class="bound"><span class="entity">ht</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">n</span> <span class="main">←</span> Array.len <span class="main">(</span>the_array <span class="free"><span class="bound"><span class="entity">ht</span></span></span><span class="main">)</span><span class="main">;</span>
    <span class="bound">h</span> <span class="main">←</span> ht_new_sz <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="bound">n</span><span class="main">)</span><span class="main">;</span>
    ht_copy <span class="bound">n</span> <span class="free"><span class="bound"><span class="entity">ht</span></span></span> <span class="bound">h</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">"Operation on Abstraction"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ls_rehash</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span><span class="main">::</span>hashable <span class="main">×</span> <span class="tfree">'v</span><span class="main">)</span> list list <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span> <span class="main">×</span> <span class="tfree">'v</span><span class="main">)</span> list list"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ls_rehash</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> ls_copy <span class="main">(</span>List.length <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">(</span>replicate <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> length <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="main">[]</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ht_hash_ls_rehash<span class="main">:</span> <span class="quoted"><span class="quoted">"ht_hash <span class="main">(</span>ls_rehash <span class="free">l</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ht_hash_ls_copy ls_rehash_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ht_distinct_ls_rehash<span class="main">:</span> <span class="quoted"><span class="quoted">"ht_distinct <span class="main">(</span>ls_rehash <span class="free">l</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ht_distinct_ls_copy ls_rehash_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> length_ls_rehash<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;</span> length <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;</span> length <span class="main">(</span>ls_rehash <span class="free">l</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;</span> length <span class="main">(</span>replicate <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> length <span class="free">l</span><span class="main">)</span> <span class="main">[]</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">from</span></span> length_ls_copy<span class="main">[</span><span class="operator">OF</span> this<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="quoted">"length <span class="free">l</span>"</span></span> <span class="quoted"><span class="free">l</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ls_rehash_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ht_imp_len<span class="main">:</span> <span class="quoted"><span class="quoted">"is_hashtable <span class="free">l</span> <span class="free">ht</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> is_hashtable <span class="free">l</span> <span class="free">ht</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span>length <span class="free">l</span> <span class="main">&gt;</span> <span class="main">0</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> is_hashtable_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">sep_auto</span>

<span class="keyword1"><span class="command">lemma</span></span> complete_ht_rehash<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span>is_hashtable <span class="free">l</span> <span class="free">ht</span><span class="main">&gt;</span> ht_rehash <span class="free">ht</span>
  <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> is_hashtable <span class="free">l</span> <span class="free">ht</span> <span class="main">*</span> is_hashtable <span class="main">(</span>ls_rehash <span class="free">l</span><span class="main">)</span> <span class="bound">r</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cons_pre_rule<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ht_imp_len<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> ht_rehash_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> complete_ht_new_sz<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">l</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> complete_ht_copy <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ls_rehash_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">load_factor</span> <span class="main">::</span> <span class="quoted">nat</span> <span class="comment1">― ‹in percent›</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">load_factor</span> <span class="main">=</span> <span class="numeral">75</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ht_update</span>
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k</span><span class="main">::</span><span class="main">{</span>heap<span class="main">,</span>hashable<span class="main">}</span> <span class="main">⇒</span> <span class="tfree">'v</span><span class="main">::</span>heap <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">)</span> hashtable
  <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">)</span> hashtable Heap"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ht_update</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">ht</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">m</span> <span class="main">←</span> Array.len <span class="main">(</span>the_array <span class="free"><span class="bound"><span class="entity">ht</span></span></span><span class="main">)</span><span class="main">;</span>
    <span class="bound">ht</span> <span class="main">←</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">m</span> <span class="main">*</span> load_factor <span class="main">≤</span> <span class="main">(</span>the_size <span class="free"><span class="bound"><span class="entity">ht</span></span></span><span class="main">)</span> <span class="main">*</span> <span class="numeral">100</span> <span class="keyword1">then</span>
        ht_rehash <span class="free"><span class="bound"><span class="entity">ht</span></span></span>
      <span class="keyword1">else</span> return <span class="free"><span class="bound"><span class="entity">ht</span></span></span><span class="main">)</span><span class="main">;</span>
    ht_upd <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="bound">ht</span>
  <span class="main">}</span>"</span></span>


<span class="keyword1"><span class="command">lemma</span></span> complete_ht_update_normal<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">¬</span> length <span class="free">l</span> <span class="main">*</span> load_factor <span class="main">≤</span> <span class="main">(</span>the_size <span class="free">ht</span><span class="main">)</span><span class="main">*</span> <span class="numeral">100</span> <span class="main">⟹</span>
  <span class="main">&lt;</span>is_hashtable <span class="free">l</span> <span class="free">ht</span><span class="main">&gt;</span>
  ht_update <span class="free">k</span> <span class="free">v</span> <span class="free">ht</span>
  <span class="main">&lt;</span>is_hashtable <span class="main">(</span>abs_update <span class="free">k</span> <span class="free">v</span> <span class="free">l</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ht_update_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> is_hashtable_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cons_pre_rule<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> P' <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted">"is_hashtable <span class="free">l</span> <span class="free">ht</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> is_hashtable_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> complete_ht_upd<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> complete_ht_update_rehash<span class="main">:</span>
  <span class="quoted"><span class="quoted">"length <span class="free">l</span> <span class="main">*</span> load_factor <span class="main">≤</span> <span class="main">(</span>the_size <span class="free">ht</span><span class="main">)</span><span class="main">*</span> <span class="numeral">100</span> <span class="main">⟹</span>
  <span class="main">&lt;</span>is_hashtable <span class="free">l</span> <span class="free">ht</span><span class="main">&gt;</span>
  ht_update <span class="free">k</span> <span class="free">v</span> <span class="free">ht</span>
  <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> is_hashtable <span class="free">l</span> <span class="free">ht</span>
    <span class="main">*</span> is_hashtable <span class="main">(</span>abs_update <span class="free">k</span> <span class="free">v</span> <span class="main">(</span>ls_rehash <span class="free">l</span><span class="main">)</span><span class="main">)</span> <span class="bound">r</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ht_update_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> complete_ht_rehash complete_ht_upd<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Conversion to List›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ht_to_list</span> <span class="main">::</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span><span class="main">::</span>heap<span class="main">,</span> <span class="tfree">'v</span><span class="main">::</span>heap<span class="main">)</span> hashtable <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span> <span class="main">×</span> <span class="tfree">'v</span><span class="main">)</span> list Heap"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ht_to_list</span> <span class="free"><span class="bound"><span class="entity">ht</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">l</span> <span class="main">←</span> <span class="main">(</span>Array.freeze <span class="main">(</span>the_array <span class="free"><span class="bound"><span class="entity">ht</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    return <span class="main">(</span>concat <span class="bound">l</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> complete_ht_to_list<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span>is_hashtable <span class="free">l</span> <span class="free">ht</span><span class="main">&gt;</span> ht_to_list <span class="free">ht</span>
  <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> is_hashtable <span class="free">l</span> <span class="free">ht</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="bound">r</span> <span class="main">=</span> concat <span class="free">l</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ht_to_list_def is_hashtable_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">sep_auto</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Hash_Map">
<div class="head">
<h1>Theory Hash_Map</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">"Hash-Maps"</span></span>
<span class="keyword1"><span class="command">theory</span></span> Hash_Map
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="Hash_Table.html">Hash_Table</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Auxiliary Lemmas›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> map_of_ls_update<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"map_of <span class="main">(</span>fst <span class="main">(</span>ls_update <span class="free">k</span> <span class="free">v</span> <span class="free">l</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>map_of <span class="free">l</span><span class="main">)</span><span class="main">(</span><span class="free">k</span> <span class="main">↦</span> <span class="free">v</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">l</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> ls_update.induct<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ext Let_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> map_of_concat<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">∈</span> dom <span class="main">(</span>map_of<span class="main">(</span>concat <span class="free">l</span><span class="main">)</span><span class="main">)</span> 
  <span class="main">⟹</span> <span class="main">∃</span><span class="bound">i</span><span class="main">.</span> <span class="free">k</span> <span class="main">∈</span> dom <span class="main">(</span>map_of<span class="main">(</span><span class="free">l</span><span class="main">!</span><span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">i</span> <span class="main">&lt;</span> length <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">l</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="main">0</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Suc_mono domI nth_Cons_Suc<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> map_of_concat'<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">∈</span> dom <span class="main">(</span>map_of<span class="main">(</span><span class="free">l</span><span class="main">!</span><span class="free">i</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> <span class="free">i</span> <span class="main">&lt;</span> length <span class="free">l</span> <span class="main">⟹</span> <span class="free">k</span> <span class="main">∈</span> dom <span class="main">(</span>map_of<span class="main">(</span>concat <span class="free">l</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">l</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">i</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">i</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> map_of_concat'''<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">i</span><span class="main">.</span> <span class="free">k</span> <span class="main">∈</span> dom <span class="main">(</span>map_of<span class="main">(</span><span class="free">l</span><span class="main">!</span><span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">i</span> <span class="main">&lt;</span> length <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">∈</span> dom <span class="main">(</span>map_of<span class="main">(</span>concat <span class="free">l</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">i</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">∈</span> dom <span class="main">(</span>map_of <span class="main">(</span><span class="free">l</span> <span class="main">!</span> <span class="skolem">i</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> <span class="skolem">i</span> <span class="main">&lt;</span> length <span class="free">l</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">from</span></span> map_of_concat'<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>
 
<span class="keyword1"><span class="command">lemma</span></span> map_of_concat''<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">k</span> <span class="main">∈</span> dom <span class="main">(</span>map_of<span class="main">(</span>concat <span class="free">l</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> 
  <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">i</span><span class="main">.</span> <span class="free">k</span> <span class="main">∈</span> dom <span class="main">(</span>map_of<span class="main">(</span><span class="free">l</span><span class="main">!</span><span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">i</span> <span class="main">&lt;</span> length <span class="free">l</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command">using</span></span> map_of_concat<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">k</span></span> <span class="quoted"><span class="free">l</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">using</span></span> map_of_concat'<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">k</span></span> <span class="quoted"><span class="free">l</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> abs_update_length<span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>abs_update <span class="free">k</span> <span class="free">v</span> <span class="free">l</span><span class="main">)</span> <span class="main">=</span> length <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> abs_update_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ls_update_map_of_eq<span class="main">:</span>
  <span class="quoted"><span class="quoted">"map_of <span class="main">(</span>fst <span class="main">(</span>ls_update <span class="free">k</span> <span class="free">v</span> <span class="free">ls</span><span class="main">)</span><span class="main">)</span> <span class="free">k</span> <span class="main">=</span> Some <span class="free">v</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">ls</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> ls_update.induct<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ls_update_map_of_neq<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≠</span> <span class="free">k</span> <span class="main">⟹</span> map_of <span class="main">(</span>fst <span class="main">(</span>ls_update <span class="free">k</span> <span class="free">v</span> <span class="free">ls</span><span class="main">)</span><span class="main">)</span> <span class="free">x</span> <span class="main">=</span> map_of <span class="free">ls</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">ls</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> ls_update.induct<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Main Definitions and Lemmas›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">is_hashmap'</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">)</span> map 
    <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span> <span class="main">×</span> <span class="tfree">'v</span><span class="main">)</span> list list 
    <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span><span class="main">::</span><span class="main">{</span>heap<span class="main">,</span>hashable<span class="main">}</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">::</span>heap<span class="main">)</span> hashtable
    <span class="main">⇒</span> assn"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">is_hashmap'</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">ht</span></span></span> <span class="main">=</span> is_hashtable <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">ht</span></span></span> <span class="main">*</span> <span class="main">↑</span> <span class="main">(</span>map_of <span class="main">(</span>concat <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">is_hashmap</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">)</span> map <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span><span class="main">::</span><span class="main">{</span>heap<span class="main">,</span>hashable<span class="main">}</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">::</span>heap<span class="main">)</span> hashtable <span class="main">⇒</span> assn"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">is_hashmap</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">ht</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">l</span><span class="main">.</span> is_hashmap' <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="bound">l</span> <span class="free"><span class="bound"><span class="entity">ht</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> is_hashmap'_prec<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">s</span> <span class="bound">s'</span><span class="main">.</span> <span class="free">h</span><span class="main">⊨</span><span class="main">(</span>is_hashmap' <span class="free">m</span> <span class="free">l</span> <span class="free">ht</span> <span class="main">*</span> <span class="free">F1</span><span class="main">)</span> <span class="keyword1">∧<span class="hidden">⇩</span><sub>A</sub></span> <span class="main">(</span>is_hashmap' <span class="free">m'</span> <span class="free">l'</span> <span class="free">ht</span> <span class="main">*</span> <span class="free">F2</span><span class="main">)</span>
  <span class="main">⟶</span> <span class="free">l</span><span class="main">=</span><span class="free">l'</span> <span class="main">∧</span> <span class="free">m</span><span class="main">=</span><span class="free">m'</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> is_hashmap'_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> preciseD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> is_hashtable_prec<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="free">l</span> <span class="main">=</span> <span class="free">l'</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> preciseD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> is_hashtable_prec<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> is_hashmap_prec<span class="main">:</span> <span class="quoted"><span class="quoted">"precise is_hashmap"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> is_hashmap_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> is_hashmap'_prec<span class="main">)</span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">hm_new</span> <span class="main">≡</span> ht_new"</span></span>
<span class="keyword1"><span class="command">lemma</span></span> hm_new_rule'<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="keyword1">emp</span><span class="main">&gt;</span> 
  hm_new<span class="main">::</span><span class="main">(</span><span class="tfree">'k</span><span class="main">::</span><span class="main">{</span>heap<span class="main">,</span>hashable<span class="main">}</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">::</span>heap<span class="main">)</span> hashtable Heap 
  <span class="main">&lt;</span>is_hashmap' Map.empty <span class="main">(</span>replicate <span class="main">(</span>def_hashmap_size <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'k</span><span class="main">)</span><span class="main">)</span> <span class="main">[]</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cons_post_rule<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> complete_ht_new
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> is_hashmap'_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span> 

<span class="keyword1"><span class="command">lemma</span></span> hm_new_rule<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="keyword1">emp</span><span class="main">&gt;</span> hm_new <span class="main">&lt;</span>is_hashmap Map.empty<span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cons_post_rule<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> complete_ht_new
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> is_hashmap_def is_hashmap'_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sep_auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> ht_hash_distinct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"ht_hash <span class="free">l</span> 
  <span class="main">⟹</span> <span class="main">∀</span><span class="bound">i</span> <span class="bound">j</span> <span class="main">.</span> <span class="bound">i</span><span class="main">≠</span><span class="bound">j</span> <span class="main">∧</span> <span class="bound">i</span> <span class="main">&lt;</span> length <span class="free">l</span> <span class="main">∧</span> <span class="bound">j</span> <span class="main">&lt;</span> length <span class="free">l</span> 
    <span class="main">⟶</span> set <span class="main">(</span><span class="free">l</span><span class="main">!</span><span class="bound">i</span><span class="main">)</span> <span class="main">∩</span> set <span class="main">(</span><span class="free">l</span><span class="main">!</span><span class="bound">j</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ht_hash_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">metis</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> ht_hash_in_dom_in_dom_bounded_hashcode_nat<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_hash <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">∈</span> dom <span class="main">(</span>map_of<span class="main">(</span>concat <span class="free">l</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">∈</span> dom <span class="main">(</span>map_of<span class="main">(</span><span class="free">l</span><span class="main">!</span>bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> map_of_concat<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">i</span></span> 
    <span class="keyword2"><span class="keyword">where</span></span> i<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">∈</span> dom <span class="main">(</span>map_of <span class="main">(</span><span class="free">l</span> <span class="main">!</span> <span class="skolem">i</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> <span class="skolem">i</span> <span class="main">&lt;</span> length <span class="free">l</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">thm</span></span> ht_hash_def
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="free">k</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>set<span class="main">(</span><span class="free">l</span><span class="main">!</span><span class="skolem">i</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> map_of_SomeD<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> this <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v</span></span> <span class="keyword2"><span class="keyword">where</span></span> v<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">k</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>set<span class="main">(</span><span class="free">l</span><span class="main">!</span><span class="skolem">i</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">from</span></span> assms<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">unfolded</span> ht_hash_def<span class="main">]</span> i v bounded_hashcode_nat_bounds 
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span> <span class="main">=</span> <span class="skolem">i</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> fst_conv<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> i <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ht_hash_in_dom_bounded_hashcode_nat_in_dom<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_hash <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;</span> length <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">∈</span> dom <span class="main">(</span>map_of<span class="main">(</span><span class="free">l</span><span class="main">!</span>bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">∈</span> dom <span class="main">(</span>map_of<span class="main">(</span>concat <span class="free">l</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> map_of_concat'<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">k</span></span> <span class="quoted"><span class="free">l</span></span> <span class="quoted"><span class="quoted">"bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span>"</span></span><span class="main">]</span> 
    assms<span class="main">(</span>2<span class="main">,</span>3<span class="main">)</span> bounded_hashcode_nat_bounds<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"length <span class="free">l</span>"</span></span> <span class="quoted"><span class="free">k</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>


<span class="keyword1"><span class="command">lemma</span></span> ht_hash_in_dom_in_dom_bounded_hashcode_nat_eq<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_hash <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;</span> length <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">k</span> <span class="main">∈</span> dom <span class="main">(</span>map_of<span class="main">(</span>concat <span class="free">l</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> 
  <span class="main">=</span> <span class="main">(</span><span class="free">k</span> <span class="main">∈</span> dom <span class="main">(</span>map_of<span class="main">(</span><span class="free">l</span><span class="main">!</span>bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command">using</span></span> ht_hash_in_dom_in_dom_bounded_hashcode_nat<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> 
    ht_hash_in_dom_bounded_hashcode_nat_in_dom<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>


<span class="keyword1"><span class="command">lemma</span></span> ht_hash_in_dom_i_bounded_hashcode_nat_i<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_hash <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;</span> length <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">&lt;</span> length <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">∈</span> dom <span class="main">(</span>map_of <span class="main">(</span><span class="free">l</span><span class="main">!</span><span class="free">i</span><span class="main">)</span><span class="main">)</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">=</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">using</span></span> bounded_hashcode_nat_bounds
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ht_hash_def ht_distinct_def dom_map_of_conv_image_fst<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ht_hash_in_bounded_hashcode_nat_not_i_not_in_dom_i<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_hash <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;</span> length <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">&lt;</span> length <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">≠</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">∉</span> dom <span class="main">(</span>map_of <span class="main">(</span><span class="free">l</span><span class="main">!</span><span class="free">i</span><span class="main">)</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">using</span></span> bounded_hashcode_nat_bounds
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ht_hash_def ht_distinct_def dom_map_of_conv_image_fst<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ht_hash_ht_distinct_in_dom_unique_value<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_hash <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_distinct <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;</span> length <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">∈</span> dom <span class="main">(</span>map_of <span class="main">(</span>concat <span class="free">l</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃!</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="free">k</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>concat <span class="free">l</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms<span class="main">(</span>4<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> ex<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="free">k</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>concat <span class="free">l</span><span class="main">)</span>"</span></span>  
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> map_of_SomeD<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">=</span> <span class="skolem">w</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> kv<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">k</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>concat <span class="free">l</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> kw<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">k</span><span class="main">,</span><span class="skolem">w</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>concat <span class="free">l</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">v</span> <span class="skolem">w</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> ht_hash_in_dom_in_dom_bounded_hashcode_nat<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span>4<span class="main"><span class="main">)</span></span><span class="main">]</span> 
    <span class="keyword1"><span class="command">have</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">∈</span> dom <span class="main">(</span>map_of <span class="main">(</span><span class="free">l</span> <span class="main">!</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">∉</span> dom<span class="main">(</span>map_of<span class="main">(</span><span class="free">l</span><span class="main">!</span><span class="skolem">i</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> length <span class="free">l</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">≠</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">i</span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">from</span></span> ht_hash_in_bounded_hashcode_nat_not_i_not_in_dom_i<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span>3<span class="main"><span class="main">)</span></span> that<span class="main">]</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">have</span></span> v<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">k</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span><span class="free">l</span> <span class="main">!</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">from</span></span> kv <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">i</span><span class="main">.</span> <span class="bound">i</span> <span class="main">&lt;</span> length <span class="free">l</span> <span class="main">∧</span> <span class="main">(</span><span class="free">k</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span><span class="free">l</span><span class="main">!</span><span class="bound">i</span><span class="main">)</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> <span class="main">(</span><span class="operator">metis</span> in_set_conv_nth<span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> this <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">i</span></span> <span class="keyword2"><span class="keyword">where</span></span> i<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> length <span class="free">l</span> <span class="main">∧</span> <span class="main">(</span><span class="free">k</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span><span class="free">l</span><span class="main">!</span><span class="skolem">i</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">∈</span> dom <span class="main">(</span>map_of <span class="main">(</span><span class="free">l</span><span class="main">!</span><span class="skolem">i</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">)</span></span> prod.exhaust a assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> fst_conv ht_hash_def<span class="main">)</span> 
      <span class="keyword1"><span class="command">from</span></span> i ht_hash_in_dom_i_bounded_hashcode_nat_i<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span>3<span class="main"><span class="main">)</span></span> _ this<span class="main">]</span> 
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">=</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">with</span></span> i <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">have</span></span> w<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">k</span><span class="main">,</span><span class="skolem">w</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span><span class="free">l</span> <span class="main">!</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">from</span></span> kw <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">i</span><span class="main">.</span> <span class="bound">i</span> <span class="main">&lt;</span> length <span class="free">l</span> <span class="main">∧</span> <span class="main">(</span><span class="free">k</span><span class="main">,</span> <span class="skolem">w</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span><span class="free">l</span><span class="main">!</span><span class="bound">i</span><span class="main">)</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> <span class="main">(</span><span class="operator">metis</span> in_set_conv_nth<span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> this <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">i</span></span> <span class="keyword2"><span class="keyword">where</span></span> i<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> length <span class="free">l</span> <span class="main">∧</span> <span class="main">(</span><span class="free">k</span><span class="main">,</span> <span class="skolem">w</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span><span class="free">l</span><span class="main">!</span><span class="skolem">i</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">∈</span> dom <span class="main">(</span>map_of <span class="main">(</span><span class="free">l</span><span class="main">!</span><span class="skolem">i</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">)</span></span> prod.exhaust a assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> fst_conv ht_hash_def<span class="main">)</span> 
      <span class="keyword1"><span class="command">from</span></span> i ht_hash_in_dom_i_bounded_hashcode_nat_i<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span>3<span class="main"><span class="main">)</span></span> _ this<span class="main">]</span> 
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">=</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">with</span></span> i <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">from</span></span> assms<span class="main">(</span>2<span class="main">,</span>3<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> 
      <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst <span class="main">(</span><span class="free">l</span> <span class="main">!</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ht_distinct_def bounded_hashcode_nat_bounds<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> Map.map_of_is_SomeI<span class="main">[</span><span class="operator">OF</span> this v<span class="main">]</span> Map.map_of_is_SomeI<span class="main">[</span><span class="operator">OF</span> this w<span class="main">]</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">=</span> <span class="skolem">w</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>    
  <span class="keyword1"><span class="command">with</span></span> ex <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">lemma</span></span> ht_hash_ht_distinct_map_of<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_hash <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_distinct <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;</span> length <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"map_of <span class="main">(</span>concat <span class="free">l</span><span class="main">)</span> <span class="free">k</span> 
  <span class="main">=</span> map_of<span class="main">(</span><span class="free">l</span><span class="main">!</span>bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span><span class="main">)</span> <span class="free">k</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">∈</span> dom <span class="main">(</span>map_of<span class="main">(</span>concat <span class="free">l</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">hence</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"map_of <span class="main">(</span>concat <span class="free">l</span><span class="main">)</span> <span class="free">k</span> <span class="main">=</span> None"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> ht_hash_in_dom_in_dom_bounded_hashcode_nat_eq<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span>3<span class="main"><span class="main">)</span></span><span class="main">]</span> False 
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">∉</span> dom <span class="main">(</span>map_of <span class="main">(</span><span class="free">l</span> <span class="main">!</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"map_of<span class="main">(</span><span class="free">l</span><span class="main">!</span>bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span><span class="main">)</span> <span class="free">k</span> <span class="main">=</span> None"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> a <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">from</span></span> True <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="keyword2"><span class="keyword">where</span></span> y<span class="main">:</span> <span class="quoted"><span class="quoted">"map_of <span class="main">(</span>concat <span class="free">l</span><span class="main">)</span> <span class="free">k</span> <span class="main">=</span> Some <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">k</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>concat <span class="free">l</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> map_of_SomeD<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> ht_hash_in_dom_in_dom_bounded_hashcode_nat_eq<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span>3<span class="main"><span class="main">)</span></span><span class="main">]</span> True 
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">∈</span> dom <span class="main">(</span>map_of <span class="main">(</span><span class="free">l</span> <span class="main">!</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">from</span></span> this <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">z</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    z<span class="main">:</span> <span class="quoted"><span class="quoted">"map_of<span class="main">(</span><span class="free">l</span><span class="main">!</span>bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span><span class="main">)</span> <span class="free">k</span> <span class="main">=</span> Some <span class="skolem">z</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">k</span><span class="main">,</span><span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span><span class="free">l</span> <span class="main">!</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> map_of_SomeD<span class="main">)</span> 
  <span class="keyword1"><span class="command">with</span></span> bounded_hashcode_nat_bounds<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">k</span></span><span class="main">]</span> 
  <span class="keyword1"><span class="command">have</span></span> b<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">k</span><span class="main">,</span><span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>concat <span class="free">l</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> ht_hash_ht_distinct_in_dom_unique_value<span class="main">[</span><span class="operator">OF</span> assms True<span class="main">]</span> a b 
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">=</span> <span class="skolem">z</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> y z <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ls_lookup_map_of_pre<span class="main">:</span>
  <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst <span class="free">l</span><span class="main">)</span> <span class="main">⟹</span> ls_lookup <span class="free">k</span> <span class="free">l</span> <span class="main">=</span> map_of <span class="free">l</span> <span class="free">k</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">l</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">a</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> ls_lookup_map_of<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_hash <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_distinct <span class="free">l</span>"</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;</span> length <span class="free">l</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ls_lookup <span class="free">k</span> <span class="main">(</span><span class="free">l</span> <span class="main">!</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span><span class="main">)</span> 
  <span class="main">=</span> map_of <span class="main">(</span>concat <span class="free">l</span><span class="main">)</span> <span class="free">k</span>"</span></span>  
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms<span class="main">(</span>2<span class="main">,</span>3<span class="main">)</span> 
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst <span class="main">(</span><span class="free">l</span> <span class="main">!</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span><span class="main">)</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ht_distinct_def bounded_hashcode_nat_bounds<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> ls_lookup_map_of_pre<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> 
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ls_lookup <span class="free">k</span> <span class="main">(</span><span class="free">l</span> <span class="main">!</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span><span class="main">)</span> 
    <span class="main">=</span> map_of <span class="main">(</span><span class="free">l</span> <span class="main">!</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span><span class="main">)</span> <span class="free">k</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> ht_hash_ht_distinct_map_of<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> 
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_of <span class="main">(</span><span class="free">l</span> <span class="main">!</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span><span class="main">)</span> <span class="free">k</span> 
    <span class="main">=</span> map_of <span class="main">(</span>concat <span class="free">l</span><span class="main">)</span> <span class="free">k</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">hm_lookup</span> <span class="main">≡</span> ht_lookup"</span></span>
<span class="keyword1"><span class="command">lemma</span></span> hm_lookup_rule'<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span>is_hashmap' <span class="free">m</span> <span class="free">l</span> <span class="free">ht</span><span class="main">&gt;</span> hm_lookup <span class="free">k</span> <span class="free">ht</span> 
    <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> is_hashmap' <span class="free">m</span> <span class="free">l</span> <span class="free">ht</span> <span class="main">*</span> 
      <span class="main">↑</span><span class="main">(</span><span class="bound">r</span> <span class="main">=</span> <span class="free">m</span> <span class="free">k</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> is_hashmap'_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sep_auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cons_post_rule<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> complete_ht_lookup<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">l</span></span> <span class="quoted"><span class="free">ht</span></span> <span class="quoted"><span class="free">k</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sep_auto</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ls_lookup_map_of is_hashtable_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> hm_lookup_rule<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span>is_hashmap <span class="free">m</span> <span class="free">ht</span><span class="main">&gt;</span> hm_lookup <span class="free">k</span> <span class="free">ht</span> 
    <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> is_hashmap <span class="free">m</span> <span class="free">ht</span> <span class="main">*</span> 
      <span class="main">↑</span><span class="main">(</span><span class="bound">r</span> <span class="main">=</span> <span class="free">m</span> <span class="free">k</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> is_hashmap_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sep_auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cons_post_rule<span class="main"><span class="main">[</span></span><span class="operator">OF</span> hm_lookup_rule'<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">sep_auto</span>

<span class="keyword1"><span class="command">lemma</span></span> abs_update_map_of''<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_hash <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_distinct <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;</span> length <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"map_of <span class="main">(</span>concat <span class="main">(</span>abs_update <span class="free">k</span> <span class="free">v</span> <span class="free">l</span><span class="main">)</span><span class="main">)</span> <span class="free">k</span> <span class="main">=</span> Some <span class="free">v</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> ht_hash_ht_distinct_map_of<span class="main">[</span>
    <span class="operator">OF</span> ht_hash_update<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span> 
       ht_distinct_update<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span> 
       length_update<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span><span class="main">,</span> 
    <span class="operator">of</span> <span class="quoted"><span class="free">k</span></span> <span class="quoted"><span class="free">v</span></span> <span class="quoted"><span class="free">k</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_of <span class="main">(</span>concat <span class="main">(</span>abs_update <span class="free">k</span> <span class="free">v</span> <span class="free">l</span><span class="main">)</span><span class="main">)</span> <span class="free">k</span> 
    <span class="main">=</span> map_of <span class="main">(</span><span class="main">(</span>abs_update <span class="free">k</span> <span class="free">v</span> <span class="free">l</span><span class="main">)</span> <span class="main">!</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span><span class="main">)</span> <span class="free">k</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> abs_update_length<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> 
    <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> map_of <span class="main">(</span>fst <span class="main">(</span>ls_update <span class="free">k</span> <span class="free">v</span> 
                        <span class="main">(</span><span class="free">l</span> <span class="main">!</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="free">k</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> abs_update_def bounded_hashcode_nat_bounds<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main"><span class="main">(</span></span></span>3<span class="main"><span class="main"><span class="main">)</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> Some <span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ls_update_map_of_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> abs_update_map_of_hceq<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_hash <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_distinct <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;</span> length <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≠</span> <span class="free">k</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">x</span> 
    <span class="main">=</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"map_of <span class="main">(</span>concat <span class="main">(</span>abs_update <span class="free">k</span> <span class="free">v</span> <span class="free">l</span><span class="main">)</span><span class="main">)</span> <span class="free">x</span> <span class="main">=</span> map_of <span class="main">(</span>concat <span class="free">l</span><span class="main">)</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> ht_hash_ht_distinct_map_of<span class="main">[</span>
    <span class="operator">OF</span> ht_hash_update<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span> 
       ht_distinct_update<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span> 
       length_update<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span><span class="main">,</span> 
    <span class="operator">of</span> <span class="quoted"><span class="free">k</span></span> <span class="quoted"><span class="free">v</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_of <span class="main">(</span>concat <span class="main">(</span>abs_update <span class="free">k</span> <span class="free">v</span> <span class="free">l</span><span class="main">)</span><span class="main">)</span> <span class="free">x</span> 
    <span class="main">=</span> map_of <span class="main">(</span><span class="main">(</span>abs_update <span class="free">k</span> <span class="free">v</span> <span class="free">l</span><span class="main">)</span> <span class="main">!</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">x</span><span class="main">)</span> <span class="free">x</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> abs_update_length<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> assms<span class="main">(</span>5<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> 
    <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> map_of <span class="main">(</span>fst <span class="main">(</span>ls_update <span class="free">k</span> <span class="free">v</span> 
                        <span class="main">(</span><span class="free">l</span> <span class="main">!</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="free">x</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> abs_update_def bounded_hashcode_nat_bounds<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main"><span class="main">(</span></span></span>3<span class="main"><span class="main"><span class="main">)</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> 
    <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> map_of <span class="main">(</span><span class="free">l</span> <span class="main">!</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">x</span><span class="main">)</span> <span class="free">x</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ls_update_map_of_neq<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main"><span class="main">(</span></span></span>4<span class="main"><span class="main"><span class="main">)</span></span></span><span class="main"><span class="main">]</span></span> assms<span class="main"><span class="main">(</span></span>5<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> ht_hash_ht_distinct_map_of<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1-3<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> 
    <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> map_of <span class="main">(</span>concat <span class="free">l</span><span class="main">)</span> <span class="free">x</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> abs_update_map_of_hcneq<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_hash <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_distinct <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;</span> length <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≠</span> <span class="free">k</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">x</span> 
    <span class="main">≠</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"map_of <span class="main">(</span>concat <span class="main">(</span>abs_update <span class="free">k</span> <span class="free">v</span> <span class="free">l</span><span class="main">)</span><span class="main">)</span> <span class="free">x</span> <span class="main">=</span> map_of <span class="main">(</span>concat <span class="free">l</span><span class="main">)</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> ht_hash_ht_distinct_map_of<span class="main">[</span>
    <span class="operator">OF</span> ht_hash_update<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span> 
        ht_distinct_update<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span> 
        length_update<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span><span class="main">,</span> 
    <span class="operator">of</span> <span class="quoted"><span class="free">k</span></span> <span class="quoted"><span class="free">v</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_of <span class="main">(</span>concat <span class="main">(</span>abs_update <span class="free">k</span> <span class="free">v</span> <span class="free">l</span><span class="main">)</span><span class="main">)</span> <span class="free">x</span> 
    <span class="main">=</span> map_of <span class="main">(</span><span class="main">(</span>abs_update <span class="free">k</span> <span class="free">v</span> <span class="free">l</span><span class="main">)</span> <span class="main">!</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">x</span><span class="main">)</span> <span class="free">x</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> abs_update_length<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> assms<span class="main">(</span>5<span class="main">)</span> 
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> map_of <span class="main">(</span><span class="free">l</span> <span class="main">!</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">x</span><span class="main">)</span> <span class="free">x</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> abs_update_def bounded_hashcode_nat_bounds<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main"><span class="main">(</span></span></span>3<span class="main"><span class="main"><span class="main">)</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> ht_hash_ht_distinct_map_of<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1-3<span class="main"><span class="main">)</span></span><span class="main">]</span> 
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> map_of <span class="main">(</span>concat <span class="free">l</span><span class="main">)</span> <span class="free">x</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>  
 

<span class="keyword1"><span class="command">lemma</span></span> abs_update_map_of'''<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_hash <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_distinct <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;</span> length <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≠</span> <span class="free">k</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"map_of <span class="main">(</span>concat <span class="main">(</span>abs_update <span class="free">k</span> <span class="free">v</span> <span class="free">l</span><span class="main">)</span><span class="main">)</span> <span class="free">x</span> <span class="main">=</span> map_of <span class="main">(</span>concat <span class="free">l</span><span class="main">)</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> 
    <span class="quoted"><span class="quoted">"bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">x</span> <span class="main">=</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> abs_update_map_of_hceq<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span> 
    abs_update_map_of_hcneq<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> abs_update_map_of'<span class="main">:</span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_hash <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_distinct <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;</span> length <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"map_of <span class="main">(</span>concat <span class="main">(</span>abs_update <span class="free">k</span> <span class="free">v</span> <span class="free">l</span><span class="main">)</span><span class="main">)</span> <span class="free">x</span> 
    <span class="main">=</span> <span class="main">(</span>map_of <span class="main">(</span>concat <span class="free">l</span><span class="main">)</span><span class="main">(</span><span class="free">k</span> <span class="main">↦</span> <span class="free">v</span><span class="main">)</span><span class="main">)</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="free">k</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> abs_update_map_of''<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> abs_update_map_of'''<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> abs_update_map_of<span class="main">:</span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_hash <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_distinct <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;</span> length <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"map_of <span class="main">(</span>concat <span class="main">(</span>abs_update <span class="free">k</span> <span class="free">v</span> <span class="free">l</span><span class="main">)</span><span class="main">)</span> 
    <span class="main">=</span> map_of <span class="main">(</span>concat <span class="free">l</span><span class="main">)</span><span class="main">(</span><span class="free">k</span> <span class="main">↦</span> <span class="free">v</span><span class="main">)</span> "</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> abs_update_map_of'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main">)</span>


<span class="keyword1"><span class="command">lemma</span></span> ls_insls_map_of<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_hash <span class="free">ld</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_distinct <span class="free">ld</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;</span> length <span class="free">ld</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"map_of <span class="main">(</span>concat <span class="main">(</span>ls_insls <span class="free">xs</span> <span class="free">ld</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> map_of <span class="main">(</span>concat <span class="free">ld</span><span class="main">)</span> <span class="main">++</span> map_of <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">ld</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">a</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> ls_insls.simps<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">premises</span></span> prems
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> prems<span class="main">(</span>5<span class="main">)</span> prems<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> ht_hash_update<span class="main"><span class="main">[</span></span><span class="operator">OF</span> prems<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span> 
      ht_distinct_update<span class="main"><span class="main">[</span></span><span class="operator">OF</span> prems<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span> 
      length_update<span class="main"><span class="main">[</span></span><span class="operator">OF</span> prems<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span><span class="main">]</span> 
      abs_update_map_of<span class="main">[</span><span class="operator">OF</span> prems<span class="main"><span class="main">(</span></span>2-4<span class="main"><span class="main">)</span></span><span class="main">]</span> 
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> map_add_upd_left<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> dom_map_of_conv_image_fst<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> ls_insls_map_of'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_hash <span class="free">ls</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_distinct <span class="free">ls</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_hash <span class="free">ld</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_distinct <span class="free">ld</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;</span> length <span class="free">ld</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">&lt;</span> length <span class="free">ls</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"map_of <span class="main">(</span>concat <span class="main">(</span>ls_insls <span class="main">(</span><span class="free">ls</span> <span class="main">!</span> <span class="free">n</span><span class="main">)</span> <span class="free">ld</span><span class="main">)</span><span class="main">)</span> 
      <span class="main">++</span> map_of <span class="main">(</span>concat <span class="main">(</span>take <span class="free">n</span> <span class="free">ls</span><span class="main">)</span><span class="main">)</span>
    <span class="main">=</span> map_of <span class="main">(</span>concat <span class="free">ld</span><span class="main">)</span> <span class="main">++</span> map_of <span class="main">(</span>concat <span class="main">(</span>take <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="free">ls</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms<span class="main">(</span>2<span class="main">,</span>6<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst <span class="main">(</span><span class="free">ls</span> <span class="main">!</span> <span class="free">n</span><span class="main">)</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ht_distinct_def<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> ls_insls_map_of<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>3-5<span class="main"><span class="main">)</span></span> this<span class="main">]</span> assms<span class="main">(</span>6<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> List.take_Suc_conv_app_nth<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ls_copy_map_of<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_hash <span class="free">ls</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_distinct <span class="free">ls</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_hash <span class="free">ld</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_distinct <span class="free">ld</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;</span> length <span class="free">ld</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">≤</span> length <span class="free">ls</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"map_of <span class="main">(</span>concat <span class="main">(</span>ls_copy <span class="free">n</span> <span class="free">ls</span> <span class="free">ld</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> map_of <span class="main">(</span>concat <span class="free">ld</span><span class="main">)</span> <span class="main">++</span> map_of <span class="main">(</span>concat <span class="main">(</span>take <span class="free">n</span> <span class="free">ls</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">ld</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">premises</span></span> prems <span class="keyword2"><span class="keyword">for</span></span> n ld
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">note</span></span> a <span class="main">=</span> ht_hash_ls_insls<span class="main">[</span><span class="operator">OF</span> prems<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span><span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="free">ls</span> <span class="main">!</span> <span class="skolem">n</span>"</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">note</span></span> b <span class="main">=</span> ht_distinct_ls_insls<span class="main">[</span><span class="operator">OF</span> prems<span class="main"><span class="main">(</span></span>5<span class="main"><span class="main">)</span></span><span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="free">ls</span> <span class="main">!</span> <span class="skolem">n</span>"</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">note</span></span> c <span class="main">=</span> length_ls_insls<span class="main">[</span><span class="operator">OF</span> prems<span class="main"><span class="main">(</span></span>6<span class="main"><span class="main">)</span></span><span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="free">ls</span> <span class="main">!</span> <span class="skolem">n</span>"</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">from</span></span> prems <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">&lt;</span> length <span class="free">ls</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">with</span></span> 
      ls_insls_map_of'<span class="main">[</span><span class="operator">OF</span> prems<span class="main"><span class="main">(</span></span>2-6<span class="main"><span class="main">)</span></span> this<span class="main">]</span> 
      prems<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span>2<span class="main"><span class="main">)</span></span> a b c<span class="main">]</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">lemma</span></span> ls_rehash_map_of<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_hash <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_distinct <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;</span> length <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"map_of <span class="main">(</span>concat <span class="main">(</span>ls_rehash <span class="free">l</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> map_of <span class="main">(</span>concat <span class="free">l</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>3<span class="main">)</span> ls_copy_map_of<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span>2<span class="main"><span class="main">)</span></span> 
    ht_hash_replicate ht_distinct_replicate<span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ls_rehash_def<span class="main">)</span>


<span class="keyword1"><span class="command">lemma</span></span> abs_update_rehash_map_of<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_hash <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_distinct <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;</span> length <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"map_of <span class="main">(</span>concat <span class="main">(</span>abs_update <span class="free">k</span> <span class="free">v</span> <span class="main">(</span>ls_rehash <span class="free">l</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> 
  <span class="main">=</span> map_of <span class="main">(</span>concat <span class="free">l</span><span class="main">)</span><span class="main">(</span><span class="free">k</span> <span class="main">↦</span> <span class="free">v</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">note</span></span> a <span class="main">=</span> ht_hash_ls_rehash<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">l</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">note</span></span> b <span class="main">=</span> ht_distinct_ls_rehash<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">l</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">note</span></span> c <span class="main">=</span> length_ls_rehash<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">from</span></span> abs_update_map_of<span class="main">[</span><span class="operator">OF</span> a b c<span class="main">]</span> ls_rehash_map_of<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> 
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">hm_update</span> <span class="main">≡</span> ht_update"</span></span>
<span class="keyword1"><span class="command">lemma</span></span> hm_update_rule'<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span>is_hashmap' <span class="free">m</span> <span class="free">l</span> <span class="free">ht</span><span class="main">&gt;</span> 
    hm_update <span class="free">k</span> <span class="free">v</span> <span class="free">ht</span> 
  <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> is_hashmap <span class="main">(</span><span class="free">m</span><span class="main">(</span><span class="free">k</span> <span class="main">↦</span> <span class="free">v</span><span class="main">)</span><span class="main">)</span> <span class="bound">r</span> <span class="main">*</span> <span class="keyword1">true</span><span class="main">&gt;</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"length <span class="free">l</span> <span class="main">*</span> load_factor <span class="main">≤</span> the_size <span class="free">ht</span> <span class="main">*</span> <span class="numeral">100</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> is_hashmap'_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sep_auto</span>    
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cons_post_rule<span class="main"><span class="main">[</span></span><span class="operator">OF</span> complete_ht_update_rehash<span class="main"><span class="main">[</span></span><span class="operator">OF</span> True<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> is_hashmap_def is_hashmap'_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sep_auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> abs_update_rehash_map_of is_hashtable_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>    
    <span class="keyword1"><span class="command">unfolding</span></span> is_hashmap'_def is_hashtable_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sep_auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cons_post_rule<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> complete_ht_update_normal<span class="main">[</span><span class="operator">OF</span> False<span class="main">,</span> <span class="operator">simplified</span> is_hashtable_def<span class="main">,</span> 
      <span class="operator">simplified</span><span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">k</span></span> <span class="quoted"><span class="free">v</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">unfolding</span></span> is_hashmap_def is_hashmap'_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sep_auto</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> abs_update_map_of is_hashtable_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> hm_update_rule<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span>is_hashmap <span class="free">m</span> <span class="free">ht</span><span class="main">&gt;</span> 
    hm_update <span class="free">k</span> <span class="free">v</span> <span class="free">ht</span> 
  <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> is_hashmap <span class="main">(</span><span class="free">m</span><span class="main">(</span><span class="free">k</span> <span class="main">↦</span> <span class="free">v</span><span class="main">)</span><span class="main">)</span> <span class="bound">r</span> <span class="main">*</span> <span class="keyword1">true</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> is_hashmap_def<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">m</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hm_update_rule'<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ls_delete_map_of<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst <span class="free">l</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"map_of <span class="main">(</span>fst <span class="main">(</span>ls_delete <span class="free">k</span> <span class="free">l</span><span class="main">)</span><span class="main">)</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span>map_of <span class="free">l</span><span class="main">)</span> <span class="main">|`</span> <span class="main">(</span><span class="main">-</span> <span class="main">{</span><span class="free">k</span><span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">l</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> ls_delete.induct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_of_eq_None_iff Let_def<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> ComplD ComplI Compl_insert option.set<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> 
    insertE insertI2 map_upd_eq_restrict restrict_map_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> update_ls_delete_map_of<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_hash <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_distinct <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_hash <span class="main">(</span><span class="free">l</span><span class="main">[</span>bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span> 
  <span class="main">:=</span> fst <span class="main">(</span>ls_delete <span class="free">k</span> <span class="main">(</span><span class="free">l</span> <span class="main">!</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_distinct <span class="main">(</span><span class="free">l</span><span class="main">[</span>bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span> 
  <span class="main">:=</span> fst <span class="main">(</span>ls_delete <span class="free">k</span> <span class="main">(</span><span class="free">l</span> <span class="main">!</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;</span> length <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"map_of <span class="main">(</span>concat <span class="main">(</span><span class="free">l</span><span class="main">[</span>bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span> 
    <span class="main">:=</span> fst <span class="main">(</span>ls_delete <span class="free">k</span> <span class="main">(</span><span class="free">l</span> <span class="main">!</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="free">x</span>
  <span class="main">=</span> <span class="main">(</span><span class="main">(</span>map_of <span class="main">(</span>concat <span class="free">l</span><span class="main">)</span><span class="main">)</span> <span class="main">|`</span> <span class="main">(</span><span class="main">-</span> <span class="main">{</span><span class="free">k</span><span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms<span class="main">(</span>2<span class="main">)</span> bounded_hashcode_nat_bounds<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>5<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> 
    distinct<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst <span class="main">(</span><span class="free">l</span> <span class="main">!</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ht_distinct_def<span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> id1 <span class="main">=</span> ht_hash_ht_distinct_map_of<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">,</span></span>4<span class="main"><span class="main">)</span></span><span class="main">,</span> <span class="operator">simplified</span><span class="main">,</span> 
    <span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>5<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">x</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">note</span></span> id2 <span class="main">=</span> ht_hash_ht_distinct_map_of<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span>2<span class="main"><span class="main">,</span></span>5<span class="main"><span class="main">)</span></span><span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">x</span></span><span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> 
      <span class="quoted"><span class="quoted">"bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">x</span> <span class="main">=</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">with</span></span> id1
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_of <span class="main">(</span>concat <span class="main">(</span><span class="free">l</span><span class="main">[</span>bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span> 
      <span class="main">:=</span> fst <span class="main">(</span>ls_delete <span class="free">k</span> <span class="main">(</span><span class="free">l</span> <span class="main">!</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="free">x</span> 
      <span class="main">=</span>
      map_of <span class="main">(</span><span class="free">l</span><span class="main">[</span>bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span> 
        <span class="main">:=</span> fst <span class="main">(</span>ls_delete <span class="free">k</span> <span class="main">(</span><span class="free">l</span> <span class="main">!</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span><span class="main">)</span><span class="main">)</span><span class="main">]</span> 
      <span class="main">!</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span><span class="main">)</span> <span class="free">x</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> 
      <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> map_of <span class="main">(</span>fst <span class="main">(</span>ls_delete <span class="free">k</span> 
                          <span class="main">(</span><span class="free">l</span> <span class="main">!</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="free">x</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bounded_hashcode_nat_bounds<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main"><span class="main">(</span></span></span>5<span class="main"><span class="main"><span class="main">)</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> ls_delete_map_of<span class="main">[</span><span class="operator">OF</span> distinct<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> 
      <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span>map_of <span class="main">(</span><span class="free">l</span> <span class="main">!</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="free">k</span><span class="main">)</span> <span class="main">|`</span> <span class="main">(</span><span class="main">-</span> <span class="main">{</span><span class="free">k</span><span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="free">x</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="free">k</span>"</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> id2 True<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">with</span></span> bounded_hashcode_nat_bounds<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>5<span class="main"><span class="main">)</span></span><span class="main">]</span> id1 id2<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> 
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="free">k</span>"</span></span><span class="main">)</span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">hm_delete</span> <span class="main">≡</span> ht_delete"</span></span>
<span class="keyword1"><span class="command">lemma</span></span> hm_delete_rule'<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span>is_hashmap' <span class="free">m</span> <span class="free">l</span> <span class="free">ht</span><span class="main">&gt;</span> hm_delete <span class="free">k</span> <span class="free">ht</span> <span class="main">&lt;</span>is_hashmap <span class="main">(</span><span class="free">m</span> <span class="main">|`</span> <span class="main">(</span><span class="main">-</span><span class="main">{</span><span class="free">k</span><span class="main">}</span><span class="main">)</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> is_hashmap'_def<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free">m</span></span><span class="main"><span class="main">]</span></span> is_hashtable_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sep_auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cons_post_rule<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> complete_ht_delete<span class="main">[</span><span class="operator">simplified</span> is_hashtable_def<span class="main">]</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sep_auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> is_hashmap_def is_hashmap'_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> is_hashtable_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> update_ls_delete_map_of<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> hm_delete_rule<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span>is_hashmap <span class="free">m</span> <span class="free">ht</span><span class="main">&gt;</span> hm_delete <span class="free">k</span> <span class="free">ht</span> <span class="main">&lt;</span>is_hashmap <span class="main">(</span><span class="free">m</span> <span class="main">|`</span> <span class="main">(</span><span class="main">-</span><span class="main">{</span><span class="free">k</span><span class="main">}</span><span class="main">)</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> is_hashmap_def<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">m</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hm_delete_rule'<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">hm_isEmpty</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">)</span> hashtable <span class="main">⇒</span> bool Heap"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">hm_isEmpty</span> <span class="free"><span class="bound"><span class="entity">ht</span></span></span> <span class="main">≡</span> return <span class="main">(</span>the_size <span class="free"><span class="bound"><span class="entity">ht</span></span></span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> hm_isEmpty_rule'<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span>is_hashmap' <span class="free">m</span> <span class="free">l</span> <span class="free">ht</span><span class="main">&gt;</span> 
  hm_isEmpty <span class="free">ht</span> 
  <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> is_hashmap' <span class="free">m</span> <span class="free">l</span> <span class="free">ht</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="bound">r</span> <span class="main">⟷</span> <span class="free">m</span><span class="main">=</span>Map.empty<span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> hm_isEmpty_def
  <span class="keyword1"><span class="command">unfolding</span></span> is_hashmap_def is_hashmap'_def is_hashtable_def ht_size_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">ht</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sep_auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> hm_isEmpty_rule<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span>is_hashmap <span class="free">m</span> <span class="free">ht</span><span class="main">&gt;</span> hm_isEmpty <span class="free">ht</span> <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> is_hashmap <span class="free">m</span> <span class="free">ht</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="bound">r</span> <span class="main">⟷</span> <span class="free">m</span><span class="main">=</span>Map.empty<span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> is_hashmap_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> hm_isEmpty_rule'<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">hm_size</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">)</span> hashtable <span class="main">⇒</span> nat Heap"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">hm_size</span> <span class="free"><span class="bound"><span class="entity">ht</span></span></span> <span class="main">≡</span> return <span class="main">(</span>the_size <span class="free"><span class="bound"><span class="entity">ht</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> length_card_dom_map_of<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst <span class="free">l</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"length <span class="free">l</span> <span class="main">=</span> card <span class="main">(</span>dom <span class="main">(</span>map_of <span class="free">l</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">l</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">a</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> fst_conv map_of_SomeD<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="improper">aa</span> <span class="main">∉</span> dom <span class="main">(</span>map_of <span class="improper">l</span><span class="main">)</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> dom_map_of_conv_image_fst<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ht_hash_dom_map_of_disj<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_hash <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">&lt;</span> length <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">j</span> <span class="main">&lt;</span> length <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">≠</span> <span class="free">j</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"dom <span class="main">(</span>map_of <span class="main">(</span><span class="free">l</span><span class="main">!</span><span class="free">i</span><span class="main">)</span><span class="main">)</span> <span class="main">∩</span> dom <span class="main">(</span>map_of<span class="main">(</span><span class="free">l</span><span class="main">!</span><span class="free">j</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">unfolding</span></span> ht_hash_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> fst_conv map_of_SomeD<span class="main">)</span>


<span class="keyword1"><span class="command">lemma</span></span> ht_hash_dom_map_of_disj_drop<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_hash <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">&lt;</span> length <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"dom <span class="main">(</span>map_of <span class="main">(</span><span class="free">l</span><span class="main">!</span><span class="free">i</span><span class="main">)</span><span class="main">)</span> <span class="main">∩</span> dom <span class="main">(</span>map_of <span class="main">(</span>concat <span class="main">(</span>drop <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span> <span class="free">l</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">premises</span></span> prems <span class="keyword2"><span class="keyword">for</span></span> x y z
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> prems<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> dom <span class="main">(</span>map_of <span class="main">(</span>concat <span class="main">(</span>drop <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span> <span class="free">l</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">j</span><span class="main">.</span> <span class="bound">j</span> <span class="main">&lt;</span> length <span class="main">(</span>drop <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span> <span class="free">l</span><span class="main">)</span> 
      <span class="main">∧</span> <span class="skolem">x</span> <span class="main">∈</span> dom <span class="main">(</span>map_of <span class="main">(</span><span class="main">(</span>drop <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span> <span class="free">l</span><span class="main">)</span><span class="main">!</span><span class="bound">j</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Hash_Map.map_of_concat 
        <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> dom <span class="main">(</span>map_of <span class="main">(</span>concat <span class="main">(</span>drop <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span> <span class="free">l</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>›</span></span> length_drop<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> this <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">j</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
      j<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">&lt;</span> length <span class="main">(</span>drop <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span> <span class="free">l</span><span class="main">)</span> 
        <span class="main">∧</span> <span class="skolem">x</span> <span class="main">∈</span> dom <span class="main">(</span>map_of <span class="main">(</span><span class="main">(</span>drop <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span> <span class="free">l</span><span class="main">)</span><span class="main">!</span><span class="skolem">j</span><span class="main">)</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">hence</span></span> length<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Suc <span class="free">i</span> <span class="main">+</span> <span class="skolem">j</span><span class="main">)</span> <span class="main">&lt;</span> length <span class="free">l</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> j <span class="keyword1"><span class="command">have</span></span> neq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">≠</span> <span class="main">(</span>Suc <span class="free">i</span> <span class="main">+</span> <span class="skolem">j</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> j <span class="keyword1"><span class="command">have</span></span> in_dom<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> dom <span class="main">(</span>map_of <span class="main">(</span><span class="free">l</span><span class="main">!</span><span class="main">(</span>Suc <span class="free">i</span> <span class="main">+</span> <span class="skolem">j</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> prems<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> in_dom2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> dom <span class="main">(</span>map_of <span class="main">(</span><span class="free">l</span> <span class="main">!</span> <span class="free">i</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> ht_hash_dom_map_of_disj<span class="main">[</span><span class="operator">OF</span> assms length neq<span class="main">]</span> in_dom in_dom2
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> sum_list_length_card_dom_map_of_concat<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_hash <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ht_distinct <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sum_list <span class="main">(</span>map length <span class="free">l</span><span class="main">)</span> <span class="main">=</span> card <span class="main">(</span>dom <span class="main">(</span>map_of <span class="main">(</span>concat <span class="free">l</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> ht_hash_dom_map_of_disj_drop<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">i</span><span class="main">.</span> <span class="bound">i</span> <span class="main">&lt;</span> length <span class="free">l</span> 
    <span class="main">⟶</span> dom <span class="main">(</span>map_of <span class="main">(</span><span class="free">l</span> <span class="main">!</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">∩</span> dom <span class="main">(</span>map_of <span class="main">(</span>concat <span class="main">(</span>drop <span class="main">(</span>Suc <span class="bound">i</span><span class="main">)</span> <span class="free">l</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
        <span class="main">=</span> <span class="main">{}</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> assms<span class="main">(</span>2<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">l</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> Nil
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">l</span> <span class="skolem">ls</span><span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> Cons<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"ht_distinct <span class="skolem">ls</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ht_distinct_def<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> Cons<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> b<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound"><span class="bound">i</span></span> <span class="main">&lt;</span> length <span class="skolem">ls</span><span class="main">.</span> dom <span class="main">(</span>map_of <span class="main">(</span><span class="skolem">ls</span> <span class="main">!</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span> 
      <span class="main">∩</span> dom <span class="main">(</span>map_of <span class="main">(</span>concat <span class="main">(</span>drop <span class="main">(</span>Suc <span class="bound">i</span><span class="main">)</span> <span class="skolem">ls</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> allI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"Suc <span class="improper">i</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> P<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> <span class="bound">i</span><span class="main">&lt;</span>Suc <span class="main">(</span>length <span class="skolem">ls</span><span class="main">)</span> <span class="main">⟶</span>
             dom <span class="main">(</span>map_of <span class="main">(</span><span class="main">(</span><span class="skolem">l</span> <span class="main">#</span> <span class="skolem">ls</span><span class="main">)</span> <span class="main">!</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">∩</span> dom <span class="main">(</span>map_of <span class="main">(</span>concat <span class="main">(</span>drop <span class="bound">i</span> <span class="skolem">ls</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
             <span class="main">{}</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> allE<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command">from</span></span> Cons<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst <span class="skolem">l</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ht_distinct_def<span class="main">)</span>
    <span class="keyword1"><span class="command">note</span></span> l <span class="main">=</span> length_card_dom_map_of<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span>
    <span class="keyword1"><span class="command">from</span></span> Cons<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> c<span class="main">:</span> <span class="quoted"><span class="quoted">"dom <span class="main">(</span>map_of <span class="skolem">l</span><span class="main">)</span> <span class="main">∩</span> dom <span class="main">(</span>map_of <span class="main">(</span>concat <span class="skolem">ls</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">0</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> P<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> <span class="bound">i</span><span class="main">&lt;</span>Suc <span class="main">(</span>length <span class="skolem">ls</span><span class="main">)</span> <span class="main">⟶</span>
             dom <span class="main">(</span>map_of <span class="main">(</span><span class="main">(</span><span class="skolem">l</span> <span class="main">#</span> <span class="skolem">ls</span><span class="main">)</span> <span class="main">!</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span> 
               <span class="main">∩</span> dom <span class="main">(</span>map_of <span class="main">(</span>concat <span class="main">(</span>drop <span class="bound">i</span> <span class="skolem">ls</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> 
             <span class="main">=</span> <span class="main">{}</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> allE<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command">from</span></span> Cons<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> a b<span class="main">]</span> l c <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> card_Un_disjoint<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">lemma</span></span> hm_size_rule'<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span>is_hashmap' <span class="free">m</span> <span class="free">l</span> <span class="free">ht</span><span class="main">&gt;</span> 
  hm_size <span class="free">ht</span> 
  <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> is_hashmap' <span class="free">m</span> <span class="free">l</span> <span class="free">ht</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="bound">r</span> <span class="main">=</span> card <span class="main">(</span>dom <span class="free">m</span><span class="main">)</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> hm_size_def is_hashmap_def is_hashmap'_def is_hashtable_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sep_auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">ht</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ht_size_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sep_auto</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sum_list_length_card_dom_map_of_concat<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> hm_size_rule<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span>is_hashmap <span class="free">m</span> <span class="free">ht</span><span class="main">&gt;</span> 
    hm_size <span class="free">ht</span> 
  <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> is_hashmap <span class="free">m</span> <span class="free">ht</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="bound">r</span> <span class="main">=</span> card <span class="main">(</span>dom <span class="free">m</span><span class="main">)</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> is_hashmap_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> hm_size_rule'<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Iterators›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Definitions›</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'k</span><span class="main">,</span><span class="tfree">'v</span><span class="main">)</span> hm_it <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat <span class="main">×</span> <span class="main">(</span><span class="tfree">'k</span><span class="main">×</span><span class="tfree">'v</span><span class="main">)</span> list <span class="main">×</span> <span class="main">(</span><span class="tfree">'k</span><span class="main">,</span><span class="tfree">'v</span><span class="main">)</span> hashtable<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">hm_it_adjust</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span><span class="main">::</span><span class="main">{</span>heap<span class="main">,</span>hashable<span class="main">}</span><span class="main">,</span><span class="tfree">'v</span><span class="main">::</span>heap<span class="main">)</span> hashtable <span class="main">⇒</span> nat Heap"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">hm_it_adjust</span> <span class="main">0</span> <span class="free"><span class="bound"><span class="entity">ht</span></span></span> <span class="main">=</span> return <span class="main">0</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">hm_it_adjust</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">ht</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">l</span> <span class="main">←</span> Array.nth <span class="main">(</span>the_array <span class="free"><span class="bound"><span class="entity">ht</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">;</span>
    <span class="keyword1">case</span> <span class="bound">l</span> <span class="keyword1">of</span> 
      <span class="main">[]</span> <span class="main">⇒</span> <span class="free">hm_it_adjust</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">ht</span></span></span>
    <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span>  return <span class="free"><span class="bound"><span class="entity">n</span></span></span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">hm_it_init</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span><span class="main">::</span><span class="main">{</span>heap<span class="main">,</span>hashable<span class="main">}</span><span class="main">,</span><span class="tfree">'v</span><span class="main">::</span>heap<span class="main">)</span> hashtable <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span><span class="main">,</span><span class="tfree">'v</span><span class="main">)</span> hm_it Heap"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">hm_it_init</span> <span class="free"><span class="bound"><span class="entity">ht</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="bound">n</span><span class="main">←</span>Array.len <span class="main">(</span>the_array <span class="free"><span class="bound"><span class="entity">ht</span></span></span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1">if</span> <span class="bound">n</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> return <span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="main">[]</span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">ht</span></span></span><span class="main">)</span>
  <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">i</span><span class="main">←</span>hm_it_adjust <span class="main">(</span><span class="bound">n</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">ht</span></span></span><span class="main">;</span>
    <span class="bound">l</span><span class="main">←</span>Array.nth <span class="main">(</span>the_array <span class="free"><span class="bound"><span class="entity">ht</span></span></span><span class="main">)</span> <span class="bound">i</span><span class="main">;</span>
    return <span class="main">(</span><span class="bound">i</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">ht</span></span></span><span class="main">)</span>
  <span class="main">}</span>
<span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">hm_it_has_next</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span><span class="main">::</span><span class="main">{</span>heap<span class="main">,</span>hashable<span class="main">}</span><span class="main">,</span><span class="tfree">'v</span><span class="main">::</span>heap<span class="main">)</span> hm_it <span class="main">⇒</span> bool Heap"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">hm_it_has_next</span> <span class="free"><span class="bound"><span class="entity">it</span></span></span> 
  <span class="main">≡</span> return <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">it</span></span></span> <span class="keyword1">of</span> <span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="main">[]</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">⇒</span> False <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> True<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">hm_it_next</span> <span class="main">::</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span><span class="main">::</span><span class="main">{</span>heap<span class="main">,</span>hashable<span class="main">}</span><span class="main">,</span><span class="tfree">'v</span><span class="main">::</span>heap<span class="main">)</span> hm_it 
    <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'k</span><span class="main">×</span><span class="tfree">'v</span><span class="main">)</span><span class="main">×</span><span class="main">(</span><span class="tfree">'k</span><span class="main">,</span><span class="tfree">'v</span><span class="main">)</span> hm_it<span class="main">)</span> Heap"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">hm_it_next</span> <span class="free"><span class="bound"><span class="entity">it</span></span></span> <span class="main">≡</span> <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">it</span></span></span> <span class="keyword1">of</span> 
    <span class="main">(</span><span class="bound">i</span><span class="main">,</span><span class="bound">a</span><span class="main">#</span><span class="bound">b</span><span class="main">#</span><span class="bound">l</span><span class="main">,</span><span class="bound">ht</span><span class="main">)</span> <span class="main">⇒</span> return <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="main">(</span><span class="bound">i</span><span class="main">,</span><span class="bound">b</span><span class="main">#</span><span class="bound">l</span><span class="main">,</span><span class="bound">ht</span><span class="main">)</span><span class="main">)</span>
  <span class="main">|</span> <span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="main">[</span><span class="bound">a</span><span class="main">]</span><span class="main">,</span><span class="bound">ht</span><span class="main">)</span> <span class="main">⇒</span> return <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="main">[]</span><span class="main">,</span><span class="bound">ht</span><span class="main">)</span><span class="main">)</span>
  <span class="main">|</span> <span class="main">(</span>Suc <span class="bound">i</span><span class="main">,</span><span class="main">[</span><span class="bound">a</span><span class="main">]</span><span class="main">,</span><span class="bound">ht</span><span class="main">)</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">i</span> <span class="main">←</span> hm_it_adjust <span class="bound">i</span> <span class="bound">ht</span><span class="main">;</span>
    <span class="bound">l</span> <span class="main">←</span> Array.nth <span class="main">(</span>the_array <span class="bound">ht</span><span class="main">)</span> <span class="bound">i</span><span class="main">;</span>
    return <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="main">(</span><span class="bound">i</span><span class="main">,</span>rev <span class="bound">l</span><span class="main">,</span><span class="bound">ht</span><span class="main">)</span><span class="main">)</span>
  <span class="main">}</span>
  "</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hm_is_it'</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">ht</span></span></span> <span class="free"><span class="bound"><span class="entity">l'</span></span></span> <span class="free"><span class="bound"><span class="entity">it</span></span></span> <span class="main">≡</span>  
  is_hashtable <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">ht</span></span></span> <span class="main">*</span> 
  <span class="main">↑</span><span class="main">(</span><span class="keyword1">let</span> <span class="main">(</span><span class="bound">i</span><span class="main">,</span><span class="bound">r</span><span class="main">,</span><span class="bound">ht'</span><span class="main">)</span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">it</span></span></span> <span class="keyword1">in</span> 
       <span class="free"><span class="bound"><span class="entity">ht</span></span></span> <span class="main">=</span> <span class="bound">ht'</span> 
     <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">l'</span></span></span> <span class="main">=</span> <span class="main">(</span>concat <span class="main">(</span>take <span class="bound">i</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="main">@</span> rev <span class="bound">r</span><span class="main">)</span>
     <span class="main">∧</span> distinct <span class="main">(</span>map fst <span class="main">(</span><span class="free"><span class="bound"><span class="entity">l'</span></span></span><span class="main">)</span><span class="main">)</span>
     <span class="main">∧</span> <span class="bound">i</span> <span class="main">≤</span> length <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">∧</span> <span class="main">(</span><span class="bound">r</span><span class="main">=</span><span class="main">[]</span> <span class="main">⟶</span> <span class="bound">i</span><span class="main">=</span><span class="main">0</span><span class="main">)</span>
   <span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hm_is_it</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">ht</span></span></span> <span class="free"><span class="bound"><span class="entity">m'</span></span></span> <span class="free"><span class="bound"><span class="entity">it</span></span></span> <span class="main">≡</span> <span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">l</span> <span class="bound">l'</span><span class="main">.</span> 
  hm_is_it' <span class="bound">l</span> <span class="free"><span class="bound"><span class="entity">ht</span></span></span> <span class="bound">l'</span> <span class="free"><span class="bound"><span class="entity">it</span></span></span> 
  <span class="main">*</span> <span class="main">↑</span><span class="main">(</span>map_of <span class="main">(</span>concat <span class="bound">l</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">∧</span> map_of <span class="bound">l'</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">m'</span></span></span><span class="main">)</span> 
  "</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Auxiliary Lemmas›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> concat_take_Suc_empty<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">n</span> <span class="main">&lt;</span> length <span class="free">l</span><span class="main">;</span> <span class="free">l</span><span class="main">!</span><span class="free">n</span><span class="main">=</span><span class="main">[]</span> <span class="main">⟧</span> 
  <span class="main">⟹</span> concat <span class="main">(</span>take <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="free">l</span><span class="main">)</span> <span class="main">=</span> concat <span class="main">(</span>take <span class="free">n</span> <span class="free">l</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">l</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">l</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span>2<span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">l</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span>2<span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> nth_concat_splitE<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span><span class="main">&lt;</span>length <span class="main">(</span>concat <span class="free">ls</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">j</span> <span class="free">k</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">j</span> <span class="main">&lt;</span> length <span class="free">ls</span>"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">&lt;</span> length <span class="main">(</span><span class="free">ls</span><span class="main">!</span><span class="free">j</span><span class="main">)</span>"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"concat <span class="free">ls</span> <span class="main">!</span> <span class="free">i</span> <span class="main">=</span> <span class="free">ls</span><span class="main">!</span><span class="free">j</span><span class="main">!</span><span class="free">k</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">=</span> length <span class="main">(</span>concat <span class="main">(</span>take <span class="free">j</span> <span class="free">ls</span><span class="main">)</span><span class="main">)</span> <span class="main">+</span> <span class="free">k</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">ls</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">i</span></span> <span class="quoted"><span class="free">thesis</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">l</span> <span class="skolem">ls</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span><span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> L<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> length <span class="skolem">l</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"concat <span class="main">(</span><span class="skolem">l</span><span class="main">#</span><span class="skolem">ls</span><span class="main">)</span> <span class="main">!</span> <span class="skolem">i</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">l</span><span class="main">#</span><span class="skolem">ls</span><span class="main">)</span><span class="main">!</span><span class="main">0</span><span class="main">!</span><span class="skolem">i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> nth_append<span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> Cons.prems<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="main">0</span></span> <span class="quoted"><span class="skolem">i</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> L<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> L<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="main">(</span><span class="skolem">i</span> <span class="main">&lt;</span> length <span class="skolem">l</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"concat <span class="main">(</span><span class="skolem">l</span><span class="main">#</span><span class="skolem">ls</span><span class="main">)</span><span class="main">!</span><span class="skolem">i</span> <span class="main">=</span> concat <span class="skolem">ls</span> <span class="main">!</span> <span class="main">(</span><span class="skolem">i</span> <span class="main">-</span> length <span class="skolem">l</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> nth_append<span class="main">)</span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">j</span></span> <span class="skolem"><span class="skolem">k</span></span> <span class="keyword2"><span class="keyword">where</span></span>
      <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">&lt;</span> length <span class="skolem">ls</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span> <span class="main">&lt;</span> length <span class="main">(</span><span class="skolem">ls</span><span class="main">!</span><span class="skolem">j</span><span class="main">)</span>"</span></span> 
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"concat <span class="skolem">ls</span> <span class="main">!</span> <span class="main">(</span><span class="skolem">i</span> <span class="main">-</span> length <span class="skolem">l</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">ls</span><span class="main">!</span><span class="skolem">j</span><span class="main">!</span><span class="skolem">k</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">-</span> length <span class="skolem">l</span> <span class="main">=</span> length <span class="main">(</span>concat <span class="main">(</span>take <span class="skolem">j</span> <span class="skolem">ls</span><span class="main">)</span><span class="main">)</span> <span class="main">+</span> <span class="skolem">k</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> Cons.hyps<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">-</span> length <span class="skolem">l</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> Cons.prems L
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> L 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> Cons.prems<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted">"Suc <span class="skolem">j</span>"</span></span> <span class="quoted"><span class="skolem">k</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> nth_append<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> is_hashmap'_distinct<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"is_hashtable <span class="free">l</span> <span class="free">ht</span> 
    <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> is_hashtable <span class="free">l</span> <span class="free">ht</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span>distinct <span class="main">(</span>map fst <span class="main">(</span>concat <span class="free">l</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> distinct_conv_nth<span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> allI impI<span class="main"><span class="keyword3">,</span></span> <span class="operator">elim</span> exE<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span> <span class="skolem">j</span> <span class="skolem">a</span> <span class="skolem">b</span>
  <span class="keyword3"><span class="command">assume</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> length <span class="main">(</span>concat <span class="free">l</span><span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> 2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">&lt;</span> length <span class="main">(</span>concat <span class="free">l</span><span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> 3<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span><span class="main">≠</span><span class="skolem">j</span>"</span></span>
  
  <span class="keyword3"><span class="command">assume</span></span> HM<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span> <span class="main">⊨</span> is_hashtable <span class="free">l</span> <span class="free">ht</span>"</span></span>

  <span class="keyword1"><span class="command">from</span></span> 1 <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">ji</span></span> <span class="skolem"><span class="skolem">ki</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    IFMT<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">=</span> length <span class="main">(</span>concat <span class="main">(</span>take <span class="skolem">ji</span> <span class="free">l</span><span class="main">)</span><span class="main">)</span> <span class="main">+</span> <span class="skolem">ki</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> JI_LEN<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">ji</span> <span class="main">&lt;</span> length <span class="free">l</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> KI_LEN<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">ki</span> <span class="main">&lt;</span> length <span class="main">(</span><span class="free">l</span><span class="main">!</span><span class="skolem">ji</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"concat <span class="free">l</span> <span class="main">!</span> <span class="skolem">i</span> <span class="main">=</span> <span class="free">l</span><span class="main">!</span><span class="skolem">ji</span><span class="main">!</span><span class="skolem">ki</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> nth_concat_splitE<span class="main">)</span>

  <span class="keyword1"><span class="command">from</span></span> 2 <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">jj</span></span> <span class="skolem"><span class="skolem">kj</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    JFMT<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">=</span> length <span class="main">(</span>concat <span class="main">(</span>take <span class="skolem">jj</span> <span class="free">l</span><span class="main">)</span><span class="main">)</span> <span class="main">+</span> <span class="skolem">kj</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> JJ_LEN<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">jj</span> <span class="main">&lt;</span> length <span class="free">l</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> KJ_LEN<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">kj</span> <span class="main">&lt;</span> length <span class="main">(</span><span class="free">l</span><span class="main">!</span><span class="skolem">jj</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"concat <span class="free">l</span> <span class="main">!</span> <span class="skolem">j</span> <span class="main">=</span> <span class="free">l</span><span class="main">!</span><span class="skolem">jj</span><span class="main">!</span><span class="skolem">kj</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> nth_concat_splitE<span class="main">)</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"fst <span class="main">(</span>concat <span class="free">l</span> <span class="main">!</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">≠</span> fst <span class="main">(</span>concat <span class="free">l</span> <span class="main">!</span> <span class="skolem">j</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">ji</span><span class="main">=</span><span class="skolem">jj</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> IFMT JFMT <span class="quoted"><span class="quoted">‹<span class="skolem">i</span><span class="main">≠</span><span class="skolem">j</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ki</span><span class="main">≠</span><span class="skolem">kj</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> HM JJ_LEN <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst <span class="main">(</span><span class="free">l</span><span class="main">!</span><span class="skolem">jj</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> is_hashmap'_def is_hashtable_def ht_distinct_def
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> KI_LEN KJ_LEN
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> distinct_conv_nth<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> NE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">ji</span><span class="main">≠</span><span class="skolem">jj</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> HM <span class="keyword1"><span class="command">have</span></span> 
      <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">∈</span>set <span class="main">(</span><span class="free">l</span><span class="main">!</span><span class="skolem">ji</span><span class="main">)</span><span class="main">.</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="main">(</span>fst <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">ji</span>"</span></span>
      <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">∈</span>set <span class="main">(</span><span class="free">l</span><span class="main">!</span><span class="skolem">jj</span><span class="main">)</span><span class="main">.</span> bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="main">(</span>fst <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">jj</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> is_hashmap'_def is_hashtable_def ht_hash_def
      <span class="keyword1"><span class="command">using</span></span> JI_LEN JJ_LEN
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> KI_LEN KJ_LEN NE <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> nth_mem<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> take_set<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>take <span class="free">n</span> <span class="free">l</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span> <span class="free">l</span><span class="main">!</span><span class="bound">i</span> <span class="main">|</span> <span class="bound">i</span><span class="main">.</span> <span class="bound">i</span><span class="main">&lt;</span><span class="free">n</span> <span class="main">∧</span> <span class="bound">i</span><span class="main">&lt;</span>length <span class="free">l</span> <span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_conv_nth<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">i</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> skip_empty_aux<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"concat <span class="main">(</span>take <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="free">l</span><span class="main">)</span> <span class="main">=</span> concat <span class="main">(</span>take <span class="main">(</span>Suc <span class="free">x</span><span class="main">)</span> <span class="free">l</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> L<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Suc <span class="free">n</span> <span class="main">≤</span> length <span class="free">l</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≤</span> <span class="free">n</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">i</span><span class="main">.</span> <span class="free">x</span><span class="main">&lt;</span><span class="bound">i</span> <span class="main">∧</span> <span class="bound">i</span><span class="main">≤</span><span class="free">n</span> <span class="main">⟶</span> <span class="free">l</span><span class="main">!</span><span class="bound">i</span><span class="main">=</span><span class="main">[]</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"take <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="free">l</span> <span class="main">=</span> take <span class="main">(</span>Suc <span class="free">x</span> <span class="main">+</span> <span class="main">(</span><span class="free">n</span> <span class="main">-</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span> <span class="free">l</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> take <span class="main">(</span>Suc <span class="free">x</span><span class="main">)</span> <span class="free">l</span> <span class="main">@</span> take <span class="main">(</span><span class="free">n</span> <span class="main">-</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span>drop <span class="main">(</span>Suc <span class="free">x</span><span class="main">)</span> <span class="free">l</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> take_add<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span>   <span class="keyword1"><span class="command">have</span></span> 
    <span class="quoted"><span class="quoted">"concat <span class="main">(</span>take <span class="main">(</span>Suc <span class="free">x</span><span class="main">)</span> <span class="free">l</span><span class="main">)</span> <span class="main">=</span> 
      concat <span class="main">(</span>take <span class="main">(</span>Suc <span class="free">x</span><span class="main">)</span> <span class="free">l</span><span class="main">)</span> <span class="main">@</span> concat <span class="main">(</span>take <span class="main">(</span><span class="free">n</span> <span class="main">-</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span>drop <span class="main">(</span>Suc <span class="free">x</span><span class="main">)</span> <span class="free">l</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> A <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">hence</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">l</span><span class="main">∈</span>set <span class="main">(</span>take <span class="main">(</span><span class="free">n</span> <span class="main">-</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span>drop <span class="main">(</span>Suc <span class="free">x</span><span class="main">)</span> <span class="free">l</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> <span class="bound">l</span><span class="main">=</span><span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">safe</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span><span class="main">&lt;</span><span class="skolem">i</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span><span class="main">≤</span><span class="free">n</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">l</span><span class="main">!</span><span class="skolem">i</span> <span class="main">∈</span> set <span class="main">(</span>take <span class="main">(</span><span class="free">n</span> <span class="main">-</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span>drop <span class="main">(</span>Suc <span class="free">x</span><span class="main">)</span> <span class="free">l</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> L<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword">del</span></span><span class="main">]</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> take_set<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">-</span> Suc <span class="free">x</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">with</span></span> 1 <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">l</span><span class="main">!</span><span class="skolem">i</span><span class="main">=</span><span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> take_Suc0<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="free">l</span><span class="main">≠</span><span class="main">[]</span> <span class="main">⟹</span> take <span class="main">(</span>Suc <span class="main">0</span><span class="main">)</span> <span class="free">l</span> <span class="main">=</span> <span class="main">[</span><span class="free">l</span><span class="main">!</span><span class="main">0</span><span class="main">]</span>"</span></span> 
  <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">&lt;</span> length <span class="free">l</span> <span class="main">⟹</span> take <span class="main">(</span>Suc <span class="main">0</span><span class="main">)</span> <span class="free">l</span> <span class="main">=</span> <span class="main">[</span><span class="free">l</span><span class="main">!</span><span class="main">0</span><span class="main">]</span>"</span></span> 
  <span class="quoted"><span class="quoted">"Suc <span class="free">n</span> <span class="main">≤</span> length <span class="free">l</span> <span class="main">⟹</span> take <span class="main">(</span>Suc <span class="main">0</span><span class="main">)</span> <span class="free">l</span> <span class="main">=</span> <span class="main">[</span><span class="free">l</span><span class="main">!</span><span class="main">0</span><span class="main">]</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">l</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>


<span class="keyword1"><span class="command">lemma</span></span> concat_take_Suc_app_nth<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">&lt;</span> length <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"concat <span class="main">(</span>take <span class="main">(</span>Suc <span class="free">x</span><span class="main">)</span> <span class="free">l</span><span class="main">)</span> <span class="main">=</span> concat <span class="main">(</span>take <span class="free">x</span> <span class="free">l</span><span class="main">)</span> <span class="main">@</span> <span class="free">l</span> <span class="main">!</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> take_Suc_conv_app_nth<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> hm_hashcode_eq<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">j</span> <span class="main">&lt;</span> length <span class="main">(</span><span class="free">l</span><span class="main">!</span><span class="free">i</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">&lt;</span> length <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">⊨</span> is_hashtable <span class="free">l</span> <span class="free">ht</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"bounded_hashcode_nat <span class="main">(</span>length <span class="free">l</span><span class="main">)</span> <span class="main">(</span>fst <span class="main">(</span><span class="free">l</span><span class="main">!</span><span class="free">i</span><span class="main">!</span><span class="free">j</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">i</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">unfolding</span></span> is_hashtable_def ht_hash_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">l</span><span class="main">!</span><span class="free">i</span><span class="main">!</span><span class="free">j</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> set_conv_nth<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> distinct_imp_distinct_take<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst <span class="main">(</span>concat <span class="free">l</span><span class="main">)</span><span class="main">)</span>
  <span class="main">⟹</span> distinct <span class="main">(</span>map fst <span class="main">(</span>concat <span class="main">(</span>take <span class="free">x</span> <span class="free">l</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> append_take_drop_id<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">l</span></span><span class="main"><span class="main">,</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> append_take_drop_id<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> hm_it_adjust_rule<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">i</span><span class="main">&lt;</span>length <span class="free">l</span> <span class="main">⟹</span> <span class="main">&lt;</span>is_hashtable <span class="free">l</span> <span class="free">ht</span><span class="main">&gt;</span> 
    hm_it_adjust <span class="free">i</span> <span class="free">ht</span> 
   <span class="main">&lt;</span><span class="main">λ</span><span class="bound">j</span><span class="main">.</span> is_hashtable <span class="free">l</span> <span class="free">ht</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span>
      <span class="bound">j</span><span class="main">≤</span><span class="free">i</span> <span class="main">∧</span> 
      <span class="main">(</span>concat <span class="main">(</span>take <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span> <span class="free">l</span><span class="main">)</span> <span class="main">=</span> concat <span class="main">(</span>take <span class="main">(</span>Suc <span class="bound">j</span><span class="main">)</span> <span class="free">l</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
      <span class="main">(</span><span class="bound">j</span><span class="main">=</span><span class="main">0</span> <span class="main">∨</span> <span class="free">l</span><span class="main">!</span><span class="bound">j</span> <span class="main">≠</span> <span class="main">[]</span><span class="main">)</span>
    <span class="main">)</span>    
   <span class="main">&gt;</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">i</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 0 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">sep_auto</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> Suc.prems
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> 
      <span class="quasi_keyword">heap</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Suc.hyps
      <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> concat_take_Suc_empty
      <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> list.split<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>  

<span class="keyword1"><span class="command">lemma</span></span> hm_it_next_rule'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">l'</span><span class="main">≠</span><span class="main">[]</span> <span class="main">⟹</span> 
    <span class="main">&lt;</span>hm_is_it' <span class="free">l</span> <span class="free">ht</span> <span class="free">l'</span> <span class="free">it</span><span class="main">&gt;</span> 
      hm_it_next <span class="free">it</span> 
    <span class="main">&lt;</span><span class="main">λ</span><span class="main">(</span><span class="main">(</span><span class="bound">k</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">,</span><span class="bound">it'</span><span class="main">)</span><span class="main">.</span> 
      hm_is_it' <span class="free">l</span> <span class="free">ht</span> <span class="main">(</span>butlast <span class="free">l'</span><span class="main">)</span> <span class="bound">it'</span> 
    <span class="main">*</span> <span class="main">↑</span><span class="main">(</span>last <span class="free">l'</span> <span class="main">=</span> <span class="main">(</span><span class="bound">k</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">∧</span> distinct <span class="main">(</span>map fst <span class="free">l'</span><span class="main">)</span> <span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> hm_it_next_def hm_is_it'_def is_hashmap'_def
  <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">hypsubst_thin</span> <span class="main"><span class="main">=</span></span> <span class="quasi_keyword">true</span><span class="main">]</span><span class="main">]</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">plain</span><span class="main"><span class="main">)</span></span>
    <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> nat.split list.split 
    <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> hm_it_adjust_rule
    <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> take_Suc0<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split nat.split list.split<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> allI impI conjI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sep_auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">plain</span><span class="main"><span class="main">)</span></span>
    <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> hm_it_adjust_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sep_auto</span>

  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">l</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> SUP_upper fst_image_mp image_mono set_concat<span class="main">)</span>

  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> skip_empty_aux<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> concat_take_Suc_app_nth<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sep_auto</span>

  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> butlast_append<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> butlast_append<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sep_auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> butlast_append<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> butlast_append<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Ex_list_of_length Suc_leD concat_take_Suc_app_nth le_neq_implies_less le_trans nat.inject not_less_eq_eq<span class="main">)</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Main Lemmas›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> hm_it_next_rule<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">m'</span><span class="main">≠</span>Map.empty <span class="main">⟹</span> 
    <span class="main">&lt;</span>hm_is_it <span class="free">m</span> <span class="free">ht</span> <span class="free">m'</span> <span class="free">it</span><span class="main">&gt;</span> 
      hm_it_next <span class="free">it</span> 
    <span class="main">&lt;</span><span class="main">λ</span><span class="main">(</span><span class="main">(</span><span class="bound">k</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">,</span><span class="bound">it'</span><span class="main">)</span><span class="main">.</span> hm_is_it <span class="free">m</span> <span class="free">ht</span> <span class="main">(</span><span class="free">m'</span> <span class="main">|`</span> <span class="main">(</span><span class="main">-</span><span class="main">{</span><span class="bound">k</span><span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="bound">it'</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="free">m'</span> <span class="bound">k</span> <span class="main">=</span> Some <span class="bound">v</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">ys</span> <span class="skolem">a</span>
    <span class="keyword1"><span class="command">have</span></span> aux3<span class="main">:</span> <span class="quoted"><span class="quoted">" 
      <span class="main">⟦</span>distinct <span class="main">(</span>map fst <span class="skolem">ys</span><span class="main">)</span><span class="main">;</span> <span class="skolem">a</span> <span class="main">∉</span> fst <span class="main">`</span> set <span class="skolem">ys</span><span class="main">⟧</span> <span class="main">⟹</span> map_of <span class="skolem">ys</span> <span class="skolem">a</span> <span class="main">=</span> None"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">ys</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> aux3 <span class="main">=</span> this

  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">m'</span><span class="main">≠</span>Map.empty"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> hm_is_it_def 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> hm_it_next_rule'<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">l'</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_cases<span class="main"><span class="keyword3">,</span></span> 
      <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> restrict_map_def aux3 <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ext<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">l'</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_cases<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> hm_it_init_rule<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">ht</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span><span class="main">::</span><span class="main">{</span>heap<span class="main">,</span>hashable<span class="main">}</span><span class="main">,</span><span class="tfree">'v</span><span class="main">::</span>heap<span class="main">)</span> hashtable"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span>is_hashmap <span class="free">m</span> <span class="free">ht</span><span class="main">&gt;</span> hm_it_init <span class="free">ht</span> <span class="main">&lt;</span>hm_is_it <span class="free">m</span> <span class="free">ht</span> <span class="free">m</span><span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> hm_it_init_def is_hashmap_def is_hashmap'_def 
    hm_is_it_def hm_is_it'_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> map_of_append <span class="quasi_keyword">heap</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hm_it_adjust_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">l</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> concat_eq_Nil_conv map_of_append<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> distinct_imp_distinct_take 
    <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> ent_fwd<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ is_hashmap'_distinct<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> sym<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
    <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> is_hashtable_def ht_distinct_def rev_map<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> set_conv_nth<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">hypsubst_thin</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> j<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">ia</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> hm_hashcode_eq<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> j<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">ib</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> hm_hashcode_eq<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
    <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> is_hashmap'_def is_hashtable_def ht_distinct_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> ent_fwd<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ is_hashmap'_distinct<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> concat_take_Suc_app_nth<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">l</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">hypsubst_thin</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> concat_take_Suc_app_nth<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">l</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> map_of_rev_distinct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> hm_it_has_next_rule<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span>hm_is_it <span class="free">m</span> <span class="free">ht</span> <span class="free">m'</span> <span class="free">it</span><span class="main">&gt;</span> hm_it_has_next <span class="free">it</span> 
    <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> hm_is_it <span class="free">m</span> <span class="free">ht</span> <span class="free">m'</span> <span class="free">it</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="bound">r</span><span class="main">⟷</span><span class="free">m'</span><span class="main">≠</span>Map.empty<span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> is_hashmap'_def hm_is_it_def hm_is_it'_def hm_it_has_next_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> nat.split list.split<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> hm_it_finish<span class="main">:</span> <span class="quoted"><span class="quoted">"hm_is_it <span class="free">m</span> <span class="free">p</span> <span class="free">m'</span> <span class="free">it</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> is_hashmap <span class="free">m</span> <span class="free">p</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> hm_is_it_def hm_is_it'_def is_hashmap_def is_hashmap'_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">sep_auto</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Hash_Map_Impl">
<div class="head">
<h1>Theory Hash_Map_Impl</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">"Hash-Maps (Interface Instantiations)"</span></span>
<span class="keyword1"><span class="command">theory</span></span> Hash_Map_Impl
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Imp_Map_Spec.html">Imp_Map_Spec</a> <a href="Hash_Map.html">Hash_Map</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> hm_map_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"imp_map is_hashmap"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> is_hashmap_prec<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">interpretation</span></span> hm<span class="main">:</span> imp_map <span class="quoted">is_hashmap</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> hm_map_impl<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> hm_empty_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"imp_map_empty is_hashmap hm_new"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> hm_new_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">interpretation</span></span> hm<span class="main">:</span> imp_map_empty <span class="quoted">is_hashmap</span> <span class="quoted">hm_new</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> hm_empty_impl<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> hm_lookup_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"imp_map_lookup is_hashmap hm_lookup"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> hm_lookup_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">interpretation</span></span> hm<span class="main">:</span> imp_map_lookup <span class="quoted">is_hashmap</span> <span class="quoted">hm_lookup</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> hm_lookup_impl<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> hm_update_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"imp_map_update is_hashmap hm_update"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> hm_update_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">interpretation</span></span> hm<span class="main">:</span> imp_map_update <span class="quoted">is_hashmap</span> <span class="quoted">hm_update</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> hm_update_impl<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> hm_delete_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"imp_map_delete is_hashmap hm_delete"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> hm_delete_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">interpretation</span></span> hm<span class="main">:</span> imp_map_delete <span class="quoted">is_hashmap</span> <span class="quoted">hm_delete</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> hm_delete_impl<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> hm_is_empty_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"imp_map_is_empty is_hashmap hm_isEmpty"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> hm_isEmpty_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">interpretation</span></span> hm<span class="main">:</span> imp_map_is_empty <span class="quoted">is_hashmap</span> <span class="quoted">hm_isEmpty</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> hm_is_empty_impl<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> hm_size_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"imp_map_size is_hashmap hm_size"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> hm_size_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">interpretation</span></span> hm<span class="main">:</span> imp_map_size <span class="quoted">is_hashmap</span> <span class="quoted">hm_size</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> hm_size_impl<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> hm_iterate_impl<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"imp_map_iterate is_hashmap hm_is_it hm_it_init hm_it_has_next hm_it_next"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> hm_it_init_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> hm_it_next_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> hm_it_has_next_rule<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ent_frame_fwd<span class="main"><span class="main">[</span></span><span class="operator">OF</span> hm_it_finish<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frame_inference</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">solve_entails</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">interpretation</span></span> hm<span class="main">:</span> 
  imp_map_iterate <span class="quoted">is_hashmap</span> <span class="quoted">hm_is_it</span> <span class="quoted">hm_it_init</span> <span class="quoted">hm_it_has_next</span> <span class="quoted">hm_it_next</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> hm_iterate_impl<span class="main">)</span>

<span class="comment1">(*
definition "hm_is_it'' m ht l' it ≡ 
  ∃<span class="hidden">⇩</span><sub>A</sub>l. hm_is_it' l ht l' it * ↑(map_of (concat l) = m)"

lemma hm_iterate'_impl: 
  "imp_map_iterate' is_hashmap hm_is_it'' hm_it_init hm_it_has_next hm_it_next"
  apply unfold_locales
  apply (rule hm_it_init_rule)
  apply (erule hm_it_next_rule)
  apply (rule hm_it_has_next_rule)
  apply (rule ent_frame_fwd[OF hm_it_finish])
  apply (frame_inference)
  apply solve_entails
  done

*)</span>

<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">hm_new</span></span> <span class="quoted"><span class="quoted">hm_lookup</span></span> <span class="quoted"><span class="quoted">hm_update</span></span> <span class="quoted"><span class="quoted">hm_delete</span></span> <span class="quoted"><span class="quoted">hm_isEmpty</span></span> <span class="quoted"><span class="quoted">hm_size</span></span> 
  <span class="quoted"><span class="quoted">hm_it_init</span></span> <span class="quoted"><span class="quoted">hm_it_has_next</span></span> <span class="quoted"><span class="quoted">hm_it_next</span></span>
  <span class="keyword2"><span class="keyword">checking</span></span> SML_imp

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Imp_Set_Spec">
<div class="head">
<h1>Theory Imp_Set_Spec</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Interface for Sets›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Imp_Set_Spec
<span class="keyword2"><span class="keyword">imports</span></span> <span class="quoted">"<a href="Sep_Main.html">../Sep_Main</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  This file specifies an abstract interface for set data structures. It can
  be implemented by concrete set data structures, as demonstrated in the 
  hash set example.
›</span></span>

<span class="keyword1"><span class="command">locale</span></span> imp_set <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">is_set</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> assn"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> precise<span class="main">:</span> <span class="quoted"><span class="quoted">"precise <span class="free">is_set</span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> imp_set_empty <span class="main">=</span> imp_set <span class="main">+</span>
  <span class="keyword2"><span class="keyword">constrains</span></span> is_set <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> assn"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">empty</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s</span> Heap"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> empty_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="keyword1">emp</span><span class="main">&gt;</span> <span class="free">empty</span> <span class="main">&lt;</span><span class="free">is_set</span> <span class="main">{}</span><span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> imp_set_is_empty <span class="main">=</span> imp_set <span class="main">+</span>
  <span class="keyword2"><span class="keyword">constrains</span></span> is_set <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> assn"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">is_empty</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s</span> <span class="main">⇒</span> bool Heap"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> is_empty_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">is_set</span> <span class="free">s</span> <span class="free">p</span><span class="main">&gt;</span> <span class="free">is_empty</span> <span class="free">p</span> <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="free">is_set</span> <span class="free">s</span> <span class="free">p</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="bound">r</span> <span class="main">⟷</span> <span class="free">s</span><span class="main">=</span><span class="main">{}</span><span class="main">)</span><span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> imp_set_memb <span class="main">=</span> imp_set <span class="main">+</span>
  <span class="keyword2"><span class="keyword">constrains</span></span> is_set <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> assn"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">memb</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> bool Heap"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> memb_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">is_set</span> <span class="free">s</span> <span class="free">p</span><span class="main">&gt;</span> <span class="free">memb</span> <span class="free">a</span> <span class="free">p</span> <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="free">is_set</span> <span class="free">s</span> <span class="free">p</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="bound">r</span> <span class="main">⟷</span> <span class="free">a</span> <span class="main">∈</span> <span class="free">s</span><span class="main">)</span><span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> imp_set_ins <span class="main">=</span> imp_set <span class="main">+</span>
  <span class="keyword2"><span class="keyword">constrains</span></span> is_set <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> assn"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">ins</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'s</span> Heap"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> ins_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">is_set</span> <span class="free">s</span> <span class="free">p</span><span class="main">&gt;</span> <span class="free">ins</span> <span class="free">a</span> <span class="free">p</span> <span class="main">&lt;</span><span class="free">is_set</span> <span class="main">(</span>Set.insert <span class="free">a</span> <span class="free">s</span><span class="main">)</span><span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>
    
<span class="keyword1"><span class="command">locale</span></span> imp_set_delete <span class="main">=</span> imp_set <span class="main">+</span>
  <span class="keyword2"><span class="keyword">constrains</span></span> is_set <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> assn"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">delete</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'s</span> Heap"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> delete_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">is_set</span> <span class="free">s</span> <span class="free">p</span><span class="main">&gt;</span> <span class="free">delete</span> <span class="free">a</span> <span class="free">p</span> <span class="main">&lt;</span><span class="free">is_set</span> <span class="main">(</span><span class="free">s</span> <span class="main">-</span> <span class="main">{</span><span class="free">a</span><span class="main">}</span><span class="main">)</span><span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> imp_set_size <span class="main">=</span> imp_set <span class="main">+</span>
  <span class="keyword2"><span class="keyword">constrains</span></span> is_set <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> assn"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">size</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s</span> <span class="main">⇒</span> nat Heap"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> size_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">is_set</span> <span class="free">s</span> <span class="free">p</span><span class="main">&gt;</span> <span class="free">size</span> <span class="free">p</span> <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="free">is_set</span> <span class="free">s</span> <span class="free">p</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="bound">r</span> <span class="main">=</span> card <span class="free">s</span><span class="main">)</span><span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> imp_set_iterate <span class="main">=</span> imp_set <span class="main">+</span>
  <span class="keyword2"><span class="keyword">constrains</span></span> is_set <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> assn"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">is_it</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'it</span> <span class="main">⇒</span> assn"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">it_init</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'it</span><span class="main">)</span> Heap"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">it_has_next</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'it</span> <span class="main">⇒</span> bool Heap"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">it_next</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'it</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">×</span><span class="tfree">'it</span><span class="main">)</span> Heap"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> it_init_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">is_set</span> <span class="free">s</span> <span class="free">p</span><span class="main">&gt;</span> <span class="free">it_init</span> <span class="free">p</span> <span class="main">&lt;</span><span class="free">is_it</span> <span class="free">s</span> <span class="free">p</span> <span class="free">s</span><span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> it_next_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s'</span><span class="main">≠</span><span class="main">{}</span> <span class="main">⟹</span> 
    <span class="main">&lt;</span><span class="free">is_it</span> <span class="free">s</span> <span class="free">p</span> <span class="free">s'</span> <span class="free">it</span><span class="main">&gt;</span> 
      <span class="free">it_next</span> <span class="free">it</span> 
    <span class="main">&lt;</span><span class="main">λ</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">it'</span><span class="main">)</span><span class="main">.</span> <span class="free">is_it</span> <span class="free">s</span> <span class="free">p</span> <span class="main">(</span><span class="free">s'</span> <span class="main">-</span> <span class="main">{</span><span class="bound">a</span><span class="main">}</span><span class="main">)</span> <span class="bound">it'</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="bound">a</span> <span class="main">∈</span> <span class="free">s'</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> it_has_next_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">is_it</span> <span class="free">s</span> <span class="free">p</span> <span class="free">s'</span> <span class="free">it</span><span class="main">&gt;</span> <span class="free">it_has_next</span> <span class="free">it</span> <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="free">is_it</span> <span class="free">s</span> <span class="free">p</span> <span class="free">s'</span> <span class="free">it</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="bound">r</span><span class="main">⟷</span><span class="free">s'</span><span class="main">≠</span><span class="main">{}</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> quit_iteration<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free">is_it</span> <span class="free">s</span> <span class="free">p</span> <span class="free">s'</span> <span class="free">it</span> <span class="keyword1">⟹<span class="hidden">⇩</span><sub>A</sub></span> <span class="free">is_set</span> <span class="free">s</span> <span class="free">p</span> <span class="main">*</span> <span class="keyword1">true</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Hash_Set_Impl">
<div class="head">
<h1>Theory Hash_Set_Impl</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">"Hash-Sets"</span></span>
<span class="keyword1"><span class="command">theory</span></span> Hash_Set_Impl
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Imp_Set_Spec.html">Imp_Set_Spec</a> <a href="Hash_Map_Impl.html">Hash_Map_Impl</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Auxiliary Definitions›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">map_of_set</span><span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">⇀</span>unit"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">map_of_set</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≡</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="keyword1">then</span> Some <span class="main">()</span> <span class="keyword1">else</span> None"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ne_some_unit_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span><span class="main">≠</span>Some <span class="main">()</span> <span class="main">⟷</span> <span class="free">x</span><span class="main">=</span>None"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> map_of_set_simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"dom <span class="main">(</span>map_of_set <span class="free">s</span><span class="main">)</span> <span class="main">=</span> <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"map_of_set <span class="main">(</span>dom <span class="free">m</span><span class="main">)</span> <span class="main">=</span> <span class="free">m</span>"</span></span>
  <span class="quoted"><span class="quoted">"map_of_set <span class="main">{}</span> <span class="main">=</span> Map.empty"</span></span>
  <span class="quoted"><span class="quoted">"map_of_set <span class="free">s</span> <span class="free">x</span> <span class="main">=</span> None <span class="main">⟷</span> <span class="free">x</span><span class="main">∉</span><span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"map_of_set <span class="free">s</span> <span class="free">x</span> <span class="main">=</span> Some <span class="free">u</span> <span class="main">⟷</span> <span class="free">x</span><span class="main">∈</span><span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"map_of_set <span class="free">s</span> <span class="main">(</span><span class="free">x</span><span class="main">↦</span><span class="main">()</span><span class="main">)</span> <span class="main">=</span> map_of_set <span class="main">(</span>insert <span class="free">x</span> <span class="free">s</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>map_of_set <span class="free">s</span><span class="main">)</span> <span class="main">|`</span> <span class="main">(</span><span class="main">-</span><span class="main">{</span><span class="free">x</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> map_of_set <span class="main">(</span><span class="free">s</span> <span class="main">-</span><span class="main">{</span><span class="free">x</span><span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> map_of_set_def 
    dom_def ne_some_unit_eq restrict_map_def 
    <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ext<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> map_of_set_eq'<span class="main">:</span>
  <span class="quoted"><span class="quoted">"map_of_set <span class="free">a</span> <span class="main">=</span> map_of_set <span class="free">b</span> <span class="main">⟷</span> <span class="free">a</span><span class="main">=</span><span class="free">b</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> map_of_set_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> option.simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> map_of_set_eq<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"map_of_set <span class="free">s</span> <span class="main">=</span> <span class="free">m</span> <span class="main">⟷</span> dom <span class="free">m</span><span class="main">=</span><span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
    <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> dom_def map_of_set_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span> ne_some_unit_eq 
    <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ext<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> option.simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Main Definitions›</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'a</span> hashset <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span>unit<span class="main">)</span> hashtable"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">is_hashset</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">ht</span></span></span> <span class="main">≡</span> is_hashmap <span class="main">(</span>map_of_set <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">ht</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> hs_set_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"imp_set is_hashset"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command">unfolding</span></span> is_hashset_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> map_of_set_eq'<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> preciseD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> is_hashmap_prec<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">interpretation</span></span> hs<span class="main">:</span> imp_set <span class="quoted">is_hashset</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> hs_set_impl<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">hs_new</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span><span class="main">{</span>heap<span class="main">,</span>hashable<span class="main">}</span> hashset Heap"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">hs_new</span> <span class="main">=</span> hm_new"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> hs_new_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"imp_set_empty is_hashset hs_new"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> hm_new_rule <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> is_hashset_def hs_new_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">interpretation</span></span> hs<span class="main">:</span> imp_set_empty <span class="quoted">is_hashset</span> <span class="quoted">hs_new</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> hs_new_impl<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">hs_memb</span><span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span><span class="main">{</span>heap<span class="main">,</span>hashable<span class="main">}</span> <span class="main">⇒</span> <span class="tfree">'a</span> hashset <span class="main">⇒</span> bool Heap"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">hs_memb</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span> 
  <span class="bound">r</span><span class="main">←</span>hm_lookup <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">;</span> 
  return <span class="main">(</span><span class="keyword1">case</span> <span class="bound">r</span> <span class="keyword1">of</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> True <span class="main">|</span> None <span class="main">⇒</span> False<span class="main">)</span>  
<span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> hs_memb_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"imp_set_memb is_hashset hs_memb"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command">unfolding</span></span> hs_memb_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> 
    <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> hm_lookup_rule 
    <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> is_hashset_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">interpretation</span></span> hs<span class="main">:</span> imp_set_memb <span class="quoted">is_hashset</span> <span class="quoted">hs_memb</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> hs_memb_impl<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">hs_ins</span><span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span><span class="main">{</span>heap<span class="main">,</span>hashable<span class="main">}</span> <span class="main">⇒</span> <span class="tfree">'a</span> hashset <span class="main">⇒</span> <span class="tfree">'a</span> hashset Heap"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">hs_ins</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">ht</span></span></span> <span class="main">≡</span> hm_update <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">()</span> <span class="free"><span class="bound"><span class="entity">ht</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> hs_ins_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"imp_set_ins is_hashset hs_ins"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> hm_update_rule <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hs_ins_def is_hashset_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">interpretation</span></span> hs<span class="main">:</span> imp_set_ins <span class="quoted">is_hashset</span> <span class="quoted">hs_ins</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> hs_ins_impl<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">hs_delete</span>
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span><span class="main">{</span>heap<span class="main">,</span>hashable<span class="main">}</span> <span class="main">⇒</span> <span class="tfree">'a</span> hashset <span class="main">⇒</span> <span class="tfree">'a</span> hashset Heap"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">hs_delete</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">ht</span></span></span> <span class="main">≡</span> hm_delete <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">ht</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> hs_delete_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"imp_set_delete is_hashset hs_delete"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> hm_delete_rule <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> is_hashset_def hs_delete_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">interpretation</span></span> hs<span class="main">:</span> imp_set_delete <span class="quoted">is_hashset</span> <span class="quoted">hs_delete</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> hs_delete_impl<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hs_isEmpty</span> <span class="main">==</span> hm_isEmpty"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> hs_is_empty_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"imp_set_is_empty is_hashset hs_isEmpty"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> hm_isEmpty_rule <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> is_hashset_def hs_isEmpty_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">interpretation</span></span> hs<span class="main">:</span> imp_set_is_empty <span class="quoted">is_hashset</span> <span class="quoted">hs_isEmpty</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> hs_is_empty_impl<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hs_size</span> <span class="main">==</span> hm_size"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> hs_size_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"imp_set_size is_hashset hs_size"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> hm_size_rule <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> is_hashset_def hs_size_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">interpretation</span></span> hs<span class="main">:</span> imp_set_size <span class="quoted">is_hashset</span> <span class="quoted">hs_size</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> hs_size_impl<span class="main">)</span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> hs_it <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span>unit<span class="main">)</span> hm_it"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hs_is_it</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">hs</span></span></span> <span class="free"><span class="bound"><span class="entity">its</span></span></span> <span class="free"><span class="bound"><span class="entity">it</span></span></span> 
  <span class="main">≡</span> hm_is_it <span class="main">(</span>map_of_set <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">hs</span></span></span> <span class="main">(</span>map_of_set <span class="free"><span class="bound"><span class="entity">its</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">it</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">hs_it_init</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span><span class="main">{</span>heap<span class="main">,</span>hashable<span class="main">}</span><span class="main">)</span> hashset <span class="main">⇒</span> <span class="tfree">'a</span> hs_it Heap"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">hs_it_init</span> <span class="main">≡</span> hm_it_init"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">hs_it_has_next</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span><span class="main">{</span>heap<span class="main">,</span>hashable<span class="main">}</span><span class="main">)</span> hs_it <span class="main">⇒</span> bool Heap"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">hs_it_has_next</span> <span class="main">≡</span> hm_it_has_next"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">hs_it_next</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span><span class="main">{</span>heap<span class="main">,</span>hashable<span class="main">}</span><span class="main">)</span> hs_it <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">×</span><span class="tfree">'a</span> hs_it<span class="main">)</span> Heap"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">hs_it_next</span> <span class="free"><span class="bound"><span class="entity">it</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">,</span><span class="bound">it</span><span class="main">)</span> <span class="main">←</span> hm_it_next <span class="free"><span class="bound"><span class="entity">it</span></span></span><span class="main">;</span>
    return <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">it</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> hs_iterate_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"imp_set_iterate 
  is_hashset hs_is_it hs_it_init hs_it_has_next hs_it_next"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command">unfolding</span></span> hs_it_init_def hs_it_next_def hs_it_has_next_def 
    hs_is_it_def is_hashset_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sep_auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sep_auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sep_auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">eintros</span><span class="main"><span class="main">:</span></span> hm.quit_iteration<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">interpretation</span></span> hs<span class="main">:</span> imp_set_iterate 
  <span class="quoted">is_hashset</span> <span class="quoted">hs_is_it</span> <span class="quoted">hs_it_init</span> <span class="quoted">hs_it_has_next</span> <span class="quoted">hs_it_next</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> hs_iterate_impl<span class="main">)</span>

<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">hs_new</span></span> <span class="quoted"><span class="quoted">hs_memb</span></span> <span class="quoted"><span class="quoted">hs_ins</span></span> <span class="quoted"><span class="quoted">hs_delete</span></span> <span class="quoted"><span class="quoted">hs_isEmpty</span></span> <span class="quoted"><span class="quoted">hs_size</span></span> 
  <span class="quoted"><span class="quoted">hs_it_init</span></span> <span class="quoted"><span class="quoted">hs_it_has_next</span></span> <span class="quoted"><span class="quoted">hs_it_next</span></span>
  <span class="keyword2"><span class="keyword">checking</span></span> SML_imp

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="To_List_GA">
<div class="head">
<h1>Theory To_List_GA</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Generic Algorithm to Convert Sets to Lists›</span></span>
<span class="keyword1"><span class="command">theory</span></span> To_List_GA
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Imp_Set_Spec.html">Imp_Set_Spec</a> <a href="Imp_List_Spec.html">Imp_List_Spec</a> <a href="Hash_Set_Impl.html">Hash_Set_Impl</a> <a href="Open_List.html">Open_List</a>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This theory demonstrates how to develop a generic to-list 
    algorithm, and gives a sample instantiation for hash sets and open lists.
›</span></span>

  <span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Algorithm›</span></span>
  <span class="keyword1"><span class="command">partial_function</span></span> <span class="main">(</span>heap<span class="main">)</span> <span class="entity">to_list_ga_rec</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="free">to_list_ga_rec</span> 
      <span class="free"><span class="bound"><span class="entity">it_has_next</span></span></span> <span class="free"><span class="bound"><span class="entity">it_next</span></span></span> 
      <span class="free"><span class="bound"><span class="entity">l_prepend</span></span></span>
      <span class="free"><span class="bound"><span class="entity">it</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> 
    <span class="main">=</span>
    <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">b</span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">it_has_next</span></span></span> <span class="free"><span class="bound"><span class="entity">it</span></span></span><span class="main">;</span>
      <span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">it</span><span class="main">)</span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">it_next</span></span></span> <span class="free"><span class="bound"><span class="entity">it</span></span></span><span class="main">;</span>
        <span class="bound">l</span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">l_prepend</span></span></span> <span class="bound">x</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">;</span>
        <span class="free">to_list_ga_rec</span> <span class="free"><span class="bound"><span class="entity">it_has_next</span></span></span> <span class="free"><span class="bound"><span class="entity">it_next</span></span></span> 
          <span class="free"><span class="bound"><span class="entity">l_prepend</span></span></span> <span class="bound">it</span> <span class="bound">l</span>
      <span class="main">}</span> <span class="keyword1">else</span>
        return <span class="free"><span class="bound"><span class="entity">l</span></span></span>
    <span class="main">}</span>
    "</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> to_list_ga_rec_rule<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"imp_set_iterate <span class="free">is_set</span> <span class="free">is_it</span> <span class="free">it_init</span> <span class="free">it_has_next</span> <span class="free">it_next</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"imp_list_prepend <span class="free">is_list</span> <span class="free">l_prepend</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> FIN<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">it</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"
    <span class="main">&lt;</span> <span class="free">is_it</span> <span class="free">s</span> <span class="free">si</span> <span class="free">it</span> <span class="free">iti</span> <span class="main">*</span> <span class="free">is_list</span> <span class="free">l</span> <span class="free">li</span> <span class="main">&gt;</span> 
      to_list_ga_rec <span class="free">it_has_next</span> <span class="free">it_next</span> <span class="free">l_prepend</span> <span class="free">iti</span> <span class="free">li</span>
    <span class="main">&lt;</span> <span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">l'</span><span class="main">.</span> <span class="free">is_set</span> <span class="free">s</span> <span class="free">si</span> 
      <span class="main">*</span> <span class="free">is_list</span> <span class="bound">l'</span> <span class="bound">r</span>
      <span class="main">*</span> <span class="main">↑</span><span class="main">(</span>set <span class="bound">l'</span> <span class="main">=</span> set <span class="free">l</span> <span class="main">∪</span> <span class="free">it</span><span class="main">)</span> <span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">interpret</span></span> imp_set_iterate <span class="quoted"><span class="free">is_set</span></span> <span class="quoted"><span class="free">is_it</span></span> <span class="quoted"><span class="free">it_init</span></span> <span class="quoted"><span class="free">it_has_next</span></span> <span class="quoted"><span class="free">it_next</span></span>
      <span class="main">+</span> imp_list_prepend <span class="quoted"><span class="free">is_list</span></span> <span class="quoted"><span class="free">l_prepend</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span><span class="main"><span class="keyword3">+</span></span>

    <span class="keyword1"><span class="command">from</span></span> FIN <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">l</span></span> <span class="quoted"><span class="free">li</span></span> <span class="quoted"><span class="free">iti</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> finite_psubset_induct<span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>psubset <span class="skolem">it</span><span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> to_list_ga_rec.simps<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> psubset.IH<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ent_frame_fwd<span class="main"><span class="main">[</span></span><span class="operator">OF</span> quit_iteration<span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">frame_inference</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">solve_entails</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">to_list_ga</span> 
    <span class="free"><span class="bound"><span class="entity">it_init</span></span></span> <span class="free"><span class="bound"><span class="entity">it_has_next</span></span></span> <span class="free"><span class="bound"><span class="entity">it_next</span></span></span>
    <span class="free"><span class="bound"><span class="entity">l_empty</span></span></span> <span class="free"><span class="bound"><span class="entity">l_prepend</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> 
    <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">it</span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">it_init</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">;</span>
      <span class="bound">l</span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">l_empty</span></span></span><span class="main">;</span>
      <span class="bound">l</span> <span class="main">←</span> to_list_ga_rec <span class="free"><span class="bound"><span class="entity">it_has_next</span></span></span> <span class="free"><span class="bound"><span class="entity">it_next</span></span></span> <span class="free"><span class="bound"><span class="entity">l_prepend</span></span></span> <span class="bound">it</span> <span class="bound">l</span><span class="main">;</span>
      return <span class="bound">l</span>
    <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> to_list_ga_rule<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> IT<span class="main">:</span> <span class="quoted"><span class="quoted">"imp_set_iterate <span class="free">is_set</span> <span class="free">is_it</span> <span class="free">it_init</span> <span class="free">it_has_next</span> <span class="free">it_next</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> EM<span class="main">:</span> <span class="quoted"><span class="quoted">"imp_list_empty <span class="free">is_list</span> <span class="free">l_empty</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> PREP<span class="main">:</span> <span class="quoted"><span class="quoted">"imp_list_prepend <span class="free">is_list</span> <span class="free">l_prepend</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> FIN<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">s</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"
    <span class="main">&lt;</span><span class="free">is_set</span> <span class="free">s</span> <span class="free">si</span><span class="main">&gt;</span>
    to_list_ga <span class="free">it_init</span> <span class="free">it_has_next</span> <span class="free">it_next</span>
      <span class="free">l_empty</span> <span class="free">l_prepend</span> <span class="free">si</span>
    <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">l</span><span class="main">.</span> <span class="free">is_set</span> <span class="free">s</span> <span class="free">si</span> <span class="main">*</span> <span class="free">is_list</span> <span class="bound">l</span> <span class="bound">r</span> <span class="main">*</span> <span class="keyword1">true</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span>set <span class="bound">l</span> <span class="main">=</span> <span class="free">s</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">interpret</span></span> imp_list_empty <span class="quoted"><span class="free">is_list</span></span> <span class="quoted"><span class="free">l_empty</span></span> <span class="main">+</span>
      imp_set_iterate <span class="quoted"><span class="free">is_set</span></span> <span class="quoted"><span class="free">is_it</span></span> <span class="quoted"><span class="free">it_init</span></span> <span class="quoted"><span class="free">it_has_next</span></span> <span class="quoted"><span class="free">it_next</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span><span class="main"><span class="keyword3">+</span></span>

    <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span> <span class="main">=</span> to_list_ga_rec_rule<span class="main">[</span><span class="operator">OF</span> IT PREP<span class="main">]</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> to_list_ga_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> FIN<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Sample Instantiation for hash set and open list›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hs_to_ol</span> 
    <span class="main">≡</span> to_list_ga hs_it_init hs_it_has_next hs_it_next
        os_empty os_prepend"</span></span>
  
  <span class="keyword1"><span class="command">lemmas</span></span> hs_to_ol_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span> <span class="main">=</span>
    to_list_ga_rule<span class="main">[</span><span class="operator">OF</span> hs_iterate_impl os_empty_impl os_prepend_impl<span class="main">,</span>
    <span class="operator">folded</span> hs_to_ol_def<span class="main">]</span> 


  <span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">hs_to_ol</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML_imp

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Union_Find">
<div class="head">
<h1>Theory Union_Find</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Union-Find Data-Structure›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Union_Find
<span class="keyword2"><span class="keyword">imports</span></span> 
  <span class="quoted">"<a href="Sep_Main.html">../Sep_Main</a>"</span> 
  <a href="../Collections/Partial_Equivalence_Relation.html">Collections.Partial_Equivalence_Relation</a>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Code_Target_Numeral.html">HOL-Library.Code_Target_Numeral</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We implement a simple union-find data-structure based on an array.
  It uses path compression and a size-based union heuristics.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Abstract Union-Find on Lists›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We first formulate union-find structures on lists, and later implement 
  them using Imperative/HOL. This is a separation of proof concerns
  between proving the algorithmic idea correct and generating the verification
  conditions.
›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Representatives›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We define a function that searches for the representative of an element.
  This function is only partially defined, as it does not terminate on all
  lists. We use the domain of this function to characterize valid union-find 
  lists. 
›</span></span>
<span class="keyword1"><span class="command">function</span></span> <span class="main">(</span>domintros<span class="main">)</span> <span class="entity">rep_of</span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">rep_of</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">!</span><span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="keyword1">else</span> <span class="free">rep_of</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">!</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">pat_completeness</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A valid union-find structure only contains valid indexes, and
  the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>rep_of›</span></span></span></span> function terminates for all indexes.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">ufa_invar</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">≡</span> <span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span>length <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">.</span> rep_of_dom <span class="main">(</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">,</span><span class="bound">i</span><span class="main">)</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">!</span><span class="bound">i</span><span class="main">&lt;</span>length <span class="free"><span class="bound"><span class="entity">l</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ufa_invarD<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>ufa_invar <span class="free">l</span><span class="main">;</span> <span class="free">i</span><span class="main">&lt;</span>length <span class="free">l</span><span class="main">⟧</span> <span class="main">⟹</span> rep_of_dom <span class="main">(</span><span class="free">l</span><span class="main">,</span><span class="free">i</span><span class="main">)</span>"</span></span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>ufa_invar <span class="free">l</span><span class="main">;</span> <span class="free">i</span><span class="main">&lt;</span>length <span class="free">l</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">l</span><span class="main">!</span><span class="free">i</span><span class="main">&lt;</span>length <span class="free">l</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> ufa_invar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We derive the following equations for the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>rep-of›</span></span></span></span> function.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> rep_of_refl<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">l</span><span class="main">!</span><span class="free">i</span><span class="main">=</span><span class="free">i</span> <span class="main">⟹</span> rep_of <span class="free">l</span> <span class="free">i</span> <span class="main">=</span> <span class="free">i</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> rep_of.psimps<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> rep_of.domintros<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> rep_of_step<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>ufa_invar <span class="free">l</span><span class="main">;</span> <span class="free">i</span><span class="main">&lt;</span>length <span class="free">l</span><span class="main">;</span> <span class="free">l</span><span class="main">!</span><span class="free">i</span><span class="main">≠</span><span class="free">i</span><span class="main">⟧</span> <span class="main">⟹</span> rep_of <span class="free">l</span> <span class="free">i</span> <span class="main">=</span> rep_of <span class="free">l</span> <span class="main">(</span><span class="free">l</span><span class="main">!</span><span class="free">i</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> rep_of.psimps<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> ufa_invarD<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemmas</span></span> rep_of_simps <span class="main">=</span> rep_of_refl rep_of_step

<span class="keyword1"><span class="command">lemma</span></span> rep_of_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>ufa_invar <span class="free">l</span><span class="main">;</span> <span class="free">i</span><span class="main">&lt;</span>length <span class="free">l</span><span class="main">⟧</span> 
  <span class="main">⟹</span> rep_of <span class="free">l</span> <span class="free">i</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">l</span><span class="main">!</span><span class="free">i</span><span class="main">=</span><span class="free">i</span> <span class="keyword1">then</span> <span class="free">i</span> <span class="keyword1">else</span> rep_of <span class="free">l</span> <span class="main">(</span><span class="free">l</span><span class="main">!</span><span class="free">i</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rep_of_simps<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We derive a custom induction rule, that is more suited to
  our purposes.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> rep_of_induct<span class="main">[</span><span class="operator">case_names</span> base step<span class="main">,</span> <span class="operator">consumes</span> 2<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> I<span class="main">:</span> <span class="quoted"><span class="quoted">"ufa_invar <span class="free">l</span>"</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> L<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">i</span><span class="main">&lt;</span>length <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> BASE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">i</span><span class="main">.</span> <span class="main">⟦</span> ufa_invar <span class="free">l</span><span class="main">;</span> <span class="bound">i</span><span class="main">&lt;</span>length <span class="free">l</span><span class="main">;</span> <span class="free">l</span><span class="main">!</span><span class="bound">i</span><span class="main">=</span><span class="bound">i</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="free">l</span> <span class="bound">i</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> STEP<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">i</span><span class="main">.</span> <span class="main">⟦</span> ufa_invar <span class="free">l</span><span class="main">;</span> <span class="bound">i</span><span class="main">&lt;</span>length <span class="free">l</span><span class="main">;</span> <span class="free">l</span><span class="main">!</span><span class="bound">i</span><span class="main">≠</span><span class="bound">i</span><span class="main">;</span> <span class="free">P</span> <span class="free">l</span> <span class="main">(</span><span class="free">l</span><span class="main">!</span><span class="bound">i</span><span class="main">)</span> <span class="main">⟧</span> 
    <span class="main">⟹</span> <span class="free">P</span> <span class="free">l</span> <span class="bound">i</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">l</span> <span class="free">i</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> ufa_invarD<span class="main">[</span><span class="operator">OF</span> I L<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ufa_invar <span class="free">l</span> <span class="main">∧</span> <span class="free">i</span><span class="main">&lt;</span>length <span class="free">l</span> <span class="main">⟶</span> <span class="free">P</span> <span class="free">l</span> <span class="free">i</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="skolem">l</span><span class="main"><span class="main">≡</span></span><span class="quoted"><span class="free">l</span></span> <span class="quoted"><span class="free">i</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rep_of.pinduct<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> STEP BASE <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> ufa_invarD<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> I L <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In the following, we define various properties of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>rep_of›</span></span></span></span>.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> rep_of_min<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> ufa_invar <span class="free">l</span><span class="main">;</span> <span class="free">i</span><span class="main">&lt;</span>length <span class="free">l</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">l</span><span class="main">!</span><span class="main">(</span>rep_of <span class="free">l</span> <span class="free">i</span><span class="main">)</span> <span class="main">=</span> rep_of <span class="free">l</span> <span class="free">i</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>rep_of_dom <span class="main">(</span><span class="free">l</span><span class="main">,</span><span class="free">i</span><span class="main">)</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">l</span><span class="main">!</span><span class="main">(</span>rep_of <span class="free">l</span> <span class="free">i</span><span class="main">)</span> <span class="main">=</span> rep_of <span class="free">l</span> <span class="free">i</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span>  <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rep_of.pinduct<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> rep_of.psimps<span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> rep_of.psimps<span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span> 
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> ufa_invar <span class="free">l</span><span class="main">;</span> <span class="free">i</span><span class="main">&lt;</span>length <span class="free">l</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">l</span><span class="main">!</span><span class="main">(</span>rep_of <span class="free">l</span> <span class="free">i</span><span class="main">)</span> <span class="main">=</span> rep_of <span class="free">l</span> <span class="free">i</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> ufa_invarD<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> rep_of_bound<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> ufa_invar <span class="free">l</span><span class="main">;</span> <span class="free">i</span><span class="main">&lt;</span>length <span class="free">l</span> <span class="main">⟧</span> <span class="main">⟹</span> rep_of <span class="free">l</span> <span class="free">i</span> <span class="main">&lt;</span> length <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rep_of_induct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rep_of_iff<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> rep_of_idem<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> ufa_invar <span class="free">l</span><span class="main">;</span> <span class="free">i</span><span class="main">&lt;</span>length <span class="free">l</span> <span class="main">⟧</span> <span class="main">⟹</span> rep_of <span class="free">l</span> <span class="main">(</span>rep_of <span class="free">l</span> <span class="free">i</span><span class="main">)</span> <span class="main">=</span> rep_of <span class="free">l</span> <span class="free">i</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rep_of_min rep_of_refl<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> rep_of_min_upd<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> ufa_invar <span class="free">l</span><span class="main">;</span> <span class="free">x</span><span class="main">&lt;</span>length <span class="free">l</span><span class="main">;</span> <span class="free">i</span><span class="main">&lt;</span>length <span class="free">l</span> <span class="main">⟧</span> <span class="main">⟹</span> 
  rep_of <span class="main">(</span><span class="free">l</span><span class="main">[</span>rep_of <span class="free">l</span> <span class="free">x</span> <span class="main">:=</span> rep_of <span class="free">l</span> <span class="free">x</span><span class="main">]</span><span class="main">)</span> <span class="free">i</span> <span class="main">=</span> rep_of <span class="free">l</span> <span class="free">i</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> list_update_id rep_of_min<span class="main">)</span>   

<span class="keyword1"><span class="command">lemma</span></span> rep_of_idx<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>ufa_invar <span class="free">l</span><span class="main">;</span> <span class="free">i</span><span class="main">&lt;</span>length <span class="free">l</span><span class="main">⟧</span> <span class="main">⟹</span> rep_of <span class="free">l</span> <span class="main">(</span><span class="free">l</span><span class="main">!</span><span class="free">i</span><span class="main">)</span> <span class="main">=</span> rep_of <span class="free">l</span> <span class="free">i</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> rep_of_step<span class="main">)</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Abstraction to Partial Equivalence Relation›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ufa_α</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat list <span class="main">⇒</span> <span class="main">(</span>nat<span class="main">×</span>nat<span class="main">)</span> set"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ufa_α</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> 
    <span class="main">≡</span> <span class="main">{</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span><span class="main">&lt;</span>length <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">∧</span> <span class="bound">y</span><span class="main">&lt;</span>length <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">∧</span> rep_of <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="bound">x</span> <span class="main">=</span> rep_of <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="bound">y</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ufa_α_equiv<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"part_equiv <span class="main">(</span>ufa_α <span class="free">l</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command">unfolding</span></span> ufa_α_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> symI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> transI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> ufa_α_lenD<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">)</span><span class="main">∈</span>ufa_α <span class="free">l</span> <span class="main">⟹</span> <span class="free">x</span><span class="main">&lt;</span>length <span class="free">l</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">)</span><span class="main">∈</span>ufa_α <span class="free">l</span> <span class="main">⟹</span> <span class="free">y</span><span class="main">&lt;</span>length <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ufa_α_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> ufa_α_dom<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Domain <span class="main">(</span>ufa_α <span class="free">l</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span>length <span class="free">l</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ufa_α_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> ufa_α_refl<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">i</span><span class="main">,</span><span class="free">i</span><span class="main">)</span><span class="main">∈</span>ufa_α <span class="free">l</span> <span class="main">⟷</span> <span class="free">i</span><span class="main">&lt;</span>length <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ufa_α_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> ufa_α_len_eq<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ufa_α <span class="free">l</span> <span class="main">=</span> ufa_α <span class="free">l'</span>"</span></span>  
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"length <span class="free">l</span> <span class="main">=</span> length <span class="free">l'</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> assms le_antisym less_not_refl linorder_le_less_linear ufa_α_refl<span class="main">)</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Operations›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> ufa_init_invar<span class="main">:</span> <span class="quoted"><span class="quoted">"ufa_invar <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">]</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ufa_invar_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rep_of.domintros<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ufa_init_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"ufa_α <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">]</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">x</span><span class="main">)</span> <span class="main">|</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">&lt;</span><span class="free">n</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ufa_α_def
  <span class="keyword1"><span class="command">using</span></span> ufa_init_invar<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">n</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rep_of_refl<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> ufa_find_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>ufa_invar <span class="free">l</span><span class="main">;</span> <span class="free">x</span><span class="main">&lt;</span>length <span class="free">l</span><span class="main">;</span> <span class="free">y</span><span class="main">&lt;</span>length <span class="free">l</span><span class="main">⟧</span> 
  <span class="main">⟹</span> rep_of <span class="free">l</span> <span class="free">x</span> <span class="main">=</span> rep_of <span class="free">l</span> <span class="free">y</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">)</span><span class="main">∈</span>ufa_α <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ufa_α_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">ufa_union</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">[</span>rep_of <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:=</span> rep_of <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">]</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ufa_union_invar<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> I<span class="main">:</span> <span class="quoted"><span class="quoted">"ufa_invar <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> L<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span><span class="main">&lt;</span>length <span class="free">l</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span><span class="main">&lt;</span>length <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ufa_invar <span class="main">(</span>ufa_union <span class="free">l</span> <span class="free">x</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ufa_invar_def
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> allI impI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> length_list_update<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span>
  <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span><span class="main">&lt;</span>length <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">with</span></span> I <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"rep_of_dom <span class="main">(</span><span class="free">l</span><span class="main">,</span><span class="skolem">i</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> ufa_invarD<span class="main">)</span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ufa_union <span class="free">l</span> <span class="free">x</span> <span class="free">y</span> <span class="main">!</span> <span class="skolem">i</span> <span class="main">&lt;</span> length <span class="free">l</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> I L A
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span><span class="main">=</span>rep_of <span class="free">l</span> <span class="free">x</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rep_of_bound <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> ufa_invarD<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"rep_of_dom <span class="main">(</span>ufa_union <span class="free">l</span> <span class="free">x</span> <span class="free">y</span><span class="main">,</span> <span class="skolem">i</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> I A L
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rep_of_induct<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>base <span class="skolem">i</span><span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> rep_of.domintros<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span><span class="main">=</span>rep_of <span class="free">l</span> <span class="free">x</span>"</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> rep_of.domintros<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rep_of_min<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">i</span><span class="main">)</span>

    <span class="keyword1"><span class="command">from</span></span> step.prems <span class="quoted"><span class="quoted">‹ufa_invar <span class="free">l</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">i</span><span class="main">&lt;</span>length <span class="free">l</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">l</span><span class="main">!</span><span class="skolem">i</span><span class="main">≠</span><span class="skolem">i</span>›</span></span> 
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ufa_union <span class="free">l</span> <span class="free">x</span> <span class="free">y</span> <span class="main">!</span> <span class="skolem">i</span> <span class="main">=</span> <span class="free">l</span><span class="main">!</span><span class="skolem">i</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rep_of_min rep_of_bound nth_list_update<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

    <span class="keyword1"><span class="command">from</span></span> step <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> rep_of.domintros<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> 
    <span class="quoted"><span class="quoted">"rep_of_dom <span class="main">(</span>ufa_union <span class="free">l</span> <span class="free">x</span> <span class="free">y</span><span class="main">,</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">∧</span> ufa_union <span class="free">l</span> <span class="free">x</span> <span class="free">y</span> <span class="main">!</span> <span class="skolem">i</span> <span class="main">&lt;</span> length <span class="free">l</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ufa_union_aux<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> I<span class="main">:</span> <span class="quoted"><span class="quoted">"ufa_invar <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> L<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span><span class="main">&lt;</span>length <span class="free">l</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span><span class="main">&lt;</span>length <span class="free">l</span>"</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> IL<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">i</span><span class="main">&lt;</span>length <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"rep_of <span class="main">(</span>ufa_union <span class="free">l</span> <span class="free">x</span> <span class="free">y</span><span class="main">)</span> <span class="free">i</span> <span class="main">=</span> 
    <span class="main">(</span><span class="keyword1">if</span> rep_of <span class="free">l</span> <span class="free">i</span> <span class="main">=</span> rep_of <span class="free">l</span> <span class="free">x</span> <span class="keyword1">then</span> rep_of <span class="free">l</span> <span class="free">y</span> <span class="keyword1">else</span> rep_of <span class="free">l</span> <span class="free">i</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> I IL
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rep_of_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>base <span class="skolem">i</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"rep_of <span class="free">l</span> <span class="skolem">i</span> <span class="main">=</span> <span class="skolem">i</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="free">l</span><span class="main">!</span><span class="skolem">i</span><span class="main">=</span><span class="skolem">i</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rep_of_refl<span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> <span class="quoted"><span class="quoted">‹ufa_invar <span class="free">l</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">i</span><span class="main">&lt;</span>length <span class="free">l</span>›</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span><span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> A<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"rep_of <span class="free">l</span> <span class="free">x</span> <span class="main">=</span> <span class="skolem">i</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">l</span><span class="main">[</span><span class="skolem">i</span> <span class="main">:=</span> rep_of <span class="free">l</span> <span class="free">y</span><span class="main">]</span> <span class="main">!</span> <span class="skolem">i</span> <span class="main">=</span> rep_of <span class="free">l</span> <span class="free">y</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rep_of_bound<span class="main">)</span>

    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span><span class="main">)</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"rep_of <span class="free">l</span> <span class="free">y</span> <span class="main">=</span> <span class="skolem">i</span>"</span></span> 
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rep_of_refl<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"rep_of <span class="free">l</span> <span class="free">y</span> <span class="main">≠</span> <span class="skolem">i</span>"</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"rep_of <span class="main">(</span><span class="free">l</span><span class="main">[</span><span class="skolem">i</span> <span class="main">:=</span> rep_of <span class="free">l</span> <span class="free">y</span><span class="main">]</span><span class="main">)</span> <span class="skolem">i</span> <span class="main">=</span> rep_of <span class="free">l</span> <span class="free">y</span>"</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> rep_of_step<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ufa_union_invar<span class="main"><span class="main">[</span></span><span class="operator">OF</span> I L<span class="main"><span class="main">]</span></span><span class="main"><span class="main">,</span></span> <span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">using</span></span> A <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> rep_of_refl<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> i<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"rep_of <span class="free">l</span> <span class="free">y</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">using</span></span> I L
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rep_of_min<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rep_of_refl<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"rep_of <span class="free">l</span> <span class="free">x</span> <span class="main">≠</span> <span class="skolem">i</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"ufa_union <span class="free">l</span> <span class="free">x</span> <span class="free">y</span> <span class="main">!</span> <span class="skolem">i</span> <span class="main">=</span> <span class="free">l</span><span class="main">!</span><span class="skolem">i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="free">l</span><span class="main">!</span><span class="skolem">i</span><span class="main">=</span><span class="skolem">i</span>›</span></span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"rep_of <span class="main">(</span>ufa_union <span class="free">l</span> <span class="free">x</span> <span class="free">y</span><span class="main">)</span> <span class="skolem">i</span> <span class="main">=</span> <span class="skolem">i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rep_of_refl<span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> A <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>    
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">i</span><span class="main">)</span>

  <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> I L <span class="quoted"><span class="quoted">‹<span class="skolem">i</span><span class="main">&lt;</span>length <span class="free">l</span>›</span></span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"rep_of <span class="free">l</span> <span class="free">x</span> <span class="main">≠</span> <span class="skolem">i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> I L<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> rep_of_min <span class="quoted"><span class="quoted">‹<span class="free">l</span><span class="main">!</span><span class="skolem">i</span><span class="main">≠</span><span class="skolem">i</span>›</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ufa_union <span class="free">l</span> <span class="free">x</span> <span class="free">y</span> <span class="main">!</span> <span class="skolem">i</span> <span class="main">=</span> <span class="free">l</span><span class="main">!</span><span class="skolem">i</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nth_list_update rep_of_bound <span class="quoted"><span class="quoted">‹<span class="free">l</span><span class="main">!</span><span class="skolem">i</span><span class="main">≠</span><span class="skolem">i</span>›</span></span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"rep_of <span class="main">(</span>ufa_union <span class="free">l</span> <span class="free">x</span> <span class="free">y</span><span class="main">)</span> <span class="skolem">i</span> <span class="main">=</span> rep_of <span class="main">(</span>ufa_union <span class="free">l</span> <span class="free">x</span> <span class="free">y</span><span class="main">)</span> <span class="main">(</span><span class="free">l</span><span class="main">!</span><span class="skolem">i</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rep_of_iff<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ufa_union_invar<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">OF</span> I L<span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> step.hyps<span class="main">(</span>4<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rep_of_idx<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>
  
<span class="keyword1"><span class="command">lemma</span></span> ufa_union_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> ufa_invar <span class="free">l</span><span class="main">;</span> <span class="free">x</span><span class="main">&lt;</span>length <span class="free">l</span><span class="main">;</span> <span class="free">y</span><span class="main">&lt;</span>length <span class="free">l</span> <span class="main">⟧</span> 
  <span class="main">⟹</span> ufa_α <span class="main">(</span>ufa_union <span class="free">l</span> <span class="free">x</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> per_union <span class="main">(</span>ufa_α <span class="free">l</span><span class="main">)</span> <span class="free">x</span> <span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ufa_α_def per_union_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ufa_union_aux
    <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm
  <span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ufa_compress_aux<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> I<span class="main">:</span> <span class="quoted"><span class="quoted">"ufa_invar <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> L<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span><span class="main">&lt;</span>length <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ufa_invar <span class="main">(</span><span class="free">l</span><span class="main">[</span><span class="free">x</span> <span class="main">:=</span> rep_of <span class="free">l</span> <span class="free">x</span><span class="main">]</span><span class="main">)</span>"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span>length <span class="free">l</span><span class="main">.</span> rep_of <span class="main">(</span><span class="free">l</span><span class="main">[</span><span class="free">x</span> <span class="main">:=</span> rep_of <span class="free">l</span> <span class="free">x</span><span class="main">]</span><span class="main">)</span> <span class="bound">i</span> <span class="main">=</span> rep_of <span class="free">l</span> <span class="bound">i</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span><span class="main">&lt;</span>length <span class="main">(</span><span class="free">l</span><span class="main">[</span><span class="free">x</span> <span class="main">:=</span> rep_of <span class="free">l</span> <span class="free">x</span><span class="main">]</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> IL<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span><span class="main">&lt;</span>length <span class="free">l</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">have</span></span> G1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">l</span><span class="main">[</span><span class="free">x</span> <span class="main">:=</span> rep_of <span class="free">l</span> <span class="free">x</span><span class="main">]</span> <span class="main">!</span> <span class="skolem">i</span> <span class="main">&lt;</span> length <span class="main">(</span><span class="free">l</span><span class="main">[</span><span class="free">x</span> <span class="main">:=</span> rep_of <span class="free">l</span> <span class="free">x</span><span class="main">]</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> I IL 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> ufa_invarD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> I<span class="main"><span class="main">]</span></span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> nth_list_update rep_of_bound<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> I IL <span class="keyword1"><span class="command">have</span></span> G2<span class="main">:</span> <span class="quoted"><span class="quoted">"rep_of <span class="main">(</span><span class="free">l</span><span class="main">[</span><span class="free">x</span> <span class="main">:=</span> rep_of <span class="free">l</span> <span class="free">x</span><span class="main">]</span><span class="main">)</span> <span class="skolem">i</span> <span class="main">=</span> rep_of <span class="free">l</span> <span class="skolem">i</span> 
      <span class="main">∧</span> rep_of_dom <span class="main">(</span><span class="free">l</span><span class="main">[</span><span class="free">x</span> <span class="main">:=</span> rep_of <span class="free">l</span> <span class="free">x</span><span class="main">]</span><span class="main">,</span> <span class="skolem">i</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rep_of_induct<span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>base <span class="skolem">i</span><span class="main">)</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">x</span><span class="main">=</span><span class="skolem">i</span>"</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rep_of.domintros <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rep_of_refl<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">i</span><span class="main">)</span> 
      <span class="keyword1"><span class="command">hence</span></span> D<span class="main">:</span> <span class="quoted"><span class="quoted">"rep_of_dom <span class="main">(</span><span class="free">l</span><span class="main">[</span><span class="free">x</span> <span class="main">:=</span> rep_of <span class="free">l</span> <span class="free">x</span><span class="main">]</span><span class="main">,</span> <span class="skolem">i</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> rep_of.domintros<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">x</span><span class="main">=</span><span class="skolem">i</span>"</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rep_of.domintros <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rep_of_min<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span> <span class="keyword1"><span class="command">using</span></span> step
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> rep_of.psimps<span class="main"><span class="main">[</span></span><span class="operator">OF</span> D<span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">x</span><span class="main">=</span><span class="skolem">i</span>"</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rep_of_min rep_of_idx<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> rep_of.psimps<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> i<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"rep_of <span class="free">l</span> <span class="skolem">i</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rep_of.domintros <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rep_of_min<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">note</span></span> G1 G2
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> G<span class="main">=</span>this

  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span>length <span class="free">l</span><span class="main">.</span> rep_of <span class="main">(</span><span class="free">l</span><span class="main">[</span><span class="free">x</span> <span class="main">:=</span> rep_of <span class="free">l</span> <span class="free">x</span><span class="main">]</span><span class="main">)</span> <span class="bound">i</span> <span class="main">=</span> rep_of <span class="free">l</span> <span class="bound">i</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">from</span></span> G <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"ufa_invar <span class="main">(</span><span class="free">l</span><span class="main">[</span><span class="free">x</span> <span class="main">:=</span> rep_of <span class="free">l</span> <span class="free">x</span><span class="main">]</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ufa_invar_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ufa_compress_invar<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> I<span class="main">:</span> <span class="quoted"><span class="quoted">"ufa_invar <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> L<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span><span class="main">&lt;</span>length <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ufa_invar <span class="main">(</span><span class="free">l</span><span class="main">[</span><span class="free">x</span> <span class="main">:=</span> rep_of <span class="free">l</span> <span class="free">x</span><span class="main">]</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> ufa_compress_aux<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ufa_compress_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> I<span class="main">:</span> <span class="quoted"><span class="quoted">"ufa_invar <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> L<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span><span class="main">&lt;</span>length <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ufa_α <span class="main">(</span><span class="free">l</span><span class="main">[</span><span class="free">x</span> <span class="main">:=</span> rep_of <span class="free">l</span> <span class="free">x</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> ufa_α <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ufa_α_def ufa_compress_aux<span class="main"><span class="main">[</span></span><span class="operator">OF</span> I<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Implementation with Imperative/HOL›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In this section, we implement the union-find data-structure with
  two arrays, one holding the next-pointers, and another one holding the size
  information. Note that we do not prove that the array for the 
  size information contains any reasonable values, as the correctness of the
  algorithm is not affected by this. We leave it future work to also estimate
  the complexity of the algorithm.
›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> uf <span class="main">=</span> <span class="quoted"><span class="quoted">"nat array <span class="main">×</span> nat array"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">is_uf</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat<span class="main">×</span>nat<span class="main">)</span> set <span class="main">⇒</span> uf <span class="main">⇒</span> assn"</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">is_uf</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≡</span> <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span><span class="bound">p</span><span class="main">)</span> <span class="main">⇒</span> 
  <span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">l</span> <span class="bound">szl</span><span class="main">.</span> <span class="bound">p</span><span class="keyword1">↦<span class="hidden">⇩</span><sub>a</sub></span><span class="bound">l</span> <span class="main">*</span> <span class="bound">s</span><span class="keyword1">↦<span class="hidden">⇩</span><sub>a</sub></span><span class="bound">szl</span> 
    <span class="main">*</span> <span class="main">↑</span><span class="main">(</span>ufa_invar <span class="bound">l</span> <span class="main">∧</span> ufa_α <span class="bound">l</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">∧</span> length <span class="bound">szl</span> <span class="main">=</span> length <span class="bound">l</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uf_init</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> uf Heap"</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">uf_init</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">l</span> <span class="main">←</span> Array.of_list <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span><span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">]</span><span class="main">;</span>
    <span class="bound">szl</span> <span class="main">←</span> Array.new <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">(</span><span class="main">1</span><span class="main">::</span>nat<span class="main">)</span><span class="main">;</span>
    return <span class="main">(</span><span class="bound">szl</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> uf_init_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="keyword1">emp</span><span class="main">&gt;</span> uf_init <span class="free">n</span> <span class="main">&lt;</span>is_uf <span class="main">{</span><span class="main">(</span><span class="bound">i</span><span class="main">,</span><span class="bound">i</span><span class="main">)</span> <span class="main">|</span><span class="bound">i</span><span class="main">.</span> <span class="bound">i</span><span class="main">&lt;</span><span class="free">n</span><span class="main">}</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> uf_init_def is_uf_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ufa_init_correct ufa_init_invar<span class="main">)</span>

<span class="keyword1"><span class="command">partial_function</span></span> <span class="main">(</span>heap<span class="main">)</span> <span class="entity">uf_rep_of</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat array <span class="main">⇒</span> nat <span class="main">⇒</span> nat Heap"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="free">uf_rep_of</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">n</span> <span class="main">←</span> Array.nth <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">;</span>
    <span class="keyword1">if</span> <span class="bound">n</span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="keyword1">then</span> return <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="keyword1">else</span> <span class="free">uf_rep_of</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="bound">n</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> uf_rep_of_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>ufa_invar <span class="free">l</span><span class="main">;</span> <span class="free">i</span><span class="main">&lt;</span>length <span class="free">l</span><span class="main">⟧</span> <span class="main">⟹</span>
  <span class="main">&lt;</span><span class="free">p</span><span class="keyword1">↦<span class="hidden">⇩</span><sub>a</sub></span><span class="free">l</span><span class="main">&gt;</span> uf_rep_of <span class="free">p</span> <span class="free">i</span> <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="free">p</span><span class="keyword1">↦<span class="hidden">⇩</span><sub>a</sub></span><span class="free">l</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="bound">r</span><span class="main">=</span>rep_of <span class="free">l</span> <span class="free">i</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rep_of_induct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> uf_rep_of.simps<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rep_of_refl<span class="main">)</span>

  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> uf_rep_of.simps<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rep_of_step<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We chose a non tail-recursive version here, as it is easier to prove.›</span></span>
<span class="keyword1"><span class="command">partial_function</span></span> <span class="main">(</span>heap<span class="main">)</span> <span class="entity">uf_compress</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat <span class="main">⇒</span> nat array <span class="main">⇒</span> unit Heap"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="free">uf_compress</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">ci</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span>
    <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">ci</span></span></span> <span class="keyword1">then</span> return <span class="main">()</span>
    <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">ni</span><span class="main">←</span>Array.nth <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">;</span>
      <span class="free">uf_compress</span> <span class="bound">ni</span> <span class="free"><span class="bound"><span class="entity">ci</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">;</span>
      Array.upd <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">ci</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">;</span>
      return <span class="main">()</span>
    <span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> uf_compress_rule<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> ufa_invar <span class="free">l</span><span class="main">;</span> <span class="free">i</span><span class="main">&lt;</span>length <span class="free">l</span><span class="main">;</span> <span class="free">ci</span><span class="main">=</span>rep_of <span class="free">l</span> <span class="free">i</span> <span class="main">⟧</span> <span class="main">⟹</span>
  <span class="main">&lt;</span><span class="free">p</span><span class="keyword1">↦<span class="hidden">⇩</span><sub>a</sub></span><span class="free">l</span><span class="main">&gt;</span> uf_compress <span class="free">i</span> <span class="free">ci</span> <span class="free">p</span> 
  <span class="main">&lt;</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">l'</span><span class="main">.</span> <span class="free">p</span><span class="keyword1">↦<span class="hidden">⇩</span><sub>a</sub></span><span class="bound">l'</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span>ufa_invar <span class="bound">l'</span> <span class="main">∧</span> length <span class="bound">l'</span> <span class="main">=</span> length <span class="free">l</span> 
     <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span>length <span class="free">l</span><span class="main">.</span> rep_of <span class="bound">l'</span> <span class="bound">i</span> <span class="main">=</span> rep_of <span class="free">l</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rep_of_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>base <span class="skolem">i</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> uf_compress.simps<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rep_of_refl<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">i</span><span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> SS <span class="main">=</span> <span class="quoted"><span class="quoted">‹ufa_invar <span class="free">l</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">i</span><span class="main">&lt;</span>length <span class="free">l</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">l</span><span class="main">!</span><span class="skolem">i</span><span class="main">≠</span><span class="skolem">i</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">ci</span> <span class="main">=</span> rep_of <span class="free">l</span> <span class="skolem">i</span>›</span></span>

  <span class="keyword1"><span class="command">from</span></span> step.IH 
  <span class="keyword1"><span class="command">have</span></span> IH'<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="free">p</span> <span class="keyword1">↦<span class="hidden">⇩</span><sub>a</sub></span> <span class="free">l</span><span class="main">&gt;</span> 
       uf_compress <span class="main">(</span><span class="free">l</span> <span class="main">!</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">(</span>rep_of <span class="free">l</span> <span class="skolem">i</span><span class="main">)</span> <span class="free">p</span>
     <span class="main">&lt;</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">l'</span><span class="main">.</span> <span class="free">p</span> <span class="keyword1">↦<span class="hidden">⇩</span><sub>a</sub></span> <span class="bound">l'</span> <span class="main">*</span> 
        <span class="main">↑</span> <span class="main">(</span>ufa_invar <span class="bound">l'</span> <span class="main">∧</span> length <span class="free">l</span> <span class="main">=</span> length <span class="bound">l'</span> 
           <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span>length <span class="bound">l'</span><span class="main">.</span> rep_of <span class="free">l</span> <span class="bound">i</span> <span class="main">=</span> rep_of <span class="bound">l'</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span>
     <span class="main">&gt;</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rep_of_idx SS<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> 
      back_subst<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ cong<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">OF</span> cong<span class="main"><span class="main"><span class="main"><span class="main">[</span></span></span></span><span class="operator">OF</span> arg_cong<span class="main"><span class="main"><span class="main"><span class="main"><span class="main">[</span></span></span></span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main">=</span></span></span></span></span></span><span class="quoted">hoare_triple</span><span class="main"><span class="main"><span class="main"><span class="main"><span class="main">]</span></span></span></span></span><span class="main"><span class="main"><span class="main"><span class="main">]</span></span></span></span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>2<span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ent_iffI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sep_auto</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> uf_compress.simps<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> SS<span class="main">)</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> IH'<span class="main">)</span>
    
    <span class="keyword1"><span class="command">using</span></span> SS <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">plain</span><span class="main"><span class="main">)</span></span><span class="main">)</span> 
    <span class="keyword1"><span class="command">using</span></span> ufa_compress_invar <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fastforce</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">using</span></span> ufa_compress_aux<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fastforce</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uf_rep_of_c</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat array <span class="main">⇒</span> nat <span class="main">⇒</span> nat Heap"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">uf_rep_of_c</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">ci</span><span class="main">←</span>uf_rep_of <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">;</span>
    uf_compress <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="bound">ci</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">;</span>
    return <span class="bound">ci</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> uf_rep_of_c_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>ufa_invar <span class="free">l</span><span class="main">;</span> <span class="free">i</span><span class="main">&lt;</span>length <span class="free">l</span><span class="main">⟧</span> <span class="main">⟹</span>
  <span class="main">&lt;</span><span class="free">p</span><span class="keyword1">↦<span class="hidden">⇩</span><sub>a</sub></span><span class="free">l</span><span class="main">&gt;</span> uf_rep_of_c <span class="free">p</span> <span class="free">i</span> <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">l'</span><span class="main">.</span> <span class="free">p</span><span class="keyword1">↦<span class="hidden">⇩</span><sub>a</sub></span><span class="bound">l'</span> 
    <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="bound">r</span><span class="main">=</span>rep_of <span class="free">l</span> <span class="free">i</span> <span class="main">∧</span> ufa_invar <span class="bound">l'</span>
       <span class="main">∧</span> length <span class="bound">l'</span> <span class="main">=</span> length <span class="free">l</span> 
       <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span>length <span class="free">l</span><span class="main">.</span> rep_of <span class="bound">l'</span> <span class="bound">i</span> <span class="main">=</span> rep_of <span class="free">l</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> uf_rep_of_c_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> uf_compress_rule<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uf_cmp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uf <span class="main">⇒</span> nat <span class="main">⇒</span> nat <span class="main">⇒</span> bool Heap"</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">uf_cmp</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">let</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span><span class="bound">p</span><span class="main">)</span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">;</span>
    <span class="bound">n</span><span class="main">←</span>Array.len <span class="bound">p</span><span class="main">;</span>
    <span class="keyword1">if</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">≥</span><span class="bound">n</span> <span class="main">∨</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">≥</span><span class="bound">n</span><span class="main">)</span> <span class="keyword1">then</span> return False
    <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">ci</span><span class="main">←</span>uf_rep_of_c <span class="bound">p</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">;</span>
      <span class="bound">cj</span><span class="main">←</span>uf_rep_of_c <span class="bound">p</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">;</span>
      return <span class="main">(</span><span class="bound">ci</span><span class="main">=</span><span class="bound">cj</span><span class="main">)</span>
    <span class="main">}</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> cnv_to_ufa_α_eq<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span>length <span class="free">l</span><span class="main">.</span> rep_of <span class="free">l'</span> <span class="bound">i</span> <span class="main">=</span> rep_of <span class="free">l</span> <span class="bound">i</span><span class="main">)</span><span class="main">;</span> length <span class="free">l</span> <span class="main">=</span> length <span class="free">l'</span><span class="main">⟧</span> 
  <span class="main">⟹</span> <span class="main">(</span>ufa_α <span class="free">l</span> <span class="main">=</span> ufa_α <span class="free">l'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ufa_α_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> uf_cmp_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span>is_uf <span class="free">R</span> <span class="free">u</span><span class="main">&gt;</span> uf_cmp <span class="free">u</span> <span class="free">i</span> <span class="free">j</span> <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> is_uf <span class="free">R</span> <span class="free">u</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="bound">r</span><span class="main">⟷</span><span class="main">(</span><span class="free">i</span><span class="main">,</span><span class="free">j</span><span class="main">)</span><span class="main">∈</span><span class="free">R</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> uf_cmp_def is_uf_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> ufa_α_lenD <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> not_le <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> cnv_to_ufa_α_eq<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> cnv_to_ufa_α_eq<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> cnv_to_ufa_α_eq<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> cnv_to_ufa_α_eq<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> cnv_to_ufa_α_eq<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> cnv_to_ufa_α_eq<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> ufa_find_correct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uf_union</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uf <span class="main">⇒</span> nat <span class="main">⇒</span> nat <span class="main">⇒</span> uf Heap"</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">uf_union</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">let</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span><span class="bound">p</span><span class="main">)</span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">;</span>
    <span class="bound">ci</span> <span class="main">←</span> uf_rep_of <span class="bound">p</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">;</span>
    <span class="bound">cj</span> <span class="main">←</span> uf_rep_of <span class="bound">p</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">;</span>
    <span class="keyword1">if</span> <span class="main">(</span><span class="bound">ci</span><span class="main">=</span><span class="bound">cj</span><span class="main">)</span> <span class="keyword1">then</span> return <span class="main">(</span><span class="bound">s</span><span class="main">,</span><span class="bound">p</span><span class="main">)</span> 
    <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">si</span> <span class="main">←</span> Array.nth <span class="bound">s</span> <span class="bound">ci</span><span class="main">;</span>
      <span class="bound">sj</span> <span class="main">←</span> Array.nth <span class="bound">s</span> <span class="bound">cj</span><span class="main">;</span>
      <span class="keyword1">if</span> <span class="bound">si</span><span class="main">&lt;</span><span class="bound">sj</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
        Array.upd <span class="bound">ci</span> <span class="bound">cj</span> <span class="bound">p</span><span class="main">;</span>
        Array.upd <span class="bound">cj</span> <span class="main">(</span><span class="bound">si</span><span class="main">+</span><span class="bound">sj</span><span class="main">)</span> <span class="bound">s</span><span class="main">;</span>
        return <span class="main">(</span><span class="bound">s</span><span class="main">,</span><span class="bound">p</span><span class="main">)</span>
      <span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span> 
        Array.upd <span class="bound">cj</span> <span class="bound">ci</span> <span class="bound">p</span><span class="main">;</span>
        Array.upd <span class="bound">ci</span> <span class="main">(</span><span class="bound">si</span><span class="main">+</span><span class="bound">sj</span><span class="main">)</span> <span class="bound">s</span><span class="main">;</span>
        return <span class="main">(</span><span class="bound">s</span><span class="main">,</span><span class="bound">p</span><span class="main">)</span>
      <span class="main">}</span>
    <span class="main">}</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> uf_union_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">i</span><span class="main">∈</span>Domain <span class="free">R</span><span class="main">;</span> <span class="free">j</span><span class="main">∈</span> Domain <span class="free">R</span><span class="main">⟧</span> 
  <span class="main">⟹</span> <span class="main">&lt;</span>is_uf <span class="free">R</span> <span class="free">u</span><span class="main">&gt;</span> uf_union <span class="free">u</span> <span class="free">i</span> <span class="free">j</span> <span class="main">&lt;</span>is_uf <span class="main">(</span>per_union <span class="free">R</span> <span class="free">i</span> <span class="free">j</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> uf_union_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">u</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> is_uf_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> 
    <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> per_union_cmp ufa_α_lenD ufa_find_correct
    rep_of_bound
    ufa_union_invar
    ufa_union_correct
  <span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">uf_init</span></span> <span class="quoted"><span class="quoted">uf_cmp</span></span> <span class="quoted"><span class="quoted">uf_union</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML_imp

<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">uf_init</span></span> <span class="quoted"><span class="quoted">uf_cmp</span></span> <span class="quoted"><span class="quoted">uf_union</span></span> <span class="keyword2"><span class="keyword">checking</span></span> Scala_imp

<span class="comment1">(*
ML_val {*
  val u = @{code uf_init} 10 ();

  val u = @{code uf_union} u 1 2 ();
  val u = @{code uf_union} u 3 4 ();
  val u = @{code uf_union} u 5 6 ();
  val u = @{code uf_union} u 7 8 ();

  val u = @{code uf_union} u 1 3 ();
  val u = @{code uf_union} u 5 7 ();

  val u = @{code uf_union} u 1 5 ();

  val b = @{code uf_cmp} u 8 4 ();
  val it = u;
*}*)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Idioms">
<div class="head">
<h1>Theory Idioms</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Common Proof Methods and Idioms›</span></span> 
<span class="keyword1"><span class="command">theory</span></span> Idioms 
<span class="keyword2"><span class="keyword">imports</span></span> <span class="quoted">"<a href="Sep_Main.html">../Sep_Main</a>"</span> <a href="Open_List.html">Open_List</a> <a href="Circ_List.html">Circ_List</a> <a href="Hash_Set_Impl.html">Hash_Set_Impl</a>
<span class="keyword2"><span class="keyword">begin</span></span> 
<span class="keyword1"><span class="command">text_raw</span></span><span class="quoted"><span class="plain_text">‹\label{thy:ex:idioms}›</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
    This theory gives a short documentation of common proof techniques and 
    idioms for the separation logic framework. For this purpose, it presents
    some proof snippets (inspired by the other example theories), and heavily
    comments on them.
›</span></span>

  <span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹The Method <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sep_auto›</span></span></span></span>›</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The most versatile method of our framework is <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sep_auto›</span></span></span></span>,
    which integrates the verification condition generator, the entailment
    solver and some pre- and postprocessing tactics based on the simplifier 
    and classical reasoner. It can be applied to a Hoare-triple or entailment
    subgoal, and will try to solve it, and any emerging new goals. It stops
    when the goal is either solved or it gets stuck somewhere.›</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹As a simple example for <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sep_auto›</span></span></span></span> consider the following
    program that does some operations on two circular lists:›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">test</span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">l1</span> <span class="main">←</span> cs_empty<span class="main">;</span>
    <span class="bound">l2</span> <span class="main">←</span> cs_empty<span class="main">;</span>
    <span class="bound">l1</span> <span class="main">←</span> cs_append <span class="inner_quoted">''a''</span> <span class="bound">l1</span><span class="main">;</span>
    <span class="bound">l2</span> <span class="main">←</span> cs_append <span class="inner_quoted">''c''</span> <span class="bound">l2</span><span class="main">;</span>
    <span class="bound">l1</span> <span class="main">←</span> cs_append <span class="inner_quoted">''b''</span> <span class="bound">l1</span><span class="main">;</span>
    <span class="bound">l2</span> <span class="main">←</span> cs_append <span class="inner_quoted">''e''</span> <span class="bound">l2</span><span class="main">;</span>
    <span class="bound">l2</span> <span class="main">←</span> cs_prepend <span class="inner_quoted">''d''</span> <span class="bound">l2</span><span class="main">;</span>
    <span class="bound">l2</span> <span class="main">←</span> cs_rotate <span class="bound">l2</span><span class="main">;</span>
    return <span class="main">(</span><span class="bound">l1</span><span class="main">,</span><span class="bound">l2</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>
  
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sep_auto›</span></span></span></span> method does all the 
    necessary frame-inference automatically, and thus manages to prove
    the following lemma in one step:›</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="keyword1">emp</span><span class="main">&gt;</span> 
    test 
    <span class="main">&lt;</span><span class="main">λ</span><span class="main">(</span><span class="bound">l1</span><span class="main">,</span><span class="bound">l2</span><span class="main">)</span><span class="main">.</span> cs_list <span class="main">[</span><span class="inner_quoted">''a''</span><span class="main">,</span><span class="inner_quoted">''b''</span><span class="main">]</span> <span class="bound">l1</span> 
      <span class="main">*</span> cs_list <span class="main">[</span><span class="inner_quoted">''c''</span><span class="main">,</span><span class="inner_quoted">''e''</span><span class="main">,</span><span class="inner_quoted">''d''</span><span class="main">]</span> <span class="bound">l2</span><span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> test_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sep_auto›</span></span></span></span> accepts all the section-options of the classical
    reasoner and simplifier, e.g., <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>simp add/del:›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>intro:›</span></span></span></span>.
    Moreover, it has some more section options, the most useful being 
    <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>heap add/del:›</span></span></span></span> to add or remove Hoare-rules that are applied
    with frame-inference. A complete documentation of the accepted options can
    be found in Section~\ref{sec:auto:overview}.
›</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹As a typical example, consider the following proof:›</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> complete_ht_rehash<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">&lt;</span>is_hashtable <span class="free">l</span> <span class="free">ht</span><span class="main">&gt;</span> ht_rehash <span class="free">ht</span> 
    <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> is_hashtable <span class="free">l</span> <span class="free">ht</span> <span class="main">*</span> is_hashtable <span class="main">(</span>ls_rehash <span class="free">l</span><span class="main">)</span> <span class="bound">r</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> LEN<span class="main">:</span> <span class="quoted"><span class="quoted">" <span class="free">l</span> <span class="main">≠</span> <span class="main">[]</span> <span class="main">⟹</span> Suc <span class="main">0</span> <span class="main">&lt;</span> <span class="numeral">2</span> <span class="main">*</span> length <span class="free">l</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">l</span></span><span class="main">)</span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cons_pre_rule<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ht_imp_len<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">unfolding</span></span> ht_rehash_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> 
        <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> complete_ht_new_sz complete_ht_copy
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ls_rehash_def LEN
      <span class="main">)</span> <span class="comment1">― ‹Here we add a heap-rule, and some simp-rules›</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Applying Single Rules›</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\paragraph{Hoare Triples} In this example, we show how to do
    a proof step-by-step.›</span></span>

  <span class="keyword1"><span class="command">lemma</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">&lt;</span>os_list <span class="free">xs</span> <span class="free">n</span><span class="main">&gt;</span> os_prepend <span class="free">x</span> <span class="free">n</span> <span class="main">&lt;</span>os_list <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> os_prepend_def
    <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹The rules to deconstruct compound statements are contained in the
      <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sep_decon_rules›</span></span></span></span> collection›</span></span>
    <span class="keyword1"><span class="command">thm</span></span> <span class="dynamic"><span class="dynamic">sep_decon_rules</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> <span class="dynamic"><span class="dynamic">sep_decon_rules</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹The rules for statement that deend on the heap are
      contained in the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sep_heap_rules›</span></span></span></span> collection. The
      <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>fi_rule›</span></span></span></span>-lemma prepares frame inference for them›</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> <span class="dynamic"><span class="dynamic">sep_heap_rules</span></span><span class="main"><span class="main">[</span></span><span class="operator">THEN</span> fi_rule<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">frame_inference</span> <span class="comment1">― ‹This method does the frame-inference›</span>
    
    <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹The consequence rule comes in three versions, 
      <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>const_rule›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>cons_pre_rule›</span></span></span></span>, 
      and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>cons_post_rule›</span></span></span></span>›</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cons_post_rule<span class="main">)</span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> <span class="dynamic"><span class="dynamic">sep_decon_rules</span></span><span class="main">)</span>

    <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹A simplification unfolds <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>os_list›</span></span></span></span> and extract the
      pure part of the assumption›</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span><span class="main">)</span>

    <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹We can use <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>ent_ex_postI›</span></span></span></span> to manually introduce 
      existentials in entailsments›</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">xa</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> ent_ex_postI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">n</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> ent_ex_postI<span class="main">)</span>
    <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹The simplifier has a setup for assertions, so it will do the rest›</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Note that the proof above can be done with <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sep_auto›</span></span></span></span>,
    the "Swiss army knife" of our framework›</span></span>
  <span class="keyword1"><span class="command">lemma</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">&lt;</span>os_list <span class="free">xs</span> <span class="free">n</span><span class="main">&gt;</span> os_prepend <span class="free">x</span> <span class="free">n</span> <span class="main">&lt;</span>os_list <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> os_prepend_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">sep_auto</span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\paragraph{Entailment} This example presents an actual proof
    from the circular list theory, where we have to manually apply a
    rule and give some hints to frame inference›</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> cs_append_rule<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">&lt;</span>cs_list <span class="free">l</span> <span class="free">p</span><span class="main">&gt;</span> cs_append <span class="free">x</span> <span class="free">p</span> <span class="main">&lt;</span>cs_list <span class="main">(</span><span class="free">l</span><span class="main">@</span><span class="main">[</span><span class="free">x</span><span class="main">]</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cs_append.simps<span class="main">)</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cs_append.simps <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> lseg_append<span class="main">)</span>
    <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹At this point, we are left with an entailment subgoal that sep-auto
      cannot solve. A closer look reveals that we could use the rule
      <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>lseg_append›</span></span></span></span>. 
      
      With the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>ent_frame_fwd›</span></span></span></span>-rule, we can manually apply a rule to
      solve an entailment, involving frame inference. In this case, we have
      the additional problem that frame-inference guesses
      a wrong instantiation, and is not able to infer the frame.
      So we have to pre-instantiate the rule, as done below.›</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> s1<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">a</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> ent_frame_fwd<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lseg_append<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">frame_inference</span> <span class="comment1">― ‹Now frame-inference is able to infer the frame›</span>

    <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Now we are left with a trivial entailment, modulo commutativity of
      star. This can be handled by the entailment solver:›</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">solve_entails</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>



  <span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Functions with Explicit Recursion›</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹If the termination argument of a function depends on one of
    its parameters, we can use the function package. For example, 
    the following function inserts elements from a list into a hash-set:›</span></span>

  <span class="keyword1"><span class="command">fun</span></span> <span class="entity">ins_from_list</span> 
    <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'x</span><span class="main">::</span><span class="main">{</span>heap<span class="main">,</span>hashable<span class="main">}</span><span class="main">)</span> list <span class="main">⇒</span> <span class="tfree">'x</span> hashset <span class="main">⇒</span> <span class="tfree">'x</span> hashset Heap"</span></span> 
    <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">ins_from_list</span> <span class="main">[]</span> <span class="free"><span class="bound"><span class="entity">hs</span></span></span> <span class="main">=</span> return <span class="free"><span class="bound"><span class="entity">hs</span></span></span>"</span></span> <span class="main">|</span>
    <span class="quoted"><span class="quoted">"<span class="free">ins_from_list</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">hs</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span> <span class="bound">hs</span> <span class="main">←</span> hs_ins <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">hs</span></span></span><span class="main">;</span> <span class="free">ins_from_list</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="bound">hs</span> <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Proofs over such functions are usually done by structural
    induction on the explicit parameter, in this case, on the list›</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> ins_from_list_correct<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">&lt;</span>is_hashset <span class="free">s</span> <span class="free">hs</span><span class="main">&gt;</span> ins_from_list <span class="free">l</span> <span class="free">hs</span> <span class="main">&lt;</span>is_hashset <span class="main">(</span><span class="free">s</span><span class="main">∪</span>set <span class="free">l</span><span class="main">)</span><span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">l</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">hs</span></span> <span class="quoted"><span class="free">s</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">x</span> <span class="skolem">l</span><span class="main">)</span> 
    <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹In the induction step, the induction hypothesis has to be 
      declared as a heap-rule, as <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sep_auto›</span></span></span></span> currently does not
      look for potential heap-rules among the premises of the subgoal›</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> Cons.IH<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">sep_auto</span>


  <span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹
    Functions with Recursion Involving the Heap
›</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹If the termination argument of a function depends on data stored on
    the heap, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>partial_function›</span></span></span></span> is a useful tool.

    Note that, despite the name, proving a Hoare-Triple <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>&lt;…&gt; … &lt;…&gt;›</span></span></span></span>
    for something defined with <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>partial_function›</span></span></span></span> implies total 
    correctness.
›</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In the following example, we compute the sum of a list, using an
    iterator. Note that the partial-function package does not provide a
    code generator setup by default, so we have to add a <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>[code]›</span></span></span></span>
    attribute manually›</span></span>
  <span class="keyword1"><span class="command">partial_function</span></span> <span class="main">(</span>heap<span class="main">)</span> <span class="entity">os_sum'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"int os_list_it <span class="main">⇒</span> int <span class="main">⇒</span> int Heap"</span></span> 
    <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free">os_sum'</span> <span class="free"><span class="bound"><span class="entity">it</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">b</span> <span class="main">←</span> os_it_has_next <span class="free"><span class="bound"><span class="entity">it</span></span></span><span class="main">;</span>
      <span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">it'</span><span class="main">)</span> <span class="main">←</span> os_it_next <span class="free"><span class="bound"><span class="entity">it</span></span></span><span class="main">;</span>
        <span class="free">os_sum'</span> <span class="bound">it'</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">+</span><span class="bound">x</span><span class="main">)</span>
      <span class="main">}</span> <span class="keyword1">else</span> return <span class="free"><span class="bound"><span class="entity">s</span></span></span>
    <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The proof that the function is correct can be done by induction
    over the representation of the list that we still have to iterate over.
    Note that for iterators over sets, we need induction on finite sets,
    cf. also <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>To_List_Ga.thy›</span></span></span></span>›</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> os_sum'_rule<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">&lt;</span>os_is_it <span class="free">l</span> <span class="free">p</span> <span class="free">l'</span> <span class="free">it</span><span class="main">&gt;</span> 
    os_sum' <span class="free">it</span> <span class="free">s</span> 
    <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> os_list <span class="free">l</span> <span class="free">p</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="bound">r</span> <span class="main">=</span> <span class="free">s</span> <span class="main">+</span> sum_list <span class="free">l'</span><span class="main">)</span><span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">l'</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">it</span></span> <span class="quoted"><span class="free">s</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹To unfold the definition of a partial function, we have to use 
        <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>subst›</span></span></span></span>. Note that <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>simp›</span></span></span></span> would loop, unfolding the
        function arbitrarily deep›</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> os_sum'.simps<span class="main">)</span>
      <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sep_auto›</span></span></span></span> accepts all the section parameters that 
        <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>auto›</span></span></span></span> does, eg. <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>intro:›</span></span></span></span>›</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> os.quit_iteration<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">x</span> <span class="skolem">l'</span><span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> os_sum'.simps<span class="main">)</span>
      <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Additionally, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sep_auto›</span></span></span></span> accepts some more section 
        parameters. The most common one, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>heap:›</span></span></span></span>, declares rules 
        to be used with frame inference. See Section~\ref{sec:auto:overview}
        for a complete overview.›</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> Cons.hyps<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>


  <span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Precision Proofs›</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
    Precision lemmas show that an assertion uniquely determines some of its
    parameters. Our example shows that two list segments from the same start 
    pointer and with the same list, also have to end at the same end pointer.
›</span></span>
  
  <span class="keyword1"><span class="command">lemma</span></span> lseg_prec3<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">q</span> <span class="bound">q'</span><span class="main">.</span> <span class="free">h</span> <span class="main">⊨</span> <span class="main">(</span>lseg <span class="free">l</span> <span class="free">p</span> <span class="bound">q</span> <span class="main">*</span> <span class="free">F1</span><span class="main">)</span> <span class="keyword1">∧<span class="hidden">⇩</span><sub>A</sub></span> <span class="main">(</span>lseg <span class="free">l</span> <span class="free">p</span> <span class="bound">q'</span> <span class="main">*</span> <span class="free">F2</span><span class="main">)</span> <span class="main">⟶</span> <span class="bound">q</span><span class="main">=</span><span class="bound">q'</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> allI<span class="main">)</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">l</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="free">F1</span></span> <span class="quoted"><span class="free">F2</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span> <span class="comment1">― ‹A precision solver for references and arrays is included
        in the standard simplifier setup. Building a general precision solver
        remains future work.›</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span> <span class="comment1">― ‹Unfortunately, the simplifier cannot cope with arbitrarily  
        directed equations, so we have to use some more powerful tool›</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">x</span> <span class="skolem">l</span><span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
  
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="improper">na</span><span class="main">=</span><span class="improper">n</span>"</span></span><span class="main">)</span>
  
      <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹The <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>prec_frame›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>prec_frame'›</span></span></span></span> rules are 
        useful to do precision proofs›</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> prec_frame'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> Cons.hyps<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">frame_inference</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">frame_inference</span>
  
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> prec_frame<span class="main"><span class="main">[</span></span><span class="operator">OF</span> sngr_prec<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">frame_inference</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">frame_inference</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Default_Insts">
<div class="head">
<h1>Theory Default_Insts</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> Default_Insts
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">instantiation</span></span> nat <span class="main">::</span> <span class="quoted">default</span> <span class="keyword2"><span class="keyword">begin</span></span>
    <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"default <span class="main">=</span> <span class="main">(</span><span class="main">0</span><span class="main">::</span>nat<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="command">instantiation</span></span> int <span class="main">::</span> <span class="quoted">default</span> <span class="keyword2"><span class="keyword">begin</span></span>
    <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"default <span class="main">=</span> <span class="main">(</span><span class="main">0</span><span class="main">::</span>int<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="command">instantiation</span></span> bool <span class="main">::</span> <span class="quoted">default</span> <span class="keyword2"><span class="keyword">begin</span></span>
    <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"default <span class="main">=</span> False"</span></span>
    <span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="command">instantiation</span></span> prod <span class="main">::</span> <span class="main">(</span><span class="quoted">default</span><span class="main">,</span><span class="quoted">default</span><span class="main">)</span> <span class="quoted">default</span> <span class="keyword2"><span class="keyword">begin</span></span>
    <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"default <span class="main">=</span> <span class="main">(</span>default<span class="main">,</span>default<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="command">instantiation</span></span> list <span class="main">::</span> <span class="main">(</span><span class="quoted">type</span><span class="main">)</span><span class="quoted">default</span> <span class="keyword2"><span class="keyword">begin</span></span>
    <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"default <span class="main">=</span> <span class="main">[]</span>"</span></span>
    <span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="command">instantiation</span></span> option <span class="main">::</span> <span class="main">(</span><span class="quoted">type</span><span class="main">)</span><span class="quoted">default</span> <span class="keyword2"><span class="keyword">begin</span></span>
    <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"default <span class="main">=</span> None"</span></span>
    <span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="command">instantiation</span></span> sum <span class="main">::</span> <span class="main">(</span><span class="quoted">default</span><span class="main">,</span><span class="quoted">type</span><span class="main">)</span><span class="quoted">default</span> <span class="keyword2"><span class="keyword">begin</span></span>
    <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"default <span class="main">=</span> Inl default"</span></span>
    <span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Array_Blit">
<div class="head">
<h1>Theory Array_Blit</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Bit Block Transfer and Other Array Optimizations›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Array_Blit
<span class="keyword2"><span class="keyword">imports</span></span> 
  <span class="quoted">"<a href="Sep_Main.html">../Sep_Main</a>"</span> 
  <span class="quoted">"<a href="../../HOL/HOL-Library/Code_Target_Numeral.html">HOL-Library.Code_Target_Numeral</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Definition"</span></span>

  <span class="comment1">(* TODO/FIXME: Does not work with same arrays and overlapping ranges.
    Currently, the generated code will throw an exception if the arrays are the same.

    If only used with blit_rule, separation logic guarantees that arrays will be disjoint.
  *)</span>
  <span class="keyword1"><span class="command">primrec</span></span> <span class="entity">blit</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">_</span> array <span class="main">⇒</span> nat <span class="main">⇒</span> <span class="main">_</span> array <span class="main">⇒</span> nat <span class="main">⇒</span> nat <span class="main">⇒</span> unit Heap"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">blit</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">0</span> <span class="main">=</span> return <span class="main">()</span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">blit</span> <span class="free"><span class="bound"><span class="entity">src</span></span></span> <span class="free"><span class="bound"><span class="entity">si</span></span></span> <span class="free"><span class="bound"><span class="entity">dst</span></span></span> <span class="free"><span class="bound"><span class="entity">di</span></span></span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">x</span> <span class="main">←</span> Array.nth <span class="free"><span class="bound"><span class="entity">src</span></span></span> <span class="free"><span class="bound"><span class="entity">si</span></span></span><span class="main">;</span>
      Array.upd <span class="free"><span class="bound"><span class="entity">di</span></span></span> <span class="bound">x</span> <span class="free"><span class="bound"><span class="entity">dst</span></span></span><span class="main">;</span>
      <span class="free">blit</span> <span class="free"><span class="bound"><span class="entity">src</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">si</span></span></span><span class="main">+</span><span class="main">1</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">dst</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">di</span></span></span><span class="main">+</span><span class="main">1</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span>
    <span class="main">}</span>"</span></span>
  
  <span class="keyword1"><span class="command">lemma</span></span> blit_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> LEN<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">si</span><span class="main">+</span><span class="free">len</span> <span class="main">≤</span> length <span class="free">lsrc</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">di</span><span class="main">+</span><span class="free">len</span> <span class="main">≤</span> length <span class="free">ldst</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">&lt;</span> <span class="free">src</span> <span class="keyword1">↦<span class="hidden">⇩</span><sub>a</sub></span> <span class="free">lsrc</span> 
      <span class="main">*</span> <span class="free">dst</span> <span class="keyword1">↦<span class="hidden">⇩</span><sub>a</sub></span> <span class="free">ldst</span> <span class="main">&gt;</span>
    blit <span class="free">src</span> <span class="free">si</span> <span class="free">dst</span> <span class="free">di</span> <span class="free">len</span>
    <span class="main">&lt;</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">src</span> <span class="keyword1">↦<span class="hidden">⇩</span><sub>a</sub></span> <span class="free">lsrc</span> 
      <span class="main">*</span> <span class="free">dst</span> <span class="keyword1">↦<span class="hidden">⇩</span><sub>a</sub></span> <span class="main">(</span>take <span class="free">di</span> <span class="free">ldst</span> <span class="main">@</span> take <span class="free">len</span> <span class="main">(</span>drop <span class="free">si</span> <span class="free">lsrc</span><span class="main">)</span> <span class="main">@</span> drop <span class="main">(</span><span class="free">di</span><span class="main">+</span><span class="free">len</span><span class="main">)</span> <span class="free">ldst</span><span class="main">)</span>
    <span class="main">&gt;</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> LEN
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">len</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">si</span></span> <span class="quoted"><span class="free">di</span></span> <span class="quoted"><span class="free">ldst</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> 0 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">sep_auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">len</span><span class="main">)</span> 
    <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span> <span class="main">=</span> Suc.IH

    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="free">lsrc</span> <span class="main">!</span> <span class="skolem">si</span> <span class="main">#</span> take <span class="skolem">len</span> <span class="main">(</span>drop <span class="main">(</span>Suc <span class="skolem">si</span><span class="main">)</span> <span class="free">lsrc</span><span class="main">)</span> <span class="main">@</span> <span class="bound">x</span>
      <span class="main">=</span> take <span class="main">(</span>Suc <span class="skolem">len</span><span class="main">)</span> <span class="main">(</span>drop <span class="skolem">si</span> <span class="free">lsrc</span><span class="main">)</span> <span class="main">@</span> <span class="bound">x</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Suc.prems<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> add_Suc_right Cons_nth_drop_Suc
        less_Suc_eq_le add.commute not_less_eq take_Suc_Cons 
        Nat.trans_le_add2<span class="main">)</span>

    <span class="keyword1"><span class="command">from</span></span> Suc.prems <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> take_update_last drop_upd_irrelevant<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">nth_oo</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">nth_oo</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">l</span><span class="main">←</span>Array.len <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">;</span>
    <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">&lt;</span><span class="bound">l</span> <span class="keyword1">then</span>
      Array.nth <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span>
    <span class="keyword1">else</span> 
      return <span class="free"><span class="bound"><span class="entity">v</span></span></span>
  <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">upd_oo</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">upd_oo</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">l</span><span class="main">←</span>Array.len <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">;</span>
    <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">&lt;</span><span class="bound">l</span> <span class="keyword1">then</span>
      Array.upd <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span>
    <span class="keyword1">else</span>
      <span class="free"><span class="bound"><span class="entity">f</span></span></span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">ML_val</span></span> Array.update

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Code Generator Setup"</span></span>
  <span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">code_module</span></span> <span class="quoted">"array_blit"</span> <span class="main">⇀</span> <span class="main">(</span>SML<span class="main">)</span>
    <span class="quoted">‹
   fun array_blit src si dst di len = (
      src=dst andalso raise Fail ("array_blit: Same arrays");
      ArraySlice.copy {
        di = IntInf.toInt di,
        src = ArraySlice.slice (src,IntInf.toInt si,SOME (IntInf.toInt len)),
        dst = dst})

    fun array_nth_oo v a i () = Array.sub(a,IntInf.toInt i) handle Subscript =&gt; v | Overflow =&gt; v
    fun array_upd_oo f i x a () = 
      (Array.update(a,IntInf.toInt i,x); a) handle Subscript =&gt; f () | Overflow =&gt; f ()

›</span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">blit'</span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">blit'</span> <span class="free"><span class="bound"><span class="entity">src</span></span></span> <span class="free"><span class="bound"><span class="entity">si</span></span></span> <span class="free"><span class="bound"><span class="entity">dst</span></span></span> <span class="free"><span class="bound"><span class="entity">di</span></span></span> <span class="free"><span class="bound"><span class="entity">len</span></span></span> 
      <span class="main">=</span> blit <span class="free"><span class="bound"><span class="entity">src</span></span></span> <span class="main">(</span>nat_of_integer <span class="free"><span class="bound"><span class="entity">si</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">dst</span></span></span> <span class="main">(</span>nat_of_integer <span class="free"><span class="bound"><span class="entity">di</span></span></span><span class="main">)</span> 
          <span class="main">(</span>nat_of_integer <span class="free"><span class="bound"><span class="entity">len</span></span></span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"blit <span class="free">src</span> <span class="free">si</span> <span class="free">dst</span> <span class="free">di</span> <span class="free">len</span> 
      <span class="main">=</span> blit' <span class="free">src</span> <span class="main">(</span>integer_of_nat <span class="free">si</span><span class="main">)</span> <span class="free">dst</span> <span class="main">(</span>integer_of_nat <span class="free">di</span><span class="main">)</span> 
          <span class="main">(</span>integer_of_nat <span class="free">len</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> blit'_def<span class="main">)</span>

  <span class="comment1">(* TODO: Export to other languages: OCaml, Haskell *)</span>
  <span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">blit'</span> <span class="main">⇀</span>
    <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"(fn/ ()/ =&gt; /array'_blit _ _ _ _ _)"</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"{ ('_: Unit)/=&gt;/
      def safecopy(src: Array['_], srci: Int, dst: Array['_], dsti: Int, len: Int) = {
        if (src eq dst)
          sys.error(\"array'_blit: Same arrays\")
        else
          System.arraycopy(src, srci, dst, dsti, len)
      }
      safecopy(_.array,_.toInt,_.array,_.toInt,_.toInt)
    }"</span>
  
  <span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">nth_oo'</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">==</span> nth_oo <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="keyword1">o</span> nat_of_integer"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">upd_oo'</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">==</span> upd_oo <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="keyword1">o</span> nat_of_integer"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"nth_oo <span class="free">v</span> <span class="free">a</span> <span class="main">==</span> nth_oo' <span class="free">v</span> <span class="free">a</span> <span class="keyword1">o</span> integer_of_nat"</span></span>
    <span class="quoted"><span class="quoted">"upd_oo <span class="free">f</span> <span class="main">==</span> upd_oo' <span class="free">f</span> <span class="keyword1">o</span> integer_of_nat"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nth_oo'_def upd_oo'_def o_def<span class="main">)</span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Fallbacks›</span></span>
  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> nth_oo'_def<span class="main">[</span><span class="operator">unfolded</span> nth_oo_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> upd_oo'_def<span class="main">[</span><span class="operator">unfolded</span> upd_oo_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span><span class="main">]</span>

  <span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">nth_oo'</span> <span class="main">⇀</span> <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"array'_nth'_oo _ _ _"</span>
    <span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">upd_oo'</span> <span class="main">⇀</span> <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"array'_upd'_oo _ _ _ _"</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Derived Functions›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">array_shrink</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="comment1">― ‹Avoiding the need for default value›</span>
    <span class="bound">l</span><span class="main">←</span>Array.len <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">;</span>
    <span class="keyword1">if</span> <span class="bound">l</span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="keyword1">then</span> 
      return <span class="free"><span class="bound"><span class="entity">a</span></span></span>
    <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="bound">l</span><span class="main">=</span><span class="main">0</span> <span class="keyword1">then</span> 
      Array.of_list <span class="main">[]</span>
    <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">x</span><span class="main">←</span>Array.nth <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">0</span><span class="main">;</span>
      <span class="bound">a'</span><span class="main">←</span>Array.new <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="bound">x</span><span class="main">;</span>
      blit <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">0</span> <span class="bound">a'</span> <span class="main">0</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">;</span>
      return <span class="bound">a'</span>
    <span class="main">}</span>
  <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> array_shrink_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">≤</span>length <span class="free">la</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span> <span class="free">a</span><span class="keyword1">↦<span class="hidden">⇩</span><sub>a</sub></span><span class="free">la</span> <span class="main">&gt;</span> array_shrink <span class="free">a</span> <span class="free">s</span> <span class="main">&lt;</span><span class="main">λ</span><span class="bound">a'</span><span class="main">.</span> <span class="bound">a'</span><span class="keyword1">↦<span class="hidden">⇩</span><sub>a</sub></span>take <span class="free">s</span> <span class="free">la</span> <span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> array_shrink_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">sep_auto</span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">array_grow</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">l</span><span class="main">←</span>Array.len <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">;</span>
    <span class="keyword1">if</span> <span class="bound">l</span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="keyword1">then</span> 
      return <span class="free"><span class="bound"><span class="entity">a</span></span></span>
    <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">a'</span><span class="main">←</span>Array.new <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">;</span>
      blit <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">0</span> <span class="bound">a'</span> <span class="main">0</span> <span class="bound">l</span><span class="main">;</span>
      return <span class="bound">a'</span>
    <span class="main">}</span>
  <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> array_grow_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">≥</span>length <span class="free">la</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"
      <span class="main">&lt;</span> <span class="free">a</span><span class="keyword1">↦<span class="hidden">⇩</span><sub>a</sub></span><span class="free">la</span> <span class="main">&gt;</span> 
        array_grow <span class="free">a</span> <span class="free">s</span> <span class="free">x</span> 
      <span class="main">&lt;</span><span class="main">λ</span><span class="bound">a'</span><span class="main">.</span> <span class="bound">a'</span><span class="keyword1">↦<span class="hidden">⇩</span><sub>a</sub></span> <span class="main">(</span><span class="free">la</span> <span class="main">@</span> replicate <span class="main">(</span><span class="free">s</span><span class="main">-</span>length <span class="free">la</span><span class="main">)</span> <span class="free">x</span><span class="main">)</span><span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">unfolding</span></span> array_grow_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">sep_auto</span>

      
  <span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">array_grow</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML Scala    

    
  <span class="comment1">(* TODO: Are there system-calls for array-copy? *)</span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">array_copy</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">l</span><span class="main">←</span>Array.len <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">;</span>
    <span class="keyword1">if</span> <span class="bound">l</span><span class="main">=</span><span class="main">0</span> <span class="keyword1">then</span> 
      Array.of_list <span class="main">[]</span>
    <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">s</span> <span class="main">←</span> Array.nth <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">0</span><span class="main">;</span>
      <span class="bound">a'</span><span class="main">←</span>Array.new <span class="bound">l</span> <span class="bound">s</span><span class="main">;</span>
      blit <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">0</span> <span class="bound">a'</span> <span class="main">0</span> <span class="bound">l</span><span class="main">;</span>
      return <span class="bound">a'</span>
    <span class="main">}</span>
  <span class="main">}</span>"</span></span>
  
  <span class="keyword1"><span class="command">lemma</span></span> array_copy_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"
      <span class="main">&lt;</span> <span class="free">a</span><span class="keyword1">↦<span class="hidden">⇩</span><sub>a</sub></span><span class="free">l</span><span class="main">&gt;</span> 
        array_copy <span class="free">a</span> 
      <span class="main">&lt;</span><span class="main">λ</span><span class="bound">a'</span><span class="main">.</span> <span class="free">a</span><span class="keyword1">↦<span class="hidden">⇩</span><sub>a</sub></span><span class="free">l</span> <span class="main">*</span> <span class="bound">a'</span><span class="keyword1">↦<span class="hidden">⇩</span><sub>a</sub></span> <span class="free">l</span><span class="main">&gt;</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> array_copy_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">sep_auto</span>
    
  <span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">array_copy</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML Scala    
    
    
<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Array_Map_Impl">
<div class="head">
<h1>Theory Array_Map_Impl</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> Array_Map_Impl
<span class="keyword2"><span class="keyword">imports</span></span> 
  <span class="quoted">"<a href="Sep_Main.html">../Sep_Main</a>"</span> <a href="Imp_Map_Spec.html">Imp_Map_Spec</a> <a href="Array_Blit.html">Array_Blit</a>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Code_Target_Numeral.html">HOL-Library.Code_Target_Numeral</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Array Map"</span></span>

  <span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'v</span> array_map <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> option array"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">iam_initial_size</span> <span class="main">≡</span> <span class="numeral">8</span><span class="main">::</span>nat"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">iam_of_list</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">≡</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">&lt;</span>length <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">!</span><span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="keyword1">else</span> None"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">is_iam</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat<span class="main">⇀</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>heap<span class="main">)</span> array_map <span class="main">⇒</span> assn"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">is_iam</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">≡</span> <span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">l</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="keyword1">↦<span class="hidden">⇩</span><sub>a</sub></span><span class="bound">l</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">=</span>iam_of_list <span class="bound">l</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">iam_new_sz</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">::</span>heap<span class="main">)</span> array_map Heap"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">iam_new_sz</span> <span class="free"><span class="bound"><span class="entity">sz</span></span></span> <span class="main">≡</span> Array.new <span class="free"><span class="bound"><span class="entity">sz</span></span></span> None"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">iam_new</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">::</span>heap<span class="main">)</span> array_map Heap"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">iam_new</span> <span class="main">≡</span> iam_new_sz iam_initial_size"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">iam_lookup</span> 
    <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">::</span>heap<span class="main">)</span> array_map <span class="main">⇒</span> <span class="tfree">'v</span> option Heap"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">iam_lookup</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">l</span><span class="main">←</span>Array.len <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">;</span>
      <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">&lt;</span> <span class="bound">l</span> <span class="keyword1">then</span> Array.nth <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="keyword1">else</span> return None
    <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"iam_lookup <span class="free">k</span> <span class="free">a</span> <span class="main">≡</span> nth_oo None <span class="free">a</span> <span class="free">k</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> nth_oo_def iam_lookup_def <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">iam_delete</span>
    <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">::</span>heap<span class="main">)</span> array_map <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">::</span>heap<span class="main">)</span> array_map Heap"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">iam_delete</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">l</span><span class="main">←</span>Array.len <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">;</span>
      <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">&lt;</span> <span class="bound">l</span> <span class="keyword1">then</span> Array.upd <span class="free"><span class="bound"><span class="entity">k</span></span></span> None <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="keyword1">else</span> return <span class="free"><span class="bound"><span class="entity">a</span></span></span>
    <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"iam_delete <span class="free">k</span> <span class="free">a</span> <span class="main">≡</span> upd_oo <span class="main">(</span>return <span class="free">a</span><span class="main">)</span> <span class="free">k</span> None <span class="free">a</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> upd_oo_def iam_delete_def <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">iam_update</span>
    <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="tfree">'v</span><span class="main">::</span>heap <span class="main">⇒</span> <span class="tfree">'v</span> array_map <span class="main">⇒</span> <span class="tfree">'v</span> array_map Heap"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">iam_update</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">l</span><span class="main">←</span>Array.len <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">;</span>
      <span class="bound">a</span><span class="main">←</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">&gt;=</span><span class="bound">l</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
          <span class="keyword1">let</span> <span class="bound">newsz</span> <span class="main">=</span> max <span class="main">(</span><span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">+</span><span class="main">1</span><span class="main">)</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="bound">l</span> <span class="main">+</span> <span class="numeral">3</span><span class="main">)</span><span class="main">;</span>
          array_grow <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="bound">newsz</span> None
        <span class="main">}</span> <span class="keyword1">else</span> return <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">;</span>

      Array.upd <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="bound">a</span>
    <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"iam_update <span class="free">k</span> <span class="free">v</span> <span class="free">a</span> <span class="main">=</span> upd_oo 
    <span class="main">(</span><span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">l</span><span class="main">←</span>Array.len <span class="free">a</span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">newsz</span> <span class="main">=</span> max <span class="main">(</span><span class="free">k</span><span class="main">+</span><span class="main">1</span><span class="main">)</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="bound">l</span> <span class="main">+</span> <span class="numeral">3</span><span class="main">)</span><span class="main">;</span>
      <span class="bound">a</span><span class="main">←</span>array_grow <span class="free">a</span> <span class="bound">newsz</span> None<span class="main">;</span>
      Array.upd <span class="free">k</span> <span class="main">(</span>Some <span class="free">v</span><span class="main">)</span> <span class="bound">a</span>
    <span class="main">}</span><span class="main">)</span>
    <span class="free">k</span> <span class="main">(</span>Some <span class="free">v</span><span class="main">)</span> <span class="free">a</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
      <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">t</span> <span class="bound">e</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">l</span><span class="main">←</span>Array.len <span class="free">a</span><span class="main">;</span>
        <span class="keyword1">if</span> <span class="bound">x</span> <span class="bound">l</span> <span class="keyword1">then</span> 
          <span class="bound">t</span> <span class="bound">l</span> 
        <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
          <span class="bound">l'</span><span class="main">←</span>Array.len <span class="free">a</span><span class="main">;</span>
          <span class="bound">e</span> <span class="bound">l</span> <span class="bound">l'</span>
        <span class="main">}</span> 
      <span class="main">}</span>
      <span class="main">=</span>
      <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">l</span><span class="main">←</span>Array.len <span class="free">a</span><span class="main">;</span>
        <span class="keyword1">if</span> <span class="bound">x</span> <span class="bound">l</span> <span class="keyword1">then</span> <span class="bound">t</span> <span class="bound">l</span> <span class="keyword1">else</span> <span class="bound">e</span> <span class="bound">l</span> <span class="bound">l</span>
      <span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> bind_def execute_len 
        <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split
        <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ext
      <span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> upd_oo_def iam_update_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> arg_cong<span class="main"><span class="main">,</span></span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f1<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">bind</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> precise_iam<span class="main">:</span> <span class="quoted"><span class="quoted">"precise is_iam"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> is_iam_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> preciseD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> snga_prec<span class="main"><span class="main">]</span></span><span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> iam_new_abs<span class="main">:</span> <span class="quoted"><span class="quoted">"iam_of_list <span class="main">(</span>replicate <span class="free">n</span> None<span class="main">)</span> <span class="main">=</span> Map.empty"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> iam_of_list_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">lemma</span></span> iam_new_sz_rule<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="keyword1">emp</span><span class="main">&gt;</span> iam_new_sz <span class="free">n</span> <span class="main">&lt;</span> is_iam Map.empty <span class="main">&gt;</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> iam_new_sz_def is_iam_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> iam_new_abs<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> iam_new_rule<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="keyword1">emp</span><span class="main">&gt;</span> iam_new <span class="main">&lt;</span> is_iam Map.empty <span class="main">&gt;</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> iam_new_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> iam_new_sz_rule<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> iam_lookup_abs1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">k</span><span class="main">&lt;</span>length <span class="free">l</span> <span class="main">⟹</span> iam_of_list <span class="free">l</span> <span class="free">k</span> <span class="main">=</span> <span class="free">l</span><span class="main">!</span><span class="free">k</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> iam_of_list_def<span class="main">)</span>
  <span class="keyword1"><span class="command">lemma</span></span> iam_lookup_abs2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="free">k</span><span class="main">&lt;</span>length <span class="free">l</span> <span class="main">⟹</span> iam_of_list <span class="free">l</span> <span class="free">k</span> <span class="main">=</span> None"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> iam_of_list_def<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> iam_lookup_rule<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span> is_iam <span class="free">m</span> <span class="free">p</span> <span class="main">&gt;</span> 
    iam_lookup <span class="free">k</span> <span class="free">p</span> 
    <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> is_iam <span class="free">m</span> <span class="free">p</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="bound">r</span><span class="main">=</span><span class="free">m</span> <span class="free">k</span><span class="main">)</span> <span class="main">&gt;</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> iam_lookup_def is_iam_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> iam_lookup_abs1 iam_lookup_abs2<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> iam_delete_abs1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">k</span><span class="main">&lt;</span>length <span class="free">l</span> 
    <span class="main">⟹</span> iam_of_list <span class="main">(</span><span class="free">l</span><span class="main">[</span><span class="free">k</span> <span class="main">:=</span> None<span class="main">]</span><span class="main">)</span> <span class="main">=</span> iam_of_list <span class="free">l</span> <span class="main">|`</span> <span class="main">(</span><span class="main">-</span> <span class="main">{</span><span class="free">k</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> iam_of_list_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ext <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> restrict_map_def<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> iam_delete_abs2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="free">k</span><span class="main">&lt;</span>length <span class="free">l</span> 
    <span class="main">⟹</span> iam_of_list <span class="free">l</span> <span class="main">|`</span> <span class="main">(</span><span class="main">-</span> <span class="main">{</span><span class="free">k</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> iam_of_list <span class="free">l</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> iam_of_list_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ext <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> restrict_map_def<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> iam_delete_rule<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span> is_iam <span class="free">m</span> <span class="free">p</span> <span class="main">&gt;</span>
    iam_delete <span class="free">k</span> <span class="free">p</span>
    <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> is_iam <span class="main">(</span><span class="free">m</span><span class="main">|`</span><span class="main">(</span><span class="main">-</span><span class="main">{</span><span class="free">k</span><span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="bound">r</span><span class="main">&gt;</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> is_iam_def iam_delete_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> iam_delete_abs1 iam_delete_abs2<span class="main">)</span>
    

  <span class="keyword1"><span class="command">lemma</span></span> iam_update_abs1<span class="main">:</span> <span class="quoted"><span class="quoted">"iam_of_list <span class="main">(</span><span class="free">l</span><span class="main">@</span>replicate <span class="free">n</span> None<span class="main">)</span> <span class="main">=</span> iam_of_list <span class="free">l</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> iam_of_list_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ext <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> nth_append<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> iam_update_abs2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> length <span class="free">l</span> <span class="main">≤</span> <span class="free">k</span> 
    <span class="main">⟹</span> iam_of_list <span class="main">(</span><span class="free">l</span><span class="main">[</span><span class="free">k</span> <span class="main">:=</span> Some <span class="free">v</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> iam_of_list <span class="free">l</span><span class="main">(</span><span class="free">k</span> <span class="main">↦</span> <span class="free">v</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> iam_of_list_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">lemma</span></span> iam_update_rule<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">&lt;</span> is_iam <span class="free">m</span> <span class="free">p</span> <span class="main">&gt;</span> iam_update <span class="free">k</span> <span class="free">v</span> <span class="free">p</span> <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> is_iam <span class="main">(</span><span class="free">m</span><span class="main">(</span><span class="free">k</span><span class="main">↦</span><span class="free">v</span><span class="main">)</span><span class="main">)</span> <span class="bound">r</span><span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> is_iam_def iam_update_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> 
      <span class="quasi_keyword">decon</span><span class="main"><span class="main">:</span></span> decon_if_split 
      <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> iam_update_abs1 iam_update_abs2<span class="main">)</span>
  
  <span class="keyword1"><span class="command">interpretation</span></span> iam<span class="main">:</span> imp_map <span class="quoted">is_iam</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> precise_iam<span class="main">)</span>
  <span class="keyword1"><span class="command">interpretation</span></span> iam<span class="main">:</span> imp_map_empty <span class="quoted">is_iam</span> <span class="quoted">iam_new</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> iam_new_rule<span class="main">)</span>
  <span class="keyword1"><span class="command">interpretation</span></span> iam_sz<span class="main">:</span> imp_map_empty <span class="quoted">is_iam</span> <span class="quoted"><span class="quoted">"iam_new_sz <span class="free">sz</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> iam_new_sz_rule<span class="main">)</span>
 
  <span class="keyword1"><span class="command">interpretation</span></span> iam<span class="main">:</span> imp_map_lookup <span class="quoted">is_iam</span> <span class="quoted">iam_lookup</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> iam_lookup_rule<span class="main">)</span>
  <span class="keyword1"><span class="command">interpretation</span></span> iam<span class="main">:</span> imp_map_delete <span class="quoted">is_iam</span> <span class="quoted">iam_delete</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> iam_delete_rule<span class="main">)</span>
  <span class="keyword1"><span class="command">interpretation</span></span> iam<span class="main">:</span> imp_map_update <span class="quoted">is_iam</span> <span class="quoted">iam_update</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> iam_update_rule<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Array_Set_Impl">
<div class="head">
<h1>Theory Array_Set_Impl</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> Array_Set_Impl
<span class="keyword2"><span class="keyword">imports</span></span> 
  <span class="quoted">"<a href="Sep_Main.html">../Sep_Main</a>"</span> <a href="Imp_Set_Spec.html">Imp_Set_Spec</a> <a href="Array_Blit.html">Array_Blit</a>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Code_Target_Numeral.html">HOL-Library.Code_Target_Numeral</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Array Set"</span></span>

  <span class="keyword1"><span class="command">type_synonym</span></span> array_set <span class="main">=</span> <span class="quoted"><span class="quoted">"bool array"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">ias_initial_size</span> <span class="main">≡</span> <span class="numeral">8</span><span class="main">::</span>nat"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">ias_of_list</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">≡</span> <span class="main">{</span><span class="bound">i</span><span class="main">.</span> <span class="bound">i</span><span class="main">&lt;</span>length <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">!</span><span class="bound">i</span><span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">is_ias</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat set<span class="main">)</span> <span class="main">⇒</span> array_set <span class="main">⇒</span> assn"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">is_ias</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">≡</span> <span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">l</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="keyword1">↦<span class="hidden">⇩</span><sub>a</sub></span><span class="bound">l</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">=</span>ias_of_list <span class="bound">l</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">ias_new_sz</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> array_set Heap"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ias_new_sz</span> <span class="free"><span class="bound"><span class="entity">sz</span></span></span> <span class="main">≡</span> Array.new <span class="free"><span class="bound"><span class="entity">sz</span></span></span> False"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">ias_new</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"array_set Heap"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ias_new</span> <span class="main">≡</span> ias_new_sz ias_initial_size"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">ias_memb</span>
    <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> array_set <span class="main">⇒</span> bool Heap"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ias_memb</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">l</span><span class="main">←</span>Array.len <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">;</span>
      <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">&lt;</span> <span class="bound">l</span> <span class="keyword1">then</span> Array.nth <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="keyword1">else</span> return False
    <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ias_memb <span class="free">k</span> <span class="free">a</span> <span class="main">≡</span> nth_oo False <span class="free">a</span> <span class="free">k</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> ias_memb_def nth_oo_def <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">ias_delete</span>
    <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> array_set <span class="main">⇒</span> array_set Heap"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ias_delete</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">l</span><span class="main">←</span>Array.len <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">;</span>
      <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">&lt;</span> <span class="bound">l</span> <span class="keyword1">then</span> Array.upd <span class="free"><span class="bound"><span class="entity">k</span></span></span> False <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="keyword1">else</span> return <span class="free"><span class="bound"><span class="entity">a</span></span></span>
    <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ias_delete <span class="free">k</span> <span class="free">a</span> <span class="main">≡</span> upd_oo <span class="main">(</span>return <span class="free">a</span><span class="main">)</span> <span class="free">k</span> False <span class="free">a</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> ias_delete_def upd_oo_def <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">ias_ins</span>
    <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> array_set <span class="main">⇒</span> array_set Heap"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ias_ins</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">l</span><span class="main">←</span>Array.len <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">;</span>
      <span class="bound">a</span><span class="main">←</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">&gt;=</span><span class="bound">l</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
          <span class="keyword1">let</span> <span class="bound">newsz</span> <span class="main">=</span> max <span class="main">(</span><span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">+</span><span class="main">1</span><span class="main">)</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="bound">l</span> <span class="main">+</span> <span class="numeral">3</span><span class="main">)</span><span class="main">;</span>
          array_grow <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="bound">newsz</span> False
        <span class="main">}</span> <span class="keyword1">else</span> return <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">;</span>

      Array.upd <span class="free"><span class="bound"><span class="entity">k</span></span></span> True <span class="bound">a</span>
    <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ias_ins <span class="free">k</span> <span class="free">a</span> <span class="main">≡</span> upd_oo <span class="main">(</span><span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">l</span><span class="main">←</span>Array.len <span class="free">a</span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">newsz</span> <span class="main">=</span> max <span class="main">(</span><span class="free">k</span><span class="main">+</span><span class="main">1</span><span class="main">)</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="bound">l</span> <span class="main">+</span> <span class="numeral">3</span><span class="main">)</span><span class="main">;</span>
      <span class="bound">a</span><span class="main">←</span>array_grow <span class="free">a</span> <span class="bound">newsz</span> False<span class="main">;</span>
      Array.upd <span class="free">k</span> True <span class="bound">a</span>
    <span class="main">}</span><span class="main">)</span>
    <span class="free">k</span> True <span class="free">a</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> ias_ins_def upd_oo_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> eq_reflection<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_def execute_len execute_return<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


  <span class="keyword1"><span class="command">lemma</span></span> precise_ias<span class="main">:</span> <span class="quoted"><span class="quoted">"precise is_ias"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> is_ias_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> preciseD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> snga_prec<span class="main"><span class="main">]</span></span><span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> ias_new_abs<span class="main">:</span> <span class="quoted"><span class="quoted">"ias_of_list <span class="main">(</span>replicate <span class="free">n</span> False<span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> ias_of_list_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">lemma</span></span> ias_new_sz_rule<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="keyword1">emp</span><span class="main">&gt;</span> ias_new_sz <span class="free">n</span> <span class="main">&lt;</span> is_ias <span class="main">{}</span> <span class="main">&gt;</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> ias_new_sz_def is_ias_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ias_new_abs<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> ias_new_rule<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="keyword1">emp</span><span class="main">&gt;</span> ias_new <span class="main">&lt;</span> is_ias <span class="main">{}</span> <span class="main">&gt;</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> ias_new_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> ias_new_sz_rule<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> ias_memb_abs1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">k</span><span class="main">&lt;</span>length <span class="free">l</span> <span class="main">⟹</span> <span class="free">k</span><span class="main">∈</span>ias_of_list <span class="free">l</span> <span class="main">⟷</span> <span class="free">l</span><span class="main">!</span><span class="free">k</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ias_of_list_def<span class="main">)</span>
  <span class="keyword1"><span class="command">lemma</span></span> ias_memb_abs2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="free">k</span><span class="main">&lt;</span>length <span class="free">l</span> <span class="main">⟹</span> <span class="free">k</span><span class="main">∉</span>ias_of_list <span class="free">l</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ias_of_list_def<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> ias_memb_rule<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span> is_ias <span class="free">m</span> <span class="free">p</span> <span class="main">&gt;</span> 
    ias_memb <span class="free">k</span> <span class="free">p</span> 
    <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> is_ias <span class="free">m</span> <span class="free">p</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="bound">r</span><span class="main">⟷</span><span class="free">k</span><span class="main">∈</span><span class="free">m</span><span class="main">)</span> <span class="main">&gt;</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> ias_memb_def is_ias_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ias_memb_abs1 ias_memb_abs2<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> ias_delete_abs1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">k</span><span class="main">&lt;</span>length <span class="free">l</span> 
    <span class="main">⟹</span> ias_of_list <span class="main">(</span><span class="free">l</span><span class="main">[</span><span class="free">k</span> <span class="main">:=</span> False<span class="main">]</span><span class="main">)</span> <span class="main">=</span> ias_of_list <span class="free">l</span> <span class="main">-</span> <span class="main">{</span><span class="free">k</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> ias_of_list_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> nth_list_update<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> ias_delete_abs2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="free">k</span><span class="main">&lt;</span>length <span class="free">l</span> 
    <span class="main">⟹</span> ias_of_list <span class="free">l</span> <span class="main">-</span> <span class="main">{</span><span class="free">k</span><span class="main">}</span> <span class="main">=</span> ias_of_list <span class="free">l</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> ias_of_list_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> ias_delete_rule<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span> is_ias <span class="free">m</span> <span class="free">p</span> <span class="main">&gt;</span>
    ias_delete <span class="free">k</span> <span class="free">p</span>
    <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> is_ias <span class="main">(</span><span class="free">m</span><span class="main">-</span><span class="main">{</span><span class="free">k</span><span class="main">}</span><span class="main">)</span> <span class="bound">r</span><span class="main">&gt;</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> is_ias_def ias_delete_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ias_delete_abs1 ias_delete_abs2<span class="main">)</span>
    
  <span class="keyword1"><span class="command">lemma</span></span> ias_ins_abs1<span class="main">:</span> <span class="quoted"><span class="quoted">"ias_of_list <span class="main">(</span><span class="free">l</span><span class="main">@</span>replicate <span class="free">n</span> False<span class="main">)</span> <span class="main">=</span> ias_of_list <span class="free">l</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> ias_of_list_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> conjE<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"<span class="improper">x</span><span class="main">&lt;</span>length <span class="free">l</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nth_append<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>2<span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nth_append<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">lemma</span></span> ias_ins_abs2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> length <span class="free">l</span> <span class="main">≤</span> <span class="free">k</span> 
    <span class="main">⟹</span> ias_of_list <span class="main">(</span><span class="free">l</span><span class="main">[</span><span class="free">k</span> <span class="main">:=</span> True<span class="main">]</span><span class="main">)</span> <span class="main">=</span> insert <span class="free">k</span> <span class="main">(</span>ias_of_list <span class="free">l</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> ias_of_list_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> nth_list_update<span class="main">)</span>
  
  <span class="keyword1"><span class="command">lemma</span></span> ias_ins_rule<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">&lt;</span> is_ias <span class="free">m</span> <span class="free">p</span> <span class="main">&gt;</span> ias_ins <span class="free">k</span> <span class="free">p</span> <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> is_ias <span class="main">(</span>insert <span class="free">k</span> <span class="free">m</span><span class="main">)</span> <span class="bound">r</span><span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> is_ias_def ias_ins_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> 
      <span class="quasi_keyword">decon</span><span class="main"><span class="main">:</span></span> decon_if_split 
      <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ias_ins_abs1 ias_ins_abs2<span class="main">)</span>
  
  <span class="keyword1"><span class="command">lemma</span></span> ias_set_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"imp_set is_ias"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> precise_ias<span class="main">)</span>
  <span class="keyword1"><span class="command">interpretation</span></span> ias<span class="main">:</span> imp_set <span class="quoted">is_ias</span> <span class="keyword1"><span class="command">using</span></span> ias_set_impl <span class="keyword1"><span class="command">.</span></span>
  
  <span class="keyword1"><span class="command">lemma</span></span> ias_empty_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"imp_set_empty is_ias ias_new"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> ias_new_rule<span class="main">)</span>
  <span class="keyword1"><span class="command">interpretation</span></span> ias<span class="main">:</span> imp_set_empty <span class="quoted">is_ias</span> <span class="quoted">ias_new</span> <span class="keyword1"><span class="command">using</span></span> ias_empty_impl <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> ias_empty_sz_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"imp_set_empty is_ias <span class="main">(</span>ias_new_sz <span class="free">sz</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> ias_new_sz_rule<span class="main">)</span>
  <span class="keyword1"><span class="command">interpretation</span></span> ias_sz<span class="main">:</span> imp_set_empty <span class="quoted">is_ias</span> <span class="quoted"><span class="quoted">"ias_new_sz <span class="free">sz</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> ias_empty_sz_impl <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> ias_memb_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"imp_set_memb is_ias ias_memb"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> ias_memb_rule<span class="main">)</span>
  <span class="keyword1"><span class="command">interpretation</span></span> ias<span class="main">:</span> imp_set_memb <span class="quoted">is_ias</span> <span class="quoted">ias_memb</span>
    <span class="keyword1"><span class="command">using</span></span> ias_memb_impl <span class="keyword1"><span class="command">.</span></span>
  
  <span class="keyword1"><span class="command">lemma</span></span> ias_delete_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"imp_set_delete is_ias ias_delete"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> ias_delete_rule<span class="main">)</span>
  <span class="keyword1"><span class="command">interpretation</span></span> ias<span class="main">:</span> imp_set_delete <span class="quoted">is_ias</span> <span class="quoted">ias_delete</span>
    <span class="keyword1"><span class="command">using</span></span> ias_delete_impl <span class="keyword1"><span class="command">.</span></span>

  <span class="comment1">(* Self - contained proof, for paper *)</span>  
  <span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span>
    <span class="keyword1"><span class="command">interpretation</span></span> ias<span class="main">:</span> imp_set_ins <span class="quoted">is_ias</span> <span class="quoted">ias_ins</span> <span class="keyword1"><span class="command">proof</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">s</span> <span class="skolem">p</span> <span class="skolem">a</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span>is_ias <span class="skolem">s</span> <span class="skolem">p</span><span class="main">&gt;</span> ias_ins <span class="skolem">a</span> <span class="skolem">p</span> <span class="main">&lt;</span>is_ias <span class="main">(</span>insert <span class="skolem">a</span> <span class="skolem">s</span><span class="main">)</span><span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> is_ias_def ias_ins_def
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">decon</span><span class="main"><span class="main">:</span></span> decon_if_split <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ias_ins_abs1 ias_ins_abs2<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>    

  <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"imp_set_ins is_ias ias_ins"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> ias_ins_rule<span class="main">)</span>
  
  <span class="keyword1"><span class="command">lemma</span></span> ias_ins_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"imp_set_ins is_ias ias_ins"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> ias_ins_rule<span class="main">)</span>
  <span class="keyword1"><span class="command">interpretation</span></span> ias<span class="main">:</span> imp_set_ins <span class="quoted">is_ias</span> <span class="quoted">ias_ins</span>
    <span class="keyword1"><span class="command">using</span></span> ias_ins_impl <span class="keyword1"><span class="command">.</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="From_List_GA">
<div class="head">
<h1>Theory From_List_GA</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Generic Algorithm to Generate Sets from Lists›</span></span>
<span class="keyword1"><span class="command">theory</span></span> From_List_GA
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Imp_Set_Spec.html">Imp_Set_Spec</a> <a href="Imp_List_Spec.html">Imp_List_Spec</a> <a href="Hash_Set_Impl.html">Hash_Set_Impl</a> <a href="Array_Set_Impl.html">Array_Set_Impl</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">term</span></span> <span class="quoted">fold</span>

  <span class="keyword1"><span class="command">primrec</span></span> <span class="entity">from_list_ga_aux</span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">from_list_ga_aux</span> <span class="free"><span class="bound"><span class="entity">ins</span></span></span> <span class="main">[]</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> return <span class="free"><span class="bound"><span class="entity">s</span></span></span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">from_list_ga_aux</span> <span class="free"><span class="bound"><span class="entity">ins</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> 
     <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span> <span class="bound">s</span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">ins</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">;</span> <span class="free">from_list_ga_aux</span> <span class="free"><span class="bound"><span class="entity">ins</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="bound">s</span> <span class="main">}</span>"</span></span>
 
  <span class="keyword1"><span class="command">lemma</span></span> from_list_ga_aux_rule<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"imp_set_ins <span class="free">is_set</span> <span class="free">ins</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> 
    <span class="quoted"><span class="quoted">"<span class="main">&lt;</span> <span class="free">is_set</span> <span class="free">s</span> <span class="free">p</span> <span class="main">&gt;</span> from_list_ga_aux <span class="free">ins</span> <span class="free">l</span> <span class="free">p</span> <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="free">is_set</span> <span class="main">(</span>set <span class="free">l</span> <span class="main">∪</span> <span class="free">s</span><span class="main">)</span> <span class="bound">r</span> <span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">interpret</span></span> imp_set_ins <span class="quoted"><span class="free">is_set</span></span> <span class="quoted"><span class="free">ins</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">l</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">sep_auto</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">x</span> <span class="skolem">l</span><span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> Cons.IH<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">from_list_ga</span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span> <span class="bound">s</span><span class="main">←</span><span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">;</span> from_list_ga_aux <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="bound">s</span><span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> from_list_ga_rule<span class="main">:</span>
    <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">empty</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"imp_set_empty <span class="free">is_set</span> <span class="free">empty</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> I<span class="main">:</span> <span class="quoted"><span class="quoted">"imp_set_ins <span class="free">is_set</span> <span class="free">ins</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="keyword1">emp</span><span class="main">&gt;</span> from_list_ga <span class="free">empty</span> <span class="free">ins</span> <span class="free">l</span> <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="free">is_set</span> <span class="main">(</span>set <span class="free">l</span><span class="main">)</span> <span class="bound">r</span><span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">interpret</span></span> imp_set_empty <span class="quoted"><span class="free">is_set</span></span> <span class="quoted"><span class="free">empty</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
    <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span> <span class="main">=</span> from_list_ga_aux_rule<span class="main">[</span><span class="operator">OF</span> I<span class="main">]</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> from_list_ga_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">sep_auto</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hs_from_list</span> <span class="main">≡</span> from_list_ga hs_new hs_ins"</span></span>
  <span class="keyword1"><span class="command">lemmas</span></span> hs_from_list_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span> 
    <span class="main">=</span> from_list_ga_rule<span class="main">[</span><span class="operator">OF</span> hs_new_impl hs_ins_impl<span class="main">,</span> <span class="operator">folded</span> hs_from_list_def<span class="main">]</span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">ias_from_list</span> <span class="main">≡</span> from_list_ga ias_new ias_ins"</span></span>
  <span class="keyword1"><span class="command">lemmas</span></span> ias_from_list_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span> 
    <span class="main">=</span> from_list_ga_rule<span class="main">[</span><span class="operator">OF</span> ias_empty_impl ias_ins_impl<span class="main">,</span> 
        <span class="operator">folded</span> ias_from_list_def<span class="main">]</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Sep_Examples">
<div class="head">
<h1>Theory Sep_Examples</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">theory</span></span> Sep_Examples
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="Sep_Main.html">Sep_Main</a>
  <span class="quoted">"<a href="Imp_List_Spec.html">Examples/Imp_List_Spec</a>"</span>
  <span class="quoted">"<a href="List_Seg.html">Examples/List_Seg</a>"</span> <span class="quoted">"<a href="Open_List.html">Examples/Open_List</a>"</span> <span class="quoted">"<a href="Circ_List.html">Examples/Circ_List</a>"</span>
  <span class="quoted">"<a href="Imp_Map_Spec.html">Examples/Imp_Map_Spec</a>"</span> <span class="quoted">"<a href="Hash_Map_Impl.html">Examples/Hash_Map_Impl</a>"</span> <span class="quoted">"<a href="Array_Map_Impl.html">Examples/Array_Map_Impl</a>"</span>
  <span class="quoted">"<a href="Imp_Set_Spec.html">Examples/Imp_Set_Spec</a>"</span> <span class="quoted">"<a href="Hash_Set_Impl.html">Examples/Hash_Set_Impl</a>"</span> <span class="quoted">"<a href="Array_Set_Impl.html">Examples/Array_Set_Impl</a>"</span>
  <span class="quoted">"<a href="To_List_GA.html">Examples/To_List_GA</a>"</span>
  <span class="quoted">"<a href="From_List_GA.html">Examples/From_List_GA</a>"</span>
  <span class="quoted">"<a href="Union_Find.html">Examples/Union_Find</a>"</span>
  <span class="quoted">"<a href="Idioms.html">Examples/Idioms</a>"</span>  
<span class="keyword2"><span class="keyword">begin</span></span>


<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div>