<div id="List_Inversions">
<div class="head">
<h1>Theory List_Inversions</h1>
</div>
<pre class="source"><span class="comment1">(*
  File:     List_Inversions.thy
  Author:   Manuel Eberl, TU München

  A formalisation of inversions of a list and the O(n log n) divide-and-conquer algorithm
  to count them.
*)</span>
<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹The Inversions of a List›</span></span>
<span class="keyword1"><span class="command">theory</span></span> List_Inversions
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a> <span class="quoted">"<a href="../../HOL/HOL-Library/Permutations.html">HOL-Library.Permutations</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Definition of inversions›</span></span>

<span class="keyword1"><span class="command">context</span></span> preorder
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We define inversions as pair of indices w.\,r.\,t.\ a preorder.
›</span></span>
<span class="keyword1"><span class="command">inductive_set</span></span> <span class="entity">inversions</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> <span class="main">(</span>nat <span class="main">×</span> nat<span class="main">)</span> set"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="entity">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">⟹</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">&lt;</span> length <span class="free">xs</span> <span class="main">⟹</span> less <span class="main">(</span><span class="free">xs</span> <span class="main">!</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free">xs</span> <span class="main">!</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">)</span> <span class="main">∈</span> <span class="free">inversions</span> <span class="free">xs</span>"</span></span>

<span class="keyword1" id="List_Inversions-inversions_subset"><span class="command">lemma</span></span> inversions_subset<span class="main">:</span> <span class="quoted"><span class="quoted">"inversions <span class="free">xs</span> <span class="main">⊆</span> Sigma <span class="main">{..&lt;</span>length <span class="free">xs</span><span class="main">}</span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> <span class="main">{</span><span class="bound">i</span><span class="main">&lt;..&lt;</span>length <span class="free">xs</span><span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> inversions.simps<span class="main">)</span>

<span class="keyword1" id="List_Inversions-finite_inversions"><span class="command">lemma</span></span> finite_inversions <span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>inversions <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> finite_subset<span class="main"><span class="main">[</span></span><span class="operator">OF</span> inversions_subset<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="List_Inversions-inversions_altdef"><span class="command">lemma</span></span> inversions_altdef<span class="main">:</span> <span class="quoted"><span class="quoted">"inversions <span class="free">xs</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="bound">i</span><span class="main">,</span> <span class="bound">j</span><span class="main">)</span><span class="main">.</span> <span class="bound">i</span> <span class="main">&lt;</span> <span class="bound">j</span> <span class="main">∧</span> <span class="bound">j</span> <span class="main">&lt;</span> length <span class="free">xs</span> <span class="main">∧</span> less <span class="main">(</span><span class="free">xs</span> <span class="main">!</span> <span class="bound">j</span><span class="main">)</span> <span class="main">(</span><span class="free">xs</span> <span class="main">!</span> <span class="bound">i</span><span class="main">)</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> inversions.simps<span class="main">)</span>

<span class="keyword1" id="List_Inversions-inversions_code"><span class="command">lemma</span></span> inversions_code<span class="main">:</span>
  <span class="quoted"><span class="quoted">"inversions <span class="free">xs</span> <span class="main">=</span>
     Sigma <span class="main">{..&lt;</span>length <span class="free">xs</span><span class="main">}</span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> Set.filter <span class="main">(</span><span class="main">λ</span><span class="bound">j</span><span class="main">.</span> less <span class="main">(</span><span class="free">xs</span> <span class="main">!</span> <span class="bound">j</span><span class="main">)</span> <span class="main">(</span><span class="free">xs</span> <span class="main">!</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">{</span><span class="bound">i</span><span class="main">&lt;..&lt;</span>length <span class="free">xs</span><span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> inversions_altdef<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> inversions_code

<span class="keyword1" id="List_Inversions-inversions_trivial"><span class="command">lemma</span></span> inversions_trivial <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="free">xs</span> <span class="main">≤</span> Suc <span class="main">0</span> <span class="main">⟹</span> inversions <span class="free">xs</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> inversions_altdef<span class="main">)</span>

<span class="keyword1" id="List_Inversions-inversions_imp_less"><span class="command">lemma</span></span> inversions_imp_less<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">z</span> <span class="main">∈</span> inversions <span class="free">xs</span> <span class="main">⟹</span> fst <span class="free">z</span> <span class="main">&lt;</span> snd <span class="free">z</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">z</span> <span class="main">∈</span> inversions <span class="free">xs</span> <span class="main">⟹</span> snd <span class="free">z</span> <span class="main">&lt;</span> length <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> inversions_altdef<span class="main">)</span>

<span class="keyword1" id="List_Inversions-inversions_Nil"><span class="command">lemma</span></span> inversions_Nil <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"inversions <span class="main">[]</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> inversions_altdef<span class="main">)</span>

<span class="keyword1" id="List_Inversions-inversions_Cons"><span class="command">lemma</span></span> inversions_Cons<span class="main">:</span>
  <span class="quoted"><span class="quoted">"inversions <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span>
     <span class="main">(</span><span class="main">λ</span><span class="bound">j</span><span class="main">.</span> <span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="bound">j</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span> <span class="main">`</span> <span class="main">{</span><span class="bound"><span class="bound">j</span></span><span class="main">∈</span><span class="main">{..&lt;</span>length <span class="free">xs</span><span class="main">}</span><span class="main">.</span> less <span class="main">(</span><span class="free">xs</span> <span class="main">!</span> <span class="bound">j</span><span class="main">)</span> <span class="free">x</span><span class="main">}</span> <span class="main">∪</span>
     map_prod Suc Suc <span class="main">`</span> inversions <span class="free">xs</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> inversions <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⟷</span> <span class="skolem">z</span> <span class="main">∈</span> <span class="var">?rhs</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">z</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">z</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> inversions_altdef map_prod_def nth_Cons <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> nat.splits<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The following function returns the inversions between two lists, i.\,e.\ all pairs of
  an element in the first list with an element in the second list such that the former
  is greater than the latter.
›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">inversions_between</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="main">(</span>nat <span class="main">×</span> nat<span class="main">)</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">inversions_between</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">=</span>
     <span class="main">{</span><span class="main">(</span><span class="bound"><span class="bound">i</span></span><span class="main">,</span> <span class="bound"><span class="bound">j</span></span><span class="main">)</span> <span class="main">∈</span> <span class="main">{..&lt;</span>length <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">}</span><span class="main">×</span><span class="main">{..&lt;</span>length <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">}</span><span class="main">.</span> less <span class="main">(</span><span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">!</span> <span class="bound">j</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">!</span> <span class="bound">i</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1" id="List_Inversions-finite_inversions_between"><span class="command">lemma</span></span> finite_inversions_between <span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>inversions_between <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> finite_subset<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">{..&lt;</span></span></span>length <span class="free"><span class="free"><span class="free">xs</span></span></span><span class="main"><span class="main"><span class="main">}</span></span></span> <span class="main"><span class="main"><span class="main">×</span></span></span> <span class="main"><span class="main"><span class="main">{..&lt;</span></span></span>length <span class="free"><span class="free"><span class="free">xs</span></span></span> <span class="main"><span class="main"><span class="main">+</span></span></span> length <span class="free"><span class="free"><span class="free">ys</span></span></span><span class="main"><span class="main"><span class="main">}</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
       <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> inversions_between_def<span class="main">)</span>

<span class="keyword1" id="List_Inversions-inversions_between_Nil"><span class="command">lemma</span></span> inversions_between_Nil <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"inversions_between <span class="main">[]</span> <span class="free">ys</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="quoted"><span class="quoted">"inversions_between <span class="free">xs</span> <span class="main">[]</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inversions_between_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We can now show the following equality for the inversions of the concatenation of two lists:
›</span></span>
<span class="keyword1"><span class="command">proposition</span></span> inversions_append<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">xs</span> <span class="free">ys</span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">≡</span> length <span class="free">xs</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">≡</span> length <span class="free">ys</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"inversions <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span>
           inversions <span class="free">xs</span> <span class="main">∪</span> map_prod <span class="main">(</span><span class="main">(+)</span> <span class="free">m</span><span class="main">)</span> <span class="main">(</span><span class="main">(+)</span> <span class="free">m</span><span class="main">)</span> <span class="main">`</span> inversions <span class="free">ys</span> <span class="main">∪</span>
           map_prod id <span class="main">(</span><span class="main">(+)</span> <span class="free">m</span><span class="main">)</span> <span class="main">`</span> inversions_between <span class="free">xs</span> <span class="free">ys</span>"</span></span>
        <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">note</span></span> defs <span class="main">=</span> inversions_altdef inversions_between_def m_def n_def map_prod_def
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> inversions <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span> <span class="main">⟷</span> <span class="skolem">z</span> <span class="main">∈</span> <span class="var">?rhs</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">z</span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> inversions <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">i</span></span> <span class="skolem"><span class="skolem">j</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">i</span><span class="main">,</span> <span class="skolem">j</span><span class="main">)</span>"</span></span>
                      <span class="keyword2"><span class="keyword">and</span></span> ij<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> <span class="skolem">j</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">&lt;</span> <span class="free">m</span> <span class="main">+</span> <span class="free">n</span>"</span></span> <span class="quoted"><span class="quoted">"less <span class="main">(</span><span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span> <span class="main">!</span> <span class="skolem">j</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span> <span class="main">!</span> <span class="skolem">i</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">z</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> inversions_altdef m_def n_def<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> ij <span class="keyword1"><span class="command">consider</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">&lt;</span> <span class="free">m</span>"</span></span> <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">≥</span> <span class="free">m</span>"</span></span> <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> <span class="free">m</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">≥</span> <span class="free">m</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">linarith</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> <span class="var">?rhs</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> <span class="free">m</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">≥</span> <span class="free">m</span>"</span></span>
      <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">j'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j'</span> <span class="main">=</span> <span class="skolem">j</span> <span class="main">-</span> <span class="free">m</span>"</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">=</span> <span class="free">m</span> <span class="main">+</span> <span class="skolem">j'</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">j</span> <span class="main">≥</span> <span class="free">m</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> j'_def<span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> ij <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">i</span> <span class="main">&lt;</span> <span class="free">m</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> inversions_altdef map_prod_def inversions_between_def nth_append m_def n_def<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">≥</span> <span class="free">m</span>"</span></span>
      <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">i'</span></span> <span class="skolem"><span class="skolem">j'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i'</span> <span class="main">=</span> <span class="skolem">i</span> <span class="main">-</span> <span class="free">m</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j'</span> <span class="main">=</span> <span class="skolem">j</span> <span class="main">-</span> <span class="free">m</span>"</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">=</span> <span class="free">m</span> <span class="main">+</span> <span class="skolem">i'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">=</span> <span class="free">m</span> <span class="main">+</span> <span class="skolem">j'</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">i</span> <span class="main">&lt;</span> <span class="skolem">j</span>›</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">i</span> <span class="main">≥</span> <span class="free">m</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> i'_def j'_def<span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> ij <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> inversions_altdef map_prod_def nth_append m_def n_def<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">use</span> ij <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="quoted">‹<span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main">:</span> nth_append defs›</span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> nth_append defs<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Counting inversions›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We now define versions of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> inversions<span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> inversions_between<span class="antiquote"><span class="antiquote">}</span></span></span></span> that
  only return the <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">∗</span></span>‹number›</span></span> of inversions.
›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">inversion_number</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">inversion_number</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> card <span class="main">(</span>inversions <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">inversion_number_between</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">inversion_number_between</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">=</span> card <span class="main">(</span>inversions_between <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="List_Inversions-inversions_between_code"><span class="command">lemma</span></span> inversions_between_code<span class="main">:</span>
  <span class="quoted"><span class="quoted">"inversions_between <span class="free">xs</span> <span class="free">ys</span> <span class="main">=</span>
     Set.filter <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">i</span><span class="main">,</span><span class="bound">j</span><span class="main">)</span><span class="main">.</span> less <span class="main">(</span><span class="free">ys</span> <span class="main">!</span> <span class="bound">j</span><span class="main">)</span> <span class="main">(</span><span class="free">xs</span> <span class="main">!</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">{..&lt;</span>length <span class="free">xs</span><span class="main">}</span><span class="main">×</span><span class="main">{..&lt;</span>length <span class="free">ys</span><span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> inversions_between_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> inversions_between_code

<span class="keyword1" id="List_Inversions-inversion_number_Nil"><span class="command">lemma</span></span> inversion_number_Nil <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"inversion_number <span class="main">[]</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inversion_number_def<span class="main">)</span>

<span class="keyword1" id="List_Inversions-inversion_number_trivial"><span class="command">lemma</span></span> inversion_number_trivial <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="free">xs</span> <span class="main">≤</span> Suc <span class="main">0</span> <span class="main">⟹</span> inversion_number <span class="free">xs</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> inversion_number_def<span class="main">)</span>

<span class="keyword1" id="List_Inversions-inversion_number_between_Nil"><span class="command">lemma</span></span> inversion_number_between_Nil <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"inversion_number_between <span class="main">[]</span> <span class="free">ys</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="quoted"><span class="quoted">"inversion_number_between <span class="free">xs</span> <span class="main">[]</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inversion_number_between_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We again get the following nice equation for the number of inversions of a concatenation:
›</span></span>
<span class="keyword1"><span class="command">proposition</span></span> inversion_number_append<span class="main">:</span>
  <span class="quoted"><span class="quoted">"inversion_number <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span>
     inversion_number <span class="free">xs</span> <span class="main">+</span> inversion_number <span class="free">ys</span> <span class="main">+</span> inversion_number_between <span class="free">xs</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">m</span></span> <span class="skolem"><span class="skolem">n</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">=</span> length <span class="free">xs</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">=</span> length <span class="free">ys</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?A</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"inversions <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?B</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"map_prod <span class="main">(</span><span class="main">(+)</span> <span class="skolem">m</span><span class="main">)</span> <span class="main">(</span><span class="main">(+)</span> <span class="skolem">m</span><span class="main">)</span> <span class="main">`</span> inversions <span class="free">ys</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?C</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"map_prod id <span class="main">(</span><span class="main">(+)</span> <span class="skolem">m</span><span class="main">)</span> <span class="main">`</span> inversions_between <span class="free">xs</span> <span class="free">ys</span>"</span></span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"inversion_number <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> card <span class="main">(</span><span class="var">?A</span> <span class="main">∪</span> <span class="var">?B</span> <span class="main">∪</span> <span class="var">?C</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inversion_number_def inversions_append m_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> card <span class="main">(</span><span class="var">?A</span> <span class="main">∪</span> <span class="var">?B</span><span class="main">)</span> <span class="main">+</span> card <span class="var">?C</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> card_Un_disjoint finite_inversions finite_inversions_between finite_UnI finite_imageI<span class="main">)</span>
       <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> inversions_altdef inversions_between_def m_def n_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span><span class="var">?A</span> <span class="main">∪</span> <span class="var">?B</span><span class="main">)</span> <span class="main">=</span> inversion_number <span class="free">xs</span> <span class="main">+</span> card <span class="var">?B</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> inversion_number_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> card_Un_disjoint finite_inversions finite_UnI finite_imageI<span class="main">)</span>
       <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> inversions_altdef m_def n_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="var">?B</span> <span class="main">=</span> inversion_number <span class="free">ys</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> inversion_number_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> card_image<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> map_prod_def inj_on_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="var">?C</span> <span class="main">=</span> inversion_number_between <span class="free">xs</span> <span class="free">ys</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> inversion_number_between_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> card_image inj_onI<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> map_prod_def<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Stability of inversions between lists under permutations›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  A crucial fact for counting list inversions with merge sort is that the number
  of inversions <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">∗</span></span>‹between›</span></span> two lists does not change when the lists are permuted. This is
  true because the set of inversions commutes with the act of permuting the list:
›</span></span>
<span class="keyword1" id="List_Inversions-inversions_between_permute1"><span class="command">lemma</span></span> inversions_between_permute1<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">π</span> <span class="keyword1">permutes</span> <span class="main">{..&lt;</span>length <span class="free">xs</span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"inversions_between <span class="main">(</span>permute_list <span class="free">π</span> <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span> <span class="main">=</span>
             map_prod <span class="main">(</span>inv <span class="free">π</span><span class="main">)</span> id <span class="main">`</span> inversions_between <span class="free">xs</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">π</span> <span class="skolem">i</span> <span class="main">&lt;</span> length <span class="free">xs</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> length <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">π</span> <span class="keyword1">permutes</span> <span class="main">{..&lt;</span>length <span class="free">xs</span><span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">i</span> <span class="skolem">π</span>
    <span class="keyword1"><span class="command">using</span></span> permutes_in_image<span class="main">[</span><span class="operator">OF</span> that<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span> that <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"inv <span class="free">π</span> <span class="keyword1">permutes</span> <span class="main">{..&lt;</span>length <span class="free">xs</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> permutes_inv<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> assms * <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> inversions_between_def map_prod_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> image_iff permute_list_nth permutes_inverses <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> exI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted">"<span class="free">π</span> <span class="skolem">i</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">for</span></span></span></span> <span class="skolem">i</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="List_Inversions-inversions_between_permute2"><span class="command">lemma</span></span> inversions_between_permute2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">π</span> <span class="keyword1">permutes</span> <span class="main">{..&lt;</span>length <span class="free">ys</span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"inversions_between <span class="free">xs</span> <span class="main">(</span>permute_list <span class="free">π</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span>
             map_prod id <span class="main">(</span>inv <span class="free">π</span><span class="main">)</span> <span class="main">`</span> inversions_between <span class="free">xs</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">π</span> <span class="skolem">i</span> <span class="main">&lt;</span> length <span class="free">ys</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> length <span class="free">ys</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">π</span> <span class="keyword1">permutes</span> <span class="main">{..&lt;</span>length <span class="free">ys</span><span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">i</span> <span class="skolem">π</span>
    <span class="keyword1"><span class="command">using</span></span> permutes_in_image<span class="main">[</span><span class="operator">OF</span> that<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span> that <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"inv <span class="free">π</span> <span class="keyword1">permutes</span> <span class="main">{..&lt;</span>length <span class="free">ys</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> permutes_inv<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> assms * <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> inversions_between_def map_prod_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> image_iff permute_list_nth permutes_inverses <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> exI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted">"<span class="free">π</span> <span class="skolem">i</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">for</span></span></span></span> <span class="skolem">i</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">proposition</span></span> inversions_between_permute<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">π1</span> <span class="keyword1">permutes</span> <span class="main">{..&lt;</span>length <span class="free">xs</span><span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">π2</span> <span class="keyword1">permutes</span> <span class="main">{..&lt;</span>length <span class="free">ys</span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"inversions_between <span class="main">(</span>permute_list <span class="free">π1</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>permute_list <span class="free">π2</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span>
             map_prod <span class="main">(</span>inv <span class="free">π1</span><span class="main">)</span> <span class="main">(</span>inv <span class="free">π2</span><span class="main">)</span> <span class="main">`</span> inversions_between <span class="free">xs</span> <span class="free">ys</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inversions_between_permute1 inversions_between_permute2 assms
                map_prod_def image_image case_prod_unfold<span class="main">)</span>

<span class="keyword1"><span class="command">corollary</span></span> inversion_number_between_permute<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">π1</span> <span class="keyword1">permutes</span> <span class="main">{..&lt;</span>length <span class="free">xs</span><span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">π2</span> <span class="keyword1">permutes</span> <span class="main">{..&lt;</span>length <span class="free">ys</span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"inversion_number_between <span class="main">(</span>permute_list <span class="free">π1</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>permute_list <span class="free">π2</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span>
             inversion_number_between <span class="free">xs</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"inversion_number_between <span class="main">(</span>permute_list <span class="free">π1</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>permute_list <span class="free">π2</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span>
          card <span class="main">(</span>map_prod <span class="main">(</span>inv <span class="free">π1</span><span class="main">)</span> <span class="main">(</span>inv <span class="free">π2</span><span class="main">)</span> <span class="main">`</span> inversions_between <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inversion_number_between_def inversions_between_permute assms<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> inversion_number_between <span class="free">xs</span> <span class="free">ys</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> inversion_number_between_def <span class="keyword1"><span class="command">using</span></span> assms<span class="main">[</span><span class="operator">THEN</span> permutes_inj_on<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator"><span class="operator">OF</span></span> permutes_inv<span class="main"><span class="main"><span class="main">]</span></span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> card_image inj_onI<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> map_prod_def<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The following form of the above theorem is nicer to apply since it has the form of a 
  congruence rule.
›</span></span>
<span class="keyword1"><span class="command">corollary</span></span> inversion_number_between_cong_mset<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"mset <span class="free">xs</span> <span class="main">=</span> mset <span class="free">xs'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"mset <span class="free">ys</span> <span class="main">=</span> mset <span class="free">ys'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"inversion_number_between <span class="free">xs</span> <span class="free">ys</span> <span class="main">=</span> inversion_number_between <span class="free">xs'</span> <span class="free">ys'</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">π1</span></span> <span class="skolem"><span class="skolem">π2</span></span> <span class="keyword2"><span class="keyword">where</span></span> π12<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">π1</span> <span class="keyword1">permutes</span> <span class="main">{..&lt;</span>length <span class="free">xs'</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> permute_list <span class="skolem">π1</span> <span class="free">xs'</span>"</span></span>
                          <span class="quoted"><span class="quoted">"<span class="skolem">π2</span> <span class="keyword1">permutes</span> <span class="main">{..&lt;</span>length <span class="free">ys'</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">ys</span> <span class="main">=</span> permute_list <span class="skolem">π2</span> <span class="free">ys'</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms<span class="main">[</span><span class="operator">THEN</span> mset_eq_permutation<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inversion_number_between_permute<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Inversions between sorted lists›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Another fact that is crucial to the efficient computation of the inversion number is this:
  If we have two sorted lists, we can reduce computing the inversions by inspecting the 
  first elements and deleting one of them.
›</span></span>
<span class="keyword1" id="List_Inversions-inversions_between_Cons_Cons"><span class="command">lemma</span></span> inversions_between_Cons_Cons<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"sorted_wrt less_eq <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"sorted_wrt less_eq <span class="main">(</span><span class="free">y</span> <span class="main">#</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"inversions_between <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span><span class="free">y</span> <span class="main">#</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span>
             <span class="main">(</span><span class="keyword1">if</span> <span class="main">¬</span>less <span class="free">y</span> <span class="free">x</span> <span class="keyword1">then</span>
                map_prod Suc id <span class="main">`</span> inversions_between <span class="free">xs</span> <span class="main">(</span><span class="free">y</span> <span class="main">#</span> <span class="free">ys</span><span class="main">)</span>
              <span class="keyword1">else</span>
                <span class="main">{..&lt;</span>length <span class="main">(</span><span class="free">x</span><span class="main">#</span><span class="free">xs</span><span class="main">)</span><span class="main">}</span> <span class="main">×</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span> <span class="main">∪</span>
                map_prod id Suc <span class="main">`</span> inversions_between <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms  <span class="keyword1"><span class="command">unfolding</span></span> inversions_between_def map_prod_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main"><span class="keyword3">,</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> set_conv_nth nth_Cons less_le_not_le image_iff 
                  <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> order_trans <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> nat.splits<span class="main">)</span><span class="main"><span class="keyword3">?</span></span><span class="main">)</span>
  <span class="comment1">(* A bit fragile, but doing this manually is annoying *)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  This leads to the following analogous equation for counting the inversions between two
  sorted lists. Note that a single step of this only takes constant time (assuming we 
  pre-computed the lengths of the lists) so that the entire function runs in linear time.
›</span></span>
<span class="keyword1" id="List_Inversions-inversion_number_between_Cons_Cons"><span class="command">lemma</span></span> inversion_number_between_Cons_Cons<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"sorted_wrt less_eq <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"sorted_wrt less_eq <span class="main">(</span><span class="free">y</span> <span class="main">#</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"inversion_number_between <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span><span class="free">y</span> <span class="main">#</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span>
             <span class="main">(</span><span class="keyword1">if</span> <span class="main">¬</span>less <span class="free">y</span> <span class="free">x</span> <span class="keyword1">then</span>
                inversion_number_between <span class="free">xs</span> <span class="main">(</span><span class="free">y</span> <span class="main">#</span> <span class="free">ys</span><span class="main">)</span>
              <span class="keyword1">else</span>
                inversion_number_between <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span> <span class="main">+</span> length <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"less <span class="free">y</span> <span class="free">x</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"inversion_number_between <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span><span class="free">y</span> <span class="main">#</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> 
           card <span class="main">(</span>map_prod Suc id <span class="main">`</span> inversions_between <span class="free">xs</span> <span class="main">(</span><span class="free">y</span> <span class="main">#</span> <span class="free">ys</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inversion_number_between_def inversions_between_Cons_Cons<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> inversion_number_between <span class="free">xs</span> <span class="main">(</span><span class="free">y</span> <span class="main">#</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> inversion_number_between_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> card_image inj_onI<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> map_prod_def<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> False <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"inversion_number_between <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span><span class="free">y</span> <span class="main">#</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span>
           card <span class="main">(</span><span class="main">{..&lt;</span>length <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span><span class="main">}</span> <span class="main">×</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span> <span class="main">∪</span> map_prod id Suc <span class="main">`</span> inversions_between <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inversion_number_between_def inversions_between_Cons_Cons<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> length <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">+</span> card <span class="main">(</span>map_prod id Suc <span class="main">`</span> inversions_between <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> card_Un_disjoint<span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>map_prod id Suc <span class="main">`</span> inversions_between <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span>
               inversion_number_between <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> inversion_number_between_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> card_image inj_onI<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> map_prod_def<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> True <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We now define a function to compute the inversion number between two lists that are
  assumed to be sorted using the equalities we just derived.
›</span></span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">inversion_number_between_sorted</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">inversion_number_between_sorted</span> <span class="main">[]</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">=</span> <span class="main">0</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">inversion_number_between_sorted</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">[]</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">inversion_number_between_sorted</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span> <span class="main">=</span>
             <span class="main">(</span><span class="keyword1">if</span> <span class="main">¬</span>less <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">then</span>
                <span class="free">inversion_number_between_sorted</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span>
              <span class="keyword1">else</span>
                <span class="free">inversion_number_between_sorted</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">+</span> length <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">theorem</span></span> inversion_number_between_sorted_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"sorted_wrt less_eq <span class="free">xs</span> <span class="main">⟹</span> sorted_wrt less_eq <span class="free">ys</span> <span class="main">⟹</span>
     inversion_number_between_sorted <span class="free">xs</span> <span class="free">ys</span> <span class="main">=</span> inversion_number_between <span class="free">xs</span> <span class="free">ys</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> inversion_number_between_sorted.induct<span class="main">)</span>
     <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inversion_number_between_Cons_Cons<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Merge sort›</span></span>

<span class="comment1">(* TODO: Could be replaced by mergesort from HOL-Library in Isabelle 2019. *)</span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  For convenience, we first define a simple merge sort that does not compute the inversions.
  At this point, we need to start assuming a linear ordering since the merging function
  does not work otherwise.
›</span></span>

<span class="keyword1"><span class="command">context</span></span> linorder
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">split_list</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">split_list</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">n</span> <span class="main">=</span> length <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">div</span> <span class="numeral">2</span> <span class="keyword1">in</span> <span class="main">(</span>take <span class="bound">n</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">,</span> drop <span class="bound">n</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">merge_lists</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">merge_lists</span> <span class="main">[]</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">merge_lists</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">[]</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">merge_lists</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span> <span class="main">=</span>
    <span class="main">(</span><span class="keyword1">if</span> less_eq <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free">merge_lists</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">#</span> <span class="free">merge_lists</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="List_Inversions-set_merge_lists"><span class="command">lemma</span></span> set_merge_lists <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>merge_lists <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> set <span class="free">xs</span> <span class="main">∪</span> set <span class="free">ys</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> merge_lists.induct<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="List_Inversions-mset_merge_lists"><span class="command">lemma</span></span> mset_merge_lists <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"mset <span class="main">(</span>merge_lists <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> mset <span class="free">xs</span> <span class="main">+</span> mset <span class="free">ys</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> merge_lists.induct<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="List_Inversions-sorted_merge_lists"><span class="command">lemma</span></span> sorted_merge_lists <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"sorted <span class="free">xs</span> <span class="main">⟹</span> sorted <span class="free">ys</span> <span class="main">⟹</span> sorted <span class="main">(</span>merge_lists <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> merge_lists.induct<span class="main">)</span> <span class="operator">auto</span>


<span class="keyword1"><span class="command">fun</span></span> <span class="entity">merge_sort</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">merge_sort</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span>
    <span class="main">(</span><span class="keyword1">if</span> length <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">≤</span> <span class="main">1</span> <span class="keyword1">then</span>
       <span class="free"><span class="bound"><span class="entity">xs</span></span></span> 
     <span class="keyword1">else</span>
       merge_lists <span class="main">(</span><span class="free">merge_sort</span> <span class="main">(</span>take <span class="main">(</span>length <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">div</span> <span class="numeral">2</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span><span class="main">)</span>
                   <span class="main">(</span><span class="free">merge_sort</span> <span class="main">(</span>drop <span class="main">(</span>length <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">div</span> <span class="numeral">2</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span> <span class="main">=</span> merge_sort.simps

<span class="keyword1" id="List_Inversions-merge_sort_trivial"><span class="command">lemma</span></span> merge_sort_trivial <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="free">xs</span> <span class="main">≤</span> Suc <span class="main">0</span> <span class="main">⟹</span> merge_sort <span class="free">xs</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> merge_sort.simps<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">theorem</span></span> mset_merge_sort <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"mset <span class="main">(</span>merge_sort <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> mset <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> merge_sort.induct<span class="main">)</span>
     <span class="main">(</span><span class="operator">subst</span> merge_sort.simps<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">flip</span><span class="main"><span class="main">:</span></span> mset_append<span class="main">)</span>

<span class="keyword1"><span class="command">corollary</span></span> set_merge_sort <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>merge_sort <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> set <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> mset_eq_setD<span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">theorem</span></span> sorted_merge_sort <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"sorted <span class="main">(</span>merge_sort <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> merge_sort.induct<span class="main">)</span>
     <span class="main">(</span><span class="operator">subst</span> merge_sort.simps<span class="main"><span class="keyword3">,</span></span> <span class="operator">use</span> sorted01 <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="List_Inversions-inversion_number_between_code"><span class="command">lemma</span></span> inversion_number_between_code<span class="main">:</span>
  <span class="quoted"><span class="quoted">"inversion_number_between <span class="free">xs</span> <span class="free">ys</span> <span class="main">=</span> inversion_number_between_sorted <span class="main">(</span>sort <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>sort <span class="free">ys</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> inversion_number_between_sorted_correct<span class="main">)</span>
     <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sorted_sorted_wrt <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> inversion_number_between_cong_mset<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">]</span> <span class="main">=</span> inversion_number_between_code


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Merge sort with inversion counting›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Finally, we can put together all the components and define a variant of merge sort that
  counts the number of inversions in the original list:
›</span></span>
<span class="keyword1"><span class="command">function</span></span> <span class="entity">sort_and_count_inversions</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">×</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">sort_and_count_inversions</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span>
     <span class="main">(</span><span class="keyword1">if</span> length <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">≤</span> <span class="main">1</span> <span class="keyword1">then</span>
        <span class="main">(</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">,</span> <span class="main">0</span><span class="main">)</span>
      <span class="keyword1">else</span>
        <span class="keyword1">let</span> <span class="main">(</span><span class="bound">xs1</span><span class="main">,</span> <span class="bound">xs2</span><span class="main">)</span> <span class="main">=</span> split_list <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">;</span>
            <span class="main">(</span><span class="bound">xs1'</span><span class="main">,</span> <span class="bound">m</span><span class="main">)</span> <span class="main">=</span> <span class="free">sort_and_count_inversions</span> <span class="bound">xs1</span><span class="main">;</span>
            <span class="main">(</span><span class="bound">xs2'</span><span class="main">,</span> <span class="bound">n</span><span class="main">)</span> <span class="main">=</span> <span class="free">sort_and_count_inversions</span> <span class="bound">xs2</span>
        <span class="keyword1">in</span>
            <span class="main">(</span>merge_lists <span class="bound">xs1'</span> <span class="bound">xs2'</span><span class="main">,</span> <span class="bound">m</span> <span class="main">+</span> <span class="bound">n</span> <span class="main">+</span> inversion_number_between_sorted <span class="bound">xs1'</span> <span class="bound">xs2'</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">termination</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">relation</span> <span class="quoted"><span class="quoted">"measure length"</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> split_list_def Let_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span> <span class="main">=</span> sort_and_count_inversions.simps


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The projection of this function to the first component is simply the standard merge sort
  algorithm that we defined and proved correct before.
›</span></span>
<span class="keyword1"><span class="command">theorem</span></span> fst_sort_and_count_inversions <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"fst <span class="main">(</span>sort_and_count_inversions <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> merge_sort <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> length_induct<span class="main">)</span>
     <span class="main">(</span><span class="operator">subst</span> sort_and_count_inversions.simps<span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> merge_sort.simps<span class="main"><span class="keyword3">,</span></span>
      <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_list_def case_prod_unfold Let_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The projection to the second component is the inversion number.
›</span></span>
<span class="keyword1"><span class="command">theorem</span></span> snd_sort_and_count_inversions <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"snd <span class="main">(</span>sort_and_count_inversions <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> inversion_number <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> length_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">xs</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"length <span class="skolem">xs</span> <span class="main">≤</span> <span class="main">1</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> take <span class="main">(</span>length <span class="skolem">xs</span> <span class="keyword1">div</span> <span class="numeral">2</span><span class="main">)</span> <span class="skolem">xs</span> <span class="main">@</span> drop <span class="main">(</span>length <span class="skolem">xs</span> <span class="keyword1">div</span> <span class="numeral">2</span><span class="main">)</span> <span class="skolem">xs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"inversion_number <span class="main">…</span> <span class="main">=</span> snd <span class="main">(</span>sort_and_count_inversions <span class="skolem">xs</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> inversion_number_append<span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> sort_and_count_inversions.simps<span class="main">)</span>
         <span class="main">(</span><span class="operator">use</span> False 1 <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="quoted">‹<span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main">:</span> Let_def split_list_def case_prod_unfold 
                                     inversion_number_between_sorted_correct
                                     sorted_sorted_wrt <span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
                               <span class="quasi_keyword">cong</span><span class="main">:</span> inversion_number_between_cong_mset›</span><span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sort_and_count_inversions.simps<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">]</span> <span class="main">=</span> snd_sort_and_count_inversions <span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div>