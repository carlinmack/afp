<div id="Linorder_Helper">
<div class="head">
<h1>Theory Linorder_Helper</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">text_raw</span></span><span class="quoted"><span class="plain_text">‹\section*{Sorting a list by two keys}›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Linorder_Helper
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Sorting is fun...›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The problem is that Isabelle does not have anything like \texttt{sortBy}, only <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> sort_key<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
This means that there is no way to sort something based on two properties, with one being infinitely more important.›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Enter this:›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> linord_helper <span class="main">=</span> LinordHelper <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="tfree"><span class="quoted"><span class="tfree">'b</span></span></span>

<span class="keyword1"><span class="command">instantiation</span></span> linord_helper <span class="main">::</span> <span class="main">(</span><span class="quoted">linorder</span><span class="main">,</span> <span class="quoted">linorder</span><span class="main">)</span> <span class="quoted">linorder</span>
<span class="keyword2"><span class="keyword">begin</span></span>                                  
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">linord_helper_less_eq1</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="keyword1">of</span> LinordHelper <span class="bound">a1</span> <span class="bound">a2</span> <span class="main">⇒</span> <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="keyword1">of</span> LinordHelper <span class="bound">b1</span> <span class="bound">b2</span> <span class="main">⇒</span> <span class="bound">a1</span> <span class="main">&lt;</span> <span class="bound">b1</span> <span class="main">∨</span> <span class="bound">a1</span> <span class="main">=</span> <span class="bound">b1</span> <span class="main">∧</span> <span class="bound">a2</span> <span class="main">≤</span> <span class="bound">b2</span><span class="main">)</span>"</span></span>
	<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">⟷</span> linord_helper_less_eq1 <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span>"</span></span>
	<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">≠</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">∧</span> linord_helper_less_eq1 <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> linord_helper_less_eq1_def less_eq_linord_helper_def less_linord_helper_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> linord_helper.splits<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> linord_helper_less <span class="main">=</span> less_linord_helper_def linord_helper_less_eq1_def
<span class="keyword1"><span class="command">lemmas</span></span> linord_helper_le <span class="main">=</span> less_eq_linord_helper_def linord_helper_less_eq1_def

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Now, it is possible to use <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"sort_key <span class="free"><span class="free">f</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, 
with <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">f</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> constructing a <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> LinordHelper<span class="antiquote"><span class="antiquote">}</span></span></span></span> containing the two desired properties for sorting.›</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Routing_Table">
<div class="head">
<h1>Theory Routing_Table</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Routing Table›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Routing_Table
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../IP_Addresses/Prefix_Match.html">IP_Addresses.Prefix_Match</a>
        <a href="../IP_Addresses/IPv4.html">IP_Addresses.IPv4</a> <a href="../IP_Addresses/IPv6.html">IP_Addresses.IPv6</a>
        <a href="Linorder_Helper.html">Linorder_Helper</a>
        <a href="../IP_Addresses/Prefix_Match_toString.html">IP_Addresses.Prefix_Match_toString</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹This section makes the necessary definitions to work with a routing table using longest prefix matching.›</span></span>
<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Definition›</span></span>

<span class="keyword1"><span class="command">record</span></span><span class="main">(</span><span class="keyword2"><span class="keyword">overloaded</span></span><span class="main">)</span> <span class="tfree">'i</span> routing_action <span class="main">=</span> 
  output_iface <span class="main">::</span> <span class="quoted">string</span>
  next_hop <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'i</span> word option"</span></span> <span class="comment1">(* no next hop iff locally attached *)</span>

<span class="comment1">(* Routing rule matching ip route unicast type *)</span>
<span class="keyword1"><span class="command">record</span></span><span class="main">(</span><span class="keyword2"><span class="keyword">overloaded</span></span><span class="main">)</span> <span class="tfree">'i</span> routing_rule <span class="main">=</span>
  routing_match <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'i</span><span class="main">::</span>len<span class="main">)</span> prefix_match"</span></span> <span class="comment1">(* done on the dst *)</span>
  metric <span class="main">::</span> <span class="quoted">nat</span>
  routing_action <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'i</span> routing_action"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹This definition is engineered to model routing tables on packet forwarding devices.
It eludes, e.g., the source address hint, which is only relevant for packets originating from the device itself.›</span></span>
<span class="comment1">(* See also: http://linux-ip.net/html/routing-saddr-selection.html *)</span>

<span class="keyword1"><span class="command">context</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">default_metric</span> <span class="main">=</span> <span class="main">0</span>"</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'i</span> prefix_routing <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'i</span> routing_rule<span class="main">)</span> list"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">routing_oiface</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">≡</span> output_iface <span class="main">(</span>routing_action <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span>"</span></span> <span class="comment1">(* I needed this a lot... *)</span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">routing_prefix</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">≡</span> pfxm_length <span class="main">(</span>routing_match <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">valid_prefixes</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">valid_prefixes</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">=</span> foldr conj <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">rr</span><span class="main">.</span> valid_prefix <span class="main">(</span>routing_match <span class="bound">rr</span><span class="main">)</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> True"</span></span>
<span class="keyword1"><span class="command">lemma</span></span> valid_prefixes_split<span class="main">:</span> <span class="quoted"><span class="quoted">"valid_prefixes <span class="main">(</span><span class="free">r</span><span class="main">#</span><span class="free">rs</span><span class="main">)</span> <span class="main">⟹</span> valid_prefix <span class="main">(</span>routing_match <span class="free">r</span><span class="main">)</span> <span class="main">∧</span> valid_prefixes <span class="free">rs</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> valid_prefixes_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>

<span class="keyword1"><span class="command">lemma</span></span> foldr_True_set<span class="main">:</span> <span class="quoted"><span class="quoted">"foldr <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">(∧)</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="free">l</span> True <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> set <span class="free">l</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">l</span></span><span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">lemma</span></span> valid_prefixes_alt_def<span class="main">:</span> <span class="quoted"><span class="quoted">"valid_prefixes <span class="free">r</span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">e</span> <span class="main">∈</span> set <span class="free">r</span><span class="main">.</span> valid_prefix <span class="main">(</span>routing_match <span class="bound">e</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> valid_prefixes_def
  <span class="keyword1"><span class="command">unfolding</span></span> foldr_map
  <span class="keyword1"><span class="command">unfolding</span></span> comp_def
  <span class="keyword1"><span class="command">unfolding</span></span> foldr_True_set
  <span class="keyword1"><span class="command">..</span></span>
  
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">has_default_route</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'i</span><span class="main">::</span>len<span class="main">)</span> prefix_routing <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">has_default_route</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">rs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span>pfxm_length <span class="main">(</span>routing_match <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span> <span class="main">∨</span> <span class="free">has_default_route</span> <span class="free"><span class="bound"><span class="entity">rs</span></span></span><span class="main">)</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">has_default_route</span> Nil <span class="main">=</span> False"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> has_default_route_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"has_default_route <span class="free">rt</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">r</span> <span class="main">∈</span> set <span class="free">rt</span><span class="main">.</span> pfxm_length <span class="main">(</span>routing_match <span class="bound">r</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">rt</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Single Packet Semantics›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">routing_table_semantics</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'i</span><span class="main">::</span>len<span class="main">)</span> prefix_routing <span class="main">⇒</span> <span class="tfree">'i</span> word <span class="main">⇒</span> <span class="tfree">'i</span> routing_action"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">routing_table_semantics</span> <span class="main">[]</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> routing_action <span class="main">(</span>undefined<span class="main">::</span><span class="tfree">'i</span> routing_rule<span class="main">)</span>"</span></span> <span class="main">|</span> 
<span class="quoted"><span class="quoted">"<span class="free">routing_table_semantics</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">rs</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> prefix_match_semantics <span class="main">(</span>routing_match <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="keyword1">then</span> routing_action <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="keyword1">else</span> <span class="free">routing_table_semantics</span> <span class="free"><span class="bound"><span class="entity">rs</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">lemma</span></span> routing_table_semantics_ports_from_table<span class="main">:</span> <span class="quoted"><span class="quoted">"valid_prefixes <span class="free">rtbl</span> <span class="main">⟹</span> has_default_route <span class="free">rtbl</span> <span class="main">⟹</span> 
  routing_table_semantics <span class="free">rtbl</span> <span class="free">packet</span> <span class="main">=</span> <span class="free">r</span> <span class="main">⟹</span> <span class="free">r</span> <span class="main">∈</span> routing_action <span class="main">`</span> set <span class="free">rtbl</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">rtbl</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">r</span> <span class="skolem">rs</span><span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> v_pfxs <span class="main">=</span> valid_prefixes_split<span class="main">[</span><span class="operator">OF</span> Cons.prems<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"pfxm_length <span class="main">(</span>routing_match <span class="skolem">r</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True                                                 
    <span class="keyword1"><span class="command">note</span></span> zero_prefix_match_all<span class="main">[</span><span class="operator">OF</span> conjunct1<span class="main"><span class="main">[</span></span><span class="operator">OF</span> v_pfxs<span class="main"><span class="main">]</span></span> True<span class="main">]</span> Cons.prems<span class="main">(</span>3<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"has_default_route <span class="skolem">rs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Cons.prems<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> Cons.IH<span class="main">[</span><span class="operator">OF</span> conjunct2<span class="main"><span class="main">[</span></span><span class="operator">OF</span> v_pfxs<span class="main"><span class="main">]</span></span> this<span class="main">]</span> Cons.prems<span class="main">(</span>3<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Longest Prefix Match›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹We can abuse <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> LinordHelper<span class="antiquote"><span class="antiquote">}</span></span></span></span> to sort.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">routing_rule_sort_key</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">r</span><span class="main">.</span> LinordHelper <span class="main">(</span><span class="main">0</span> <span class="main">-</span> <span class="main">(</span>of_nat <span class="main">::</span> nat <span class="main">⇒</span> int<span class="main">)</span> <span class="main">(</span>pfxm_length <span class="main">(</span>routing_match <span class="bound">r</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>metric <span class="bound">r</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹There is actually a slight design choice here. We can choose to sort based on <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> less_eq_prefix_match_def<span class="antiquote"><span class="antiquote">}</span></span></span></span> (thus including the address) or only the prefix length (excluding it).
  Which is taken does not matter gravely, since the bits of the prefix can't matter. They're either eqal or the rules don't overlap and the metric decides. (It does matter for the resulting list though.)
  Ignoring the prefix and taking only its length is slightly easier.›</span></span>

<span class="comment1">(*example: get longest prefix match by sorting by pfxm_length*)</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">rr_ctor</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">nh</span></span></span> <span class="free"><span class="bound"><span class="entity">me</span></span></span> <span class="main">≡</span> <span class="main">⦇</span> routing_match <span class="main">=</span> PrefixMatch <span class="main">(</span>ipv4addr_of_dotdecimal <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">,</span> metric <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">me</span></span></span><span class="main">,</span> routing_action <span class="main">=</span><span class="main">⦇</span>output_iface <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">,</span> next_hop <span class="main">=</span> <span class="main">(</span>map_option ipv4addr_of_dotdecimal <span class="free"><span class="bound"><span class="entity">nh</span></span></span><span class="main">)</span><span class="main">⦈</span> <span class="main">⦈</span>"</span></span>
<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"sort_key routing_rule_sort_key <span class="main">[</span>
  rr_ctor <span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="main">0</span><span class="main">,</span><span class="main">0</span><span class="main">,</span><span class="main">1</span><span class="main">)</span> <span class="numeral">3</span> <span class="inner_quoted">''''</span> None <span class="main">0</span><span class="main">,</span>
  rr_ctor <span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="main">0</span><span class="main">,</span><span class="main">0</span><span class="main">,</span><span class="numeral">2</span><span class="main">)</span> <span class="numeral">8</span> <span class="main">[]</span> None <span class="main">0</span><span class="main">,</span>
  rr_ctor <span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="main">0</span><span class="main">,</span><span class="main">0</span><span class="main">,</span><span class="numeral">3</span><span class="main">)</span> <span class="numeral">4</span> <span class="main">[]</span> None <span class="numeral">13</span><span class="main">,</span>
  rr_ctor <span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="main">0</span><span class="main">,</span><span class="main">0</span><span class="main">,</span><span class="numeral">3</span><span class="main">)</span> <span class="numeral">4</span> <span class="main">[]</span> None <span class="numeral">42</span><span class="main">]</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">is_longest_prefix_routing</span> <span class="main">≡</span> sorted <span class="main">∘</span> map routing_rule_sort_key"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">correct_routing</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'i</span><span class="main">::</span>len<span class="main">)</span> prefix_routing <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">correct_routing</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">≡</span> is_longest_prefix_routing <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">∧</span> valid_prefixes <span class="free"><span class="bound"><span class="entity">r</span></span></span>"</span></span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Many proofs and functions around routing require at least parts of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> correct_routing<span class="antiquote"><span class="antiquote">}</span></span></span></span> as an assumption.
Obviously, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> correct_routing<span class="antiquote"><span class="antiquote">}</span></span></span></span> is not given for arbitrary routing tables. Therefore,
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> correct_routing<span class="antiquote"><span class="antiquote">}</span></span></span></span> is made to be executable and should be checked for any routing table after parsing.
Note: <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> correct_routing<span class="antiquote"><span class="antiquote">}</span></span></span></span> used to also require <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> has_default_route<span class="antiquote"><span class="antiquote">}</span></span></span></span>,
but none of the proofs require it anymore and it is not given for any routing table.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> is_longest_prefix_routing_rule_exclusion<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"is_longest_prefix_routing <span class="main">(</span><span class="free">r1</span> <span class="main">#</span> <span class="free">rn</span> <span class="main">#</span> <span class="free">rss</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"is_longest_prefix_routing <span class="main">(</span><span class="free">r1</span> <span class="main">#</span> <span class="free">rss</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="free">rss</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> is_longest_prefix_routing_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> int_of_nat_less<span class="main">:</span> <span class="quoted"><span class="quoted">"int_of_nat <span class="free">a</span> <span class="main">&lt;</span> int_of_nat <span class="free">b</span> <span class="main">⟹</span> <span class="free">a</span> <span class="main">&lt;</span> <span class="free">b</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> int_of_nat_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> is_longest_prefix_routing_sorted_by_length<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"is_longest_prefix_routing <span class="free">r</span>"</span></span>
     <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">=</span> <span class="free">r1</span> <span class="main">#</span> <span class="free">rs</span> <span class="main">@</span> <span class="free">r2</span> <span class="main">#</span> <span class="free">rss</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>pfxm_length <span class="main">(</span>routing_match <span class="free">r1</span><span class="main">)</span> <span class="main">≥</span> pfxm_length <span class="main">(</span>routing_match <span class="free">r2</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">rs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">r</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">rn</span> <span class="skolem">rs</span><span class="main">)</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?ro</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="free">r1</span> <span class="main">#</span> <span class="skolem">rs</span> <span class="main">@</span> <span class="free">r2</span> <span class="main">#</span> <span class="free">rss</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"is_longest_prefix_routing <span class="var">?ro</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Cons.prems is_longest_prefix_routing_rule_exclusion<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">r1</span></span> <span class="quoted"><span class="skolem">rn</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">rs</span> <span class="main">@</span> <span class="free">r2</span> <span class="main">#</span> <span class="free">rss</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">from</span></span> Cons.IH<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> is_longest_prefix_routing_def routing_rule_sort_key_def linord_helper_less_eq1_def less_eq_linord_helper_def int_of_nat_def<span class="main">)</span>    
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">sort_rtbl</span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'i</span><span class="main">::</span>len<span class="main">)</span> routing_rule list <span class="main">⇒</span> <span class="tfree">'i</span> routing_rule list <span class="main">≡</span> sort_key routing_rule_sort_key"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> is_longest_prefix_routing_sort<span class="main">:</span> <span class="quoted"><span class="quoted">"is_longest_prefix_routing <span class="main">(</span>sort_rtbl <span class="free">r</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> sort_rtbl_def is_longest_prefix_routing_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">unambiguous_routing</span> <span class="free"><span class="bound"><span class="entity">rtbl</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="main">∀</span><span class="bound">rt1</span> <span class="bound">rt2</span> <span class="bound">rr</span> <span class="bound">ra</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">rtbl</span></span></span> <span class="main">=</span> <span class="bound">rt1</span> <span class="main">@</span> <span class="bound">rr</span> <span class="main">#</span> <span class="bound">rt2</span> <span class="main">⟶</span> <span class="bound">ra</span> <span class="main">∈</span> set <span class="main">(</span><span class="bound">rt1</span> <span class="main">@</span> <span class="bound">rt2</span><span class="main">)</span> <span class="main">⟶</span> routing_match <span class="bound">rr</span> <span class="main">=</span> routing_match <span class="bound">ra</span> <span class="main">⟶</span> routing_rule_sort_key <span class="bound">rr</span> <span class="main">≠</span> routing_rule_sort_key <span class="bound">ra</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">lemma</span></span> unambiguous_routing_Cons<span class="main">:</span> <span class="quoted"><span class="quoted">"unambiguous_routing <span class="main">(</span><span class="free">r</span> <span class="main">#</span> <span class="free">rtbl</span><span class="main">)</span> <span class="main">⟹</span> unambiguous_routing <span class="free">rtbl</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> unambiguous_routing_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span><span class="main">)</span> <span class="main">(</span><span class="operator">metis</span> append_Cons in_set_conv_decomp<span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"unambiguous_routing <span class="main">(</span><span class="free">rr</span> <span class="main">#</span> <span class="free">rtbl</span><span class="main">)</span> <span class="main">⟹</span> is_longest_prefix_routing <span class="main">(</span><span class="free">rr</span> <span class="main">#</span> <span class="free">rtbl</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">ra</span> <span class="main">∈</span> set <span class="free">rtbl</span> <span class="main">⟹</span> routing_match <span class="free">rr</span> <span class="main">=</span> routing_match <span class="free">ra</span> <span class="main">⟹</span> routing_rule_sort_key <span class="free">rr</span> <span class="main">&lt;</span> routing_rule_sort_key <span class="free">ra</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> is_longest_prefix_routing_def unambiguous_routing_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span><span class="main">)</span>
<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">unambiguous_routing_code</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">unambiguous_routing_code</span> <span class="main">[]</span> <span class="main">=</span> True"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">unambiguous_routing_code</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">rr</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">rtbl</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>list_all <span class="main">(</span><span class="main">λ</span><span class="bound">ra</span><span class="main">.</span> routing_match <span class="free"><span class="bound"><span class="entity">rr</span></span></span> <span class="main">≠</span> routing_match <span class="bound">ra</span> <span class="main">∨</span> routing_rule_sort_key <span class="free"><span class="bound"><span class="entity">rr</span></span></span> <span class="main">≠</span> routing_rule_sort_key <span class="bound">ra</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">rtbl</span></span></span> <span class="main">∧</span> <span class="free">unambiguous_routing_code</span> <span class="free"><span class="bound"><span class="entity">rtbl</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">lemma</span></span> unambiguous_routing_code<span class="main">[</span><span class="operator">code_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"unambiguous_routing <span class="free">rtbl</span> <span class="main">⟷</span> unambiguous_routing_code <span class="free">rtbl</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">rtbl</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">rr</span> <span class="skolem">rtbl</span><span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?l</span> <span class="main">⟷</span> <span class="var">?r</span>"</span></span><span class="main">)</span> <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">assume</span></span> l<span class="main">:</span> <span class="var"><span class="quoted"><span class="var">?l</span></span></span>
    <span class="keyword1"><span class="command">with</span></span> unambiguous_routing_Cons Cons.IH <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"unambiguous_routing_code <span class="skolem">rtbl</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"list_all <span class="main">(</span><span class="main">λ</span><span class="bound">ra</span><span class="main">.</span> routing_match <span class="skolem">rr</span> <span class="main">≠</span> routing_match <span class="bound">ra</span> <span class="main">∨</span> routing_rule_sort_key <span class="skolem">rr</span> <span class="main">≠</span> routing_rule_sort_key <span class="bound">ra</span><span class="main">)</span> <span class="skolem">rtbl</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> l <span class="keyword1"><span class="command">unfolding</span></span> unambiguous_routing_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> list_all_iff<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?r</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> r<span class="main">:</span> <span class="var"><span class="quoted"><span class="var">?r</span></span></span>
    <span class="keyword1"><span class="command">with</span></span> Cons.IH <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"unambiguous_routing <span class="skolem">rtbl</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> r <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"list_all <span class="main">(</span><span class="main">λ</span><span class="bound">ra</span><span class="main">.</span> routing_match <span class="skolem">rr</span> <span class="main">≠</span> routing_match <span class="bound">ra</span> <span class="main">∨</span>  routing_rule_sort_key <span class="skolem">rr</span> <span class="main">≠</span> routing_rule_sort_key <span class="bound">ra</span><span class="main">)</span> <span class="skolem">rtbl</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">rr</span> <span class="main">#</span> <span class="skolem">rtbl</span> <span class="main">=</span> <span class="skolem">rt1</span> <span class="main">@</span> <span class="skolem">rra</span> <span class="main">#</span> <span class="skolem">rt2</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ra</span> <span class="main">∈</span> set <span class="main">(</span><span class="skolem">rt1</span> <span class="main">@</span> <span class="skolem">rt2</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"routing_rule_sort_key <span class="skolem">rra</span> <span class="main">=</span> routing_rule_sort_key <span class="skolem">ra</span> <span class="main">∧</span> routing_match <span class="skolem">rra</span> <span class="main">=</span> routing_match <span class="skolem">ra</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">rt1</span> <span class="skolem">rt2</span> <span class="skolem">rra</span> <span class="skolem">ra</span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">rt1</span> <span class="main">=</span> <span class="main">[]</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> that * <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> list_all_iff<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False
      <span class="keyword1"><span class="command">with</span></span> that<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> rtbl<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">rtbl</span> <span class="main">=</span> tl <span class="skolem">rt1</span> <span class="main">@</span> <span class="skolem">rra</span> <span class="main">#</span> <span class="skolem">rt2</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> list.sel<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> tl_append2<span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">ra</span> <span class="main">=</span> hd <span class="skolem">rt1</span>"</span></span><span class="main">)</span> <span class="comment1">(* meh case split… *)</span>
        <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ra</span> <span class="main">∈</span> set <span class="main">(</span>tl <span class="skolem">rt1</span> <span class="main">@</span> <span class="skolem">rt2</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">rt1</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
        <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹unambiguous_routing <span class="skolem">rtbl</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>  <span class="keyword1"><span class="command">using</span></span> that<span class="main">(</span>3<span class="main">)</span> rtbl <span class="keyword1"><span class="command">unfolding</span></span> unambiguous_routing_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fast</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">rr</span> <span class="main">=</span> <span class="skolem">ra</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> that <span class="quoted"><span class="quoted">‹<span class="skolem">rt1</span> <span class="main">≠</span> <span class="main">[]</span>›</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">rt1</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span> 
        <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> that * <span class="keyword1"><span class="command">unfolding</span></span> rtbl <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> list_all_iff<span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?l</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> unambiguous_routing_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span> 
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> unambiguous_routing_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> unambigous_prefix_routing_weak_mono<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> lpfx<span class="main">:</span> <span class="quoted"><span class="quoted">"is_longest_prefix_routing <span class="main">(</span><span class="free">rr</span><span class="main">#</span><span class="free">rtbl</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> e<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="free">rr'</span> <span class="main">∈</span> set <span class="free">rtbl</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"routing_rule_sort_key <span class="free">rr'</span> <span class="main">≥</span> routing_rule_sort_key <span class="free">rr</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> is_longest_prefix_routing_def<span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> unambigous_prefix_routing_strong_mono<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> lpfx<span class="main">:</span> <span class="quoted"><span class="quoted">"is_longest_prefix_routing <span class="main">(</span><span class="free">rr</span><span class="main">#</span><span class="free">rtbl</span><span class="main">)</span>"</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> uam<span class="main">:</span> <span class="quoted"><span class="quoted">"unambiguous_routing <span class="main">(</span><span class="free">rr</span><span class="main">#</span><span class="free">rtbl</span><span class="main">)</span>"</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> e<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="free">rr'</span> <span class="main">∈</span> set <span class="free">rtbl</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> ne<span class="main">:</span> <span class="quoted"><span class="quoted">"routing_match <span class="free">rr'</span> <span class="main">=</span> routing_match <span class="free">rr</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"routing_rule_sort_key <span class="free">rr'</span> <span class="main">&gt;</span> routing_rule_sort_key <span class="free">rr</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> uam e ne <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"routing_rule_sort_key <span class="free">rr</span> <span class="main">≠</span> routing_rule_sort_key <span class="free">rr'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> unambiguous_routing_def<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> unambigous_prefix_routing_weak_mono lpfx e <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"routing_rule_sort_key <span class="free">rr</span> <span class="main">≤</span> routing_rule_sort_key <span class="free">rr'</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"routing_rule_sort_key <span class="main">(</span>rr_ctor <span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="main">0</span><span class="main">,</span><span class="main">0</span><span class="main">,</span><span class="main">0</span><span class="main">)</span> <span class="numeral">8</span> <span class="main">[]</span> None <span class="main">0</span><span class="main">)</span> <span class="main">&gt;</span> routing_rule_sort_key <span class="main">(</span>rr_ctor <span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="main">0</span><span class="main">,</span><span class="main">0</span><span class="main">,</span><span class="main">0</span><span class="main">)</span> <span class="numeral">24</span> <span class="main">[]</span> None <span class="main">0</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="comment1">(* get the inequality right… bigger means lower priority *)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹In case you don't like that formulation of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> is_longest_prefix_routing<span class="antiquote"><span class="antiquote">}</span></span></span></span> over sorting, this is your lemma.›</span></span>
<span class="keyword1"><span class="command">theorem</span></span> existential_routing<span class="main">:</span> <span class="quoted"><span class="quoted">"valid_prefixes <span class="free">rtbl</span> <span class="main">⟹</span> is_longest_prefix_routing <span class="free">rtbl</span> <span class="main">⟹</span> has_default_route <span class="free">rtbl</span> <span class="main">⟹</span> unambiguous_routing <span class="free">rtbl</span> <span class="main">⟹</span>
routing_table_semantics <span class="free">rtbl</span> <span class="free">addr</span> <span class="main">=</span> <span class="free">act</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">rr</span> <span class="main">∈</span> set <span class="free">rtbl</span><span class="main">.</span> prefix_match_semantics <span class="main">(</span>routing_match <span class="bound">rr</span><span class="main">)</span> <span class="free">addr</span> <span class="main">∧</span> routing_action <span class="bound">rr</span> <span class="main">=</span> <span class="free">act</span> <span class="main">∧</span>
  <span class="main">(</span><span class="main">∀</span><span class="bound">ra</span> <span class="main">∈</span> set <span class="free">rtbl</span><span class="main">.</span> routing_rule_sort_key <span class="bound">ra</span> <span class="main">&lt;</span> routing_rule_sort_key <span class="bound">rr</span> <span class="main">⟶</span> <span class="main">¬</span>prefix_match_semantics <span class="main">(</span>routing_match <span class="bound">ra</span><span class="main">)</span> <span class="free">addr</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">rtbl</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">rr</span> <span class="skolem">rtbl</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"prefix_match_semantics <span class="main">(</span>routing_match <span class="skolem">rr</span><span class="main">)</span> <span class="free">addr</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">hence</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"routing_table_semantics <span class="main">(</span><span class="skolem">rr</span> <span class="main">#</span> <span class="skolem">rtbl</span><span class="main">)</span> <span class="free">addr</span> <span class="main">=</span> routing_table_semantics <span class="main">(</span><span class="skolem">rr</span> <span class="main">#</span> <span class="skolem">rtbl</span><span class="main">)</span> <span class="free">addr</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"routing_prefix <span class="skolem">rr</span> <span class="main">=</span> <span class="main">0</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Need special treatment, rtbl won't have a default route, so the IH is not usable.›</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"valid_prefix <span class="main">(</span>routing_match <span class="skolem">rr</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Cons.prems valid_prefixes_split <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">with</span></span> True False <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> zero_prefix_match_all <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False
      <span class="keyword1"><span class="command">with</span></span> Cons.prems <span class="keyword1"><span class="command">have</span></span> mprems<span class="main">:</span> <span class="quoted"><span class="quoted">"valid_prefixes <span class="skolem">rtbl</span>"</span></span> <span class="quoted"><span class="quoted">"is_longest_prefix_routing <span class="skolem">rtbl</span>"</span></span> <span class="quoted"><span class="quoted">"has_default_route <span class="skolem">rtbl</span>"</span></span> <span class="quoted"><span class="quoted">"unambiguous_routing <span class="skolem">rtbl</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> valid_prefixes_split unambiguous_routing_Cons is_longest_prefix_routing_def<span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> Cons.IH<span class="main">[</span><span class="operator">OF</span> mprems<span class="main">]</span> False <span class="quoted"><span class="quoted">‹<span class="main">¬</span> prefix_match_semantics <span class="main">(</span>routing_match <span class="skolem">rr</span><span class="main">)</span> <span class="free">addr</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">from</span></span> True <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"routing_table_semantics <span class="main">(</span><span class="skolem">rr</span> <span class="main">#</span> <span class="skolem">rtbl</span><span class="main">)</span> <span class="free">addr</span> <span class="main">=</span> routing_action <span class="skolem">rr</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?l</span> <span class="main">⟷</span> <span class="var">?r</span>"</span></span><span class="main">)</span> <span class="keyword1"><span class="command">proof</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?l</span></span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">act</span> <span class="main">=</span> routing_action <span class="skolem">rr</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> True<span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">ra</span><span class="main">∈</span>set <span class="main">(</span><span class="skolem">rr</span> <span class="main">#</span> <span class="skolem">rtbl</span><span class="main">)</span><span class="main">.</span> routing_rule_sort_key <span class="skolem">rr</span> <span class="main">≤</span> routing_rule_sort_key <span class="bound">ra</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹is_longest_prefix_routing <span class="main">(</span><span class="skolem">rr</span> <span class="main">#</span> <span class="skolem">rtbl</span><span class="main">)</span>›</span></span>  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> is_longest_prefix_routing_def<span class="main">)</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?r</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> True<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?r</span></span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">guess</span></span></span></span> rr' <span class="keyword1"><span class="command">..</span></span> <span class="keyword1"><span class="command">note</span></span> rr' <span class="main">=</span> this
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">rr'</span> <span class="main">=</span> <span class="skolem">rr</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
        <span class="keyword3"><span class="command">assume</span></span> C<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">rr'</span> <span class="main">≠</span> <span class="skolem">rr</span>"</span></span>
        <span class="keyword1"><span class="command">from</span></span> C <span class="keyword1"><span class="command">have</span></span> e<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">rr'</span> <span class="main">∈</span> set <span class="skolem">rtbl</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> rr' <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
          <span class="keyword3"><span class="command">assume</span></span> eq<span class="main">:</span> <span class="quoted"><span class="quoted">"routing_match <span class="skolem">rr'</span> <span class="main">=</span> routing_match <span class="skolem">rr</span>"</span></span>
          <span class="keyword1"><span class="command">with</span></span> e <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"routing_rule_sort_key <span class="skolem">rr</span> <span class="main">&lt;</span> routing_rule_sort_key <span class="skolem">rr'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> unambigous_prefix_routing_strong_mono<span class="main">[</span><span class="operator">OF</span> Cons.prems<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">,</span></span>4<span class="main"><span class="main">)</span></span> _ eq<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">with</span></span> True rr' <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">assume</span></span> ne<span class="main">:</span> <span class="quoted"><span class="quoted">"routing_match <span class="skolem">rr'</span> <span class="main">≠</span> routing_match <span class="skolem">rr</span>"</span></span>
          <span class="keyword1"><span class="command">from</span></span> rr' Cons.prems <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"valid_prefix <span class="main">(</span>routing_match <span class="skolem">rr</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"valid_prefix <span class="main">(</span>routing_match <span class="skolem">rr'</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"prefix_match_semantics <span class="main">(</span>routing_match <span class="skolem">rr'</span><span class="main">)</span> <span class="free">addr</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> valid_prefixes_alt_def<span class="main">)</span>
          <span class="keyword1"><span class="command">note</span></span> same_length_prefixes_distinct<span class="main">[</span><span class="operator">OF</span> this<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span>2<span class="main"><span class="main">)</span></span> ne<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> _ True this<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">]</span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"routing_prefix <span class="skolem">rr</span> <span class="main">=</span> routing_prefix <span class="skolem">rr'</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?pe</span></span></span><span class="main">)</span> <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
            <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"routing_rule_sort_key <span class="skolem">rr</span> <span class="main">&lt;</span> routing_rule_sort_key <span class="skolem">rr'</span> <span class="main">⟶</span> <span class="main">¬</span> prefix_match_semantics <span class="main">(</span>routing_match <span class="skolem">rr</span><span class="main">)</span> <span class="free">addr</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> rr' <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command">with</span></span> unambigous_prefix_routing_weak_mono<span class="main">[</span><span class="operator">OF</span> Cons.prems<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> e<span class="main">]</span> True <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"routing_rule_sort_key <span class="skolem">rr</span> <span class="main">=</span> routing_rule_sort_key <span class="skolem">rr'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
            <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?pe</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> routing_rule_sort_key_def int_of_nat_def<span class="main">)</span>
          <span class="keyword1"><span class="command">qed</span></span>
          <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">.</span></span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?l</span></span></span> <span class="keyword1"><span class="command">using</span></span> rr' <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>
    


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Printing›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">routing_rule_32_toString</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">rr</span></span></span><span class="main">::</span><span class="numeral">32</span> routing_rule<span class="main">)</span> <span class="main">≡</span> 
  prefix_match_32_toString <span class="main">(</span>routing_match <span class="free"><span class="bound"><span class="entity">rr</span></span></span><span class="main">)</span> 
<span class="main">@</span> <span class="main">(</span><span class="keyword1">case</span> next_hop <span class="main">(</span>routing_action <span class="free"><span class="bound"><span class="entity">rr</span></span></span><span class="main">)</span> <span class="keyword1">of</span> Some <span class="bound">nh</span> <span class="main">⇒</span> <span class="inner_quoted">'' via ''</span> <span class="main">@</span> ipv4addr_toString <span class="bound">nh</span> <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="main">[]</span><span class="main">)</span>
<span class="main">@</span> <span class="inner_quoted">'' dev ''</span> <span class="main">@</span> routing_oiface <span class="free"><span class="bound"><span class="entity">rr</span></span></span> 
<span class="main">@</span> <span class="inner_quoted">'' metric ''</span> <span class="main">@</span> string_of_nat <span class="main">(</span>metric <span class="free"><span class="bound"><span class="entity">rr</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">routing_rule_128_toString</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">rr</span></span></span><span class="main">::</span><span class="numeral">128</span> routing_rule<span class="main">)</span> <span class="main">≡</span> 
  prefix_match_128_toString <span class="main">(</span>routing_match <span class="free"><span class="bound"><span class="entity">rr</span></span></span><span class="main">)</span> 
<span class="main">@</span> <span class="main">(</span><span class="keyword1">case</span> next_hop <span class="main">(</span>routing_action <span class="free"><span class="bound"><span class="entity">rr</span></span></span><span class="main">)</span> <span class="keyword1">of</span> Some <span class="bound">nh</span> <span class="main">⇒</span> <span class="inner_quoted">'' via ''</span> <span class="main">@</span> ipv6addr_toString <span class="bound">nh</span> <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="main">[]</span><span class="main">)</span>
<span class="main">@</span> <span class="inner_quoted">'' dev ''</span> <span class="main">@</span> routing_oiface <span class="free"><span class="bound"><span class="entity">rr</span></span></span> 
<span class="main">@</span> <span class="inner_quoted">'' metric ''</span> <span class="main">@</span> string_of_nat <span class="main">(</span>metric <span class="free"><span class="bound"><span class="entity">rr</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"map routing_rule_32_toString 
<span class="main">[</span>rr_ctor <span class="main">(</span><span class="numeral">42</span><span class="main">,</span><span class="main">0</span><span class="main">,</span><span class="main">0</span><span class="main">,</span><span class="main">0</span><span class="main">)</span> <span class="numeral">7</span> <span class="inner_quoted">''eth0''</span> None <span class="numeral">808</span><span class="main">,</span> 
 rr_ctor <span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="main">0</span><span class="main">,</span><span class="main">0</span><span class="main">,</span><span class="main">0</span><span class="main">)</span> <span class="main">0</span> <span class="inner_quoted">''eth1''</span> <span class="main">(</span>Some <span class="main">(</span><span class="numeral">222</span><span class="main">,</span><span class="numeral">173</span><span class="main">,</span><span class="numeral">190</span><span class="main">,</span><span class="numeral">239</span><span class="main">)</span><span class="main">)</span> <span class="numeral">707</span><span class="main">]</span> <span class="main">=</span>
<span class="main">[</span><span class="inner_quoted">''42.0.0.0/7 dev eth0 metric 808''</span><span class="main">,</span>
 <span class="inner_quoted">''0.0.0.0/0 via 222.173.190.239 dev eth1 metric 707''</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>

<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Routing table to Relation›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Walking through a routing table splits the (remaining) IP space when traversing a routing table into a pair of sets:
 the pair contains the IPs concerned by the current rule and those left alone.›</span></span>
<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="entity">ipset_prefix_match</span> <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">ipset_prefix_match</span> <span class="free"><span class="bound"><span class="entity">pfx</span></span></span> <span class="free"><span class="bound"><span class="entity">rg</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">pfxrg</span> <span class="main">=</span> prefix_to_wordset <span class="free"><span class="bound"><span class="entity">pfx</span></span></span> <span class="keyword1">in</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">rg</span></span></span> <span class="main">∩</span> <span class="bound">pfxrg</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">rg</span></span></span> <span class="main">-</span> <span class="bound">pfxrg</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">lemma</span></span> ipset_prefix_match_m<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>  <span class="quoted"><span class="quoted">"fst <span class="main">(</span>ipset_prefix_match <span class="free">pfx</span> <span class="free">rg</span><span class="main">)</span> <span class="main">=</span> <span class="free">rg</span> <span class="main">∩</span> <span class="main">(</span>prefix_to_wordset <span class="free">pfx</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> Let_def ipset_prefix_match_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">lemma</span></span> ipset_prefix_match_nm<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"snd <span class="main">(</span>ipset_prefix_match <span class="free">pfx</span> <span class="free">rg</span><span class="main">)</span> <span class="main">=</span> <span class="free">rg</span> <span class="main">-</span> <span class="main">(</span>prefix_to_wordset <span class="free">pfx</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> Let_def ipset_prefix_match_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">lemma</span></span> ipset_prefix_match_distinct<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">rpm</span> <span class="main">=</span> ipset_prefix_match <span class="free">pfx</span> <span class="free">rg</span> <span class="main">⟹</span> 
  <span class="main">(</span>fst <span class="free">rpm</span><span class="main">)</span> <span class="main">∩</span> <span class="main">(</span>snd <span class="free">rpm</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">lemma</span></span> ipset_prefix_match_complete<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">rpm</span> <span class="main">=</span> ipset_prefix_match <span class="free">pfx</span> <span class="free">rg</span> <span class="main">⟹</span> 
  <span class="main">(</span>fst <span class="free">rpm</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span>snd <span class="free">rpm</span><span class="main">)</span> <span class="main">=</span> <span class="free">rg</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">lemma</span></span> rpm_m_dup_simp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">rg</span> <span class="main">∩</span> fst <span class="main">(</span>ipset_prefix_match <span class="main">(</span>routing_match <span class="free">r</span><span class="main">)</span> <span class="free">rg</span><span class="main">)</span> <span class="main">=</span> fst <span class="main">(</span>ipset_prefix_match <span class="main">(</span>routing_match <span class="free">r</span><span class="main">)</span> <span class="free">rg</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="entity">range_prefix_match</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'i</span><span class="main">::</span>len prefix_match <span class="main">⇒</span> <span class="tfree">'i</span> wordinterval <span class="main">⇒</span> <span class="tfree">'i</span> wordinterval <span class="main">×</span> <span class="tfree">'i</span> wordinterval"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">range_prefix_match</span> <span class="free"><span class="bound"><span class="entity">pfx</span></span></span> <span class="free"><span class="bound"><span class="entity">rg</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">pfxrg</span> <span class="main">=</span> prefix_to_wordinterval <span class="free"><span class="bound"><span class="entity">pfx</span></span></span> <span class="keyword1">in</span> 
  <span class="main">(</span>wordinterval_intersection <span class="free"><span class="bound"><span class="entity">rg</span></span></span> <span class="bound">pfxrg</span><span class="main">,</span> wordinterval_setminus <span class="free"><span class="bound"><span class="entity">rg</span></span></span> <span class="bound">pfxrg</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">lemma</span></span> range_prefix_match_set_eq<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">r1</span><span class="main">,</span><span class="bound">r2</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span>wordinterval_to_set <span class="bound">r1</span><span class="main">,</span> wordinterval_to_set <span class="bound">r2</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>range_prefix_match <span class="free">pfx</span> <span class="free">rg</span><span class="main">)</span> <span class="main">=</span>
    ipset_prefix_match <span class="free">pfx</span> <span class="main">(</span>wordinterval_to_set <span class="free">rg</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> range_prefix_match_def ipset_prefix_match_def Let_def 
  <span class="keyword1"><span class="command">using</span></span> wordinterval_intersection_set_eq wordinterval_setminus_set_eq prefix_to_wordinterval_set_eq  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">lemma</span></span> range_prefix_match_sm<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>  <span class="quoted"><span class="quoted">"wordinterval_to_set <span class="main">(</span>fst <span class="main">(</span>range_prefix_match <span class="free">pfx</span> <span class="free">rg</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> 
    fst <span class="main">(</span>ipset_prefix_match <span class="free">pfx</span> <span class="main">(</span>wordinterval_to_set <span class="free">rg</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> fst_conv ipset_prefix_match_m  wordinterval_intersection_set_eq prefix_to_wordinterval_set_eq range_prefix_match_def<span class="main">)</span>
<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">lemma</span></span> range_prefix_match_snm<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"wordinterval_to_set <span class="main">(</span>snd <span class="main">(</span>range_prefix_match <span class="free">pfx</span> <span class="free">rg</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
    snd <span class="main">(</span>ipset_prefix_match <span class="free">pfx</span> <span class="main">(</span>wordinterval_to_set <span class="free">rg</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> snd_conv ipset_prefix_match_nm wordinterval_setminus_set_eq prefix_to_wordinterval_set_eq range_prefix_match_def<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Wordintervals for Ports by Routing›</span></span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹This split, although rather trivial, 
can be used to construct the sets (or rather: the intervals) 
of IPs that are actually matched by an entry in a routing table.›</span></span>

<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">fun</span></span> <span class="entity">routing_port_ranges</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'i</span> prefix_routing <span class="main">⇒</span> <span class="tfree">'i</span> wordinterval <span class="main">⇒</span> <span class="main">(</span>string <span class="main">×</span> <span class="main">(</span><span class="tfree">'i</span><span class="main">::</span>len<span class="main">)</span> wordinterval<span class="main">)</span> list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">routing_port_ranges</span> <span class="main">[]</span> <span class="free"><span class="bound"><span class="entity">lo</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> wordinterval_empty <span class="free"><span class="bound"><span class="entity">lo</span></span></span> <span class="keyword1">then</span> <span class="main">[]</span> <span class="keyword1">else</span> <span class="main">[</span><span class="main">(</span>routing_oiface <span class="main">(</span>undefined<span class="main">::</span><span class="tfree">'i</span> routing_rule<span class="main">)</span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">lo</span></span></span><span class="main">)</span><span class="main">]</span><span class="main">)</span>"</span></span> <span class="main">|</span> <span class="comment1">(* insert default route to nirvana. has to match what routing_table_semantics does. *)</span>
<span class="quoted"><span class="quoted">"<span class="free">routing_port_ranges</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">lo</span></span></span> <span class="main">=</span> <span class="main">(</span>
	<span class="keyword1">let</span> <span class="bound">rpm</span> <span class="main">=</span> range_prefix_match <span class="main">(</span>routing_match <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">lo</span></span></span><span class="main">;</span> <span class="bound">m</span> <span class="main">=</span> fst <span class="bound">rpm</span><span class="main">;</span> <span class="bound">nm</span> <span class="main">=</span> snd <span class="bound">rpm</span> <span class="keyword1">in</span> <span class="main">(</span>
	<span class="main">(</span>routing_oiface <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">,</span><span class="bound">m</span><span class="main">)</span> <span class="main">#</span> <span class="free">routing_port_ranges</span> <span class="free"><span class="bound"><span class="entity">as</span></span></span> <span class="bound">nm</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">lemma</span></span> routing_port_ranges_subsets<span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a1</span><span class="main">,</span> <span class="free">b1</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>routing_port_ranges <span class="free">tbl</span> <span class="free">s</span><span class="main">)</span> <span class="main">⟹</span> wordinterval_to_set <span class="free">b1</span> <span class="main">⊆</span> wordinterval_to_set <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">tbl</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">s</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>

<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">lemma</span></span> routing_port_ranges_sound<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">e</span> <span class="main">∈</span> set <span class="main">(</span>routing_port_ranges <span class="free">tbl</span> <span class="free">s</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">k</span> <span class="main">∈</span> wordinterval_to_set <span class="main">(</span>snd <span class="free">e</span><span class="main">)</span> <span class="main">⟹</span> valid_prefixes <span class="free">tbl</span> <span class="main">⟹</span>
	fst <span class="free">e</span> <span class="main">=</span> output_iface <span class="main">(</span>routing_table_semantics <span class="free">tbl</span> <span class="free">k</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">tbl</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">s</span></span><span class="main">)</span>
	<span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">a</span> <span class="skolem">as</span><span class="main">)</span>
	<span class="keyword1"><span class="command">note</span></span> s <span class="main">=</span> Cons.prems<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">unfolded</span> routing_port_ranges.simps Let_def list.set<span class="main">]</span>
	<span class="keyword1"><span class="command">note</span></span> vpfx <span class="main">=</span> valid_prefixes_split<span class="main">[</span><span class="operator">OF</span> Cons.prems<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">]</span> 
	<span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?kees</span></span></span><span class="main">)</span> <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">e</span> <span class="main">=</span> <span class="main">(</span>routing_oiface <span class="skolem">a</span><span class="main">,</span> fst <span class="main">(</span>range_prefix_match <span class="main">(</span>routing_match <span class="skolem">a</span><span class="main">)</span> <span class="skolem">s</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="main">)</span>
		<span class="keyword3"><span class="command">case</span></span> False
		<span class="keyword1"><span class="command">hence</span></span> es<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">e</span> <span class="main">∈</span> set <span class="main">(</span>routing_port_ranges <span class="skolem">as</span> <span class="main">(</span>snd <span class="main">(</span>range_prefix_match <span class="main">(</span>routing_match <span class="skolem">a</span><span class="main">)</span> <span class="skolem">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> s <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
		<span class="keyword1"><span class="command">note</span></span> eq <span class="main">=</span> Cons.IH<span class="main">[</span><span class="operator">OF</span> this Cons.prems<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> conjunct2<span class="main"><span class="main">[</span></span><span class="operator">OF</span> vpfx<span class="main"><span class="main">]</span></span><span class="main">]</span>
		<span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>prefix_match_semantics <span class="main">(</span>routing_match <span class="skolem">a</span><span class="main">)</span> <span class="free">k</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?nom</span></span></span><span class="main">)</span>
		<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
		  <span class="keyword1"><span class="command">from</span></span> routing_port_ranges_subsets<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"fst <span class="free">e</span>"</span></span> <span class="quoted"><span class="quoted">"snd <span class="free">e</span>"</span></span><span class="main">,</span> <span class="operator">unfolded</span> prod.collapse<span class="main">,</span> <span class="operator">OF</span> es<span class="main">]</span>
		  <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"wordinterval_to_set <span class="main">(</span>snd <span class="free">e</span><span class="main">)</span> <span class="main">⊆</span> wordinterval_to_set <span class="main">(</span>snd <span class="main">(</span>range_prefix_match <span class="main">(</span>routing_match <span class="skolem">a</span><span class="main">)</span> <span class="skolem">s</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
			<span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?nom</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> prefix_match_semantics_wordset<span class="main">[</span><span class="operator">OF</span> conjunct1<span class="main"><span class="main">[</span></span><span class="operator">OF</span> vpfx<span class="main"><span class="main">]</span></span><span class="main">]</span>
			  <span class="keyword1"><span class="command">using</span></span> * Cons.prems<span class="main">(</span>2<span class="main">)</span>	<span class="keyword1"><span class="command">unfolding</span></span> wordinterval_subset_set_eq
				<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> range_prefix_match_def Let_def<span class="main">)</span>
		<span class="keyword1"><span class="command">qed</span></span>
		<span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?kees</span></span></span> <span class="keyword1"><span class="command">using</span></span> eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
	<span class="keyword1"><span class="command">next</span></span>
		<span class="keyword3"><span class="command">case</span></span> True
		<span class="keyword1"><span class="command">hence</span></span> fe<span class="main">:</span> <span class="quoted"><span class="quoted">"fst <span class="free">e</span> <span class="main">=</span> routing_oiface <span class="skolem">a</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
		<span class="keyword1"><span class="command">from</span></span> True <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">∈</span> wordinterval_to_set <span class="main">(</span>fst <span class="main">(</span>range_prefix_match <span class="main">(</span>routing_match <span class="skolem">a</span><span class="main">)</span> <span class="skolem">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
			<span class="keyword1"><span class="command">using</span></span> Cons.prems<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
		<span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"prefix_match_semantics <span class="main">(</span>routing_match <span class="skolem">a</span><span class="main">)</span> <span class="free">k</span>"</span></span> 
			<span class="keyword1"><span class="command">unfolding</span></span> prefix_match_semantics_wordset<span class="main">[</span><span class="operator">OF</span> conjunct1<span class="main">,</span> <span class="operator">OF</span> vpfx<span class="main">]</span>
			<span class="keyword1"><span class="command">unfolding</span></span> range_prefix_match_def Let_def
			<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
		<span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?kees</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fe<span class="main">)</span>
	<span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>

<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">lemma</span></span> routing_port_ranges_disjoined<span class="main">:</span>
<span class="keyword2"><span class="keyword">assumes</span></span> vpfx<span class="main">:</span> <span class="quoted"><span class="quoted">"valid_prefixes <span class="free">tbl</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> ins<span class="main">:</span>  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a1</span><span class="main">,</span> <span class="free">b1</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>routing_port_ranges <span class="free">tbl</span> <span class="free">s</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a2</span><span class="main">,</span> <span class="free">b2</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>routing_port_ranges <span class="free">tbl</span> <span class="free">s</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> nemp<span class="main">:</span> <span class="quoted"><span class="quoted">"wordinterval_to_set <span class="free">b1</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">b1</span> <span class="main">≠</span> <span class="free">b2</span> <span class="main">⟷</span> wordinterval_to_set <span class="free">b1</span> <span class="main">∩</span> wordinterval_to_set <span class="free">b2</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">tbl</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">s</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">r</span> <span class="skolem">rs</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> vpfx<span class="main">:</span> <span class="quoted"><span class="quoted">"valid_prefix <span class="main">(</span>routing_match <span class="skolem">r</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"valid_prefixes <span class="skolem">rs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Cons.prems<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">using</span></span> valid_prefixes_split <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">{</span></span> <span class="comment1">(* In case that one of b1 b2 stems from r and one does not, we assume it is b1 WLOG. *)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a1</span> <span class="skolem">b1</span> <span class="skolem">a2</span> <span class="skolem">b2</span>
    <span class="keyword3"><span class="command">assume</span></span> one<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">b1</span> <span class="main">=</span> fst <span class="main">(</span>range_prefix_match <span class="main">(</span>routing_match <span class="skolem">r</span><span class="main">)</span> <span class="skolem">s</span><span class="main">)</span>"</span></span>
    <span class="keyword3"><span class="command">assume</span></span> two<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a2</span><span class="main">,</span> <span class="skolem">b2</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>routing_port_ranges <span class="skolem">rs</span> <span class="main">(</span>snd <span class="main">(</span>range_prefix_match <span class="main">(</span>routing_match <span class="skolem">r</span><span class="main">)</span> <span class="skolem">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> dc<span class="main">:</span> <span class="quoted"><span class="quoted">"wordinterval_to_set <span class="main">(</span>snd <span class="main">(</span>range_prefix_match <span class="main">(</span>routing_match <span class="skolem">r</span><span class="main">)</span> <span class="skolem">s</span><span class="main">)</span><span class="main">)</span> <span class="main">∩</span>
          wordinterval_to_set <span class="main">(</span>fst <span class="main">(</span>range_prefix_match <span class="main">(</span>routing_match <span class="skolem">r</span><span class="main">)</span> <span class="skolem">s</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"wordinterval_to_set <span class="skolem">b1</span> <span class="main">∩</span> wordinterval_to_set <span class="skolem">b2</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> one <span class="keyword1"><span class="command">using</span></span> two<span class="main">[</span><span class="operator">THEN</span> routing_port_ranges_subsets<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fast</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> * <span class="main">=</span> this
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="free">a1</span><span class="main">,</span> <span class="free">b1</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>routing_port_ranges <span class="main">(</span><span class="skolem">r</span> <span class="main">#</span> <span class="skolem">rs</span><span class="main">)</span> <span class="skolem">s</span><span class="main">)</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="free">a2</span><span class="main">,</span> <span class="free">b2</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>routing_port_ranges <span class="main">(</span><span class="skolem">r</span> <span class="main">#</span> <span class="skolem">rs</span><span class="main">)</span> <span class="skolem">s</span><span class="main">)</span>›</span></span> nemp
    Cons.IH<span class="main">[</span><span class="operator">OF</span> vpfx<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span> * 
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>    
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>

<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">lemma</span></span> routing_port_rangesI<span class="main">:</span>
<span class="quoted"><span class="quoted">"valid_prefixes <span class="free">tbl</span> <span class="main">⟹</span>
 output_iface <span class="main">(</span>routing_table_semantics <span class="free">tbl</span> <span class="free">k</span><span class="main">)</span> <span class="main">=</span> <span class="free">output_port</span> <span class="main">⟹</span>
 <span class="free">k</span> <span class="main">∈</span> wordinterval_to_set <span class="free">wi</span> <span class="main">⟹</span>
 <span class="main">(</span><span class="main">∃</span><span class="bound">ip_range</span><span class="main">.</span> <span class="main">(</span><span class="free">output_port</span><span class="main">,</span> <span class="bound">ip_range</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>routing_port_ranges <span class="free">tbl</span> <span class="free">wi</span><span class="main">)</span> <span class="main">∧</span> <span class="free">k</span> <span class="main">∈</span> wordinterval_to_set <span class="bound">ip_range</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">tbl</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">wi</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">r</span> <span class="skolem">rs</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> Cons.prems<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> vpfx<span class="main">:</span> <span class="quoted"><span class="quoted">"valid_prefix <span class="main">(</span>routing_match <span class="skolem">r</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> vpfxs<span class="main">:</span> <span class="quoted"><span class="quoted">"valid_prefixes <span class="skolem">rs</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> valid_prefixes_split<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"prefix_match_semantics <span class="main">(</span>routing_match <span class="skolem">r</span><span class="main">)</span> <span class="free">k</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
      <span class="keyword1"><span class="command">using</span></span> Cons.prems<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">using</span></span> vpfx <span class="quoted"><span class="quoted">‹<span class="free">k</span> <span class="main">∈</span> wordinterval_to_set <span class="skolem">wi</span>›</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x <span class="main"><span class="main"><span class="main">=</span></span></span>  <span class="quoted"><span class="quoted">"fst <span class="main">(</span>range_prefix_match <span class="main">(</span>routing_match <span class="skolem">r</span><span class="main">)</span> <span class="skolem">wi</span><span class="main">)</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span> 
         <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> prefix_match_semantics_wordset Let_def<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="free">k</span> <span class="main">∈</span> wordinterval_to_set <span class="skolem">wi</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> ksnd<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">∈</span> wordinterval_to_set <span class="main">(</span>snd <span class="main">(</span>range_prefix_match <span class="main">(</span>routing_match <span class="skolem">r</span><span class="main">)</span> <span class="skolem">wi</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> prefix_match_semantics_wordset vpfx<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> mpr<span class="main">:</span> <span class="quoted"><span class="quoted">"output_iface <span class="main">(</span>routing_table_semantics <span class="skolem">rs</span> <span class="free">k</span><span class="main">)</span> <span class="main">=</span> <span class="free">output_port</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Cons.prems False <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">note</span></span> Cons.IH<span class="main">[</span><span class="operator">OF</span> vpfxs mpr ksnd<span class="main">]</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Reduction›</span></span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹So far, one entry in the list would be generated for each routing table entry. 
This next step reduces it to one for each port. 
The resulting list will represent a function from port to IP wordinterval.
(It can also be understood as a function from IP (interval) to port (where the intervals don't overlap).›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">reduce_range_destination</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">≡</span>
<span class="keyword1">let</span> <span class="bound">ps</span> <span class="main">=</span> remdups <span class="main">(</span>map fst <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="keyword1">in</span>
<span class="keyword1">let</span> <span class="bound">c</span> <span class="main">=</span> <span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">(</span>wordinterval_Union <span class="main">∘</span> map snd <span class="main">∘</span> filter <span class="main">(</span><span class="main">(</span><span class="main">(=)</span> <span class="bound">s</span><span class="main">)</span> <span class="main">∘</span> fst<span class="main">)</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="keyword1">in</span>
<span class="main">[</span><span class="main">(</span><span class="bound">p</span><span class="main">,</span> <span class="bound">c</span> <span class="bound">p</span><span class="main">)</span><span class="main">.</span> p <span class="main">←</span> <span class="bound">ps</span><span class="main">]</span>
"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">routing_ipassmt_wi</span> <span class="free"><span class="bound"><span class="entity">tbl</span></span></span> <span class="main">≡</span> reduce_range_destination <span class="main">(</span>routing_port_ranges <span class="free"><span class="bound"><span class="entity">tbl</span></span></span> wordinterval_UNIV<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> routing_ipassmt_wi_distinct<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst <span class="main">(</span>routing_ipassmt_wi <span class="free">tbl</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> routing_ipassmt_wi_def reduce_range_destination_def
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> comp_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">lemma</span></span> routing_port_ranges_superseted<span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a1</span><span class="main">,</span><span class="free">b1</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>routing_port_ranges <span class="free">tbl</span> wordinterval_UNIV<span class="main">)</span> <span class="main">⟹</span> 
  <span class="main">∃</span><span class="bound">b2</span><span class="main">.</span> <span class="main">(</span><span class="free">a1</span><span class="main">,</span><span class="bound">b2</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>routing_ipassmt_wi <span class="free">tbl</span><span class="main">)</span> <span class="main">∧</span> wordinterval_to_set <span class="free">b1</span> <span class="main">⊆</span> wordinterval_to_set <span class="bound">b2</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> routing_ipassmt_wi_def reduce_range_destination_def
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Set.image_iff wordinterval_Union<span class="main">)</span>

<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">lemma</span></span> routing_ipassmt_wi_subsetted<span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a1</span><span class="main">,</span><span class="free">b1</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>routing_ipassmt_wi <span class="free">tbl</span><span class="main">)</span> <span class="main">⟹</span> 
 <span class="main">(</span><span class="free">a1</span><span class="main">,</span><span class="free">b2</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>routing_port_ranges <span class="free">tbl</span> wordinterval_UNIV<span class="main">)</span> <span class="main">⟹</span>  wordinterval_to_set <span class="free">b2</span> <span class="main">⊆</span> wordinterval_to_set <span class="free">b1</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> routing_ipassmt_wi_def reduce_range_destination_def
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Set.image_iff wordinterval_Union comp_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹This lemma should hold without the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> valid_prefixes<span class="antiquote"><span class="antiquote">}</span></span></span></span> assumption, but that would break the semantic argument and make the proof a lot harder.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> routing_ipassmt_wi_disjoint<span class="main">:</span>
<span class="keyword2"><span class="keyword">assumes</span></span> vpfx<span class="main">:</span> <span class="quoted"><span class="quoted">"valid_prefixes <span class="main">(</span><span class="free">tbl</span><span class="main">::</span><span class="main">(</span><span class="tfree">'i</span><span class="main">::</span>len<span class="main">)</span> prefix_routing<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> dif<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a1</span> <span class="main">≠</span> <span class="free">a2</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> ins<span class="main">:</span>  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a1</span><span class="main">,</span> <span class="free">b1</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>routing_ipassmt_wi <span class="free">tbl</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a2</span><span class="main">,</span> <span class="free">b2</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>routing_ipassmt_wi <span class="free">tbl</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"wordinterval_to_set <span class="free">b1</span> <span class="main">∩</span> wordinterval_to_set <span class="free">b2</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> iuf <span class="main">=</span> ins<span class="main">[</span><span class="operator">unfolded</span> routing_ipassmt_wi_def reduce_range_destination_def Let_def<span class="main">,</span> <span class="operator">simplified</span><span class="main">,</span> <span class="operator">unfolded</span> Set.image_iff comp_def<span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>wordinterval_to_set <span class="free">b1</span> <span class="main">∩</span> wordinterval_to_set <span class="free">b2</span> <span class="main">≠</span> <span class="main">{}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"wordinterval_to_set <span class="free">b1</span> <span class="main">∩</span> wordinterval_to_set <span class="free">b2</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹If the intervals are not disjoint, there exists a witness of that.›</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> x<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> wordinterval_to_set <span class="free">b1</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> wordinterval_to_set <span class="free">b2</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹This witness has to have come from some entry in the result of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> routing_port_ranges<span class="antiquote"><span class="antiquote">}</span></span></span></span>, for both of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">b1</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">b2</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">b1g</span><span class="main">.</span> <span class="skolem">x</span> <span class="main">∈</span> wordinterval_to_set <span class="bound">b1g</span> <span class="main">∧</span> wordinterval_to_set <span class="bound">b1g</span> <span class="main">⊆</span> wordinterval_to_set <span class="free">b1</span> <span class="main">∧</span> <span class="main">(</span><span class="free">a1</span><span class="main">,</span> <span class="bound">b1g</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>routing_port_ranges <span class="free">tbl</span> wordinterval_UNIV<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> iuf<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> wordinterval_Union<span class="main">)</span> <span class="comment1">(* strangely, this doesn't work with obtain *)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">b1g</span></span> <span class="keyword2"><span class="keyword">where</span></span> b1g<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> wordinterval_to_set <span class="skolem">b1g</span>"</span></span> <span class="quoted"><span class="quoted">"wordinterval_to_set <span class="skolem">b1g</span> <span class="main">⊆</span> wordinterval_to_set <span class="free">b1</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a1</span><span class="main">,</span> <span class="skolem">b1g</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>routing_port_ranges <span class="free">tbl</span> wordinterval_UNIV<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span>
  <span class="keyword1"><span class="command">from</span></span> x <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">b2g</span><span class="main">.</span> <span class="skolem">x</span> <span class="main">∈</span> wordinterval_to_set <span class="bound">b2g</span> <span class="main">∧</span> wordinterval_to_set <span class="bound">b2g</span> <span class="main">⊆</span> wordinterval_to_set <span class="free">b2</span> <span class="main">∧</span> <span class="main">(</span><span class="free">a2</span><span class="main">,</span> <span class="bound">b2g</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>routing_port_ranges <span class="free">tbl</span> wordinterval_UNIV<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> iuf<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> wordinterval_Union<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">b2g</span></span> <span class="keyword2"><span class="keyword">where</span></span> b2g<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> wordinterval_to_set <span class="skolem">b2g</span>"</span></span> <span class="quoted"><span class="quoted">"wordinterval_to_set <span class="skolem">b2g</span> <span class="main">⊆</span> wordinterval_to_set <span class="free">b2</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a2</span><span class="main">,</span> <span class="skolem">b2g</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>routing_port_ranges <span class="free">tbl</span> wordinterval_UNIV<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span>
  <span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Soudness tells us that the both <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">a1</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">a2</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> have to be the result of routing <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">x</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>
  <span class="keyword1"><span class="command">note</span></span> routing_port_ranges_sound<span class="main">[</span><span class="operator">OF</span> b1g<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">,</span> <span class="operator">unfolded</span> fst_conv snd_conv<span class="main">,</span> <span class="operator">OF</span> b1g<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> vpfx<span class="main">]</span> routing_port_ranges_sound<span class="main">[</span><span class="operator">OF</span> b2g<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">,</span> <span class="operator">unfolded</span> fst_conv snd_conv<span class="main">,</span> <span class="operator">OF</span> b2g<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> vpfx<span class="main">]</span>
  <span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹A contradiction follows from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> dif<span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>
  <span class="keyword1"><span class="command">with</span></span> dif <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> routing_ipassmt_wi_sound<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> vpfx<span class="main">:</span> <span class="quoted"><span class="quoted">"valid_prefixes <span class="free">tbl</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> ins<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">ea</span><span class="main">,</span><span class="free">eb</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>routing_ipassmt_wi <span class="free">tbl</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">∈</span> wordinterval_to_set <span class="free">eb</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">ea</span> <span class="main">=</span> output_iface <span class="main">(</span>routing_table_semantics <span class="free">tbl</span> <span class="free">k</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">note</span></span> iuf <span class="main">=</span> ins<span class="main">[</span><span class="operator">unfolded</span> routing_ipassmt_wi_def reduce_range_destination_def Let_def<span class="main">,</span> <span class="operator">simplified</span><span class="main">,</span> <span class="operator">unfolded</span> Set.image_iff comp_def<span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>
  <span class="keyword1"><span class="command">from</span></span> x <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">b1g</span><span class="main">.</span> <span class="free">k</span> <span class="main">∈</span> wordinterval_to_set <span class="bound">b1g</span> <span class="main">∧</span> wordinterval_to_set <span class="bound">b1g</span> <span class="main">⊆</span> wordinterval_to_set <span class="free">eb</span> <span class="main">∧</span> <span class="main">(</span><span class="free">ea</span><span class="main">,</span> <span class="bound">b1g</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>routing_port_ranges <span class="free">tbl</span> wordinterval_UNIV<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> iuf<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> wordinterval_Union<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">b1g</span></span> <span class="keyword2"><span class="keyword">where</span></span> b1g<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">∈</span> wordinterval_to_set <span class="skolem">b1g</span>"</span></span> <span class="quoted"><span class="quoted">"wordinterval_to_set <span class="skolem">b1g</span> <span class="main">⊆</span> wordinterval_to_set <span class="free">eb</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">ea</span><span class="main">,</span> <span class="skolem">b1g</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>routing_port_ranges <span class="free">tbl</span> wordinterval_UNIV<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span>
  <span class="keyword1"><span class="command">note</span></span> routing_port_ranges_sound<span class="main">[</span><span class="operator">OF</span> b1g<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">,</span> <span class="operator">unfolded</span> fst_conv snd_conv<span class="main">,</span> <span class="operator">OF</span> b1g<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> vpfx<span class="main">]</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> routing_ipassmt_wi<span class="main">:</span>
<span class="keyword2"><span class="keyword">assumes</span></span> vpfx<span class="main">:</span> <span class="quoted"><span class="quoted">"valid_prefixes <span class="free">tbl</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> 
  <span class="quoted"><span class="quoted">"output_iface <span class="main">(</span>routing_table_semantics <span class="free">tbl</span> <span class="free">k</span><span class="main">)</span> <span class="main">=</span> <span class="free">output_port</span> <span class="main">⟷</span>
    <span class="main">(</span><span class="main">∃</span><span class="bound">ip_range</span><span class="main">.</span> <span class="free">k</span> <span class="main">∈</span> wordinterval_to_set <span class="bound">ip_range</span> <span class="main">∧</span> <span class="main">(</span><span class="free">output_port</span><span class="main">,</span> <span class="bound">ip_range</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>routing_ipassmt_wi <span class="free">tbl</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> iffI<span class="main"><span class="keyword3">,</span></span> <span class="operator">goal_cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 2 <span class="keyword1"><span class="command">with</span></span> vpfx routing_ipassmt_wi_sound <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> 1
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">ip_range</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">output_port</span><span class="main">,</span> <span class="skolem">ip_range</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>routing_port_ranges <span class="free">tbl</span> wordinterval_UNIV<span class="main">)</span> <span class="main">∧</span> <span class="free">k</span> <span class="main">∈</span> wordinterval_to_set <span class="skolem">ip_range</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> routing_port_rangesI<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> wi <span class="main"><span class="main">=</span></span> <span class="quoted">wordinterval_UNIV</span><span class="main">,</span> <span class="operator">OF</span> vpfx<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> routing_ipassmt_wi_def reduce_range_destination_def
    <span class="keyword1"><span class="command">unfolding</span></span> Let_def comp_def
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Set.image_iff wordinterval_Union<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="comment1">(* this was not given for the old reduced_range_destination *)</span>
<span class="keyword1"><span class="command">lemma</span></span> routing_ipassmt_wi_has_all_interfaces<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> in_tbl<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">∈</span> set <span class="free">tbl</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">s</span><span class="main">.</span> <span class="main">(</span>routing_oiface <span class="free">r</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>routing_ipassmt_wi <span class="free">tbl</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> in_tbl <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">s</span><span class="main">.</span> <span class="main">(</span>routing_oiface <span class="free">r</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>routing_port_ranges <span class="free">tbl</span> <span class="skolem">S</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">S</span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">tbl</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">S</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">l</span> <span class="skolem">ls</span><span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">=</span> <span class="skolem">l</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> Cons.prems <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> Cons.prems <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">∈</span> set <span class="skolem">ls</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">from</span></span> Cons.IH<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> routing_ipassmt_wi_def reduce_range_destination_def
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Set.image_iff<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Linux_Router">
<div class="head">
<h1>Theory Linux_Router</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">"Linux Router"</span></span>
<span class="keyword1"><span class="command">theory</span></span> Linux_Router
<span class="keyword2"><span class="keyword">imports</span></span> 
	<a href="Routing_Table.html">Routing_Table</a>
	<a href="../Simple_Firewall/SimpleFw_Semantics.html">Simple_Firewall.SimpleFw_Semantics</a>
	<a href="../Simple_Firewall/Simple_Packet.html">Simple_Firewall.Simple_Packet</a>
	<span class="quoted">"<a href="../../HOL/HOL-Library/Monad_Syntax.html">HOL-Library.Monad_Syntax</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">fromMaybe</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="keyword1">of</span> Some <span class="bound">a</span> <span class="main">⇒</span> <span class="bound">a</span> <span class="main">|</span> None <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span>"</span></span> <span class="comment1">(* mehr Haskell wagen *)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Here, we present a heavily simplified model of a linux router. 
(i.e., a linux-based device with \texttt{net.ipv4.ip\_forward})
It covers the following steps in packet processing:
\begin{itemize}
 \item Packet arrives (destination port is empty, destination mac address is own address).
 \item Destination address is extracted and used for a routing table lookup.
 \item Packet is updated with output interface of routing decision.
 \item The FORWARD chain of iptables is considered.
 \item Next hop is extracted from the routing decision, fallback to destination address if directly attached.
 \item MAC address of next hop is looked up (using the mac lookup function mlf)
 \item L2 destination address of packet is updated.
\end{itemize}
This is stripped down to model only the most important and widely used aspects of packet processing.
Here are a few examples of what was abstracted away:
\begin{itemize}
 \item No local traffic.
 \item Only the \texttt{filter} table of iptables is considered, \texttt{raw} and \texttt{nat} are not.
 \item Only one routing table is considered. (Linux can have other tables than the \texttt{default} one.)
 \item No source MAC modification.
 \item \ldots
\end{itemize}
›</span></span>

<span class="keyword1"><span class="command">record</span></span> interface <span class="main">=</span>
	iface_name <span class="main">::</span> <span class="quoted">string</span>
	iface_mac <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="numeral">48</span> word"</span></span>
	<span class="comment1">(*iface_ips :: "(ipv4addr × 32 prefix_match) set" (* there is a set of IP addresses and the reachable subnets for them *), but we don't use that right now, so it is commented out. 
	Also, part of that information is already in the routing table, so careful here... *)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">iface_packet_check</span> <span class="main">::</span>  <span class="quoted"><span class="quoted">"interface list <span class="main">⇒</span><span class="main">(</span><span class="tfree">'i</span><span class="main">::</span>len<span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> simple_packet_ext_scheme <span class="main">⇒</span> interface option"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">iface_packet_check</span> <span class="free"><span class="bound"><span class="entity">ifs</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> find <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> iface_name <span class="bound">i</span> <span class="main">=</span> p_iiface <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∧</span> iface_mac <span class="bound">i</span> <span class="main">=</span> p_l2dst <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">ifs</span></span></span>"</span></span> 
<span class="keyword1"><span class="command">term</span></span> <span class="quoted">simple_fw</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">simple_linux_router</span> <span class="main">::</span>
  <span class="quoted"><span class="quoted">"<span class="tfree">'i</span> routing_rule list <span class="main">⇒</span> <span class="tfree">'i</span> simple_rule list <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'i</span><span class="main">::</span>len<span class="main">)</span> word <span class="main">⇒</span> <span class="numeral">48</span> word option<span class="main">)</span> <span class="main">⇒</span> 
         interface list <span class="main">⇒</span> <span class="tfree">'i</span> simple_packet_ext <span class="main">⇒</span> <span class="tfree">'i</span> simple_packet_ext option"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">simple_linux_router</span> <span class="free"><span class="bound"><span class="entity">rt</span></span></span> <span class="free"><span class="bound"><span class="entity">fw</span></span></span> <span class="free"><span class="bound"><span class="entity">mlf</span></span></span> <span class="free"><span class="bound"><span class="entity">ifl</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
	<span class="main"><span class="bound">_</span></span> <span class="main">←</span> iface_packet_check <span class="free"><span class="bound"><span class="entity">ifl</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">;</span>
	<span class="keyword1">let</span> <span class="bound">rd</span> <span class="comment1">― ‹(routing decision)›</span> <span class="main">=</span> routing_table_semantics <span class="free"><span class="bound"><span class="entity">rt</span></span></span> <span class="main">(</span>p_dst <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span><span class="main">;</span>
	<span class="keyword1">let</span> <span class="bound">p</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">⦇</span>p_oiface <span class="main">:=</span> output_iface <span class="bound">rd</span><span class="main">⦈</span><span class="main">;</span>
	<span class="keyword1">let</span> <span class="bound">fd</span> <span class="comment1">― ‹(firewall decision)›</span> <span class="main">=</span> simple_fw <span class="free"><span class="bound"><span class="entity">fw</span></span></span> <span class="bound">p</span><span class="main">;</span>
	<span class="main"><span class="bound">_</span></span> <span class="main">←</span> <span class="main">(</span><span class="keyword1">case</span> <span class="bound">fd</span> <span class="keyword1">of</span> Decision FinalAllow <span class="main">⇒</span> Some <span class="main">()</span> <span class="main">|</span> Decision FinalDeny <span class="main">⇒</span> None<span class="main">)</span><span class="main">;</span>
	<span class="keyword1">let</span> <span class="bound">nh</span> <span class="main">=</span> fromMaybe <span class="main">(</span>p_dst <span class="bound">p</span><span class="main">)</span> <span class="main">(</span>next_hop <span class="bound">rd</span><span class="main">)</span><span class="main">;</span>
	<span class="bound">ma</span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">mlf</span></span></span> <span class="bound">nh</span><span class="main">;</span>
	Some <span class="main">(</span><span class="bound">p</span><span class="main">⦇</span>p_l2dst <span class="main">:=</span> <span class="bound">ma</span><span class="main">⦈</span><span class="main">)</span>
<span class="main">}</span>"</span></span>
<span class="comment1">(* Can I find something that looks a bit more semantic. Maybe the option monad can reduce a bit of the foo? *)</span>
<span class="comment1">(* TODO: What happens in linux, if I send a packet to an interface with the mac of another interface? Hopefully, that is going to be dropped? *)</span> 

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹However, the above model is still too powerful for some use-cases.
Especially, the next hop look-up cannot be done without either a pre-distributed table of all MAC addresses,
or the usual mechanic of sending out an ARP request and caching the answer.
Doing ARP requests in the restricted environment of, e.g., an OpenFlow ruleset seems impossible.
Therefore, we present this model:›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">simple_linux_router_nol12</span> <span class="main">::</span>
    <span class="quoted"><span class="quoted">"<span class="tfree">'i</span> routing_rule list <span class="main">⇒</span> <span class="tfree">'i</span> simple_rule list <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'i</span><span class="main">,</span><span class="tfree">'a</span><span class="main">)</span> simple_packet_scheme <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'i</span><span class="main">::</span>len<span class="main">,</span><span class="tfree">'a</span><span class="main">)</span> simple_packet_scheme option"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">simple_linux_router_nol12</span> <span class="free"><span class="bound"><span class="entity">rt</span></span></span> <span class="free"><span class="bound"><span class="entity">fw</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
	<span class="keyword1">let</span> <span class="bound">rd</span> <span class="main">=</span> routing_table_semantics <span class="free"><span class="bound"><span class="entity">rt</span></span></span> <span class="main">(</span>p_dst <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span><span class="main">;</span>
	<span class="keyword1">let</span> <span class="bound">p</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">⦇</span>p_oiface <span class="main">:=</span> output_iface <span class="bound">rd</span><span class="main">⦈</span><span class="main">;</span>
	<span class="keyword1">let</span> <span class="bound">fd</span> <span class="main">=</span> simple_fw <span class="free"><span class="bound"><span class="entity">fw</span></span></span> <span class="bound">p</span><span class="main">;</span>
	<span class="main"><span class="bound">_</span></span> <span class="main">←</span> <span class="main">(</span><span class="keyword1">case</span> <span class="bound">fd</span> <span class="keyword1">of</span> Decision FinalAllow <span class="main">⇒</span> Some <span class="main">()</span> <span class="main">|</span> Decision FinalDeny <span class="main">⇒</span> None<span class="main">)</span><span class="main">;</span>
	Some <span class="bound">p</span>
<span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The differences to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> simple_linux_router<span class="antiquote"><span class="antiquote">}</span></span></span></span> are illustrated by the lemmata below.›</span></span>
<span class="comment1">(* an alternative formulation would maybe be "if the routing decision for the source is the same as for the destination, don't forward it." 
   This might be advantageous in $cases, however, this formulation is clearly easier to translate to openflow. *)</span>

<span class="keyword1"><span class="command">lemma</span></span> rtr_nomac_e1<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">pi</span>
	<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"simple_linux_router <span class="free">rt</span> <span class="free">fw</span> <span class="free">mlf</span> <span class="free">ifl</span> <span class="free">pi</span> <span class="main">=</span> Some <span class="free">po</span>"</span></span>
	<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"simple_linux_router_nol12 <span class="free">rt</span> <span class="free">fw</span> <span class="free">pi</span> <span class="main">=</span> Some <span class="free">po'</span>"</span></span>
	<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="free">po</span> <span class="main">=</span> <span class="free">po'</span><span class="main">⦇</span>p_l2dst <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">unfolding</span></span> simple_linux_router_nol12_def simple_linux_router_def
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits state.splits final_decision.splits Option.bind_splits if_splits<span class="main">)</span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">lemma</span></span> rtr_nomac_e2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">pi</span>
	<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"simple_linux_router <span class="free">rt</span> <span class="free">fw</span> <span class="free">mlf</span> <span class="free">ifl</span> <span class="free">pi</span> <span class="main">=</span> Some <span class="free">po</span>"</span></span>
	<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">po'</span><span class="main">.</span> simple_linux_router_nol12 <span class="free">rt</span> <span class="free">fw</span> <span class="free">pi</span> <span class="main">=</span> Some <span class="bound">po'</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">unfolding</span></span> simple_linux_router_nol12_def simple_linux_router_def
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits state.splits final_decision.splits Option.bind_splits if_splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> rtr_nomac_e3<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">pi</span>
	<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"simple_linux_router_nol12 <span class="free">rt</span> <span class="free">fw</span> <span class="free">pi</span> <span class="main">=</span> Some <span class="free">po</span>"</span></span>
	<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"iface_packet_check <span class="free">ifl</span> <span class="free">pi</span> <span class="main">=</span> Some <span class="free">i</span> <span class="comment1">― ‹don't care›</span>"</span></span>
	<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">mlf</span> <span class="main">(</span>fromMaybe <span class="main">(</span>p_dst <span class="free">pi</span><span class="main">)</span> <span class="main">(</span>next_hop <span class="main">(</span>routing_table_semantics <span class="free">rt</span> <span class="main">(</span>p_dst <span class="free">pi</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Some <span class="free">i2</span>"</span></span>
	<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">po'</span><span class="main">.</span> simple_linux_router <span class="free">rt</span> <span class="free">fw</span> <span class="free">mlf</span> <span class="free">ifl</span> <span class="free">pi</span> <span class="main">=</span> Some <span class="bound">po'</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">unfolding</span></span> simple_linux_router_nol12_def simple_linux_router_def
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits state.splits final_decision.splits Option.bind_splits if_splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> rtr_nomac_eq<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">pi</span>
	<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"iface_packet_check <span class="free">ifl</span> <span class="free">pi</span> <span class="main">≠</span> None"</span></span>
	<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">mlf</span> <span class="main">(</span>fromMaybe <span class="main">(</span>p_dst <span class="free">pi</span><span class="main">)</span> <span class="main">(</span>next_hop <span class="main">(</span>routing_table_semantics <span class="free">rt</span> <span class="main">(</span>p_dst <span class="free">pi</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">≠</span> None"</span></span>
	<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">x</span><span class="main">.</span> map_option <span class="main">(</span><span class="main">λ</span><span class="bound">p</span><span class="main">.</span> <span class="bound">p</span><span class="main">⦇</span>p_l2dst <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span> <span class="main">(</span>simple_linux_router_nol12 <span class="free">rt</span> <span class="free">fw</span> <span class="free">pi</span><span class="main">)</span> <span class="main">=</span> simple_linux_router <span class="free">rt</span> <span class="free">fw</span> <span class="free">mlf</span> <span class="free">ifl</span> <span class="free">pi</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"simple_linux_router_nol12 <span class="free">rt</span> <span class="free">fw</span> <span class="free">pi</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="quoted">"simple_linux_router <span class="free">rt</span> <span class="free">fw</span> <span class="free">mlf</span> <span class="free">ifl</span> <span class="free">pi</span>"</span></span><span class="main">)</span>
	<span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">b</span>
	<span class="keyword3"><span class="command">assume</span></span> as<span class="main">:</span> <span class="quoted"><span class="quoted">"simple_linux_router <span class="free">rt</span> <span class="free">fw</span> <span class="free">mlf</span> <span class="free">ifl</span> <span class="free">pi</span> <span class="main">=</span> Some <span class="skolem">b</span>"</span></span> <span class="quoted"><span class="quoted">"simple_linux_router_nol12 <span class="free">rt</span> <span class="free">fw</span> <span class="free">pi</span> <span class="main">=</span> Some <span class="skolem">a</span>"</span></span>
	<span class="keyword1"><span class="command">note</span></span> rtr_nomac_e1<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span>
	<span class="keyword1"><span class="command">with</span></span> as <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 
<span class="keyword1"><span class="command">next</span></span>
	<span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="keyword3"><span class="command">assume</span></span> as<span class="main">:</span> <span class="quoted"><span class="quoted">"simple_linux_router_nol12 <span class="free">rt</span> <span class="free">fw</span> <span class="free">pi</span> <span class="main">=</span> None"</span></span> <span class="quoted"><span class="quoted">"simple_linux_router <span class="free">rt</span> <span class="free">fw</span> <span class="free">mlf</span> <span class="free">ifl</span> <span class="free">pi</span> <span class="main">=</span> Some <span class="skolem">a</span>"</span></span>
	<span class="keyword1"><span class="command">note</span></span> rtr_nomac_e2<span class="main">[</span><span class="operator">OF</span> as<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span>
	<span class="keyword1"><span class="command">with</span></span> as<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
	<span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword1"><span class="command">next</span></span>
	<span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="keyword3"><span class="command">assume</span></span> as<span class="main">:</span> <span class="quoted"><span class="quoted">"simple_linux_router_nol12 <span class="free">rt</span> <span class="free">fw</span> <span class="free">pi</span> <span class="main">=</span> Some <span class="skolem">a</span>"</span></span> <span class="quoted"><span class="quoted">"simple_linux_router <span class="free">rt</span> <span class="free">fw</span> <span class="free">mlf</span> <span class="free">ifl</span> <span class="free">pi</span> <span class="main">=</span> None"</span></span>
	<span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹iface_packet_check <span class="free">ifl</span> <span class="free">pi</span> <span class="main">≠</span> None›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">i3</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"iface_packet_check <span class="free">ifl</span> <span class="free">pi</span> <span class="main">=</span> Some <span class="skolem">i3</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
	<span class="keyword1"><span class="command">note</span></span> rtr_nomac_e3<span class="main">[</span><span class="operator">OF</span> as<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> this<span class="main">]</span> assms<span class="main">(</span>2<span class="main">)</span>
	<span class="keyword1"><span class="command">with</span></span> as<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
	<span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="IpRoute_Parser">
<div class="head">
<h1>Theory IpRoute_Parser</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="plain_text">Parser</span>
<span class="keyword1"><span class="command">theory</span></span> IpRoute_Parser
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Routing_Table.html">Routing_Table</a> 
  <a href="../IP_Addresses/IP_Address_Parser.html">IP_Addresses.IP_Address_Parser</a>
<span class="keyword2"><span class="keyword">keywords</span></span> <span class="quoted">"parse_ip_route"</span> <span class="quoted">"parse_ip_6_route"</span> <span class="main">::</span> thy_decl
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹This helps to read the output of the \texttt{ip route} command into a <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="numeral"><span class="numeral">32</span></span> routing_rule list"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">empty_rr_hlp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>len<span class="main">)</span> prefix_match <span class="main">⇒</span> <span class="tfree">'a</span> routing_rule"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">empty_rr_hlp</span> <span class="free"><span class="bound"><span class="entity">pm</span></span></span> <span class="main">=</span> routing_rule.make <span class="free"><span class="bound"><span class="entity">pm</span></span></span> default_metric <span class="main">(</span>routing_action.make <span class="inner_quoted">''''</span> None<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> empty_rr_hlp_alt<span class="main">:</span>
  <span class="quoted"><span class="quoted">"empty_rr_hlp <span class="free">pm</span> <span class="main">=</span> <span class="main">⦇</span> routing_match <span class="main">=</span> <span class="free">pm</span><span class="main">,</span> metric <span class="main">=</span> <span class="main">0</span><span class="main">,</span> routing_action <span class="main">=</span> <span class="main">⦇</span>output_iface <span class="main">=</span> <span class="main">[]</span><span class="main">,</span> next_hop <span class="main">=</span> None<span class="main">⦈</span><span class="main">⦈</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> empty_rr_hlp_def routing_rule.defs default_metric_def routing_action.defs <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">routing_action_next_hop_update</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> word <span class="main">⇒</span> <span class="tfree">'a</span> routing_rule <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>len<span class="main">)</span> routing_rule"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">routing_action_next_hop_update</span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="free"><span class="bound"><span class="entity">pk</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">pk</span></span></span><span class="main">⦇</span> routing_action <span class="main">:=</span> <span class="main">(</span>routing_action <span class="free"><span class="bound"><span class="entity">pk</span></span></span><span class="main">)</span><span class="main">⦇</span> next_hop <span class="main">:=</span> Some <span class="free"><span class="bound"><span class="entity">h</span></span></span><span class="main">⦈</span> <span class="main">⦈</span>"</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"routing_action_next_hop_update <span class="free">h</span> <span class="free">pk</span> <span class="main">=</span> routing_action_update <span class="main">(</span>next_hop_update <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">(</span>Some <span class="free">h</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free">pk</span><span class="main">::</span><span class="numeral">32</span> routing_rule<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> routing_action_next_hop_update_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">routing_action_oiface_update</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"string <span class="main">⇒</span> <span class="tfree">'a</span> routing_rule <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>len<span class="main">)</span> routing_rule"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">routing_action_oiface_update</span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="free"><span class="bound"><span class="entity">pk</span></span></span> <span class="main">=</span> routing_action_update <span class="main">(</span>output_iface_update <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">h</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">pk</span></span></span><span class="main">::</span><span class="tfree">'a</span> routing_rule<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"routing_action_oiface_update <span class="free">h</span> <span class="free">pk</span> <span class="main">=</span> <span class="free">pk</span><span class="main">⦇</span> routing_action <span class="main">:=</span> <span class="main">(</span>routing_action <span class="free">pk</span><span class="main">)</span><span class="main">⦇</span> output_iface <span class="main">:=</span>  <span class="free">h</span><span class="main">⦈</span> <span class="main">⦈</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> routing_action_oiface_update_def<span class="main">)</span>

<span class="comment1">(* Could be moved to Bitmagic *)</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">default_prefix</span> <span class="main">=</span> PrefixMatch <span class="main">0</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">lemma</span></span> default_prefix_matchall<span class="main">:</span> <span class="quoted"><span class="quoted">"prefix_match_semantics default_prefix <span class="free">ip</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> default_prefix_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> valid_prefix_00 zero_prefix_match_all<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">sanity_ip_route</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">::</span><span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>len<span class="main">)</span> prefix_routing<span class="main">)</span> <span class="main">≡</span> correct_routing <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">∧</span> unambiguous_routing <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">∧</span> list_all <span class="main">(</span><span class="main">(≠)</span> <span class="inner_quoted">''''</span> <span class="main">∘</span> routing_oiface<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span>"</span></span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The parser ensures that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> sanity_ip_route<span class="antiquote"><span class="antiquote">}</span></span></span></span> holds for any ruleset that is imported.›</span></span>

<span class="comment1">(* Hide all the ugly ml in a file with the right extension *)</span>
<span class="comment1">(*Depends on the function parser_ipv4 from IP_Address_Parser*)</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹IpRoute_Parser.ml›</span>
                  
<span class="keyword1"><span class="command">ML</span></span><span class="quoted">‹
  <span class="entity">Outer_Syntax.local_theory</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">command_keyword</span> <span class="keyword1">parse_ip_route</span><span class="antiquote">}</span></span></span>
  <span class="inner_quoted">"Load a file generated by ip route and make the routing table definition available as isabelle term"</span>
  <span class="main">(</span>Parse.binding --| <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> "<span class="keyword2">=</span>"<span class="antiquote">}</span></span></span> -- Parse.string &gt;&gt; <span class="entity">register_ip_route</span> <span class="inner_numeral">32</span><span class="main">)</span>
›</span>

<span class="keyword1"><span class="command">ML</span></span><span class="quoted">‹
  <span class="entity">Outer_Syntax.local_theory</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">command_keyword</span> <span class="keyword1">parse_ip_6_route</span><span class="antiquote">}</span></span></span>
  <span class="inner_quoted">"Load a file generated by ip -6 route and make the routing table definition available as isabelle term"</span>
  <span class="main">(</span>Parse.binding --| <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> "<span class="keyword2">=</span>"<span class="antiquote">}</span></span></span> -- Parse.string &gt;&gt; <span class="entity">register_ip_route</span> <span class="inner_numeral">128</span><span class="main">)</span>
›</span>

<span class="keyword1"><span class="command">parse_ip_route</span></span> <span class="quoted">"rtbl_parser_test1"</span> <span class="main">=</span> <span class="quoted">"ip-route-ex"</span>
<span class="keyword1"><span class="command">lemma</span></span>  <span class="quoted"><span class="quoted">"sanity_ip_route rtbl_parser_test1"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span> <span class="comment1">(* checked by parse_ip_route alread *)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"rtbl_parser_test1 <span class="main">=</span>
  <span class="main">[</span><span class="main">⦇</span>routing_match <span class="main">=</span> PrefixMatch <span class="numeral">0xFFFFFF00</span> <span class="numeral">32</span><span class="main">,</span> metric <span class="main">=</span> <span class="main">0</span><span class="main">,</span> routing_action <span class="main">=</span> <span class="main">⦇</span>output_iface <span class="main">=</span> <span class="inner_quoted">''tun0''</span><span class="main">,</span> next_hop <span class="main">=</span> None<span class="main">⦈</span><span class="main">⦈</span><span class="main">,</span>
  <span class="main">⦇</span>routing_match <span class="main">=</span> PrefixMatch <span class="numeral">0xA0D2AA0</span> <span class="numeral">28</span><span class="main">,</span> metric <span class="main">=</span> <span class="numeral">303</span><span class="main">,</span> routing_action <span class="main">=</span> <span class="main">⦇</span>output_iface <span class="main">=</span> <span class="inner_quoted">''ewlan''</span><span class="main">,</span> next_hop <span class="main">=</span> None<span class="main">⦈</span><span class="main">⦈</span><span class="main">,</span>
  <span class="main">⦇</span>routing_match <span class="main">=</span> PrefixMatch <span class="numeral">0xA0D2500</span> <span class="numeral">24</span><span class="main">,</span> metric <span class="main">=</span> <span class="main">0</span><span class="main">,</span> routing_action <span class="main">=</span> <span class="main">⦇</span>output_iface <span class="main">=</span> <span class="inner_quoted">''tun0''</span><span class="main">,</span> next_hop <span class="main">=</span> Some <span class="numeral">0xFFFFFF00</span><span class="main">⦈</span><span class="main">⦈</span><span class="main">,</span>
  <span class="main">⦇</span>routing_match <span class="main">=</span> PrefixMatch <span class="numeral">0xA0D2C00</span> <span class="numeral">24</span><span class="main">,</span> metric <span class="main">=</span> <span class="main">0</span><span class="main">,</span> routing_action <span class="main">=</span> <span class="main">⦇</span>output_iface <span class="main">=</span> <span class="inner_quoted">''tun0''</span><span class="main">,</span> next_hop <span class="main">=</span> Some <span class="numeral">0xFFFFFF00</span><span class="main">⦈</span><span class="main">⦈</span><span class="main">,</span>
  <span class="main">⦇</span>routing_match <span class="main">=</span> PrefixMatch <span class="main">0</span> <span class="main">0</span><span class="main">,</span> metric <span class="main">=</span> <span class="numeral">303</span><span class="main">,</span> routing_action <span class="main">=</span> <span class="main">⦇</span>output_iface <span class="main">=</span> <span class="inner_quoted">''ewlan''</span><span class="main">,</span> next_hop <span class="main">=</span> Some <span class="numeral">0xA0D2AA1</span><span class="main">⦈</span><span class="main">⦈</span><span class="main">]</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>

<span class="keyword1"><span class="command">parse_ip_6_route</span></span> <span class="quoted">"rtbl_parser_test2"</span> <span class="main">=</span> <span class="quoted">"ip-6-route-ex"</span>
<span class="keyword1"><span class="command">value</span></span><span class="main">[</span>code<span class="main">]</span> <span class="quoted">rtbl_parser_test2</span>
<span class="keyword1"><span class="command">lemma</span></span>  <span class="quoted"><span class="quoted">"sanity_ip_route rtbl_parser_test2"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/IpRoute_Parser.ml">
<div class="head">
<h1>File ‹IpRoute_Parser.ml›</h1>
</div>
<pre class="source"><span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">register_ip_route</span> <span class="entity">bitness</span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span><span class="entity">path</span><span class="main">)</span> <span class="main">(</span><span class="entity">lthy</span><span class="main">:</span> local_theory<span class="main">)</span> <span class="main">=</span>
	<span class="keyword2"><span class="keyword">let</span></span>
	<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">bitness</span> <span class="keyword2"><span class="keyword">of</span></span>
	    <span class="inner_numeral">32</span>  <span class="main">=&gt;</span> writeln <span class="inner_quoted">"Using IPv4 parser"</span>
    <span class="main">|</span> <span class="inner_numeral">128</span> <span class="main">=&gt;</span> writeln <span class="inner_quoted">"Using IPv6 parser"</span>
    <span class="main">|</span> <span class="main">_</span>   <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail<span class="main">(</span><span class="inner_quoted">"Unable to decide on IPv4 or IPv6"</span><span class="main">)</span>

	<span class="comment1">(* Bitness dependent stuff *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">v4</span> <span class="main">=</span> <span class="main">(</span><span class="entity">bitness</span> <span class="main">=</span> <span class="inner_numeral">32</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parser_ip</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">v4</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="entity">parser_ipv4</span> &gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ip</span> <span class="main">=&gt;</span> <span class="entity">mk_ipv4addr</span> <span class="entity">ip</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="entity">parser_ipv6</span> &gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ip</span> <span class="main">=&gt;</span> <span class="entity">mk_ipv6addr</span> <span class="entity">ip</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">next_hop_update</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">v4</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> routing_action_next_hop_update <span class="main">(</span><span class="quoted"><span class="numeral">32</span></span><span class="main">)</span><span class="antiquote">}</span></span> <span class="keyword2"><span class="keyword">else</span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> routing_action_next_hop_update <span class="main">(</span><span class="quoted"><span class="numeral">128</span></span><span class="main">)</span><span class="antiquote">}</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">construct_prefix</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">v4</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"PrefixMatch <span class="main">::</span> <span class="numeral">32</span> word <span class="main">⇒</span> nat <span class="main">⇒</span> <span class="numeral">32</span> prefix_match"</span><span class="antiquote">}</span></span> <span class="keyword2"><span class="keyword">else</span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"PrefixMatch <span class="main">::</span> <span class="numeral">128</span> word <span class="main">⇒</span> nat <span class="main">⇒</span> <span class="numeral">128</span> prefix_match"</span><span class="antiquote">}</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">default_prefix</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">v4</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> default_prefix <span class="main">(</span><span class="quoted"><span class="numeral">32</span></span><span class="main">)</span><span class="antiquote">}</span></span> <span class="keyword2"><span class="keyword">else</span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> default_prefix <span class="main">(</span><span class="quoted"><span class="numeral">128</span></span><span class="main">)</span><span class="antiquote">}</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">oiface_update</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">v4</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"routing_action_oiface_update <span class="main">::</span> string <span class="main">⇒</span> <span class="numeral">32</span> routing_rule <span class="main">⇒</span> <span class="numeral">32</span> routing_rule"</span><span class="antiquote">}</span></span> <span class="keyword2"><span class="keyword">else</span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"routing_action_oiface_update <span class="main">::</span> string <span class="main">⇒</span> <span class="numeral">128</span> routing_rule <span class="main">⇒</span> <span class="numeral">128</span> routing_rule"</span><span class="antiquote">}</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">metric_update</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">v4</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"metric_update <span class="main">::</span> <span class="main">(</span>nat <span class="main">⇒</span> nat<span class="main">)</span> <span class="main">⇒</span> <span class="numeral">32</span> routing_rule <span class="main">⇒</span> <span class="numeral">32</span> routing_rule"</span><span class="antiquote">}</span></span> <span class="keyword2"><span class="keyword">else</span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"metric_update <span class="main">::</span> <span class="main">(</span>nat <span class="main">⇒</span> nat<span class="main">)</span> <span class="main">⇒</span> <span class="numeral">128</span> routing_rule <span class="main">⇒</span> <span class="numeral">128</span> routing_rule"</span><span class="antiquote">}</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">empty_rr</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">v4</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> empty_rr_hlp <span class="main">(</span><span class="quoted"><span class="numeral">32</span></span><span class="main">)</span><span class="antiquote">}</span></span> <span class="keyword2"><span class="keyword">else</span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> empty_rr_hlp <span class="main">(</span><span class="quoted"><span class="numeral">128</span></span><span class="main">)</span><span class="antiquote">}</span></span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">to_rtbl</span> <span class="entity">r</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">v4</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> sort_rtbl <span class="main">(</span><span class="quoted"><span class="numeral">32</span></span><span class="main">)</span><span class="antiquote">}</span></span> $ <span class="main">(</span><span class="entity">HOLogic.mk_list</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"<span class="numeral">32</span> routing_rule"</span><span class="antiquote">}</span></span> <span class="entity">r</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> sort_rtbl <span class="main">(</span><span class="quoted"><span class="numeral">128</span></span><span class="main">)</span><span class="antiquote">}</span></span> $ <span class="main">(</span><span class="entity">HOLogic.mk_list</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"<span class="numeral">128</span> routing_rule"</span><span class="antiquote">}</span></span> <span class="entity">r</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">sanity_check</span> <span class="entity">r</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">v4</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> sanity_ip_route <span class="main">(</span><span class="quoted"><span class="numeral">32</span></span><span class="main">)</span><span class="antiquote">}</span></span> $ <span class="entity">r</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> sanity_ip_route <span class="main">(</span><span class="quoted"><span class="numeral">128</span></span><span class="main">)</span><span class="antiquote">}</span></span> $ <span class="entity">r</span>

  <span class="comment1">(* the parser *)</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">define_const</span> <span class="main">(</span><span class="entity">t</span><span class="main">:</span> term<span class="main">)</span> <span class="main">(</span><span class="entity">name</span><span class="main">:</span> binding<span class="main">)</span> <span class="main">(</span><span class="entity">lthy</span><span class="main">:</span> local_theory<span class="main">)</span> <span class="main">:</span> local_theory <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> writeln <span class="main">(</span><span class="inner_quoted">"Defining constant `"</span>^Binding.name_of <span class="entity">name</span>^<span class="inner_quoted">"' ("</span>^Binding.name_of <span class="entity">name</span>^<span class="inner_quoted">"_def')..."</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">thm</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span> Local_Theory.define <span class="main">(</span><span class="main">(</span><span class="entity">name</span><span class="main">,</span> NoSyn<span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">(</span>Binding.empty<span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span> <span class="entity">lthy</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span> Local_Theory.note <span class="main">(</span><span class="main">(</span>Binding.suffix_name <span class="inner_quoted">"_def"</span> <span class="entity">name</span><span class="main">,</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">attributes</span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="entity">thm</span><span class="main">]</span><span class="main">)</span> <span class="entity">lthy</span><span class="main">;</span>
       <span class="keyword2"><span class="keyword">in</span></span>
         <span class="entity">lthy</span>
  <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">load_file</span> <span class="main">(</span><span class="entity">thy</span><span class="main">:</span> theory<span class="main">)</span> <span class="main">(</span><span class="entity">path</span><span class="main">:</span> string list<span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">p</span> <span class="main">=</span>  File.full_path <span class="main">(</span><span class="entity">Resources.master_directory</span> <span class="entity">thy</span><span class="main">)</span> <span class="main">(</span>Path.make <span class="entity">path</span><span class="main">)</span><span class="main">;</span> <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="inner_quoted">"Loading file "</span>^File.platform_path <span class="entity">p</span> |&gt; writeln<span class="main">;</span> <span class="keyword2"><span class="keyword">in</span></span>
        <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span>File.exists <span class="entity">p</span><span class="main">)</span> <span class="keyword1"><span class="keyword">orelse</span></span> <span class="main">(</span>File.is_dir <span class="entity">p</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"File not found"</span> <span class="keyword2"><span class="keyword">else</span></span> File.read_lines <span class="entity">p</span>
   <span class="keyword2"><span class="keyword">end</span></span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

  <span class="comment1">(* and now, some code duplication with the IPtables parser… *)</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">extract_int</span> <span class="entity">ss</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ss</span> |&gt; implode |&gt; Int.fromString <span class="keyword2"><span class="keyword">of</span></span> SOME <span class="entity">i</span> <span class="main">=&gt;</span> <span class="entity">i</span>
                                                             <span class="main">|</span> NONE <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"unparsable int"</span><span class="main">;</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_iface_char</span> <span class="entity">x</span> <span class="main">=</span> Symbol.is_ascii <span class="entity">x</span> <span class="keyword1"><span class="keyword">andalso</span></span>
      <span class="main">(</span>Symbol.is_ascii_letter <span class="entity">x</span> <span class="keyword1"><span class="keyword">orelse</span></span> Symbol.is_ascii_digit <span class="entity">x</span> <span class="keyword1"><span class="keyword">orelse</span></span> <span class="entity">x</span> <span class="main">=</span> <span class="inner_quoted">"+"</span> <span class="keyword1"><span class="keyword">orelse</span></span> <span class="entity">x</span> <span class="main">=</span> <span class="inner_quoted">"*"</span> <span class="keyword1"><span class="keyword">orelse</span></span> <span class="entity">x</span> <span class="main">=</span> <span class="inner_quoted">"."</span> <span class="keyword1"><span class="keyword">orelse</span></span> <span class="entity">x</span> <span class="main">=</span> <span class="inner_quoted">"-"</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_nat</span> <span class="entity">maxval</span> <span class="entity">i</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">i</span> &lt; <span class="inner_numeral">0</span> <span class="keyword1"><span class="keyword">orelse</span></span> <span class="entity">i</span> &gt; <span class="entity">maxval</span>
            <span class="keyword2"><span class="keyword">then</span></span>
              <span class="keyword3"><span class="keyword">raise</span></span> Fail<span class="main">(</span><span class="inner_quoted">"nat ("</span>^Int.toString <span class="entity">i</span>^<span class="inner_quoted">") must be between 0 and "</span>^Int.toString <span class="entity">maxval</span><span class="main">)</span>
            <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="entity">HOLogic.mk_number</span> <span class="entity">HOLogic.natT</span> <span class="entity">i</span><span class="main">)</span><span class="main">;</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ipprefix_to_hol</span> <span class="main">(</span><span class="entity">ip</span><span class="main">,</span><span class="entity">len</span><span class="main">)</span> <span class="main">=</span> <span class="entity">construct_prefix</span> $ <span class="entity">ip</span> $ <span class="entity">mk_nat</span> <span class="entity">bitness</span> <span class="entity">len</span><span class="main">;</span>
  
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parser_ip_cidr</span> <span class="main">=</span> <span class="entity">parser_ip</span> --| <span class="main">(</span>$$ <span class="inner_quoted">"/"</span><span class="main">)</span> -- <span class="main">(</span>Scan.many1 Symbol.is_ascii_digit &gt;&gt; <span class="entity">extract_int</span><span class="main">)</span> &gt;&gt; <span class="entity">ipprefix_to_hol</span><span class="main">;</span>
  
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parser_interface</span> <span class="main">=</span> Scan.many1 <span class="entity">is_iface_char</span> &gt;&gt; <span class="main">(</span>implode #&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span> <span class="entity">HOLogic.mk_string</span> <span class="entity">x</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
  <span class="comment1">(* end dup *)</span>
  
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parser_subnet</span> <span class="main">=</span>  <span class="main">(</span>Scan.this_string <span class="inner_quoted">"default"</span> &gt;&gt; K <span class="entity">default_prefix</span><span class="main">)</span> ||
    <span class="entity">parser_ip_cidr</span> ||
    <span class="main">(</span><span class="entity">parser_ip</span> &gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ip</span> <span class="main">=&gt;</span> <span class="entity">ipprefix_to_hol</span> <span class="main">(</span><span class="entity">ip</span><span class="main">,</span><span class="entity">bitness</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">isSpace</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span> <span class="entity">x</span> <span class="main">=</span> <span class="inner_quoted">" "</span> <span class="keyword1"><span class="keyword">orelse</span></span>  <span class="entity">x</span> <span class="main">=</span> <span class="inner_quoted">"\t"</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parser_whitespace</span> <span class="main">=</span> Scan.many1 <span class="entity">isSpace</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eater_whitespace</span> <span class="main">=</span> Scan.many <span class="entity">isSpace</span><span class="main">;</span> <span class="comment1">(* I refuse to have this eat \r to make the parser work with windows newlines. *)</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parser_via</span> <span class="main">=</span> <span class="main">(</span>Scan.this_string <span class="inner_quoted">"via"</span> -- <span class="entity">parser_whitespace</span> |-- <span class="entity">parser_ip</span><span class="main">)</span>
    &gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ip</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">pk</span> <span class="main">=&gt;</span> <span class="entity">next_hop_update</span> $ <span class="entity">ip</span> $ <span class="entity">pk</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parser_dev</span> <span class="main">=</span> <span class="main">(</span>Scan.this_string <span class="inner_quoted">"dev"</span> -- <span class="entity">parser_whitespace</span> |-- <span class="entity">parser_interface</span><span class="main">)</span>
    &gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">dev</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">pk</span> <span class="main">=&gt;</span> <span class="entity">oiface_update</span> $ <span class="entity">dev</span> $ <span class="entity">pk</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parser_metric</span> <span class="main">=</span> <span class="main">(</span>Scan.this_string <span class="inner_quoted">"metric"</span> -- <span class="entity">parser_whitespace</span> |-- Scan.many1 Symbol.is_ascii_digit<span class="main">)</span>
    &gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">metric</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">pk</span> <span class="main">=&gt;</span> <span class="entity">metric_update</span> $ <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="main">(</span><span class="main">λ</span> <span class="bound">x</span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="bound">x</span><span class="main">)</span> <span class="main">::</span> nat <span class="main">⇒</span> nat <span class="main">⇒</span> nat"</span><span class="antiquote">}</span></span> $ <span class="main">(</span><span class="entity">mk_nat</span> <span class="inner_numeral">65535</span> <span class="main">(</span><span class="entity">extract_int</span> <span class="entity">metric</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> $ <span class="entity">pk</span><span class="main">)</span>

  <span class="comment1">(* the following values are going to be ignored since they can't be represented in the model, but I want to make sure they are parsed correctly *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parser_scope</span> <span class="main">=</span> <span class="main">(</span>Scan.this_string <span class="inner_quoted">"scope"</span> -- <span class="entity">parser_whitespace</span> |-- <span class="main">(</span>
    Scan.this_string <span class="inner_quoted">"host"</span> || Scan.this_string <span class="inner_quoted">"link"</span> || Scan.this_string <span class="inner_quoted">"global"</span> || <span class="main">(</span>Scan.many1 Symbol.is_ascii_digit &gt;&gt; implode<span class="main">)</span><span class="main">)</span><span class="main">)</span>
    &gt;&gt; K I <span class="comment1">(* K I -&gt; constant ignore: this value indicates the scope of validity of the rule *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parser_proto</span> <span class="main">=</span> <span class="main">(</span>Scan.this_string <span class="inner_quoted">"proto"</span> -- <span class="entity">parser_whitespace</span> |-- <span class="main">(</span>
    Scan.this_string <span class="inner_quoted">"kernel"</span> || Scan.this_string <span class="inner_quoted">"boot"</span> || Scan.this_string <span class="inner_quoted">"static"</span> || Scan.this_string <span class="inner_quoted">"dhcp"</span> || <span class="main">(</span>Scan.many1 Symbol.is_ascii_digit &gt;&gt; implode<span class="main">)</span><span class="main">)</span><span class="main">)</span>
    &gt;&gt; K I <span class="comment1">(* ignore: this value indicates how the rt-entry came to existence *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parser_src</span> <span class="main">=</span> <span class="main">(</span>Scan.this_string <span class="inner_quoted">"src"</span> -- <span class="entity">parser_whitespace</span> |-- <span class="entity">parser_ipv4</span><span class="main">)</span> 
    &gt;&gt; K I <span class="comment1">(* ignore: this value is used if an application (on the same device as the routing table) is sending an IP packet and has not bound to a specific address *)</span>

  <span class="comment1">(* TODO (for IPv6) there might be some more options to ignore… "pref medium"? *)</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">parser_end</span> <span class="entity">p</span> <span class="entity">i</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">r</span><span class="main">,</span><span class="entity">es</span><span class="main">)</span> <span class="main">=</span> Scan.finite Symbol.stopper <span class="main">(</span><span class="entity">p</span> --| <span class="entity">eater_whitespace</span><span class="main">)</span> <span class="entity">i</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">es</span> <span class="main">=</span> <span class="main">[</span><span class="main">]</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">r</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> writeln <span class="main">(</span><span class="inner_quoted">"'"</span> ^ <span class="main">(</span>implode <span class="entity">es</span><span class="main">)</span> ^ <span class="inner_quoted">"'"</span><span class="main">)</span> <span class="keyword2"><span class="keyword">in</span></span> K <span class="entity">r</span> <span class="comment1">(* cause error - TODO: How do I do that properly? *)</span> 
    <span class="main">(</span><span class="main">(</span>$$ <span class="inner_quoted">"x"</span><span class="main">)</span> <span class="main">(</span>Symbol.explode <span class="inner_quoted">""</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span> <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parser</span> <span class="main">=</span>
    <span class="main">(</span><span class="entity">parser_end</span> <span class="main">(</span><span class="main">(</span><span class="entity">parser_subnet</span> &gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span> <span class="entity">empty_rr</span> $ <span class="entity">x</span><span class="main">)</span><span class="main">)</span>
        -- Scan.repeat <span class="main">(</span><span class="entity">parser_whitespace</span> |-- <span class="main">(</span><span class="entity">parser_via</span> || <span class="entity">parser_dev</span> || <span class="entity">parser_metric</span> || <span class="entity">parser_scope</span> || <span class="entity">parser_proto</span> || <span class="entity">parser_src</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> 
    #&gt; swap #&gt; <span class="main">(</span>uncurry <span class="main">(</span>fold <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">a</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">b</span> <span class="main">=&gt;</span> <span class="entity">a</span> <span class="entity">b</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">sanity_check_ip_route</span> <span class="main">(</span><span class="entity">ctx</span><span class="main">:</span> <span class="entity">Proof.context</span><span class="main">)</span> <span class="entity">t</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> writeln <span class="inner_quoted">"Checking sanity..."</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">check</span> <span class="main">=</span> <span class="entity">Code_Evaluation.dynamic_value_strict</span> <span class="entity">ctx</span> <span class="main">(</span><span class="entity">sanity_check</span> <span class="entity">t</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">check</span> &lt;&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"True"</span><span class="antiquote">}</span></span> <span class="keyword2"><span class="keyword">then</span></span> <span class="keyword3"><span class="keyword">raise</span></span> ERROR <span class="inner_quoted">"sanity_wf_ruleset failed"</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">t</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
	  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fcontent</span> <span class="main">=</span> <span class="entity">load_file</span> <span class="main">(</span>Proof_Context.theory_of <span class="entity">lthy</span><span class="main">)</span> <span class="main">[</span><span class="entity">path</span><span class="main">]</span>
	  <span class="comment1">(*val _ = map (Pretty.writeln o Syntax.pretty_term @{context} o parser o Symbol.explode) fcontent (* keep this one, lets you see on which line it fails *)*)</span>
	  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">r</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">parser</span> o Symbol.explode<span class="main">)</span> <span class="entity">fcontent</span>
	  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">c</span> <span class="main">=</span> <span class="entity">to_rtbl</span> <span class="entity">r</span>
	  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">s</span> <span class="main">=</span> <span class="entity">sanity_check_ip_route</span> <span class="entity">lthy</span> <span class="entity">c</span>
	  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">d</span> <span class="main">=</span> <span class="entity">define_const</span> <span class="entity">s</span> <span class="entity">name</span> <span class="entity">lthy</span>
	  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> writeln <span class="inner_quoted">"Done."</span>
	<span class="keyword2"><span class="keyword">in</span></span>
	  <span class="entity">d</span>
<span class="keyword2"><span class="keyword">end</span></span></pre>
</div>